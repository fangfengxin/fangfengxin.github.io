<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>








  <meta name="google-site-verification" content="N8ofSn2GrmJ51OE3RhiifNsuUcNAfC7JAukwhpY-WiY"/>












  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"/>
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.png?v=7.2.0" color="#222">


  <link rel="manifest" href="/images/site.webmanifest">


  <meta name="msapplication-config" content="/images/browserconfig.xml"/>





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":"default"},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta name="description" content="异常异常概念异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致 JVM 的非正常停止。 在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出该异常对象。Java 处理异常的方式是中断处理。 异常指的并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本不能运行。 异常体系 java.lang.Throwable 类：是 Java 语言中所有错误或">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语言高级（3）异常与多线程">
<meta property="og:url" content="https://fangfengxin.top/2020/02/14/java-advanced-3.html">
<meta property="og:site_name" content="Flexia&#39;s Blog">
<meta property="og:description" content="异常异常概念异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致 JVM 的非正常停止。 在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出该异常对象。Java 处理异常的方式是中断处理。 异常指的并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本不能运行。 异常体系 java.lang.Throwable 类：是 Java 语言中所有错误或">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E4%B8%BB%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.png">
<meta property="article:published_time" content="2020-02-14T10:05:14.000Z">
<meta property="article:modified_time" content="2020-07-13T08:44:22.081Z">
<meta property="article:author" content="Flexia">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="Java语言高级">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangfengxin.top/2020/02/14/java-advanced-3/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.png">





  
  
  <link rel="canonical" href="https://fangfengxin.top/2020/02/14/java-advanced-3"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java语言高级（3）异常与多线程 | Flexia's Blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145696891-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-145696891-1');
    }
  </script>



  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ccc4ebbe605a1363703684938a4b4c40";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Flexia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">记录小方方的学习之路</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    
  
  

  

  <a href="https://github.com/fangfengxin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fangfengxin.top/2020/02/14/java-advanced-3.html"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Flexia"/>
      <meta itemprop="description" content="小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~"/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Flexia's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java语言高级（3）异常与多线程

              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-14 18:05:14" itemprop="dateCreated datePublished" datetime="2020-02-14T18:05:14+08:00">2020-02-14</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-13 16:44:22" itemprop="dateModified" datetime="2020-07-13T16:44:22+08:00">2020-07-13</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">Java语言高级</span></a></span>

                
                
              
            </span>
          
		  
		  <br/>

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/02/14/java-advanced-3.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/14/java-advanced-3.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">32k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">29 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p><strong>异常</strong>：指的是<strong>程序在执行过程中，出现的非正常的情况</strong>，最终会导致 JVM 的非正常停止。</p>
<p>在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出该异常对象。Java 处理异常的方式是中断处理。</p>
<p>异常指的<strong>并不是语法错误</strong>，语法错了，编译不通过，不会产生字节码文件，根本不能运行。</p>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p> <strong><code>java.lang.Throwable</code> 类</strong>：是 Java 语言中<strong>所有错误或异常的超类</strong>。</p>
<ul>
<li><strong><code>Error</code></strong> ：错误，因为这是系统内部的错误，运行时报错，无法处理。<ul>
<li>错误相当于绝症，必须修改源代码，程序才能继续执行。</li>
</ul>
</li>
<li><strong><code>Exception</code></strong> ：编译期异常，编译（写代码）Java 程序时出现的问题。<ul>
<li><strong><code>RuntimeException</code></strong> ：运行期异常，Java 程序运行过程中出现的问题。</li>
<li>异常相当于小毛病，把异常处理掉，程序可以继续运行。</li>
</ul>
</li>
</ul>
<p> <code>Throwable</code> 中的常用方法：</p>
<ul>
<li><code>public void printStackTrace()</code> ：打印异常的详细信息（包含异常的类型、原因、出现的位置）。</li>
<li><code>public String getMessage()</code> ：获取发生异常的原因。提示给用户的时候，就提示错误原因。</li>
<li><code>public String toString()</code> ：获取异常的类型和异常描述信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Exception:编译期异常,进行编译(写代码)java程序出现的问题</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);<span class="comment">//用来格式化日期</span></span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = sdf.parse(<span class="string">"1999-0909"</span>); <span class="comment">// 把字符串格式的日期,解析为Date格式的日期</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RuntimeException:运行期异常,java程序运行过程中出现的问题</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会出现异常的代码</span></span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Error:错误</span></span><br><span class="line"><span class="comment">            OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">            内存溢出的错误,创建的数组太大了,超出了给JVM分配的内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// int[] arr = new int[1024*1024*1024];</span></span><br><span class="line">        <span class="comment">// 必须修改代码,创建的数组小一点</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常的产生过程"><a href="#异常的产生过程" class="headerlink" title="异常的产生过程"></a>异常的产生过程</h2><p><img src="/2020/02/14/java-advanced-3/异常的产生过程解析.png" alt="异常产生过程"></p>
<h1 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h1><p>Java 异常处理的五个关键字：<strong><code>throw</code>、<code>throws</code>、<code>try</code>、<code>catch</code>、<code>finally</code></strong> 。</p>
<h2 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常 throw"></a>抛出异常 <code>throw</code></h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在 Java 中，提供了一个 <strong><code>throw</code> 关键字</strong>，用来抛出一个指定的异常对象。</p>
<ol>
<li>创建一个异常对象，封装一些提示信息。</li>
<li>通过关键字 <code>throw</code> 将这个异常对象告知给调用者。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> xxxExcepiton(<span class="string">"异常产生的原因"</span>);</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li><code>throw</code> 关键字必须写在<strong>方法的内部</strong>；</li>
<li><code>throw</code> 关键字后边 <strong><code>new</code> 的对象必须是 <code>Exception</code> 或者 <code>Exception</code> 的子类对象</strong>；</li>
<li><code>throw</code> 关键字抛出指定的异常对象，我们就必须处理这个异常对象：<ul>
<li><code>throw</code> 关键字后边创建的是 <code>RuntimeException</code> 或者是 <code>RuntimeException</code> 的子类对象，我们可以不处理，默认交给 <code>JVM</code> 处理（打印异常对象，中断程序）；</li>
<li><code>throw</code> 关键字后边创建的是<strong>编译期异常</strong>（写代码的时候报错），我们就必须处理这个异常，<strong>要么 <code>throws</code>，要么 <code>try...catch</code></strong>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int[] arr = null;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> e = getElement(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,获取数组指定索引处的元素</span></span><br><span class="line"><span class="comment">        以后(工作中)我们首先必须对方法传递过来的参数进行合法性校验</span></span><br><span class="line"><span class="comment">        如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法的调用者,传递的参数有问题</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理</span></span><br><span class="line"><span class="comment">            ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以对传递过来的参数数组,进行合法性校验</span></span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"传递的数组的值是null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以对传递过来的参数index进行合法性校验</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"传递的索引超出了数组的使用范围"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ele = arr[index];</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Objects-非空判断"><a href="#Objects-非空判断" class="headerlink" title="Objects 非空判断"></a><code>Objects</code> 非空判断</h2><p>提到过 <code>Objects</code> 类由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的）。在 <code>Objects</code> 的源码中，对对象为 <code>null</code> 的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code> ：查看指定引用对象不是 null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjects</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对传递过来的参数进行合法性判断,判断是否为null</span></span><br><span class="line">        <span class="comment">/*if(obj == null) &#123;</span></span><br><span class="line"><span class="comment">            throw new NullPointerException("传递的对象的值是null");</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Objects.requireNonNull(obj);</span></span><br><span class="line">        Objects.requireNonNull(obj, <span class="string">"传递的对象的值是null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明异常-throws"><a href="#声明异常-throws" class="headerlink" title="声明异常 throws"></a>声明异常 <code>throws</code></h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。</p>
<p> <code>throws</code> 关键字：异常处理的第一种方式，交给别人去处理。当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象，可以使用 <code>throws</code> 关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终可以交给 JVM 处理（中断处理）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表) <span class="keyword">throws</span> 异常类名<span class="number">1</span>, 异常类名<span class="number">2</span>... &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li><code>throws</code> 关键字必须写在<strong>方法声明处</strong>。</li>
<li><code>throws</code> 关键字后边声明的异常必须是 <code>Exception</code> 或者是 <code>Exception</code> 的子类。</li>
<li>方法内部如果抛出了多个异常对象，那么 <code>throws</code> 后边必须也声明多个异常。<ul>
<li>如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可。</li>
</ul>
</li>
<li>调用了一个声明抛出异常的方法,我们就必须的处理声明的异常：<ul>
<li>要么继续使用 <code>throws</code> 声明抛出，交给方法的调用者处理,最终交给 JVM；</li>
<li>要么 <code>try...catch</code> 自己处理异常。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThrows</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        FileNotFoundException extends IOException extends Excepiton</span></span><br><span class="line"><span class="comment">        如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// public static void main(String[] args) throws FileNotFoundException,IOException &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        readFile(<span class="string">"c:\\a.tx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,对传递的文件路径进行合法性判断</span></span><br><span class="line"><span class="comment">        如果路径不是"c:\\a.txt",那么我们就抛出文件找不到异常对象,告知方法的调用者</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常</span></span><br><span class="line"><span class="comment">            可以使用throws继续声明抛出FileNotFoundException这个异常对象,让方法的调用者处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fileName.equals(<span class="string">"c:\\a.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"传递的文件路径不是c:\\a.txt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果传递的路径,不是.txt结尾</span></span><br><span class="line"><span class="comment">            那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="捕获异常-try-catch"><a href="#捕获异常-try-catch" class="headerlink" title="捕获异常 try...catch"></a>捕获异常 <code>try...catch</code></h2><p>如果异常出现的话，会立刻终止程序，所以我们得处理异常：</p>
<ol>
<li>该方法不处理，而是声明抛出，由该方法的调用者来处理（<code>throws</code>）。</li>
<li>在方法中使用 <code>try-catch</code> 的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常，可以对出现的异常进行指定方式的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    可能产生异常的代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(定义一个异常的变量,用来接收<span class="keyword">try</span>中抛出的异常对象) &#123;</span><br><span class="line">    异常的处理逻辑,捕获异常对象之后,怎么处理异常对象</span><br><span class="line">    一般在工作中,会把异常的信息记录到一个日志中</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li><code>try</code> 中可能会抛出多个异常对象，那么就可以使用多个 <code>catch</code> 来处理这些异常对象。</li>
<li>如果 <code>try</code> 中产生了异常，那么就会执行 <code>catch</code> 中的异常处理逻辑，执行完毕 <code>catch</code> 中的处理逻辑，继续执行 <code>try...catch</code> 之后的代码。</li>
<li>如果 <code>try</code> 中没有产生异常，那么就不会执行 <code>catch</code> 中异常的处理逻辑，执行完 <code>try</code> 中的代码，继续执行 <code>try...catch</code> 之后的代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTryCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能产生异常的代码</span></span><br><span class="line">            readFile(<span class="string">"d:\\a.tx"</span>);</span><br><span class="line">            System.out.println(<span class="string">"资源释放"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象</span></span><br><span class="line">            <span class="comment">// 异常的处理逻辑,异常异常对象之后,怎么处理异常对象</span></span><br><span class="line">            System.out.println(<span class="string">"catch - 传递的文件后缀不是.txt"</span>);</span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">// 文件的后缀名不对    </span></span><br><span class="line">            System.out.println(e);<span class="comment">//java.io.IOException: 文件的后缀名不对</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                java.io.IOException: 文件的后缀名不对</span></span><br><span class="line"><span class="comment">                    at com.itheima.demo02.Exception.Demo01TryCatch.readFile(Demo01TryCatch.java:55)</span></span><br><span class="line"><span class="comment">                    at com.itheima.demo02.Exception.Demo01TryCatch.main(Demo01TryCatch.java:27)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a><code>finally</code> 代码块</h2><p>有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而 <code>finally</code> 就是解决这个问题的，<strong>在 <code>finally</code> 代码块中存放的代码都是一定会被执行的。</strong> </p>
<p>什么时候的代码必须最终执行？当我们在 <code>try</code> 语句块中打开了一些物理资源（磁盘文件/网络连接/数据库连接等），我们都得在使用完之后，最终关闭打开的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    可能产生异常的代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(定义一个异常的变量,用来接收<span class="keyword">try</span>中抛出的异常对象) &#123;</span><br><span class="line">    异常的处理逻辑,捕获异常对象之后,怎么处理异常对象</span><br><span class="line">    一般在工作中,会把异常的信息记录到一个日志中</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    无论是否出现异常都会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li><code>finally</code> 不能单独使用，必须和 <code>try</code> 一起使用。</li>
<li><code>finally</code> 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放。</li>
<li>只有在 <code>try</code> 或者 <code>catch</code> 中调用退出 JVM 的相关方法，此时 <code>finally</code> 才不会执行，否则 <code>finally</code> 永远会执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTryCatchFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会产生异常的代码</span></span><br><span class="line">            readFile(<span class="string">"c:\\a.tx"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否出现异常,都会执行</span></span><br><span class="line">            System.out.println(<span class="string">"资源释放"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><ul>
<li>运行时异常被抛出可以不处理，即不捕获也不声明抛出。</li>
<li>多个异常使用捕获又该如何处理呢？<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获多次处理。（<code>catch</code> 里边定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在上边，否则就会报错。）</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 运行时异常被抛出可以不处理。即不捕获也不声明抛出。</span></span><br><span class="line">        <span class="comment">// 默认给虚拟机处理,终止程序,什么时候不抛出运行时异常了,在来继续执行程序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]); <span class="comment">// ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>)); <span class="comment">// IndexOutOfBoundsException: Index 3 out-of-bounds for length 3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 多个异常分别处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 多个异常一次捕获，多次处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            <span class="comment">// System.out.println(arr[3]);</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个try多个catch注意事项:</span></span><br><span class="line"><span class="comment">                catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错</span></span><br><span class="line"><span class="comment">                ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            <span class="comment">// System.out.println(arr[3]);</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 多个异常一次捕获一次处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            <span class="comment">// System.out.println(arr[3]);</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"后续代码!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>finally</code> 有 <code>return</code> 语句，永远返回 <code>finally</code> 中的结果，避免该情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = getA();</span><br><span class="line">        System.out.println(a); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,返回变量a的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 一定会执行的代码</span></span><br><span class="line">            a = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类与父类的异常：<ul>
<li>如果父类抛出了多个异常，子类重写父类方法时，<strong>抛出和父类相同的异常</strong>或者<strong>抛出父类异常的子类</strong>或者<strong>不抛出异常</strong>。</li>
<li>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</li>
<li>注意：父类异常是什么样，子类异常就什么样。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类重写父类方法时,抛出和父类相同的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类重写父类方法时,抛出父类异常的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类重写父类方法时,不抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。</span></span><br><span class="line">    <span class="comment">// public void show04() throws Exception&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时子类产生该异常，只能捕获处理，不能声明抛出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"编译期异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>为什么需要自定义异常类？Java 中不同的异常类，分别表示着某一种具体的异常情况，那么在开发中总是有些异常情况是没有定义好的，此时我们根据自己业务的异常情况来定义异常类。</p>
<p>异常类如何定义：</p>
<ol>
<li>自定义一个编译期异常类：自定义类，并继承于 <code>java.lang.Exception</code>。</li>
<li>自定义一个运行期异常类：自定义类，并继承于 <code>java.lang.RuntimeException</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXExcepiton</span> <span class="keyword">extends</span> <span class="title">Exception</span> | <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    添加一个空参数的构造方法</span><br><span class="line">    添加一个带异常信息的构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>自定义异常类一般都是以 <code>Exception</code> 结尾，说明该类是一个异常类。</li>
<li>自定义异常类，必须的继承 <code>Exception</code> 或者 <code>RuntimeException</code>：<ul>
<li>继承 <code>Exception</code> ：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么 <code>throws</code>，要么 <code>try...catch</code>。</li>
<li>继承 <code>RuntimeException</code> ：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）。</li>
</ul>
</li>
</ol>
<p>自定义一个注册异常类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个空参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        添加一个带异常信息的构造方法</span></span><br><span class="line"><span class="comment">        查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRegisterException</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.使用数组保存已经注册过的用户名(数据库)</span></span><br><span class="line">    <span class="keyword">static</span> String[] usernames = &#123;<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RegisterException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.使用Scanner获取用户输入的注册的用户名(前端,页面)</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入您要注册的用户名:"</span>);</span><br><span class="line">        String username = sc.next();</span><br><span class="line">        checkUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.定义一个方法,对用户输入的中注册的用户名进行判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> RegisterException </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历存储已经注册过用户名的数组,获取每一个用户名</span></span><br><span class="line">        <span class="keyword">for</span> (String name : usernames) &#123;</span><br><span class="line">            <span class="comment">// 使用获取到的用户名和用户输入的用户名比较</span></span><br><span class="line">            <span class="keyword">if</span>(name.equals(username)) &#123;</span><br><span class="line">                <span class="comment">// true:用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册";</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">"亲，该用户名已经被注册"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RegisterException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 打印异常后结束方法，避免方法中后续代码继续执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!";</span></span><br><span class="line">        System.out.println(<span class="string">"恭喜您,注册成功!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p><img src="/2020/02/14/java-advanced-3/并发与并行.png" alt></p>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><p><strong>进程</strong>：是指一个进入内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
<p><img src="/2020/02/14/java-advanced-3/进程概念.png" alt></p>
<h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
<p><img src="/2020/02/14/java-advanced-3/线程概念.png" alt></p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul>
<li>分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</li>
<li><strong>抢占式调度</strong>：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java 使用的为抢占式调度。<ul>
<li>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos 窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</li>
<li>实际上，CPU 使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU 在多个线程间的切换速度相对我们的感觉要快，看上去就是在同一时刻运行。</li>
<li>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让 CPU 的使用率更高。</li>
</ul>
</li>
</ul>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p><strong>主线程</strong>：执行主（main）方法的线程。</p>
<ul>
<li>JVM 执行 main 方法，main 方法会进入到栈内存，JVM 会找操作系统开辟一条 main 方法通向 CPU 的执行路径，CPU 就可以通过这个路径来执行 main 方法。</li>
</ul>
<p><img src="/2020/02/14/java-advanced-3/主线程.png" alt></p>
<h2 id="创建-Thread-类"><a href="#创建-Thread-类" class="headerlink" title="创建 Thread 类"></a>创建 <code>Thread</code> 类</h2><p>创建多线程程序的第一种方式：创建 <code>Thread</code> 类的子类。</p>
<p> <code>java.lang.Thread</code> 类是描述线程的类，<strong>所有的线程对象都必须是 <code>Thread</code> 类或其子类的实例</strong>。</p>
<p>Java 中通过继承 <code>Thread</code> 类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义一个 <code>Thread</code> 类的子类，并重写 <code>Thread</code> 类中的 <code>run()</code> 方法，设置线程任务；</li>
<li>创建 <code>Thread</code> 子类的实例，即创建线程对象；</li>
<li>调用线程对象的 <code>start()</code> 方法，启动新的线程，执行 <code>run()</code> 方法。</li>
</ol>
<p>注意：多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</p>
<h2 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 4.调用Thread类中的方法start方法,开启新的线程,执行run方法</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程随机打印结果"><a href="#多线程随机打印结果" class="headerlink" title="多线程随机打印结果"></a>多线程随机打印结果</h3><p>程序启动运行 <code>main</code> 时，JVM 启动一个进程，主线程 <code>main</code> 在 <code>main()</code> 调用时候被创建。随着调用 mt 的对象的 <code>start()</code> 方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。  </p>
<p>结果是两个线程并发地运行：当前线程（main 线程）和另一个线程（创建的新线程，执行其 run 方法）。</p>
<ul>
<li>Java 程序属于抢占式调度，哪个线程的优先级高，哪个线程优先执行；同一个优先级，随机选择一个执行。</li>
</ul>
<p><img src="/2020/02/14/java-advanced-3/多线程随机性打印结果.png" alt></p>
<h3 id="多线程内存原理"><a href="#多线程内存原理" class="headerlink" title="多线程内存原理"></a>多线程内存原理</h3><p>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间</strong>，进行方法的压栈和弹栈。当执行线程的任务结束后，线程自动在栈内存中释放。但是当所有的执行线程都结束了，那么进程就结束了。  </p>
<p><img src="/2020/02/14/java-advanced-3/多线程内存图解.png" alt></p>
<h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a><code>Thread</code> 类</h2><p> <code>Thread</code> 类中定义了有关线程的一些方法：</p>
<ul>
<li>构造方法：<ul>
<li><code>public Thread()</code> ：分配一个新的线程对象。</li>
<li><code>public Thread(String name)</code> ：分配一个指定名字的新的线程对象。</li>
<li><code>public Thread(Runnable target)</code> ：分配一个带有指定目标新的线程对象。</li>
<li><code>public Thread(Runnable target, String name)</code> ：分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
</li>
<li>常用方法：<ul>
<li><code>public String getName()</code> ：获取当前线程名称。</li>
<li><code>public void start()</code> ：导致此线程开始执行； Java 虚拟机调用此线程的 run 方法。</li>
<li><code>public void run()</code> ：此线程要执行的任务在此处定义代码。</li>
<li><code>public static void sleep(long millis)</code> ：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li>
<li><code>public static Thread currentThread()</code> ：返回对当前正在执行的线程对象的引用。</li>
</ul>
</li>
</ul>
<h3 id="获取线程名称"><a href="#获取线程名称" class="headerlink" title="获取线程名称"></a>获取线程名称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写Thread类中的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程名称</span></span><br><span class="line">        String name = getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(t); <span class="comment">// Thread[Thread-0,5,main]</span></span><br><span class="line">        String name = t.getName();</span><br><span class="line">        System.out.println(name); <span class="comment">// Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetThreadName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 调用start方法,开启新线程,执行run方法</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">// main</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置线程名称"><a href="#设置线程名称" class="headerlink" title="设置线程名称"></a>设置线程名称</h3><ol>
<li>使用 <code>Thread</code> 类中的 <code>setName(名字)</code> 方法。<ul>
<li><code>void setName(String name)</code> ：改变线程名称，使之与参数 name 相同。</li>
</ul>
</li>
<li>创建一个带参数的构造方法，参数传递线程的名称：调用父类的带参构造方法，把线程名称传递给父类，让父类（<code>Thread</code>）给子线程起一个名字。<ul>
<li><code>Thread(String name)</code> ：分配新的 <code>Thread</code> 对象。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name); <span class="comment">// 把线程名称传递给父类,让父类(Thread)给子线程起一个名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程的名称</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSetThreadName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启多线程</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.setName(<span class="string">"小强"</span>);</span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启多线程</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"旺财"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暂停执行线程"><a href="#暂停执行线程" class="headerlink" title="暂停执行线程"></a>暂停执行线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟秒表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用Thread类的sleep方法让程序睡眠1秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 <code>Runnable</code> 接口</h2><p>创建多线程程序的第二种方式：实现 <code>Runnable</code> 接口。</p>
<p> <code>java.lang.Runnable</code> 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 <code>run</code> 的无参数方法。</p>
<p>实现步骤：</p>
<ol>
<li>定义一个 <code>Runnable</code> 接口的实现类；</li>
<li>在实现类中重写 <code>Runnable</code> 接口的 <code>run()</code> 方法，设置线程任务；</li>
<li>创建一个 <code>Runnable</code> 接口的实现类对象；</li>
<li>创建 <code>Thread</code> 类对象，构造方法中传递 <code>Runnable</code> 接口的实现类对象；</li>
<li>调用 <code>Thread</code> 类中的 <code>start()</code> 方法，开启新的线程执行 <code>run()</code> 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.在实现类中重写Runnable接口的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"HelloWorld"</span> + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建一个Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">// 4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(run); <span class="comment">// 打印线程名称</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(new RunnableImpl2()); // 打印HelloWorld</span></span><br><span class="line">        <span class="comment">// 5.调用Thread类中的start方法,开启新的线程执行run方法</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实现 <code>Runnable</code> 接口，使得该类有了多线程类的特征。<code>run()</code> 方法是多线程程序的一个执行目标，所有的多线程代码都在 <code>run()</code> 方法里面。<code>Thread</code> 类实际上也是实现了 <code>Runnable</code> 接口的类。</p>
<p>实现 <code>Runnable</code> 接口创建多线程程序的好处：</p>
<ol>
<li><strong>避免了单继承的局限性</strong>：<ul>
<li>一个类只能继承一个类，类继承了 <code>Thread</code> 类就不能继承其他的类。</li>
<li>实现了 <code>Runnable</code> 接口，还可以继承其他的类，实现其他的接口。</li>
</ul>
</li>
<li>增强了程序的扩展性，降低了程序的耦合性（解耦）：<ul>
<li>实现 <code>Runnable</code> 接口的方式，把<strong>设置线程任务</strong>和<strong>开启新线程</strong>进行了分离（解耦）。</li>
<li>实现类中，重写了 <code>run()</code> 方法：用来设置线程任务。</li>
<li>创建 <code>Thread</code> 类对象，调用 <code>start()</code> 方法：用来开启新线程。</li>
</ul>
</li>
</ol>
<h2 id="匿名内部类方式创建线程"><a href="#匿名内部类方式创建线程" class="headerlink" title="匿名内部类方式创建线程"></a>匿名内部类方式创建线程</h2><p>匿名：没有名字。</p>
<p>内部类：写在其他类内部的类。</p>
<p>匿名内部类作用：简化代码。</p>
<ul>
<li>把子类继承父类，重写父类的方法，创建子类对象合一步完成。</li>
<li>把实现类实现类接口，重写接口中的方法，创建实现类对象合成一步完成。</li>
<li>匿名内部类的最终产物：子类/实现类对象，而这个类没有名字。</li>
</ul>
<p>使用线程的匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 </p>
<p>使用匿名内部类的方式实现 <code>Runnable</code> 接口，重新 <code>Runnable</code> 接口中的 <code>run()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程的父类是Thread</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"Java"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程的接口Runnable</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"程序员"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化接口的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"Java程序员"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>通过一个电影院卖票的案例，演示线程的安全问题： </p>
<p><img src="/2020/02/14/java-advanced-3/线程安全问题.png" alt="线程安全问题"></p>
<p>模拟卖票：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 出票操作</span></span><br><span class="line">                <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模拟卖票案例</span></span><br><span class="line"><span class="comment">    创建3个线程,同时开启,对共享的票进行出售</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Runnable接口的实现类对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">// 创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(ticket);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket);</span><br><span class="line">        <span class="comment">// 调用start方法开启多线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现程序出现了两个问题：</p>
<ol>
<li>相同的票数，比如 100 这张票被卖了两回。</li>
<li>不存在的票，比如 0 票与 -1 票，是不存在的。</li>
</ol>
<p>这样的线程是不安全的。</p>
<p>上述案例中造成线程安全问题的原因分析如下：<img src="/2020/02/14/java-advanced-3/线程安全问题产生的原理.png" alt></p>
<p>线程安全问题都是<strong>由全局变量及静态变量引起</strong>的。</p>
<ul>
<li>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</li>
<li>若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。</li>
</ul>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 </p>
<p>要解决上述多线程并发访问一个资源的安全性问题：也就是解决重复票与不存在票问题，Java 中提供了同步机制 （<strong><code>synchronized</code></strong>）来解决。 </p>
<p>根据案例简述：窗口 1 线程进入操作的时候，窗口 2 和窗口 3 线程只能在外等着，窗口 1 操作结束，窗口 2 和窗口 3 才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺 CPU 资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p>
<p>为了保证每个线程都能正常执行原子操作，Java 引入了线程同步机制，有三种方式完成同步操作：</p>
<ol>
<li>同步代码块；</li>
<li>同步方法；</li>
<li>锁机制。</li>
</ol>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p><strong>同步代码块</strong>： <code>synchronized</code> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁对象) &#123;</span><br><span class="line">    可能会出现线程安全问题的代码(访问了共享数据的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>通过代码块中的锁对象，可以<strong>使用任意的对象</strong>。</li>
<li>但是必须保证多个线程<strong>使用的锁对象是同一个</strong>。</li>
<li>锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个锁对象</span></span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="comment">// 先判断票是否存在</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 出票操作</span></span><br><span class="line">                    <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步技术的原理"><a href="#同步技术的原理" class="headerlink" title="同步技术的原理"></a>同步技术的原理</h3><p>同步技术使用锁对象保证线程安全，这个锁对象叫<strong>同步锁（或对象监视器）</strong>。当某线程要执行同步代码时，会检查是否有锁对象。发现有锁对象时，就会获取到锁对象，进入同步中执行，执行完同步代码立刻归还锁对象；发现没有锁对象，线程就会进入阻塞状态，一直等待到获取到锁对象。</p>
<p><img src="/2020/02/14/java-advanced-3/同步的原理.png" alt></p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p><strong>同步方法</strong>：使用 <code>synchronized</code> 修饰的方法，就叫做同步方法，保证某一线程执行该方法的时候，其他线程只能在方法外等着。 </p>
<p>使用步骤：</p>
<ol>
<li>把访问了共享数据的代码抽取出来，放到一个方法中；</li>
<li>在方法上添加 <code>synchronized</code> 修饰符。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    可能会出现线程安全问题的代码(访问了共享数据的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>非静态同步方法的锁对象是 <code>this</code> 。</li>
<li>静态同步方法的锁对象是本类的 <code>class</code> 属性，也就是当前方法所在类的字节码文件对象（<code>类名.class</code>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this:"</span> + <span class="keyword">this</span>); <span class="comment">// this:com.itheima.demo08.Synchronized.RunnableImpl@58ceff1</span></span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            payTicket();</span><br><span class="line">            payTicketStatic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个同步方法</span></span><br><span class="line"><span class="comment">        同步方法也会把方法内部的代码锁住</span></span><br><span class="line"><span class="comment">        只让一个线程执行</span></span><br><span class="line"><span class="comment">        同步方法的锁对象是谁?</span></span><br><span class="line"><span class="comment">        就是实现类对象 new RunnableImpl()</span></span><br><span class="line"><span class="comment">        也是就是this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态的同步方法</span></span><br><span class="line"><span class="comment">        锁对象是谁?</span></span><br><span class="line"><span class="comment">        不能是this</span></span><br><span class="line"><span class="comment">        this是创建对象之后产生的,静态方法优先于对象</span></span><br><span class="line"><span class="comment">        静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">payTicketStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RunnableImpl.class) &#123;</span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a><code>Lock</code> 锁</h3><p> <strong><code>java.util.concurrent.locks.Lock</code> 机制</strong>提供了比 <strong><code>synchronized</code> 代码块</strong>和 <strong><code>synchronized</code> 方法</strong>更广泛的锁定操作，同步代码块 / 同步方法具有的功能 <code>Lock</code> 都有，除此之外更强大，更体现面向对象。</p>
<p><code>Lock</code> 接口中的方法：</p>
<ul>
<li><code>public void lock()</code> ：获取锁。</li>
<li><code>public void unlock()</code> ：释放锁。</li>
</ul>
<p>使用步骤：</p>
<ol>
<li>在成员位置创建一个 <code>ReentrantLock</code> 对象（<code>java.util.concurrent.locks.ReentrantLock</code> 类实现了 <code>Lock</code> 接口）；</li>
<li>在可能会出现安全问题的代码前调用 <code>Lock</code> 接口中的方法 <code>lock()</code> 获取锁；</li>
<li>在可能会出现安全问题的代码后调用 <code>Lock</code> 接口中的方法 <code>unlock()</code> 释放锁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.在成员位置创建一个ReentrantLock对象</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line">                    lock.unlock(); <span class="comment">// 无论程序是否异常,都会把锁释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><h2 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NEW</code>（新建）</td>
<td>线程刚被创建，但是并未启动。还没调用 <code>start</code> 方法。</td>
</tr>
<tr>
<td><code>RUNNABLE</code>（可运行）</td>
<td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td>
</tr>
<tr>
<td><code>BLOCKED</code>（阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 <code>Blocked</code> 状态；当该线程持有锁时，该线程将变成 <code>Runnable</code> 状态。</td>
</tr>
<tr>
<td><code>WAITING</code>（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 <code>Waiting</code> 状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用 <code>notify</code> 或者 <code>notifyAll</code> 方法才能够唤醒。</td>
</tr>
<tr>
<td><code>TIMED_WAITING</code>（计时等待）</td>
<td>同 <code>Waiting</code> 状态，有几个方法有超时参数，调用他们将进入 <code>Timed Waiting</code> 状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 <code>Thread.sleep</code> 、<code>Object.wait</code>。</td>
</tr>
<tr>
<td><code>TERMINATED</code>（终止）</td>
<td>因为 <code>run</code> 方法正常退出而死亡，或者因为没有捕获的异常终止了 <code>run</code> 方法而死亡。</td>
</tr>
</tbody>
</table>
</div>
<p>线程的状态图：<img src="/2020/02/14/java-advanced-3/线程的状态图.png" alt="线程的状态图"></p>
<h2 id="等待与唤醒"><a href="#等待与唤醒" class="headerlink" title="等待与唤醒"></a>等待与唤醒</h2><p>进入 <code>Time Waiting</code> （计时等待）状态有两种方式：</p>
<ol>
<li>使用 <code>Thread.sleep(long m)</code> 方法，在毫秒值结束之后，线程睡醒进入到 <code>Runnable</code> / <code>Blocked</code> 状态。</li>
<li>使用 <code>Object.wait(long m)</code> 方法，<code>wait</code> 方法如果在毫秒值结束之后，还没有被 <code>notify</code> 唤醒，就会自动醒来，线程睡醒进入到 <code>Runnable</code> / <code>Blocked</code> 状态。</li>
</ol>
<p>进入 <code>Waiting</code> 状态的方式：</p>
<ul>
<li>使用 <code>Object.wait()</code> 方法，在其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法前，导致当前线程等待。</li>
</ul>
<p>唤醒的方法：</p>
<ul>
<li><code>void notify()</code> 唤醒在此对象监视器上等待的单个线程。</li>
<li><code>void notifyAll()</code> 唤醒在此对象监视器上等待的所有线程。</li>
<li>会继续执行 <code>wait</code> 方法之后的代码。</li>
</ul>
<p>注意事项：</p>
<ul>
<li><code>Timed Waiting</code>（计时等待） 与 <code>Waiting</code>（无限等待） 状态联系很紧密。 <code>Waiting</code> 状态中 <code>wait</code> 方法是空参的，而 <code>Timed Waiting</code> 中 <code>wait</code> 方法是带参的。这种带参的方法，其实是一种倒计时操作，如果提前得到（唤醒）通知，设定时间也就显得多此一举了。那么，这种设计方案其实是一举两得，如果没有得到（唤醒）通知，那么线程就处于 <code>Timed Waiting</code> 状态，直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从 <code>Timed Waiting</code> 状态立刻唤醒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建锁对象,保证唯一</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个顾客线程(消费者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 一直等着买包子</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"顾客1告知老板要的包子的种类和数量"</span>);</span><br><span class="line">                        <span class="comment">// 调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">                        System.out.println(<span class="string">"包子已经做好了,顾客1开吃!"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个顾客线程(消费者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 一直等着买包子</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"顾客2告知老板要的包子的种类和数量"</span>);</span><br><span class="line">                        <span class="comment">// 调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">                        System.out.println(<span class="string">"包子已经做好了,顾客2开吃!"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个老板线程(生产者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 一直做包子</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 花了5秒做包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>); <span class="comment">// 花5秒钟做包子</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"老板5秒钟之后做好包子,告知顾客,可以吃包子了"</span>);</span><br><span class="line">                        <span class="comment">// 做好包子之后,调用notify方法,唤醒顾客吃包子</span></span><br><span class="line">                        obj.notify(); <span class="comment">// 如果有多个等待线程,随机唤醒一个</span></span><br><span class="line">                        <span class="comment">// obj.notifyAll(); // 唤醒所有等待的线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p><strong>线程间通信：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p><img src="/2020/02/14/java-advanced-3/线程通信示意.png" alt></p>
<p>为什么要处理线程间通信？</p>
<ul>
<li>多个线程并发执行时, 在默认情况下 CPU 是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</li>
</ul>
<p>如何保证线程间通信有效利用资源？</p>
<ul>
<li>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即<strong>等待唤醒机制。</strong></li>
</ul>
<h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p><strong>等待唤醒机制</strong>是多个线程间的一种<strong>协作</strong>机制。谈到线程，经常想到的是线程间的<strong>竞争</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（<code>wait()</code>），等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）；在有多个线程进行等待时，如果需要，可以使用 <code>notifyAll()</code> 来唤醒所有的等待线程。</p>
<p> <code>wait/notify</code> 就是线程间的一种协作机制。使用到的3个方法的含义如下：</p>
<ol>
<li><code>wait</code> ：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 <code>WAITING</code>。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是通知在这个对象上等待的线程从 wait set 中释放出来，重新进入到调度队列（ready queue）中。</li>
<li><code>notify</code> ：则选取所通知对象的 wait set 中的一个线程释放。</li>
<li><code>notifyAll</code> ：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<p>注意：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能<strong>在当初调用 <code>wait</code> 方法之后的地方恢复执行</strong>。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 <code>WAITING</code> 状态变成 <code>RUNNABLE</code> 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 <code>WAITING</code> 状态又变成 <code>BLOCKED</code> 状态。</li>
</ul>
<p>调用 <code>wait</code> 和 <code>notify</code> 方法需要注意的细节：</p>
<ol>
<li><code>wait</code> 方法与 <code>notify</code> 方法必须要由<strong>同一个锁对象</strong>调用。<ul>
<li>对应的锁对象可以通过 <code>notify</code> 唤醒使用同一个锁对象调用 <code>wait</code> 方法的线程。</li>
</ul>
</li>
<li><code>wait</code> 方法与 <code>notify</code> 方法是<strong>属于 <code>Object</code> 类的方法</strong>的。<ul>
<li>锁对象可以是任意对象，而任意对象的所属类都是继承了 <code>Object</code> 类的。</li>
</ul>
</li>
<li><code>wait</code> 方法与 <code>notify</code> 方法必须要在<strong>同步代码块</strong>或者是<strong>同步方法</strong>中使用。<ul>
<li>必须要通过锁对象调用这两个方法。</li>
</ul>
</li>
</ol>
<h2 id="等待唤醒案例"><a href="#等待唤醒案例" class="headerlink" title="等待唤醒案例"></a>等待唤醒案例</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p><img src="/2020/02/14/java-advanced-3/等待与唤醒案例分析.png" alt></p>
<p>定义包子资源类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    资源类:包子类</span></span><br><span class="line"><span class="comment">	设置包子的属性</span></span><br><span class="line"><span class="comment">		皮</span></span><br><span class="line"><span class="comment">		陷</span></span><br><span class="line"><span class="comment">		包子的状态: 有 true,没有 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    <span class="comment">//皮</span></span><br><span class="line">    String pi;</span><br><span class="line">    <span class="comment">//陷</span></span><br><span class="line">    String xian;</span><br><span class="line">    <span class="comment">//包子的状态: 有 true,没有 false,设置初始值为false没有包子</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消费者(吃货)类:是一个线程类,可以继承Thread</span></span><br><span class="line"><span class="comment">	设置线程任务(run):吃包子</span></span><br><span class="line"><span class="comment">	对包子的状态进行判断</span></span><br><span class="line"><span class="comment">	false:没有包子</span></span><br><span class="line"><span class="comment">		吃货调用wait方法进入等待状态</span></span><br><span class="line"><span class="comment">	true:有包子</span></span><br><span class="line"><span class="comment">		吃货吃包子</span></span><br><span class="line"><span class="comment">		吃货吃完包子</span></span><br><span class="line"><span class="comment">		修改包子的状态为false没有</span></span><br><span class="line"><span class="comment">		吃货唤醒包子铺线程,生产包子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.需要在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.使用带参数构造方法,为这个包子变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置线程任务(run):吃包子</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让吃货一直吃包子</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="comment">//对包子的状态进行判断</span></span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="comment">// 吃货调用wait方法进入等待状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被唤醒之后执行的代码,吃包子</span></span><br><span class="line">                System.out.println(<span class="string">"吃货正在吃:"</span> + bz.pi + bz.xian + <span class="string">"的包子"</span>);</span><br><span class="line">                <span class="comment">// 吃货吃完包子</span></span><br><span class="line">                <span class="comment">// 修改包子的状态为false没有</span></span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 吃货唤醒包子铺线程,生产包子</span></span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">"吃货已经把:"</span> + bz.pi + bz.xian + <span class="string">"的包子吃完了,包子铺开始生产包子"</span>);</span><br><span class="line">                System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者(包子铺)类:是一个线程类,可以继承Thread</span></span><br><span class="line"><span class="comment">	设置线程任务(run):生产包子</span></span><br><span class="line"><span class="comment">	对包子的状态进行判断</span></span><br><span class="line"><span class="comment">	true:有包子</span></span><br><span class="line"><span class="comment">		包子铺调用wait方法进入等待状态</span></span><br><span class="line"><span class="comment">	false:没有包子</span></span><br><span class="line"><span class="comment">		包子铺生产包子</span></span><br><span class="line"><span class="comment">		增加一些趣味性:交替生产两种包子</span></span><br><span class="line"><span class="comment">			有两种状态(i%2==0)</span></span><br><span class="line"><span class="comment">		包子铺生产好了包子</span></span><br><span class="line"><span class="comment">		修改包子的状态为true有</span></span><br><span class="line"><span class="comment">		唤醒吃货线程,让吃货线程吃包子</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	注意:</span></span><br><span class="line"><span class="comment">	    包子铺线程和包子线程关系--&gt;通信(互斥)</span></span><br><span class="line"><span class="comment">	    必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line"><span class="comment">	    锁对象必须保证唯一,可以使用包子对象作为锁对象</span></span><br><span class="line"><span class="comment">	    包子铺类和吃货的类就需要把包子对象作为参数传递进来</span></span><br><span class="line"><span class="comment">	        1.需要在成员位置创建一个包子变量</span></span><br><span class="line"><span class="comment">	        2.使用带参数构造方法,为这个包子变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.需要在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.使用带参数构造方法,为这个包子变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程任务(run):生产包子</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个变量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 让包子铺一直生产包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="comment">// 对包子的状态进行判断</span></span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 包子铺调用wait方法进入等待状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被唤醒之后执行,包子铺生产包子</span></span><br><span class="line">                <span class="comment">// 增加一些趣味性:交替生产两种包子</span></span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//生产 薄皮 三鲜馅</span></span><br><span class="line">                    bz.pi = <span class="string">"薄皮"</span>;</span><br><span class="line">                    bz.xian = <span class="string">"三鲜馅"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//生产 冰皮 牛肉大葱陷</span></span><br><span class="line">                    bz.pi = <span class="string">"冰皮"</span>;</span><br><span class="line">                    bz.xian = <span class="string">"牛肉大葱陷"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">"包子铺正在生产:"</span> + bz.pi + bz.xian + <span class="string">"包子"</span>);</span><br><span class="line">                <span class="comment">// 生产包子需要3秒钟</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 包子铺生产好了包子</span></span><br><span class="line">                <span class="comment">// 修改包子的状态为true有</span></span><br><span class="line">                bz.flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒吃货线程,让吃货线程吃包子</span></span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">"包子铺已经生产好了:"</span>+ bz.pi + bz.xian + <span class="string">"包子,吃货可以开始吃了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试类:</span></span><br><span class="line"><span class="comment">	包含main方法,程序执行的入口,启动程序</span></span><br><span class="line"><span class="comment">	创建包子对象;</span></span><br><span class="line"><span class="comment">	创建包子铺线程,开启,生产包子;</span></span><br><span class="line"><span class="comment">	创建吃货线程,开启,吃包子;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建包子对象;</span></span><br><span class="line">        BaoZi bz =<span class="keyword">new</span> BaoZi();</span><br><span class="line">        <span class="comment">// 创建包子铺线程,开启,生产包子;</span></span><br><span class="line">        <span class="keyword">new</span> BaoZiPu(bz).start();</span><br><span class="line">        <span class="comment">// 创建吃货线程,开启,吃包子;</span></span><br><span class="line">        <span class="keyword">new</span> ChiHuo(bz).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题，如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在 Java 中可以通过线程池来达到这样的效果。</p>
<h2 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h2><p><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p>
<p><img src="/2020/02/14/java-advanced-3/线程池.png" alt></p>
<p><img src="/2020/02/14/java-advanced-3/线程池原理.png" alt></p>
<p>合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下（每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机）。</li>
</ol>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>Java 里面线程池的顶级接口是 <code>java.util.concurrent.Executor</code> ，但是严格意义上讲 <code>Executor</code> 并不是一个线程池，而只是一个执行线程的工具。真正的<strong>线程池接口是 <code>java.util.concurrent.ExecutorService</code></strong> 。</p>
<p> <strong><code>java.util.concurrent.Executors</code> 是线程池的工厂类</strong>，用来生成线程池。</p>
<p> <code>Executors</code> 类中的静态方法：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code> ：创建一个可重用<strong>固定线程数的线程池</strong>。<ul>
<li>参数 <code>int nThreads</code> ：创建线程池中包含的线程数量。</li>
<li>返回值 <code>ExecutorService</code> 接口：返回的是 <code>ExecutorService</code> 接口的实现类对象，可以使用<code>ExecutorService</code> 接口接收（面向接口编程）。</li>
</ul>
</li>
</ul>
<p> <code>java.util.concurrent.ExecutorService</code> 线程池接口用来从线程池中获取线程，调用 <code>start</code> 方法，执行线程任务。</p>
<ul>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code> ：获取线程池中的某一个线程对象，提交一个 Runnable 任务用于执行。</li>
<li><code>public void shutdown()</code> ：关闭/销毁线程池。</li>
</ul>
<p>线程池的使用步骤：</p>
<ol>
<li>使用线程池的工厂类 <code>Executors</code> 里边提供的静态方法 <code>newFixedThreadPool</code> 生产一个指定线程数量的线程池；</li>
<li>创建一个类，实现 <code>Runnable</code> 接口，重写 <code>run</code> 方法，设置线程任务；</li>
<li>调用 <code>ExecutorService</code> 中的方法 <code>submit</code>，传递线程任务（实现类），开启线程，执行 <code>run</code> 方法；</li>
<li>调用 <code>ExecutorService</code> 中的方法 <code>shutdown</code> 销毁线程池（不建议执行）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"创建了一个新的线程执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-1创建了一个新的线程执行</span></span><br><span class="line">        <span class="comment">// 线程池会一直开启,使用完了线程,会自动把线程归还给线程池,线程可以继续使用</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-1创建了一个新的线程执行</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-2创建了一个新的线程执行</span></span><br><span class="line"></span><br><span class="line">        es.shutdown(); <span class="comment">// 不建议执行</span></span><br><span class="line">        <span class="comment">// es.submit(new RunnableImpl()); // 抛异常,线程池都没有了,就不能获取线程了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>喜欢就支持小方方一下吧~</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="Flexia 微信支付"/>
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="Flexia 支付宝"/>
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/JavaSE/" rel="tag"><i class="fa fa-tag"></i> JavaSE</a>
          
            <a href="/tags/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/" rel="tag"><i class="fa fa-tag"></i> Java语言高级</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/12/java-advanced-2.html" rel="next" title="Java语言高级（2）集合">
                <i class="fa fa-chevron-left"></i> Java语言高级（2）集合
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/20/java-advanced-4.html" rel="prev" title="Java语言高级（4）File类与IO流">
                Java语言高级（4）File类与IO流 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Flexia"/>
            
              <p class="site-author-name" itemprop="name">Flexia</p>
              <div class="site-description motion-element" itemprop="description">小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">45</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/fangfengxin" title="GitHub &rarr; https://github.com/fangfengxin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:fangfengxin98@163.com" title="E-Mail &rarr; mailto:fangfengxin98@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#异常"><span class="nav-number">1.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异常概念"><span class="nav-number">1.1.</span> <span class="nav-text">异常概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常体系"><span class="nav-number">1.2.</span> <span class="nav-text">异常体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常的产生过程"><span class="nav-number">1.3.</span> <span class="nav-text">异常的产生过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常的处理"><span class="nav-number">2.</span> <span class="nav-text">异常的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#抛出异常-throw"><span class="nav-number">2.1.</span> <span class="nav-text">抛出异常 throw</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objects-非空判断"><span class="nav-number">2.2.</span> <span class="nav-text">Objects 非空判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明异常-throws"><span class="nav-number">2.3.</span> <span class="nav-text">声明异常 throws</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#捕获异常-try-catch"><span class="nav-number">2.4.</span> <span class="nav-text">捕获异常 try...catch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally-代码块"><span class="nav-number">2.5.</span> <span class="nav-text">finally 代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常注意事项"><span class="nav-number">2.6.</span> <span class="nav-text">异常注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义异常"><span class="nav-number">3.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-number">4.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发与并行"><span class="nav-number">4.1.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程"><span class="nav-number">4.2.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程概念"><span class="nav-number">4.2.1.</span> <span class="nav-text">进程概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程概念"><span class="nav-number">4.2.2.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程调度"><span class="nav-number">4.2.3.</span> <span class="nav-text">线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主线程"><span class="nav-number">4.2.4.</span> <span class="nav-text">主线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-Thread-类"><span class="nav-number">4.3.</span> <span class="nav-text">创建 Thread 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程原理"><span class="nav-number">4.4.</span> <span class="nav-text">多线程原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程随机打印结果"><span class="nav-number">4.4.1.</span> <span class="nav-text">多线程随机打印结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程内存原理"><span class="nav-number">4.4.2.</span> <span class="nav-text">多线程内存原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-类"><span class="nav-number">4.5.</span> <span class="nav-text">Thread 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取线程名称"><span class="nav-number">4.5.1.</span> <span class="nav-text">获取线程名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置线程名称"><span class="nav-number">4.5.2.</span> <span class="nav-text">设置线程名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#暂停执行线程"><span class="nav-number">4.5.3.</span> <span class="nav-text">暂停执行线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-Runnable-接口"><span class="nav-number">4.6.</span> <span class="nav-text">实现 Runnable 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名内部类方式创建线程"><span class="nav-number">4.7.</span> <span class="nav-text">匿名内部类方式创建线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全"><span class="nav-number">5.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全问题"><span class="nav-number">5.1.</span> <span class="nav-text">线程安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步机制"><span class="nav-number">5.2.</span> <span class="nav-text">线程同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步代码块"><span class="nav-number">5.2.1.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步技术的原理"><span class="nav-number">5.2.2.</span> <span class="nav-text">同步技术的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步方法"><span class="nav-number">5.2.3.</span> <span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock-锁"><span class="nav-number">5.2.4.</span> <span class="nav-text">Lock 锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程状态"><span class="nav-number">6.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态概述"><span class="nav-number">6.1.</span> <span class="nav-text">线程状态概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待与唤醒"><span class="nav-number">6.2.</span> <span class="nav-text">等待与唤醒</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程间通信"><span class="nav-number">6.3.</span> <span class="nav-text">线程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待唤醒机制"><span class="nav-number">6.4.</span> <span class="nav-text">等待唤醒机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待唤醒案例"><span class="nav-number">6.5.</span> <span class="nav-text">等待唤醒案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程池"><span class="nav-number">7.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池概念"><span class="nav-number">7.1.</span> <span class="nav-text">线程池概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的使用"><span class="nav-number">7.2.</span> <span class="nav-text">线程池的使用</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Flexia</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">743k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">11:15</span>
  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color='0,0,0' opacity='1' zIndex='-1' count='20' src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  
  

<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '7kWTdJsaz4FTWvD11vJ68LrU-gzGzoHsz',
    appKey: 'IagQj5azVtsiUPyjWRrvasm6',
    placeholder: '要不要说点啥……',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  


  

</body>
</html>
