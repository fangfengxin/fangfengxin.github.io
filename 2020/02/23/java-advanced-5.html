<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>








  <meta name="google-site-verification" content="N8ofSn2GrmJ51OE3RhiifNsuUcNAfC7JAukwhpY-WiY"/>












  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"/>
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.png?v=7.2.0" color="#222">


  <link rel="manifest" href="/images/site.webmanifest">


  <meta name="msapplication-config" content="/images/browserconfig.xml"/>





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":"default"},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta name="description" content="网络通信概述软件结构 C&#x2F;S 结构 ：全称为 Client &#x2F; Server 结构，是指客户端和服务器结构。 B&#x2F;S 结构 ：全称为 Browser &#x2F; Server 结构，是指浏览器和服务器结构。  两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语言高级（5）网络编程与JDK8新特性">
<meta property="og:url" content="https://fangfengxin.top/2020/02/23/java-advanced-5.html">
<meta property="og:site_name" content="Flexia&#39;s Blog">
<meta property="og:description" content="网络通信概述软件结构 C&#x2F;S 结构 ：全称为 Client &#x2F; Server 结构，是指客户端和服务器结构。 B&#x2F;S 结构 ：全称为 Browser &#x2F; Server 结构，是指浏览器和服务器结构。  两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E7%AB%AF%E5%8F%A3%E5%8F%B7.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/TCP%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A6%82%E8%BF%B0.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A1%88%E4%BE%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E6%A8%A1%E6%8B%9FBS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%9E%90.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E5%A4%8D%E5%88%B6.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E6%95%88%E6%9E%9C%E5%9B%BE1.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E6%95%88%E6%9E%9C%E5%9B%BE2.png">
<meta property="og:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E6%B5%81%E5%BC%8F%E6%80%9D%E6%83%B3%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="article:published_time" content="2020-02-23T15:16:00.000Z">
<meta property="article:modified_time" content="2020-07-13T08:44:22.101Z">
<meta property="article:author" content="Flexia">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="Java语言高级">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangfengxin.top/2020/02/23/java-advanced-5/%E7%AB%AF%E5%8F%A3%E5%8F%B7.png">





  
  
  <link rel="canonical" href="https://fangfengxin.top/2020/02/23/java-advanced-5"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java语言高级（5）网络编程与JDK8新特性 | Flexia's Blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145696891-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-145696891-1');
    }
  </script>



  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ccc4ebbe605a1363703684938a4b4c40";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Flexia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">记录小方方的学习之路</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    
  
  

  

  <a href="https://github.com/fangfengxin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fangfengxin.top/2020/02/23/java-advanced-5.html"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Flexia"/>
      <meta itemprop="description" content="小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~"/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Flexia's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java语言高级（5）网络编程与JDK8新特性

              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-23 23:16:00" itemprop="dateCreated datePublished" datetime="2020-02-23T23:16:00+08:00">2020-02-23</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-13 16:44:22" itemprop="dateModified" datetime="2020-07-13T16:44:22+08:00">2020-07-13</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">Java语言高级</span></a></span>

                
                
              
            </span>
          
		  
		  <br/>

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/02/23/java-advanced-5.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/23/java-advanced-5.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">47k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">43 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="网络通信概述"><a href="#网络通信概述" class="headerlink" title="网络通信概述"></a>网络通信概述</h1><h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><ul>
<li><strong>C/S 结构</strong> ：全称为 Client / Server 结构，是指客户端和服务器结构。</li>
<li><strong>B/S 结构</strong> ：全称为 Browser / Server 结构，是指浏览器和服务器结构。</li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
<li><strong>TCP/IP 协议：</strong> 传输控制协议 / 因特网互联协议（Transmission Control Protocol / Internet Protocol），是 Internet 最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型（链路层、网络层、传输层、应用层），每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<h2 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p> <code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><strong>UDP</strong>：用户数据报协议（User Datagram Protocol）。<ul>
<li>UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li>
<li>由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输。例如视频会议都使用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</li>
<li>但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用 UDP 协议。</li>
<li>特点：数据被限制在 64kb 以内，超出这个范围就不能发送了。</li>
</ul>
</li>
<li><strong>TCP</strong>：传输控制协议（Transmission Control Protocol）。<ul>
<li>TCP 协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</li>
<li>在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</li>
<li>三次握手：TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</li>
<li>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP 协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</li>
</ul>
</li>
</ul>
<h2 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则。</li>
</ul>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称 IP。IP 地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<h4 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h4><ul>
<li>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成 <code>a.b.c.d</code> 的形式，最多可以表示 42 亿个。</li>
<li>IPv6：由于互联网的蓬勃发展，IP 地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。为了扩大地址空间，通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping IP地址</span><br></pre></td></tr></table></figure>
<h4 id="特殊的-IP-地址"><a href="#特殊的-IP-地址" class="headerlink" title="特殊的 IP 地址"></a>特殊的 IP 地址</h4><ul>
<li>本机 IP 地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说 <strong>IP 地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是 0 ~ 65535 </strong>。其中，0 ~ 1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p><img src="/2020/02/23/java-advanced-5/端口号.png" alt></p>
<p>利用 <code>协议</code> + <code>IP地址</code> + <code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h1><h2 id="TCP-通信概述"><a href="#TCP-通信概述" class="headerlink" title="TCP 通信概述"></a>TCP 通信概述</h2><p>TCP 通信能实现两台计算机之间的数据交互，通信的两端要严格区分为客户端（Client）与服务器端（Server）。</p>
<p>两端通信时步骤：</p>
<ol>
<li>服务器端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务器端不可以主动连接客户端。</li>
<li>客户端与服务器端建立逻辑连接后，连接中会包含一个 IO 字节流对象，客户端与服务器端可以使用这个 IO 对象进行通信。</li>
</ol>
<p>在 Java 中，提供了两个类用于实现 TCP 通信程序：</p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建 <code>Socket</code> 对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建 <code>ServerSocket</code> 对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<p>服务器端必须明确两件事：</p>
<ol>
<li>多个客户端同时与服务器端交互，服务器端必须明确在和哪个客户端交互。<ul>
<li>服务器端有一个方法 <code>accept</code> 可以获取到请求的客户端对象。</li>
</ul>
</li>
<li>多个客户端同时与服务器端交互，服务器端必须使用多个 IO 对象。<ul>
<li>服务器端是没有 IO 流的，服务器端可以获取到请求的客户端对象 <code>Socket</code>，使用每个客户端 <code>Socket</code> 中提供的 IO 流与客户端进行交互。</li>
</ul>
</li>
</ol>
<p><img src="/2020/02/23/java-advanced-5/TCP通信的概述.png" alt></p>
<h2 id="Socket-类"><a href="#Socket-类" class="headerlink" title="Socket 类"></a><code>Socket</code> 类</h2><p>TCP 通信的客户端，向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据。</p>
<p>表示客户端的类：<code>Socket</code> 类。此类实现客户端套接字，套接字指的是两台设备之间通讯的端点，套接字是包含了 IP 地址和端口号的网络单位。</p>
<p>构造方法：</p>
<ul>
<li><code>public Socket(String host, int port)</code> ：创建一个流套接字并将其连接到指定主机上的指定端口号。<ul>
<li>如果指定的 host 是 <code>null</code> ，则相当于指定地址为回送地址。  </li>
<li>回送地址（127.x.x.x）是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</li>
</ul>
</li>
</ul>
<p>成员方法：</p>
<ul>
<li><code>public InputStream getInputStream()</code> ：返回此套接字的输入流。<ul>
<li>如果此 <code>Scoket</code> 具有相关联的通道，则生成的 <code>InputStream</code> 的所有操作也关联该通道。</li>
<li>关闭生成的 <code>InputStream</code> 也将关闭相关的 <code>Socket</code>。</li>
</ul>
</li>
<li><code>public OutputStream getOutputStream()</code> ：返回此套接字的输出流。<ul>
<li>如果此 <code>Scoket</code> 具有相关联的通道，则生成的 <code>OutputStream</code> 的所有操作也关联该通道。</li>
<li>关闭生成的 <code>OutputStream</code> 也将关闭相关的 <code>Socket</code>。</li>
</ul>
</li>
<li><code>public void close()</code> ：关闭此套接字。<ul>
<li>一旦一个 <code>Socket</code> 被关闭，它不可再使用。</li>
<li>关闭此 <code>Socket</code> 也将关闭相关的 <code>InputStream</code> 和 <code>OutputStream</code> 。 </li>
</ul>
</li>
<li><code>public void shutdownOutput()</code> ：禁用此套接字的输出流。   <ul>
<li>对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。</li>
<li>如果在套接字上调用 <code>shutdownOutput()</code> 后写入套接字输出流，则该流将抛出 <code>IOException</code>。 </li>
</ul>
</li>
</ul>
<p>客户端的实现步骤：</p>
<ol>
<li>创建一个客户端对象 <code>Socket</code>，构造方法绑定服务器的 IP 地址和端口号；</li>
<li>使用 <code>Socket</code> 对象中的方法 <code>getOutputStream()</code> 获取网络字节输出流 <code>OutputStream</code> 对象；</li>
<li>使用网络字节输出流 <code>OutputStream</code> 对象中的方法 <code>write</code>，给服务器发送数据；</li>
<li>使用 <code>Socket</code> 对象中的方法 <code>getInputStream()</code> 获取网络字节输入流 <code>InputStream</code> 对象；</li>
<li>使用网络字节输入流 <code>InputStream</code> 对象中的方法 <code>read</code>，读取服务器回写的数据；</li>
<li>释放资源（<code>Socket</code>）。</li>
</ol>
<p>注意：</p>
<ol>
<li>客户端和服务器端进行交互，必须使用 <code>Socket</code> 中提供的网络流，不能使用自己创建的流对象。</li>
<li>当我们创建客户端对象 <code>Socket</code> 的时候，就会去请求服务器，和服务器经过三次握手建立连接通路。<ul>
<li>这时如果服务器没有启动，那么就会抛出异常 <code>ConnectException</code>。</li>
<li>如果服务器已经启动，那么就可以进行交互。</li>
</ul>
</li>
</ol>
<h2 id="ServerSocket-类"><a href="#ServerSocket-类" class="headerlink" title="ServerSocket 类"></a><code>ServerSocket</code> 类</h2><p>TCP 通信的服务器端，接收客户端的请求，读取客户端发送的数据，给客户端回写数据。</p>
<p>表示服务器的类：<code>ServerSocket</code> 类。此类实现了服务器套接字，该对象等待通过网络的请求。</p>
<p>构造方法：</p>
<ul>
<li><code>public ServerSocket(int port)</code> ：创建绑定到特定端口的服务器套接字。</li>
</ul>
<p>成员方法：</p>
<ul>
<li><code>public Socket accept()</code> ：侦听并接受到此套接字的连接。<ul>
<li>返回一个新的 <code>Socket</code> 对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
</li>
</ul>
<p>服务器的实现步骤：</p>
<ol>
<li>创建服务器 <code>ServerSocket</code> 对象向系统要指定的端口号；</li>
<li>使用 <code>ServerSocket</code> 对象中的方法 <code>accept</code>，获取到请求的客户端对象 <code>Socket</code>；</li>
<li>使用 <code>Socket</code> 对象中的方法 <code>getInputStream()</code> 获取网络字节输入流 <code>InputStream</code> 对象；</li>
<li>使用网络字节输入流 <code>InputStream</code> 对象中的方法 <code>read</code>，读取客户端发送的数据；</li>
<li>使用 <code>Socket</code> 对象中的方法 <code>getOutputStream()</code> 获取网络字节输出流 <code>OutputStream</code> 对象；</li>
<li>使用网络字节输出流 <code>OutputStream</code> 对象中的方法 <code>write</code>，给客户端回写数据；</li>
<li>释放资源（<code>Socket</code>，<code>ServerSocket</code>）。</li>
</ol>
<h2 id="简单的-TCP-通信程序"><a href="#简单的-TCP-通信程序" class="headerlink" title="简单的 TCP 通信程序"></a>简单的 TCP 通信程序</h2><p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输出流OutputStream对象中的方法write,给服务器发送数据</span></span><br><span class="line">        os.write(<span class="string">"你好服务器"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输入流InputStream对象中的方法read,读取服务器回写的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源(Socket)</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器ServerSocket对象向系统要指定的端口号</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 使用ServerSocket对象中的方法accept,获取到请求的客户端对象Socket</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输入流InputStream对象中的方法read,读取客户端发送的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输出流OutputStream对象中的方法write,给客户端回写数据</span></span><br><span class="line">        os.write(<span class="string">"收到谢谢"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 释放资源(Socket,ServerSocket)</span></span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络编程案例"><a href="#网络编程案例" class="headerlink" title="网络编程案例"></a>网络编程案例</h1><h2 id="案例：文件上传"><a href="#案例：文件上传" class="headerlink" title="案例：文件上传"></a>案例：文件上传</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p><img src="/2020/02/23/java-advanced-5/文件上传的原理.png" alt></p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件上传案例的客户端:读取本地文件,上传到服务器,读取服务器回写的数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源:c:\\1.jpg</span></span><br><span class="line"><span class="comment">        目的地:服务器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源</span></span><br><span class="line"><span class="comment">        2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号</span></span><br><span class="line"><span class="comment">        3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象</span></span><br><span class="line"><span class="comment">        4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件</span></span><br><span class="line"><span class="comment">        5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器</span></span><br><span class="line"><span class="comment">        6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象</span></span><br><span class="line"><span class="comment">        7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据</span></span><br><span class="line"><span class="comment">        8.释放资源(FileInputStream,Socket)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件上传案例服务器端:读取客户端上传的文件,保存到服务器的硬盘,给客户端回写"上传成功"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源:客户端上传的文件</span></span><br><span class="line"><span class="comment">        目的地:服务器的硬盘 d:\\upload\\1.jpg</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建一个服务器ServerSocket对象,和系统要指定的端口号</span></span><br><span class="line"><span class="comment">        2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象</span></span><br><span class="line"><span class="comment">        3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象</span></span><br><span class="line"><span class="comment">        4.判断d:\\upload文件夹是否存在,不存在则创建</span></span><br><span class="line"><span class="comment">        5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地</span></span><br><span class="line"><span class="comment">        6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件</span></span><br><span class="line"><span class="comment">        7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上</span></span><br><span class="line"><span class="comment">        8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象</span></span><br><span class="line"><span class="comment">        9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功"</span></span><br><span class="line"><span class="comment">        10.释放资源(FileOutputStream,Socket,ServerSocket)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        </span><br><span class="line">        File file =  <span class="keyword">new</span> File(<span class="string">"d:\\upload"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">"\\1.jpg"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.getOutputStream().write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        fos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="程序阻塞问题"><a href="#程序阻塞问题" class="headerlink" title="程序阻塞问题"></a>程序阻塞问题</h4><p>执行程序，客户端和服务器都不停止，进入阻塞状态，原因如下：</p>
<ul>
<li><code>InputStream</code> 类的 <strong><code>read</code> 方法：在输入数据可用、检测到文件末尾或者抛出异常前，此方法一直阻塞</strong>。</li>
<li><code>OutputStream</code> 对象的 <code>write</code> 方法在读取到结束标记后不会将文件结束标记写入，则服务器不会接收到文件结束标记，导致服务器端的网络字节输入流阻塞。</li>
<li>服务器端的网络字节输入流阻塞，就不会执行网络字节输出流给客户端回写数据，导致客户端的网络字节输入流接收不到数据而阻塞。</li>
</ul>
<p>解决方式：</p>
<ul>
<li>在上传完文件后，给服务器端写一个文件结束标记。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      解决:上传完文件,给服务器写一个结束标记</span></span><br><span class="line"><span class="comment">      void shutdownOutput() 禁用此套接字的输出流。</span></span><br><span class="line"><span class="comment">      对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">socket.shutdownOutput();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/23/java-advanced-5/文件上传案例的阻塞问题.png" alt></p>
<h4 id="文件名称写死问题"><a href="#文件名称写死问题" class="headerlink" title="文件名称写死问题"></a>文件名称写死问题</h4><p>服务器端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      自定义一个文件的命名规则:防止同名的文件被覆盖</span></span><br><span class="line"><span class="comment">      规则:域名+毫秒值+随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String fileName = System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999</span>) + <span class="string">".jpg"</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">"\\"</span> + fileName);</span><br></pre></td></tr></table></figure>
<h4 id="循环接收问题"><a href="#循环接收问题" class="headerlink" title="循环接收问题"></a>循环接收问题</h4><p>服务器端，只保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      让服务器一直处于监听状态(死循环accept方法)</span></span><br><span class="line"><span class="comment">      有一个客户端上传文件,就保存一个文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>服务器端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用多线程技术,提高程序的效率</span></span><br><span class="line"><span class="comment">	有一个客户端上传文件,就开启一个线程,完成文件的上传</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用匿名内部类和Lambda表达式优化</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 完成文件的上传</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为Runnable接口中run方法未声明异常，所以需要在方法体内try...catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h3><p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        </span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//完成文件的上传</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       InputStream is = socket.getInputStream();</span><br><span class="line">                       </span><br><span class="line">                       File file =  <span class="keyword">new</span> File(<span class="string">"d:\\upload"</span>);</span><br><span class="line">                       <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">                           file.mkdirs();</span><br><span class="line">                       &#125;</span><br><span class="line">                       String fileName = System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999</span>) + <span class="string">".jpg"</span>;</span><br><span class="line">                       FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">"\\"</span> + fileName);</span><br><span class="line">                       </span><br><span class="line">                       <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                       <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                       <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                           fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                       socket.getOutputStream().write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                       </span><br><span class="line">                       fos.close();</span><br><span class="line">                       socket.close();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       System.out.println(e);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例：模拟-B-S-服务器"><a href="#案例：模拟-B-S-服务器" class="headerlink" title="案例：模拟 B/S 服务器"></a>案例：模拟 B/S 服务器</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务器端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p><img src="/2020/02/23/java-advanced-5/模拟BS服务器分析.png" alt></p>
<ol>
<li><p>准备页面数据，web 文件夹，复制到 Module 中。</p>
<p> <img src="/2020/02/23/java-advanced-5/复制.png" alt></p>
</li>
<li><p>模拟服务器端，<code>ServerSocket</code> 类监听端口，使用浏览器访问。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line">    socket.close();</span><br><span class="line">    server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息。</p>
<p> <img src="/2020/02/23/java-advanced-5/读取访问信息.jpg" alt></p>
<p>  <code>GET /web/index.html HTTP/1.1</code> 是浏览器的请求消息。<code>/web/index.html</code> 为浏览器想要请求的服务器端的资源，使用字符串切割方式获取到请求的资源。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">// 取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务器端实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     创建BS版本TCP服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个服务器ServerSocket,和系统要指定的端口号</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 使用accept方法获取到请求的客户端对象(浏览器)</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 把is网络字节输入流对象,转换为字符缓冲输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">// 把客户端请求信息的第一行读取出来 GET /11_Net/web/index.html HTTP/1.1</span></span><br><span class="line">        String line = br.readLine();</span><br><span class="line">        <span class="comment">// 把读取的信息进行切割,只要中间部分 /11_Net/web/index.html</span></span><br><span class="line">        String[] arr = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 把路径前边的/去掉,进行截取 11_Net/web/index.html</span></span><br><span class="line">        String htmlpath = arr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个本地字节输入流,构造方法中绑定要读取的html路径</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(htmlpath);</span><br><span class="line">        <span class="comment">// 使用Socket中的方法getOutputStream获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        os.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">        os.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一读一写复制文件,把服务读取的html文件回写到客户端</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><p><img src="/2020/02/23/java-advanced-5/效果图1.png" alt></p>
<p>发现浏览器中出现很多的叉子，说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问，因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建BS版本TCP服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            浏览器解析服务器回写的html页面,页面中如果有图片,那么浏览器就会单独的开启一个线程,读取服务器的图片</span></span><br><span class="line"><span class="comment">            我们就的让服务器一直处于监听状态,客户端请求一次,服务器就回写一次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用accept方法获取到请求的客户端对象(浏览器)</span></span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        InputStream is = socket.getInputStream();</span><br><span class="line">                        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">                        </span><br><span class="line">                        String line = br.readLine();</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                        String[] arr = line.split(<span class="string">" "</span>);</span><br><span class="line">                        String htmlpath = arr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        FileInputStream fis = <span class="keyword">new</span> FileInputStream(htmlpath);</span><br><span class="line">                        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">                        os.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                        os.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">                        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        fis.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问效果：</p>
<p><img src="/2020/02/23/java-advanced-5/效果图2.png" alt></p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h2 id="函数式接口的定义"><a href="#函数式接口的定义" class="headerlink" title="函数式接口的定义"></a>函数式接口的定义</h2><p>函数式接口在 Java 中是指：<strong>有且仅有一个抽象方法的接口</strong>。 </p>
<p>函数式接口，即适用于函数式编程场景的接口。而 Java 中的函数式编程体现就是 Lambda，所以函数式接口就是可以适用于 Lambda 使用的接口。只有确保接口中有且仅有一个抽象方法，Java 中的 Lambda 才能顺利地进行推导。 </p>
<p>备注：“<strong>语法糖</strong>”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的 <code>for-each</code> 语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java 中的 Lambda 可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。 </p>
<p>函数式接口的定义格式：只要确保接口中有且仅有一个抽象方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值类型 方法名称(参数列表);</span><br><span class="line">    <span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FunctionalInterface-注解"><a href="#FunctionalInterface-注解" class="headerlink" title="@FunctionalInterface 注解"></a><code>@FunctionalInterface</code> 注解</h2><p>与 <code>@Override</code> 注解的作用类似，Java 8 中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code> 。该注解可用于一个接口的定义上，用来检测一个接口是否是一个函数式接口。</p>
<ul>
<li>是函数式接口：编译成功；</li>
<li>不是函数式接口：编译失败（接口中没有抽象方法，或抽象方法的个数多于 1 个）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义函数式接口并使用"><a href="#自定义函数式接口并使用" class="headerlink" title="自定义函数式接口并使用"></a>自定义函数式接口并使用</h2><p>函数式接口的使用：一般可以作为方法的参数和返回值类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFunctionalInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用普通实现类重写接口中的抽象方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,参数使用函数式接口MyFunctionalInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(MyFunctionalInterface myInter)</span></span>&#123;</span><br><span class="line">        myInter.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用show方法,方法的参数是一个接口,所以可以传递接口的实现类对象</span></span><br><span class="line">        show(<span class="keyword">new</span> MyFunctionalInterfaceImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用show方法,方法的参数是一个接口,所以我们可以传递接口的匿名内部类</span></span><br><span class="line">        show(<span class="keyword">new</span> MyFunctionalInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用匿名内部类重写接口中的抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用show方法,方法的参数是一个函数式接口,所以我们可以Lambda表达式</span></span><br><span class="line">        show(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化Lambda表达式</span></span><br><span class="line">        show(() -&gt; System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>在兼顾面向对象特性的基础上，Java 语言通过 Lambda 表达式与方法引用等，为开发者打开了函数式编程的大门。</p>
<h2 id="Lambda-的延迟执行"><a href="#Lambda-的延迟执行" class="headerlink" title="Lambda 的延迟执行"></a>Lambda 的延迟执行</h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而 Lambda 表达式是延迟执行的，这正好可以 作为解决方案，提升性能。 </p>
<h3 id="性能浪费的日志案例"><a href="#性能浪费的日志案例" class="headerlink" title="性能浪费的日志案例"></a>性能浪费的日志案例</h3><p>日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoLogger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个根据日志的级别,显示日志信息的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(<span class="keyword">int</span> level, String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对日志的等级进行判断,如果是1级别,那么输出日志信息</span></span><br><span class="line">        <span class="keyword">if</span>(level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义三个日志信息</span></span><br><span class="line">        String msg1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String msg2 = <span class="string">"World"</span>;</span><br><span class="line">        String msg3 = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用showLog方法,传递日志级别和日志信息</span></span><br><span class="line">        showLog(<span class="number">2</span>, msg1 + msg2 + msg3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码存在问题：无论级别是否满足要求，作为 <code>showLog</code> 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 </p>
<h3 id="Lambda-优化"><a href="#Lambda-优化" class="headerlink" title="Lambda 优化"></a>Lambda 优化</h3><p>使用 Lambda 需要一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个拼接消息的抽象方法,返回被拼接的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">buildMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 showLog 方法进行改造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Lambda</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个显示日志的方法,方法的参数传递日志的等级和MessageBuilder接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder mb)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对日志的等级进行判断,如果是1级,则调用MessageBuilder接口中的builderMessage方法</span></span><br><span class="line">        <span class="keyword">if</span>(level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(mb.buildMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义三个日志信息</span></span><br><span class="line">        String msg1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String msg2 = <span class="string">"World"</span>;</span><br><span class="line">        String msg3 = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用showLog方法,参数MessageBuilder是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        showLog(<span class="number">1</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"不满足条件不执行"</span>);</span><br><span class="line">            <span class="comment">// 返回一个拼接好的字符串</span></span><br><span class="line">            <span class="keyword">return</span> msg1 + msg2 + msg3;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Lambda 表达式作为参数传递，仅仅是把参数传递到 <code>showLog</code> 方法中。</p>
<ul>
<li>只有满足条件，日志的等级是 1 级，才会调用接口 <code>MessageBuilder</code> 中的方法 <code>builderMessage</code>，进行字符串的拼接；</li>
<li>如果条件不满足，日志的等级不是 1 级，那么 <code>MessageBuilder</code> 接口中的方法 <code>builderMessage</code> 也不会执行，所以拼接字符串的代码也不会执行，不会存在性能的浪费。</li>
</ul>
<h2 id="使用-Lambda-作为方法的参数和返回值"><a href="#使用-Lambda-作为方法的参数和返回值" class="headerlink" title="使用 Lambda 作为方法的参数和返回值"></a>使用 Lambda 作为方法的参数和返回值</h2><p>如果抛开实现原理不说，Java 中的 Lambda 表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用 Lambda 表达式进行替代。使用 Lambda 表达式作为方法参数，其实就是使用函数式接口作为方法参数。</p>
<p>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 <code>startThread</code> 方法使用该接口作为参数，那么就可以使用 Lambda 进行传参。这种情况其实和 <code>Thread</code> 类的构造方法参数为 <code>Runnable</code> 没有本质区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable run)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用startThread方法,方法的参数是一个接口,那么我们可以传递这个接口的匿名内部类</span></span><br><span class="line">        startThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"线程启动了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用startThread方法,方法的参数是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        startThread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"线程启动了"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        startThread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"线程启动了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个 Lambda 表达式。当需要通过一个方法来获取一个 <code>java.util.Comparator</code> 接口类型的对象作为排序器时，就可以调该方法获取。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法的返回值类型是一个接口,那么我们可以返回这个接口的匿名内部类</span></span><br><span class="line">        <span class="comment">/*return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">                return o2.length() - o1.length();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法的返回值类型是一个函数式接口,所有我们可以返回一个Lambda表达式</span></span><br><span class="line">        <span class="comment">/*return (String o1, String o2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            return o2.length() - o1.length();</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续优化Lambda表达式</span></span><br><span class="line">        <span class="keyword">return</span> (o1, o2) -&gt; o2.length() - o1.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"aaa"</span>,<span class="string">"b"</span>,<span class="string">"cccccc"</span>,<span class="string">"dddddddddddd"</span>&#125;;</span><br><span class="line">        <span class="comment">// 输出排序前的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [aaa, b, cccccc, dddddddddddd]</span></span><br><span class="line">        <span class="comment">// 调用Arrays中的sort方法,对字符串数组进行排序</span></span><br><span class="line">        Arrays.sort(arr, getComparator());</span><br><span class="line">        <span class="comment">// 输出排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [dddddddddddd, cccccc, aaa, b]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h1><p>JDK 8 提供了大量常用的函数式接口以丰富 Lambda 的典型使用场景，它们主要在 <code>java.util.function</code> 包中被提供。</p>
<h2 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a><code>Supplier</code> 接口</h2><p> <code>java.util.function.Supplier&lt;T&gt;</code> 接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的 <code>get</code> 方法就会生产什么类型的数据。</p>
<h3 id="抽象方法-get"><a href="#抽象方法-get" class="headerlink" title="抽象方法 get"></a>抽象方法 <code>get</code></h3><p> <code>Supplier&lt;T&gt;</code> 接口仅包含一个无参的方法 <code>T get()</code>，用来获取一个泛型参数指定类型的对象数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSupplier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,方法的参数传递Supplier&lt;T&gt;接口,泛型执行String,get方法就会返回一个String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用getString方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        String s1 = getString(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 生产一个字符串,并返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"胡歌"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        String s2 = getString(() -&gt; <span class="string">"胡歌"</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习：求数组元素最大值"><a href="#练习：求数组元素最大值" class="headerlink" title="练习：求数组元素最大值"></a>练习：求数组元素最大值</h3><p>练习使用 <code>Supplier</code> 接口作为方法参数类型，通过 Lambda 表达式求出 int 数组中的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 方法的参数传递Supplier接口,泛型使用Integer</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sup.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">880</span>,<span class="number">99</span>,<span class="number">33</span>,-<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">// 调用getMax方法,方法的参数Supplier是一个函数式接口,传递Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; max) &#123;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"数组中元素的最大值是:"</span> + maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a><code>Consumer</code> 接口</h2><p> <code>java.util.function.Consumer&lt;T&gt;</code> 接口则正好与 <code>Supplier</code> 接口相反，它不是生产一个数据，而是<strong>消费</strong>一个数据，其数据类型由泛型决定。</p>
<h3 id="抽象方法-accept"><a href="#抽象方法-accept" class="headerlink" title="抽象方法 accept"></a>抽象方法 <code>accept</code></h3><p> <code>Consumer</code> 接口中包含抽象方法 <code>void accept(T t)</code>，意为消费一个指定泛型的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递一个字符串的姓名</span></span><br><span class="line"><span class="comment">        方法的参数传递Consumer接口,泛型使用String</span></span><br><span class="line"><span class="comment">        可以使用Consumer接口消费字符串的姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> </span>&#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递字符串姓名,方法的另一个参数是Consumer接口,是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        method(<span class="string">"赵丽颖"</span>, (String name) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 消费方式:把字符串进行反转输出</span></span><br><span class="line">            String reName = <span class="keyword">new</span> StringBuffer(name).reverse().toString();</span><br><span class="line">            System.out.println(reName);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认方法-andThen"><a href="#默认方法-andThen" class="headerlink" title="默认方法 andThen"></a>默认方法 <code>andThen</code></h3><p>如果一个方法的参数和返回值全都是 <code>Consumer</code> 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是 <code>Consumer</code> 接口中的 <code>default</code> 方法 <code>andThen</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想实现组合，需要两个或多个 Lambda 表达式，而 <code>andThen</code> 的语义正是“一步接一步”操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAndThen</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,方法的参数传递一个字符串和两个Consumer接口,Consumer接口的泛型使用字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// con1.accept(s);</span></span><br><span class="line">        <span class="comment">// con2.accept(s);</span></span><br><span class="line">        <span class="comment">// 使用andThen方法,把两个Consumer接口连接到一起,在消费数据</span></span><br><span class="line">        con1.andThen(con2).accept(s); <span class="comment">// con1连接con2,先执行con1消费数据,再执行con2消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递一个字符串,两个Lambda表达式</span></span><br><span class="line">        method(<span class="string">"Hello"</span>,</span><br><span class="line">               (t) -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 消费方式:把字符串转换为大写输出</span></span><br><span class="line">                   System.out.println(t.toUpperCase());</span><br><span class="line">               &#125;,</span><br><span class="line">               (t) -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 消费方式:把字符串转换为小写输出</span></span><br><span class="line">                   System.out.println(t.toLowerCase());</span><br><span class="line">               &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习：格式化打印信息"><a href="#练习：格式化打印信息" class="headerlink" title="练习：格式化打印信息"></a>练习：格式化打印信息</h3><p>字符串数组当中存有多条信息，请按照格式“ 姓名：XX。性别：XX。 ”的格式将信息打印出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,参数传递String类型的数组和两个Consumer接口,泛型使用String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (String message : arr) &#123;</span><br><span class="line">            <span class="comment">// 使用andThen方法连接两个Consumer接口,消费字符串</span></span><br><span class="line">            con1.andThen(con2).accept(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用printInfo方法,传递一个字符串数组,和两个Lambda表达式</span></span><br><span class="line">        printInfo(arr, (message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 消费方式:对message进行切割,获取姓名,按照指定的格式输出</span></span><br><span class="line">            String name = message.split(<span class="string">","</span>)[<span class="number">0</span>];</span><br><span class="line">            System.out.print(<span class="string">"姓名: "</span> + name + <span class="string">"。"</span>);</span><br><span class="line">        &#125;, (message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 消费方式:对message进行切割,获取年龄,按照指定的格式输出</span></span><br><span class="line">            String age = message.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">            System.out.println(<span class="string">"年龄: "</span> + age + <span class="string">"。"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Predicate-接口"><a href="#Predicate-接口" class="headerlink" title="Predicate 接口"></a><code>Predicate</code> 接口</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 <code>java.util.function.Predicate&lt;T&gt;</code> 接口。 </p>
<h3 id="抽象方法-test"><a href="#抽象方法-test" class="headerlink" title="抽象方法 test"></a>抽象方法 <code>test</code></h3><p> <code>Predicate</code> 接口中包含一个抽象方法 <code>boolean test(T t)</code> ，用于条件判断的场景，对某种数据类型的数据进行判断，结果返回一个 boolean 值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        参数传递一个String类型的字符串</span></span><br><span class="line"><span class="comment">        传递一个Predicate接口,泛型使用String</span></span><br><span class="line"><span class="comment">        使用Predicate中的方法test对字符串进行判断,并把判断的结果返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  pre.test(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abcdef"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用checkString方法对字符串进行校验,参数传递字符串和Lambda表达式</span></span><br><span class="line">        <span class="comment">/*boolean b = checkString(s, (String str) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            // 对参数传递的字符串进行判断,判断字符串的长度是否大于5,并把判断的结果返回</span></span><br><span class="line"><span class="comment">            return str.length() &gt; 5;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, str -&gt; str.length() &gt; <span class="number">5</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认方法-and"><a href="#默认方法-and" class="headerlink" title="默认方法 and"></a>默认方法 <code>and</code></h3><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。</p>
<p>使用逻辑运算符构成逻辑表达式可以连接多个条件判断：与运算符 <code>&amp;&amp;</code> 、或运算符 <code>||</code> 和 非（取反）运算符 <code>!</code> 。</p>
<p> <code>Predicate</code> 接口中有一个方法 <code>and</code>，表示并且关系，也可以用于连接两个判断条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; <span class="keyword">this</span>.test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法内部的两个判断条件，也是使用 <code>&amp;&amp;</code> 运算符连接起来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicateAnd</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,方法的参数,传递一个字符串</span></span><br><span class="line"><span class="comment">        传递两个Predicate接口</span></span><br><span class="line"><span class="comment">            一个用于判断字符串的长度是否大于5</span></span><br><span class="line"><span class="comment">            一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">            两个条件必须同时满足</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.and(pre2).test(s); <span class="comment">// 等价于 return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abcdef"</span>;</span><br><span class="line">        <span class="comment">// 调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串的长度是否大于5</span></span><br><span class="line">            <span class="keyword">return</span> str.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串中是否包含a</span></span><br><span class="line">            <span class="keyword">return</span> str.contains(<span class="string">"a"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认方法-or"><a href="#默认方法-or" class="headerlink" title="默认方法 or"></a>默认方法 <code>or</code></h3><p> <code>Predicate</code> 接口中有一个方法 <code>or</code>，表示或者关系，也可以用于连接两个判断条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法内部的两个判断条件，也是使用 <code>||</code> 运算符连接起来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicateOr</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          定义一个方法,方法的参数,传递一个字符串</span></span><br><span class="line"><span class="comment">          传递两个Predicate接口</span></span><br><span class="line"><span class="comment">              一个用于判断字符串的长度是否大于5</span></span><br><span class="line"><span class="comment">              一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">          满足一个条件即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  pre1.or(pre2).test(s); <span class="comment">// 等价于 return pre1.test(s) || pre2.test(s);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"bc"</span>;</span><br><span class="line">        <span class="comment">// 调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串的长度是否大于5</span></span><br><span class="line">            <span class="keyword">return</span> str.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串中是否包含a</span></span><br><span class="line">            <span class="keyword">return</span> str.contains(<span class="string">"a"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认方法-negate"><a href="#默认方法-negate" class="headerlink" title="默认方法 negate"></a>默认方法 <code>negate</code></h3><p> <code>Predicate</code> 接口中有一个方法 <code>negate</code>，表示取反的意思。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicateNegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          定义一个方法,方法的参数,传递一个字符串</span></span><br><span class="line"><span class="comment">          使用Predicate接口判断字符串的长度是否大于5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  pre.negate().test(s); <span class="comment">// 等效于 return !pre.test(s);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 调用checkString方法,参数传递字符串和Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串的长度是否大于5,并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> str.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习：集合信息筛选"><a href="#练习：集合信息筛选" class="headerlink" title="练习：集合信息筛选"></a>练习：集合信息筛选</h3><p>数组当中有多条“姓名+性别”的信息，请通过 <code>Predicate</code> 接口的拼装将符合要求的字符串筛选到集合 ArrayList 中，需要同时满足两个条件：</p>
<ol>
<li>必须为女生；</li>
<li>姓名为4个字。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">filter</span><span class="params">(String[] arr, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个ArrayList集合,存储过滤之后的信息</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组,获取数组中的每一条信息</span></span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            <span class="comment">// 使用Predicate接口中的方法test对获取到的字符串进行判断</span></span><br><span class="line">            <span class="keyword">boolean</span> b = pre1.and(pre2).test(s);</span><br><span class="line">            <span class="comment">// 对得到的布尔值进行判断</span></span><br><span class="line">            <span class="keyword">if</span>(b) &#123;</span><br><span class="line">                <span class="comment">// 条件成立,两个条件都满足,把信息存储到ArrayList集合中</span></span><br><span class="line">                list.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把集合返回</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span>, <span class="string">"赵丽颖,女"</span> &#125;;</span><br><span class="line">        <span class="comment">// 调用filter方法,传递字符串数组和两个Lambda表达式</span></span><br><span class="line">        ArrayList&lt;String&gt; list = filter(array, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取字符串中的性别,判断是否为女</span></span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">","</span>)[<span class="number">1</span>].equals(<span class="string">"女"</span>);</span><br><span class="line">        &#125;, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取字符串中的姓名,判断长度是否为4个字符</span></span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">","</span>)[<span class="number">0</span>].length() == <span class="number">4</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a><code>Function</code> 接口</h2><p> <code>java.util.function.Function&lt;T, R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>
<h3 id="抽象方法-apply"><a href="#抽象方法-apply" class="headerlink" title="抽象方法 apply"></a>抽象方法 <code>apply</code></h3><p> <code>Function</code> 接口中最主要的抽象方法为 <code>R apply(T t)</code>，根据类型 T 的参数获取类型 R 的结果。使用的场景如将 <code>String</code> 类型转换为 <code>Integer</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFunction</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递一个字符串类型的整数</span></span><br><span class="line"><span class="comment">        方法的参数传递一个Function接口,泛型使用&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">        使用Function接口中的方法apply,把字符串类型的整数,转换为Integer类型的整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> in = fun.apply(s);<span class="comment">//自动拆箱 Integer-&gt;int</span></span><br><span class="line">        System.out.println(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"1234"</span>;</span><br><span class="line">        <span class="comment">// 调用change方法,传递字符串类型的整数,和Lambda表达式</span></span><br><span class="line">        change(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把字符串类型的整数,转换为Integer类型的整数返回</span></span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 优化Lambda</span></span><br><span class="line">        change(s, str -&gt; Integer.parseInt(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认方法-andThen-1"><a href="#默认方法-andThen-1" class="headerlink" title="默认方法 andThen"></a>默认方法 <code>andThen</code></h3><p> <code>Function</code> 接口中有一个默认的 <code>andThen</code> 方法，用来进行组合操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法同样用于“先做什么，再做什么”的场景，和 <code>Consumer</code> 中的 <code>andThen</code> 差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    需求:</span></span><br><span class="line"><span class="comment">        把String类型的"123",转换为Inteter类型,把转换后的结果加10</span></span><br><span class="line"><span class="comment">        把增加之后的Integer类型的数据,转换为String类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFunctionAndThen</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        参数串一个字符串类型的整数</span></span><br><span class="line"><span class="comment">        参数再传递两个Function接口</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;Integer,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun1, Function&lt;Integer,String&gt; fun2)</span> </span>&#123;</span><br><span class="line">        String ss = fun1.andThen(fun2).apply(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"123"</span>;</span><br><span class="line">        change(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把字符串转换为整数+10</span></span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(str) + <span class="number">10</span>;</span><br><span class="line">        &#125;, (Integer i) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把整数转换为字符串</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="string">""</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        change(s, str -&gt; Integer.parseInt(str) + <span class="number">10</span>, i -&gt; i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习：自定义函数模型拼接"><a href="#练习：自定义函数模型拼接" class="headerlink" title="练习：自定义函数模型拼接"></a>练习：<strong>自定义函数模型拼接</strong></h3><p>请使用 <code>Function</code> 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"赵丽颖,20"</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>将字符串截取数字年龄部分，得到字符串；</li>
<li>将上一步的字符串转换成为 int 类型的数字；</li>
<li>将上一步的 int 数字累加 100，得到结果 int 数字。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        参数传递包含姓名和年龄的字符串</span></span><br><span class="line"><span class="comment">        参数再传递3个Function接口用于类型转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,String&gt; fun1, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;String,Integer&gt; fun2, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;Integer,Integer&gt; fun3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用andThen方法把三个转换组合到一起</span></span><br><span class="line">        <span class="keyword">return</span> fun1.andThen(fun2).andThen(fun3).apply(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"赵丽颖,20"</span>;</span><br><span class="line">        <span class="keyword">int</span> num = change(str, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// "赵丽颖,20"-&gt;"20"</span></span><br><span class="line">           <span class="keyword">return</span> s.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">        &#125;, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// "20"-&gt;20</span></span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">        &#125;, (Integer i) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 20-&gt;120</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a><code>Stream</code> 流</h1><p>说到 <code>Stream</code> 便容易想到 I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在 Java 8 中，得益于 Lambda 所带来的函数式编程，引入了一个<strong>全新的 <code>Stream</code> 概念</strong>，用于解决已有集合类库既有的弊端。</p>
<h2 id="流式思想"><a href="#流式思想" class="headerlink" title="流式思想"></a>流式思想</h2><h3 id="传统集合的循环遍历弊端"><a href="#传统集合的循环遍历弊端" class="headerlink" title="传统集合的循环遍历弊端"></a>传统集合的循环遍历弊端</h3><p>几乎所有的集合（如 <code>Collection</code> 接口或 <code>Map</code> 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。</p>
<p>使用传统方式对集合中的数据进行过滤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">        list.add(<span class="string">"赵敏"</span>);</span><br><span class="line">        list.add(<span class="string">"张强"</span>);</span><br><span class="line">        list.add(<span class="string">"张三丰"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">                listA.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; listB = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : listA) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                listB.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : listB) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8 的 Lambda 让我们更加专注于<strong>做什么</strong>（What）而不是<strong>怎么做</strong>（How），这点此前结合内部类进行了对比说明。现在我们仔细体会上述代码，可以发现：</p>
<ul>
<li>for 循环的语法就是“怎么做”；</li>
<li>for 循环的循环体才是“做什么”。</li>
</ul>
<p>上述代码中含有三个循环，每一个作用都不同：</p>
<ol>
<li>首先筛选所有姓张的人；</li>
<li>然后筛选名字中有三个字的人；</li>
<li>最后对结果进行打印输出。</li>
</ol>
<p>为什么使用循环？因为要遍历。但是循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并<strong>不是从第一个到最后一个顺次进行处理的循环</strong>。前者是方式，后者是目的。</p>
<h3 id="Stream-的更优写法"><a href="#Stream-的更优写法" class="headerlink" title="Stream 的更优写法"></a><code>Stream</code> 的更优写法</h3><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是。</strong>循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。那 Lambda 的衍生物 <code>Stream</code> 能给我们带来怎样更加优雅的写法呢？</p>
<p>使用 <code>Stream</code> 流的方式,遍历集合，对集合中的数据进行过滤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">        list.add(<span class="string">"赵敏"</span>);</span><br><span class="line">        list.add(<span class="string">"张强"</span>);</span><br><span class="line">        list.add(<span class="string">"张三丰"</span>);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">            .filter(name -&gt; name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">            .filter(name -&gt; name.length() == <span class="number">3</span>)</span><br><span class="line">            .forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流式思想概述"><a href="#流式思想概述" class="headerlink" title="流式思想概述"></a>流式思想概述</h3><p>整体来看，流式思想类似于工厂车间的“<strong>生产流水线</strong>”。 </p>
<p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。</p>
<p><img src="/2020/02/23/java-advanced-5/流式思想示意图.png" alt></p>
<p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字 3 是最终结果。 </p>
<p>这里的 <code>filter</code>、<code>map</code>、<code>skip</code> 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 <code>count</code> 执行的时候，整个模型才会按照指定策略执行操作。而这得益于 Lambda 的延迟执行特性。</p>
<p><code>Stream</code>（流）是一个来自数据源的元素队列。</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java 中的 <code>Stream</code> 并<strong>不会存储元素</strong>，而是按需计算。 </li>
<li><strong>数据源</strong>（流的来源） 可以是集合、数组等。 </li>
</ul>
<p>和以前的 <code>Collection</code> 操作不同， <code>Stream</code> 操作还有两个基础的特征： </p>
<ul>
<li><strong>Pipelining</strong>：中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（flfluent style）。这样做可以对操作进行优化，比如延迟执行（laziness）和短路（short-circuiting）。 </li>
<li><strong>内部迭代</strong>： 以前对集合遍历都是通过 <code>Iterator</code> 或者增强 for 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 <code>Stream</code> 提供了内部迭代的方式，流可以直接调用遍历方法。 </li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换 → 执行操作获取想要的结果，每次转换原有 <code>Stream</code> 对象不改变，返回一个新的 <code>Stream</code> 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。 </p>
<h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p> <code>java.util.stream.Stream&lt;T&gt;</code> 接口是 Java 8 新加入的最常用的流接口。（这并不是一个函数式接口。） </p>
<p>获取一个流非常简单，有以下几种常用的方式： </p>
<ol>
<li>所有的 <code>Collection</code> 集合都可以通过 <code>stream()</code> 默认方法获取流；<ul>
<li><code>default Stream&lt;E&gt; stream()</code> </li>
</ul>
</li>
<li><code>Stream</code> 接口的静态方法 <code>of(T... values)</code> 可以获取数组对应的流。<ul>
<li><code>static &lt;T&gt; Stream&lt;T&gt; of(T... values)</code> </li>
</ul>
</li>
</ol>
<h3 id="根据-Collection-获取流"><a href="#根据-Collection-获取流" class="headerlink" title="根据 Collection 获取流"></a>根据 <code>Collection</code> 获取流</h3><p>首先，<code>java.util.Collection</code> 接口中加入了 default 方法 <code>stream</code> 用来获取流，所以其所有实现类均可获取流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据-Map-获取流"><a href="#根据-Map-获取流" class="headerlink" title="根据 Map 获取流"></a>根据 Map 获取流</h3><p> <code>java.util.Map</code> 接口不是 <code>Collection</code> 的子接口，且其 K-V 数据结构不符合流元素的单一特征，所以获取对应的流需要分 key、value 或 entry 等情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取键,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; stream3 = keySet.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取值,存储到一个Collection集合中</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        Stream&lt;String&gt; stream4 = values.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取键值对(键与值的映射关系 entrySet)</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 <code>Stream</code> 接口中提供了静态方法 <code>of</code> ，使用很简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把数组转换为Stream流</span></span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 可变参数可以传递数组</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream7 = Stream.of(arr);</span><br><span class="line">        String[] arr2 = &#123;<span class="string">"a"</span>,<span class="string">"bb"</span>,<span class="string">"ccc"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream8 = Stream.of(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流的常用方法"><a href="#流的常用方法" class="headerlink" title="流的常用方法"></a>流的常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的 API。这些方法可以被分成两种： </p>
<ul>
<li><strong>延迟方法</strong>：返回值类型仍然是 <code>Stream</code> 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</li>
<li><strong>终结方法</strong>：返回值类型不再是 <code>Stream</code> 接口自身类型的方法，因此不再支持链式调用。本小节中，终结方法包括 <code>count</code> 和 <code>forEach</code> 方法。</li>
</ul>
<h3 id="逐一处理-forEach"><a href="#逐一处理-forEach" class="headerlink" title="逐一处理 forEach"></a>逐一处理 <code>forEach</code></h3><p>虽然方法名字叫 <code>forEach</code> ，但是与 for 循环中的 for-each 昵称不同。</p>
<p> <code>Stream</code> 流中的常用方法 <code>forEach</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法接收一个 <code>Consumer</code> 接口参数，会将每一个流元素交给该参数进行处理。<code>Consumer</code> 接口是一个消费型的函数式接口，可以传递 Lambda 表达式消费数据。</p>
<p>forEach 方法，用来<strong>遍历流中的数据</strong>，是一个<strong>终结方法</strong>，遍历之后就不能继续调用 <code>Stream</code> 流中的其他方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamForEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"赵六"</span>, <span class="string">"田七"</span>);</span><br><span class="line">        stream.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤 filter"></a>过滤 <code>filter</code></h3><p> <code>Stream</code> 流中的常用方法 <code>filter</code> ，用于对 <code>Stream</code> 流中的数据进行过滤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>
<p> <code>filter</code> 方法的参数 <code>Predicate</code> 是一个函数式接口，所以可以传递 Lambda 表达式，对数据进行过滤。</p>
<p>此前学习过 <code>Predicate</code> 中的抽象方法 <code>boolean test(T t)</code> ，该方法将会产生一个 boolean 值结果，代表指定的条件是否满足。</p>
<ul>
<li>如果结果为 <code>true</code>，那么 <code>Stream</code> 流的 <code>filter</code> 方法将会留用元素；</li>
<li>如果结果为 <code>false</code>，那么 <code>filter</code> 方法将会舍弃元素。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三丰"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        <span class="comment">// 对Stream流中的元素进行过滤,只要姓张的人</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.filter(name -&gt; name.startsWith(<span class="string">"张"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历stream2流</span></span><br><span class="line">        stream2.forEach(name -&gt; System.out.println(name));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历stream流</span></span><br><span class="line">        stream.forEach(name -&gt; System.out.println(name)); <span class="comment">// IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>Stream</code> 流属于管道流，只能被消费（使用）一次，上一个 <code>Stream</code> 流调用完毕方法，数据就会流转到下一个 <code>Stream</code> 上，而这时上一个 <code>Stream</code> 流已经使用完毕就会关闭，上一个 <code>Stream</code> 流再调用方法将会抛出 <code>IllegalStateException</code>。</p>
<h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 <code>map</code></h3><p> <code>Stream</code> 流中的常用方法 <code>map</code> 用于类型转换。如果需要将流中的元素映射到另一个流中，可以使用 <code>map</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该接口需要一个 <code>Function</code> 函数式接口参数，可以将当前流中的 T 类型数据转换为另一种 R 类型的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>);</span><br><span class="line">        <span class="comment">// 使用map方法,把字符串类型的整数,转换(映射)为Integer类型的整数</span></span><br><span class="line">        Stream&lt;Integer&gt; stream2 = stream.map(s -&gt; Integer.parseInt(s));</span><br><span class="line">        <span class="comment">// 遍历Stream2流</span></span><br><span class="line">        stream2.forEach(i -&gt; System.out.println(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计个数-count"><a href="#统计个数-count" class="headerlink" title="统计个数 count"></a>统计个数 <code>count</code></h3><p> <code>Stream</code> 流中的常用方法 <code>count</code> ，用于统计 <code>Stream</code> 流中元素的个数，类似旧集合 <code>Collection</code> 当中的 <code>size</code> 方法一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p> <code>count</code> 方法是一个<strong>终结方法</strong>，返回值是一个 long 类型的整数，所以不能再继续调用 <code>Stream</code> 流中的其他方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        <span class="keyword">long</span> count = stream.count();</span><br><span class="line">        System.out.println(count); <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取用前几个元素-limit"><a href="#取用前几个元素-limit" class="headerlink" title="取用前几个元素 limit"></a>取用前几个元素 <code>limit</code></h3><p> <code>limit</code> 方法可以对流进行截取，只取用前 n 个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure>
<p> <code>limit</code> 方法是一个延迟方法，只是对流中的元素进行截取，返回的是一个新的流，所以可以继续调用 <code>Stream</code> 流中的其他方法。参数是一个 long 型，如果集合当前长度大于参数则进行截取，否则不进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamLimit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>,<span class="string">"喜洋洋"</span>,<span class="string">"懒洋洋"</span>,<span class="string">"灰太狼"</span>,<span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 使用limit对Stream流中的元素进行截取,只要前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.limit(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 遍历stream2流</span></span><br><span class="line">        stream2.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跳过前几个元素-skip"><a href="#跳过前几个元素-skip" class="headerlink" title="跳过前几个元素 skip"></a>跳过前几个元素 <code>skip</code></h3><p> <code>Stream</code> 流中的常用方法 <code>skip</code> ，用于跳过元素。如果希望跳过前几个元素，可以使用 <code>skip</code> 方法获取一个截取之后的新流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果流的当前长度大于 n，则跳过前 n 个；否则将会得到一个长度为 0 的空流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamSkip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>,<span class="string">"喜洋洋"</span>,<span class="string">"懒洋洋"</span>,<span class="string">"灰太狼"</span>,<span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 使用skip方法跳过前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.skip(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 遍历stream2流</span></span><br><span class="line">        stream2.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合-concat"><a href="#组合-concat" class="headerlink" title="组合 concat"></a>组合 <code>concat</code></h3><p> <code>Stream</code> 流中的常用方法 <code>concat</code> ，用于把流组合到一起。如果有两个流，希望合并成为一个流，那么可以使用 <code>Stream</code> 接口的静态方法 <code>concat</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是一个静态方法，与 <code>java.lang.String</code> 当中的 <code>concat</code> 方法是不同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamConcat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"张三丰"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>, <span class="string">"喜洋洋"</span>, <span class="string">"懒洋洋"</span>, <span class="string">"灰太狼"</span>, <span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 把以上两个流组合为一个流</span></span><br><span class="line">        Stream&lt;String&gt; concat = Stream.concat(stream1, stream2);</span><br><span class="line">        <span class="comment">// 遍历concat流</span></span><br><span class="line">        concat.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><p>现在有两个 <code>ArrayList</code> 集合存储队伍当中的多个成员姓名，要求分别使用传统 for 循环和 <code>Stream</code> 流式处理依次进行以下若干操作步骤： </p>
<ol>
<li>第一个队伍只要名字为 3 个字的成员姓名，存储到一个新集合中。</li>
<li>第一个队伍筛选之后只要前 3 个人，存储到一个新集合中。</li>
<li>第二个队伍只要姓张的成员姓名，存储到一个新集合中。</li>
<li>第二个队伍筛选之后不要前 2 个人，存储到一个新集合中。</li>
<li>将两个队伍合并为一个队伍，存储到一个新集合中。</li>
<li>根据姓名创建 Person 对象，存储到一个新集合中。</li>
<li>打印整个队伍的 Person 对象信息。</li>
</ol>
<p>定义 Person 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传统-for-循环处理"><a href="#传统-for-循环处理" class="headerlink" title="传统 for 循环处理"></a>传统 for 循环处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoForTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        one.add(<span class="string">"宋远桥"</span>);</span><br><span class="line">        one.add(<span class="string">"苏星河"</span>);</span><br><span class="line">        one.add(<span class="string">"石破天"</span>);</span><br><span class="line">        one.add(<span class="string">"石中玉"</span>);</span><br><span class="line">        one.add(<span class="string">"老子"</span>);</span><br><span class="line">        one.add(<span class="string">"庄子"</span>);</span><br><span class="line">        one.add(<span class="string">"洪七公"</span>);</span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; one1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : one) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                one1.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; one2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            one2.add(one1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        two.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        two.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        two.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        two.add(<span class="string">"尼古拉斯赵四"</span>);</span><br><span class="line">        two.add(<span class="string">"张天爱"</span>);</span><br><span class="line">        two.add(<span class="string">"张二狗"</span>);</span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; two1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">                two1.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; two2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; two1.size(); i++) &#123;</span><br><span class="line">            two2.add(two1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        all.addAll(one2);</span><br><span class="line">        all.addAll(two2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : all) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Person(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Stream-流式处理"><a href="#Stream-流式处理" class="headerlink" title="Stream 流式处理"></a><code>Stream</code> 流式处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        one.add(<span class="string">"宋远桥"</span>);</span><br><span class="line">        one.add(<span class="string">"苏星河"</span>);</span><br><span class="line">        one.add(<span class="string">"石破天"</span>);</span><br><span class="line">        one.add(<span class="string">"石中玉"</span>);</span><br><span class="line">        one.add(<span class="string">"老子"</span>);</span><br><span class="line">        one.add(<span class="string">"庄子"</span>);</span><br><span class="line">        one.add(<span class="string">"洪七公"</span>);</span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；存储到一个新集合中。</span></span><br><span class="line">        Stream&lt;String&gt; oneStream = one.stream().filter(name -&gt; name.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        two.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        two.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        two.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        two.add(<span class="string">"尼古拉斯赵四"</span>);</span><br><span class="line">        two.add(<span class="string">"张天爱"</span>);</span><br><span class="line">        two.add(<span class="string">"张二狗"</span>);</span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；存储到一个新集合中。</span></span><br><span class="line">        Stream&lt;String&gt; twoStream = two.stream().filter(name -&gt; name.startsWith(<span class="string">"张"</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        Stream.concat(oneStream, twoStream).map(name -&gt; <span class="keyword">new</span> Person(name)).forEach(p -&gt; System.out.println(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h2 id="冗余的-Lambda-场景"><a href="#冗余的-Lambda-场景" class="headerlink" title="冗余的 Lambda 场景"></a>冗余的 Lambda 场景</h2><p>来看一个简单的函数式接口以应用 Lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过 Lambda 来使用它的代码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrintable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">        p.print(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printString(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过 Lambda 表达式指定了函数式接口 Printable 的具体操作方案为：<strong>拿到 String（类型可推导，所以可省略）数据后，在控制台中输出它</strong>。 </p>
<p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out 对象中的 println(String) 方法。既然 Lambda 希望做的事情就是调用 println(String) 方法，那何必自己手动调用呢？ </p>
<h2 id="用方法引用改进"><a href="#用方法引用改进" class="headerlink" title="用方法引用改进"></a>用方法引用改进</h2><p>能否省去 Lambda 的语法格式（尽管它已经相当简洁）呢？</p>
<p>Lambda 表达式的目的是打印参数传递的字符串，把参数 s 传递给了 System.out 对象，调用 out 对象中的方法 println 对字符串进行输出，注意：</p>
<ol>
<li>System.out 对象是已经存在的；</li>
<li>println 方法也是已经存在的。</li>
</ol>
<p>所以我们可以使用方法引用来优化 Lambda 表达式，可以使用 System.out 对象直接引用（调用）println 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrintable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">        p.print(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printString(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法引用运算符"><a href="#方法引用运算符" class="headerlink" title="方法引用运算符 ::"></a>方法引用运算符 <code>::</code></h2><p>双冒号 <code>::</code> 为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果 Lambda 要表达的函数方案已经存在于某个方法的实现中，那么则可以<strong>通过双冒号来引用该方法作为 Lambda 的替代者</strong>。 </p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>上例中，System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效： </p>
<ul>
<li>Lambda 表达式写法： <code>s -&gt; System.out.println(s);</code> </li>
<li>方法引用写法： <code>System.out::println</code> </li>
</ul>
<p>第一种语义是指：拿到参数之后经 Lambda 之手，继而传递给 System.out.println 方法去处理。 </p>
<p>第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代 Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 </p>
<p>注意：Lambda 中传递的参数一定是方法引用中的那个方法可以接收的类型，否则会抛出异常。</p>
<h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><p>如果使用 Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定重载形式，它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 </p>
<p>函数式接口是 Lambda 的基础，而方法引用是 Lambda 的孪生兄弟。 </p>
<p>上例中可以推导出唯一匹配的 <code>println(int)</code> 重载形式。</p>
<h2 id="通过对象名引用成员方法"><a href="#通过对象名引用成员方法" class="headerlink" title="通过对象名引用成员方法"></a>通过对象名引用成员方法</h2><p>通过对象名引用成员方法是最常见的一种用法，使用前提：</p>
<ol>
<li>对象已经存在；</li>
<li>成员方法已经存在。</li>
</ol>
<p>定义一个 MethodRefObject 类，包含一个成员方法 printUpperCase。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRefObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员方法,传递字符串,把字符串按照大写输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCaseString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的 Lambda 的时候，已经具有了 MethodRefObject 类的对象实例，则可以通过对象名引用成员方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjectMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">        p.print(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用printString方法,传递Lambda表达式</span></span><br><span class="line">        printString(s -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建MethodRerObject对象</span></span><br><span class="line">            MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">            <span class="comment">// 调用MethodRerObject对象中的成员方法printUpperCaseString</span></span><br><span class="line">            obj.printUpperCaseString(s);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MethodRerObject对象</span></span><br><span class="line">        MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">        <span class="comment">// 使用方法引用优化</span></span><br><span class="line">        printString(obj::printUpperCaseString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过类名引用静态方法"><a href="#通过类名引用静态方法" class="headerlink" title="通过类名引用静态方法"></a>通过类名引用静态方法</h2><p>由于在 <code>java.lang.Math</code> 类中已经存在了静态方法 <code>abs</code> ，所以当我们需要通过 Lambda 来调用该方法时，有两种写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calcable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStaticMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,方法的参数传递要计算绝对值的整数,和函数式接口Calcable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> number,Calcable c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> c.calsAbs(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递计算绝对值得整数,和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> number = method(-<span class="number">10</span>, n -&gt; Math.abs(n));</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方法引用优化Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> number2 = method(-<span class="number">10</span>, Math::abs);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过-super-引用成员方法"><a href="#通过-super-引用成员方法" class="headerlink" title="通过 super 引用成员方法"></a>通过 <code>super</code> 引用成员方法</h2><p>如果存在继承关系，当 Lambda 中需要出现 super 调用时，也可以使用方法引用进行替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义见面的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个见面的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个sayHello的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Human!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类重写父类sayHello的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法参数传递Greetable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable g)</span> </span>&#123;</span><br><span class="line">        g.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递Lambda</span></span><br><span class="line">        method(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建父类Human对象,调用父类的sayHello方法</span></span><br><span class="line">            <span class="keyword">new</span> Human().sayHello();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为有子父类关系,可以直接使用super调用父类的成员方法</span></span><br><span class="line">        method(() -&gt; <span class="keyword">super</span>.sayHello());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接使用super引用父类的成员方法</span></span><br><span class="line">        method(<span class="keyword">super</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Man().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过-this-引用成员方法"><a href="#通过-this-引用成员方法" class="headerlink" title="通过 this 引用成员方法"></a>通过 <code>this</code> 引用成员方法</h2><p> <code>this</code> 代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用 <strong><code>this::成员方法</code></strong> 的格式来使用方法引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个富有的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Richable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个想买什么就买什么的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义丈夫类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个买房子的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"北京二环内买一套四合院!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个结婚的方法,参数传递Richable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Richable r)</span> </span>&#123;</span><br><span class="line">        r.buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个非常高兴的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">soHappy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用结婚的方法,传递Lambda表达式</span></span><br><span class="line">        marry(() -&gt; <span class="keyword">this</span>.buyHouse());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接使用this引用本类的成员方法buyHouse</span></span><br><span class="line">        marry(<span class="keyword">this</span>::buyHouse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Husband().soHappy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <strong><code>类名称::new</code></strong> 的格式表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个创建Person对象的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,根据传递的姓名,创建Person对象返回</span></span><br><span class="line">    <span class="function">Person <span class="title">builderPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,参数传递姓名和PersonBuilder接口,方法中通过姓名创建Person对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name,PersonBuilder pb)</span> </span>&#123;</span><br><span class="line">        Person person = pb.builderPerson(name);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用printName方法,方法的参数传递Lambda</span></span><br><span class="line">        printName(<span class="string">"迪丽热巴"</span>, name -&gt; <span class="keyword">new</span> Person(name));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Person引用new创建对象</span></span><br><span class="line">        printName(<span class="string">"古力娜扎"</span>, Person::<span class="keyword">new</span>); <span class="comment">// 使用Person类的带参构造方法,通过传递的姓名创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h2><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同，数组的构造器引用使用 <strong><code>数据类型[]::new</code></strong> 的格式表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个创建数组的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个创建int类型数组的方法,参数传递数组的长度,返回创建好的int类型数组</span></span><br><span class="line">    <span class="keyword">int</span>[] builderArray(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递创建数组的长度和ArrayBuilder接口</span></span><br><span class="line"><span class="comment">        方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createArray(<span class="keyword">int</span> length, ArrayBuilder ab) &#123;</span><br><span class="line">        <span class="keyword">return</span> ab.builderArray(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用createArray方法,传递数组的长度和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = createArray(<span class="number">10</span>, len -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[len]);</span><br><span class="line">        System.out.println(arr1.length); <span class="comment">// 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用方法引用,int[]引用new,根据参数传递的长度来创建数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = createArray(<span class="number">10</span>, <span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">        System.out.println(arr2.length); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>喜欢就支持小方方一下吧~</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="Flexia 微信支付"/>
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="Flexia 支付宝"/>
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/JavaSE/" rel="tag"><i class="fa fa-tag"></i> JavaSE</a>
          
            <a href="/tags/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/" rel="tag"><i class="fa fa-tag"></i> Java语言高级</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/20/java-advanced-4.html" rel="next" title="Java语言高级（4）File类与IO流">
                <i class="fa fa-chevron-left"></i> Java语言高级（4）File类与IO流
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/01/java-advanced-6.html" rel="prev" title="Java语言高级（6）JUnit、反射机制与注解">
                Java语言高级（6）JUnit、反射机制与注解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Flexia"/>
            
              <p class="site-author-name" itemprop="name">Flexia</p>
              <div class="site-description motion-element" itemprop="description">小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">45</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/fangfengxin" title="GitHub &rarr; https://github.com/fangfengxin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:fangfengxin98@163.com" title="E-Mail &rarr; mailto:fangfengxin98@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#网络通信概述"><span class="nav-number">1.</span> <span class="nav-text">网络通信概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件结构"><span class="nav-number">1.1.</span> <span class="nav-text">软件结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络通信协议"><span class="nav-number">1.2.</span> <span class="nav-text">网络通信协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议分类"><span class="nav-number">1.3.</span> <span class="nav-text">协议分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络编程三要素"><span class="nav-number">1.4.</span> <span class="nav-text">网络编程三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#协议"><span class="nav-number">1.4.1.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-地址"><span class="nav-number">1.4.2.</span> <span class="nav-text">IP 地址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-地址分类"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">IP 地址分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用命令"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊的-IP-地址"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">特殊的 IP 地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#端口号"><span class="nav-number">1.4.3.</span> <span class="nav-text">端口号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-通信"><span class="nav-number">2.</span> <span class="nav-text">TCP 通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-通信概述"><span class="nav-number">2.1.</span> <span class="nav-text">TCP 通信概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket-类"><span class="nav-number">2.2.</span> <span class="nav-text">Socket 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServerSocket-类"><span class="nav-number">2.3.</span> <span class="nav-text">ServerSocket 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的-TCP-通信程序"><span class="nav-number">2.4.</span> <span class="nav-text">简单的 TCP 通信程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程案例"><span class="nav-number">3.</span> <span class="nav-text">网络编程案例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#案例：文件上传"><span class="nav-number">3.1.</span> <span class="nav-text">案例：文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本实现"><span class="nav-number">3.1.1.</span> <span class="nav-text">基本实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码优化"><span class="nav-number">3.1.2.</span> <span class="nav-text">代码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序阻塞问题"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">程序阻塞问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件名称写死问题"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">文件名称写死问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环接收问题"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">循环接收问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#效率问题"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">效率问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化实现"><span class="nav-number">3.1.3.</span> <span class="nav-text">优化实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#案例：模拟-B-S-服务器"><span class="nav-number">3.2.</span> <span class="nav-text">案例：模拟 B&#x2F;S 服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#案例分析"><span class="nav-number">3.2.1.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#案例实现"><span class="nav-number">3.2.2.</span> <span class="nav-text">案例实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问效果"><span class="nav-number">3.2.3.</span> <span class="nav-text">访问效果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式接口"><span class="nav-number">4.</span> <span class="nav-text">函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式接口的定义"><span class="nav-number">4.1.</span> <span class="nav-text">函数式接口的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FunctionalInterface-注解"><span class="nav-number">4.2.</span> <span class="nav-text">@FunctionalInterface 注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义函数式接口并使用"><span class="nav-number">4.3.</span> <span class="nav-text">自定义函数式接口并使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式编程"><span class="nav-number">5.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-的延迟执行"><span class="nav-number">5.1.</span> <span class="nav-text">Lambda 的延迟执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#性能浪费的日志案例"><span class="nav-number">5.1.1.</span> <span class="nav-text">性能浪费的日志案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-优化"><span class="nav-number">5.1.2.</span> <span class="nav-text">Lambda 优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Lambda-作为方法的参数和返回值"><span class="nav-number">5.2.</span> <span class="nav-text">使用 Lambda 作为方法的参数和返回值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用函数式接口"><span class="nav-number">6.</span> <span class="nav-text">常用函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Supplier-接口"><span class="nav-number">6.1.</span> <span class="nav-text">Supplier 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象方法-get"><span class="nav-number">6.1.1.</span> <span class="nav-text">抽象方法 get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：求数组元素最大值"><span class="nav-number">6.1.2.</span> <span class="nav-text">练习：求数组元素最大值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Consumer-接口"><span class="nav-number">6.2.</span> <span class="nav-text">Consumer 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象方法-accept"><span class="nav-number">6.2.1.</span> <span class="nav-text">抽象方法 accept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认方法-andThen"><span class="nav-number">6.2.2.</span> <span class="nav-text">默认方法 andThen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：格式化打印信息"><span class="nav-number">6.2.3.</span> <span class="nav-text">练习：格式化打印信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Predicate-接口"><span class="nav-number">6.3.</span> <span class="nav-text">Predicate 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象方法-test"><span class="nav-number">6.3.1.</span> <span class="nav-text">抽象方法 test</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认方法-and"><span class="nav-number">6.3.2.</span> <span class="nav-text">默认方法 and</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认方法-or"><span class="nav-number">6.3.3.</span> <span class="nav-text">默认方法 or</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认方法-negate"><span class="nav-number">6.3.4.</span> <span class="nav-text">默认方法 negate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：集合信息筛选"><span class="nav-number">6.3.5.</span> <span class="nav-text">练习：集合信息筛选</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-接口"><span class="nav-number">6.4.</span> <span class="nav-text">Function 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象方法-apply"><span class="nav-number">6.4.1.</span> <span class="nav-text">抽象方法 apply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认方法-andThen-1"><span class="nav-number">6.4.2.</span> <span class="nav-text">默认方法 andThen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：自定义函数模型拼接"><span class="nav-number">6.4.3.</span> <span class="nav-text">练习：自定义函数模型拼接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream-流"><span class="nav-number">7.</span> <span class="nav-text">Stream 流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#流式思想"><span class="nav-number">7.1.</span> <span class="nav-text">流式思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统集合的循环遍历弊端"><span class="nav-number">7.1.1.</span> <span class="nav-text">传统集合的循环遍历弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-的更优写法"><span class="nav-number">7.1.2.</span> <span class="nav-text">Stream 的更优写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流式思想概述"><span class="nav-number">7.1.3.</span> <span class="nav-text">流式思想概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取流"><span class="nav-number">7.2.</span> <span class="nav-text">获取流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#根据-Collection-获取流"><span class="nav-number">7.2.1.</span> <span class="nav-text">根据 Collection 获取流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据-Map-获取流"><span class="nav-number">7.2.2.</span> <span class="nav-text">根据 Map 获取流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据数组获取流"><span class="nav-number">7.2.3.</span> <span class="nav-text">根据数组获取流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流的常用方法"><span class="nav-number">7.3.</span> <span class="nav-text">流的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逐一处理-forEach"><span class="nav-number">7.3.1.</span> <span class="nav-text">逐一处理 forEach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤-filter"><span class="nav-number">7.3.2.</span> <span class="nav-text">过滤 filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射-map"><span class="nav-number">7.3.3.</span> <span class="nav-text">映射 map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#统计个数-count"><span class="nav-number">7.3.4.</span> <span class="nav-text">统计个数 count</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取用前几个元素-limit"><span class="nav-number">7.3.5.</span> <span class="nav-text">取用前几个元素 limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳过前几个元素-skip"><span class="nav-number">7.3.6.</span> <span class="nav-text">跳过前几个元素 skip</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合-concat"><span class="nav-number">7.3.7.</span> <span class="nav-text">组合 concat</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综合练习"><span class="nav-number">7.4.</span> <span class="nav-text">综合练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统-for-循环处理"><span class="nav-number">7.4.1.</span> <span class="nav-text">传统 for 循环处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-流式处理"><span class="nav-number">7.4.2.</span> <span class="nav-text">Stream 流式处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法引用"><span class="nav-number">8.</span> <span class="nav-text">方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#冗余的-Lambda-场景"><span class="nav-number">8.1.</span> <span class="nav-text">冗余的 Lambda 场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用方法引用改进"><span class="nav-number">8.2.</span> <span class="nav-text">用方法引用改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用运算符"><span class="nav-number">8.3.</span> <span class="nav-text">方法引用运算符 ::</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语义分析"><span class="nav-number">8.3.1.</span> <span class="nav-text">语义分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推导与省略"><span class="nav-number">8.3.2.</span> <span class="nav-text">推导与省略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过对象名引用成员方法"><span class="nav-number">8.4.</span> <span class="nav-text">通过对象名引用成员方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过类名引用静态方法"><span class="nav-number">8.5.</span> <span class="nav-text">通过类名引用静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-super-引用成员方法"><span class="nav-number">8.6.</span> <span class="nav-text">通过 super 引用成员方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-this-引用成员方法"><span class="nav-number">8.7.</span> <span class="nav-text">通过 this 引用成员方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的构造器引用"><span class="nav-number">8.8.</span> <span class="nav-text">类的构造器引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的构造器引用"><span class="nav-number">8.9.</span> <span class="nav-text">数组的构造器引用</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Flexia</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">743k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">11:15</span>
  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color='0,0,0' opacity='1' zIndex='-1' count='20' src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  
  

<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '7kWTdJsaz4FTWvD11vJ68LrU-gzGzoHsz',
    appKey: 'IagQj5azVtsiUPyjWRrvasm6',
    placeholder: '要不要说点啥……',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  


  

</body>
</html>
