<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>








  <meta name="google-site-verification" content="N8ofSn2GrmJ51OE3RhiifNsuUcNAfC7JAukwhpY-WiY"/>












  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"/>
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.png?v=7.2.0" color="#222">


  <link rel="manifest" href="/images/site.webmanifest">


  <meta name="msapplication-config" content="/images/browserconfig.xml"/>





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":"default"},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta name="description" content="线程什么是进程和线程？ 进程： 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。 系统运行一个程序即是一个进程从创建，运行到消亡的过程。 简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。   线程：">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE总结（多线程）">
<meta property="og:url" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading.html">
<meta property="og:site_name" content="Flexia&#39;s Blog">
<meta property="og:description" content="线程什么是进程和线程？ 进程： 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。 系统运行一个程序即是一个进程从创建，运行到消亡的过程。 简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。   线程：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/%E6%AD%BB%E9%94%811.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/ThreadLocal%E5%86%85%E9%83%A8%E7%B1%BB.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png">
<meta property="og:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png">
<meta property="article:published_time" content="2020-05-28T14:00:00.000Z">
<meta property="article:modified_time" content="2020-07-13T08:44:22.061Z">
<meta property="article:author" content="Flexia">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="JavaSE面试总结">
<meta property="article:tag" content="Java多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png">





  
  
  <link rel="canonical" href="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JavaSE总结（多线程） | Flexia's Blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145696891-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-145696891-1');
    }
  </script>



  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ccc4ebbe605a1363703684938a4b4c40";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Flexia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">记录小方方的学习之路</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    
  
  

  

  <a href="https://github.com/fangfengxin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fangfengxin.top/2020/05/28/javase-sumary-multithreading.html"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Flexia"/>
      <meta itemprop="description" content="小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~"/>
      <meta itemprop="image" content="/images/avatar.png"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Flexia's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">JavaSE总结（多线程）

              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-05-28 22:00:00" itemprop="dateCreated datePublished" datetime="2020-05-28T22:00:00+08:00">2020-05-28</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-13 16:44:22" itemprop="dateModified" datetime="2020-07-13T16:44:22+08:00">2020-07-13</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/JavaSE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">JavaSE面试总结</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaSE/JavaSE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java多线程</span></a></span>

                
                
              
            </span>
          
		  
		  <br/>

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/05/28/javase-sumary-multithreading.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/28/javase-sumary-multithreading.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">30k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">27 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h2><ul>
<li>进程：<ul>
<li>进程<strong>是程序的一次执行过程，是系统运行程序的基本单位</strong>，因此进程是动态的。</li>
<li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>
<li>简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</li>
</ul>
</li>
<li>线程：<ul>
<li>与进程相似，但线程<strong>是一个比进程更小的执行单位</strong>。</li>
<li>一个进程在其执行的过程中可以产生多个线程。</li>
<li>与进程不同的是，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>（JDK 8 之后称作元空间）资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。也正因为如此，线程也被称为轻量级进程。</li>
</ul>
</li>
<li>Java 程序天生就是多线程程序，可以通过 JMX 来看一个普通的 Java 程序有哪些线程，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] main <span class="comment">// main 线程,程序入口</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">// 清除 reference 线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">// 调用对象 finalize 方法的线程</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理给 JVM 信号的线程</span></span><br><span class="line">[<span class="number">5</span>] Attach Listener <span class="comment">// 添加事件</span></span><br><span class="line">[<span class="number">11</span>] Common-Cleaner</span><br><span class="line">[<span class="number">12</span>] Monitor Ctrl-Break</span><br></pre></td></tr></table></figure>
<ul>
<li>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 <code>main</code> 线程和多个其他线程同时运行</strong>。</li>
</ul>
<h2 id="线程与进程的关系、区别及优缺点"><a href="#线程与进程的关系、区别及优缺点" class="headerlink" title="线程与进程的关系、区别及优缺点"></a>线程与进程的关系、区别及优缺点</h2><ul>
<li>下图是 Java 内存区域，通过下图从 JVM 的角度来说一下线程和进程之间的关系。</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/JVM运行时数据区域.png" alt></p>
<ul>
<li>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区（JDK 1.8 之后的元空间）</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</li>
<li>总结：<ul>
<li>线程是进程划分成的更小的运行单位。</li>
<li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>线程执行开销小，但不利于资源的管理和保护，而进程正相反。</li>
<li>进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li>
</ul>
</li>
</ul>
<h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><ul>
<li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><ul>
<li>总体来说：<ul>
<li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong>现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
</li>
<li>深入到计算机底层来探讨：<ul>
<li><strong>单核时代：</strong>在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代：</strong>多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会有一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
</li>
</ul>
<h2 id="使用多线程可能带来什么问题？"><a href="#使用多线程可能带来什么问题？" class="headerlink" title="使用多线程可能带来什么问题？"></a>使用多线程可能带来什么问题？</h2><ul>
<li>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</li>
</ul>
<h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><ul>
<li>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/Java线程的状态.png" alt="Java线程的状态"></p>
<ul>
<li>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/Java线程状态变迁.png" alt="Java线程状态变迁"></p>
<ul>
<li>Java 线程将操作系统中的 <code>Ready</code>（就绪）和 <code>Running</code>（运行中）两种状态隐藏，统称为 <code>Runnable</code>（可运行）状态。</li>
<li>线程创建之后它将处于 <code>New</code>（新建）状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <code>Ready</code>（可运行）状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <code>Running</code>（运行）状态。</li>
<li>当线程执行 <code>wait()</code> 方法之后，线程进入 <code>Waiting</code>（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li>
<li>而 <code>Timed_Waiting</code>（超时等待）状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep(long millis)</code> 方法或 <code>wait(long millis)</code> 方法可以将 Java 线程置于 <code>Timed_Waiting</code> 状态。当超时时间到达后 Java 线程将会返回到 <code>Runnable</code> 状态。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <code>Blocked</code>（阻塞） 状态。</li>
<li>线程在退出 <code>run()</code> 方法之后将会进入到 <code>Terminated</code>（终止）状态。</li>
</ul>
<h2 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h2><ul>
<li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是<strong>为每个线程分配时间片并轮转</strong>的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，等到该线程获取到新的时间片再切换到运行状态，这个过程就属于一次上下文切换。</li>
<li>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</li>
<li>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</li>
<li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li>
</ul>
<h2 id="线程死锁的概念及避免方式"><a href="#线程死锁的概念及避免方式" class="headerlink" title="线程死锁的概念及避免方式"></a>线程死锁的概念及避免方式</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><ul>
<li>线程死锁描述的是这样一种情况：<strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止</strong>。</li>
<li>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/死锁1.png" alt="线程死锁"></p>
<ul>
<li>下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object(); <span class="comment">// 资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object(); <span class="comment">// 资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程A,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]waiting get resource1</span><br><span class="line">Thread[线程A,<span class="number">5</span>,main]waiting get resource2</span><br></pre></td></tr></table></figure>
<ul>
<li>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过 <code>Thread.sleep(1000);</code> 让线程 A 休眠 1s，为的是让线程 B 得到执行然后获取到 <code>resource2</code> 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</li>
<li>学过操作系统的朋友都知道<strong>产生死锁必须具备以下四个条件</strong>：<ol>
<li><strong>互斥条件：</strong>该资源任意一个时刻只由一个线程占用。</li>
<li><strong>请求与保持条件：</strong>一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件：</strong>线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
</li>
</ul>
<h3 id="如何避免线程死锁？"><a href="#如何避免线程死锁？" class="headerlink" title="如何避免线程死锁？"></a>如何避免线程死锁？</h3><ul>
<li>为了避免死锁，只要破坏产生死锁的四个条件中的其中一个就可以了。现在挨个分析一下：<ol>
<li><strong>破坏互斥条件</strong>：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
</li>
<li>对线程 B 的代码修改成下面这样就不会产生死锁了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"线程B"</span>).start();</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程A,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程A,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程A,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分析一下上面的代码为什么避免了死锁的发生？线程 A 首先获得到 <code>resource1</code> 的监视器锁，这时候线程 B 就获取不到了。然后线程 A 再去获取 <code>resource2</code> 的监视器锁，可以获取到。然后线程 A 释放了对 <code>resource1</code>、<code>resource2</code> 的监视器锁的占用，线程 B 获取到就可以执行了。这样就破坏了循环等待条件，因此避免了死锁。</li>
</ul>
<h2 id="sleep-与-wait-方法的区别和共同点"><a href="#sleep-与-wait-方法的区别和共同点" class="headerlink" title="sleep() 与 wait() 方法的区别和共同点"></a><code>sleep()</code> 与 <code>wait()</code> 方法的区别和共同点</h2><ul>
<li>两者最主要的区别在于：<strong><code>sleep</code> 方法没有释放锁，而 <code>wait</code> 方法释放了锁</strong>。</li>
<li>两者都可以暂停线程的执行。</li>
<li><strong><code>wait</code> 通常被用于线程间交互/通信，<code>sleep</code> 通常被用于暂停执行</strong>。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。<code>sleep()</code> 方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
</ul>
<h2 id="为什么调用-start-方法时会调用-run-方法？为什么不能直接调用-run-方法？"><a href="#为什么调用-start-方法时会调用-run-方法？为什么不能直接调用-run-方法？" class="headerlink" title="为什么调用 start() 方法时会调用 run() 方法？为什么不能直接调用 run() 方法？"></a>为什么调用 <code>start()</code> 方法时会调用 <code>run()</code> 方法？为什么不能直接调用 <code>run()</code> 方法？</h2><ul>
<li><code>new</code> 一个 <code>Thread</code>，线程进入了新建状态，调用 <code>start()</code> 方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。</li>
<li>而直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li>
<li><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，而 <code>run()</code> 方法只是 <code>Thread</code> 的一个普通方法调用，还是在主线程里执行</strong>。</li>
</ul>
<h1 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><code>synchronized</code> 关键字</h1><h2 id="认识-synchronized-关键字"><a href="#认识-synchronized-关键字" class="headerlink" title="认识 synchronized 关键字"></a>认识 <code>synchronized</code> 关键字</h2><ul>
<li><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code> 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</li>
<li>另外，在 Java 早期版本中，<code>synchronized</code> 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 <code>synchronized</code> 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对<code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。<strong>JDK 1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销</strong>。</li>
</ul>
<h2 id="synchronized-关键字最主要的-3-种使用方式"><a href="#synchronized-关键字最主要的-3-种使用方式" class="headerlink" title="synchronized 关键字最主要的 3 种使用方式"></a><code>synchronized</code> 关键字最主要的 3 种使用方式</h2><ul>
<li><strong>修饰实例方法：</strong>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法：</strong>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（<code>static</code> 表明这是该类的一个静态资源，不管 <code>new</code>了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为<strong>访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>
<li><strong>修饰代码块：</strong>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
<li>总结：<code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 <code>Class</code> 类上锁。<code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。<strong>尽量不要使用 <code>synchronized(String str)</code>，因为 JVM 中，字符串常量池具有缓存功能</strong>。</li>
</ul>
<h2 id="双重检验锁实现单例模式（线程安全）"><a href="#双重检验锁实现单例模式（线程安全）" class="headerlink" title="双重检验锁实现单例模式（线程安全）"></a>双重检验锁实现单例模式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile关键字确保，当uniqueInstance变量被初始化成Singleton实例时，</span></span><br><span class="line"><span class="comment">     * 多个线程正确地处理uniqueInstance变量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 进入同步区块后再次检查，仍是null才会创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外，需要注意 <code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要。</li>
<li><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
</li>
<li>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行顺序有可能变成 1 → 3 → 2。</li>
<li>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</li>
<li><strong>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。</li>
</ul>
<h2 id="synchronized-关键字的底层实现原理"><a href="#synchronized-关键字的底层实现原理" class="headerlink" title="synchronized 关键字的底层实现原理"></a><code>synchronized</code> 关键字的底层实现原理</h2><ul>
<li><code>synchronized</code> 关键字的底层原理属于 JVM 层面。</li>
</ul>
<h3 id="同步语句块"><a href="#同步语句块" class="headerlink" title="同步语句块"></a>同步语句块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"synchronized代码块"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 JDK 自带的 <code>javap -c -s -v -l</code> 命令查看 <code>SynchronizedDemo1</code> 类的相关字节码信息：</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/synchronized关键字原理.png" alt="synchronized关键字原理"></p>
<ul>
<li>可以看出：<strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置</strong>。</li>
<li>当执行 <code>monitorenter</code> 指令时，线程试图获取锁，也就是获取 <code>monitor</code> 的持有权，当锁计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。</li>
<li><code>monitor</code> 对象存在于每个 Java 对象的对象头中，<code>synchronized</code> 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因。</li>
<li>相应的在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。</li>
<li>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li>
</ul>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/28/javase-sumary-multithreading/synchronized关键字原理2.png" alt="synchronized关键字原理2"></p>
<ul>
<li><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</li>
<li><strong>JVM 通过 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</strong>。</li>
</ul>
<h2 id="JDK-1-6-之后的-synchronized-关键字底层做了哪些优化？"><a href="#JDK-1-6-之后的-synchronized-关键字底层做了哪些优化？" class="headerlink" title="JDK 1.6 之后的 synchronized 关键字底层做了哪些优化？"></a>JDK 1.6 之后的 <code>synchronized</code> 关键字底层做了哪些优化？</h2><ul>
<li>JDK 1.6 对锁的实现引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术</strong>来减少锁操作的开销。</li>
<li><strong>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ul>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul>
<li>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了<strong>没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而<strong>偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</li>
<li>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！</li>
<li>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul>
<li>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段（1.6 之后加入的）。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为<strong>使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了 CAS 操作</strong>。</li>
<li>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。<strong>如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生 CAS 操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！</strong>如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁。</li>
</ul>
<h3 id="自旋锁与适应性自旋锁"><a href="#自旋锁与适应性自旋锁" class="headerlink" title="自旋锁与适应性自旋锁"></a>自旋锁与适应性自旋锁</h3><ul>
<li>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</li>
<li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</li>
<li><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</li>
<li>自旋锁在 JDK 1.6 之前其实就已经引入了，不过是默认关闭的，需要通过 <code>--XX:+UseSpinning</code> 参数来开启。JDK 1.6 及 1.6 之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是 10 次，用户可以修改 <code>--XX:PreBlockSpin</code> 来更改</strong>。</li>
<li>另外，<strong>在 JDK 1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li>锁消除理解起来很简单，它指的就是虚拟机<strong>即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除</strong>。锁消除可以节省毫无意义的请求锁的时间。</li>
</ul>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul>
<li>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，—直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</li>
<li>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</li>
</ul>
<h2 id="Synchronized-和-ReenTrantLock-的对比"><a href="#Synchronized-和-ReenTrantLock-的对比" class="headerlink" title="Synchronized 和 ReenTrantLock 的对比"></a><code>Synchronized</code> 和 <code>ReenTrantLock</code> 的对比</h2><ol>
<li><strong>两者都是可重入锁：</strong><ul>
<li>“可重入锁”概念是：自己可以再次获取自己的内部锁。</li>
<li>比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</li>
</ul>
</li>
<li><strong><code>synchronized</code> 依赖于 JVM 而 <code>ReentrantLock</code> 依赖于 API：</strong><ul>
<li><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK 1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</li>
<li><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
</ul>
</li>
<li><strong><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：</strong><ol>
<li><strong>等待可中断：</strong><ul>
<li><code>ReentrantLock</code> 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。</li>
<li>也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
</ul>
</li>
<li><strong>可实现公平锁：</strong><ul>
<li><code>ReentrantLock</code> 可以指定是公平锁还是非公平锁。而 <code>synchronized</code> 只能是非公平锁。</li>
<li>所谓的公平锁就是先等待的线程先获得锁。</li>
<li><code>ReentrantLock</code> 默认是非公平的，可以通过 <code>ReentrantLock</code> 类的 <code>ReentrantLock(boolean fair)</code> 构造方法来指定是否公平。</li>
</ul>
</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）：</strong><ul>
<li><code>synchronized</code> 关键字与 <code>wait()</code> 和 <code>notify()/notifyAll()</code> 方法相结合可以实现等待/通知机制，<code>ReentrantLock</code> 类当然也可以实现，但是需要借助于 <code>Condition</code> 接口与 <code>newCondition()</code> 方法。</li>
<li><code>Condition</code> 是 JDK 1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能，也就是在一个 <code>Lock</code> 对象中可以创建多个 <code>Condition</code> 实例（即对象监视器），线程对象可以注册在指定的 <code>Condition</code> 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 </li>
<li>在使用 <code>notify()/notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 选择的，用 <code>ReentrantLock</code> 类结合 <code>Condition</code> 实例可以实现“选择性通知” ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。</li>
<li>而 <code>synchronized</code> 关键字就相当于整个 <code>Lock</code> 对象中只有一个 <code>Condition</code> 实例，所有的线程都注册在它一个身上。如果执行 <code>notifyAll()</code> 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 <code>Condition</code> 实例的 <code>signalAll()</code> 方法只会唤醒注册在该 <code>Condition</code> 实例中的所有等待线程。</li>
</ul>
</li>
</ol>
</li>
<li>性能已不是选择标准。</li>
</ol>
<h1 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h1><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><ul>
<li>在 JDK 1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。</li>
<li>而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。</li>
<li>这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/数据不一致.png" alt></p>
<ul>
<li>要解决这个问题，就需要把变量声明为 <strong><code>volatile</code></strong>，这就指示 JVM，<strong>这个变量是不稳定的，每次使用它都到主存中进行读取</strong>。</li>
<li>说白了， <strong><code>volatile</code></strong> 关键字的主要作用就是<strong>保证变量的可见性</strong>，然后还有一个作用是<strong>防止指令重排序</strong>。</li>
</ul>
<h2 id="并发编程的-3-个重要特性"><a href="#并发编程的-3-个重要特性" class="headerlink" title="并发编程的 3 个重要特性"></a>并发编程的 3 个重要特性</h2><ol>
<li><strong>原子性：</strong>一个操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li>
<li><strong>可见性：</strong>当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li>
<li><strong>有序性：</strong>代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li>
</ol>
<h2 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a><code>synchronized</code> 和 <code>volatile</code> 的区别</h2><ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code> 性能肯定比 <code>synchronized</code> 要好</strong>。（<code>synchronized</code> 关键字在 Java SE 1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 <code>synchronized</code> 关键字的场景还是更多一些</strong>。）</li>
<li><strong><code>volatile</code> 关键字只能用于变量，而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong>。</li>
<li><strong>多线程访问 <code>volatile</code> 关键字不会发生阻塞，而 <code>synchronized</code> 关键字可能会发生阻塞</strong>。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证</strong>。</li>
<li><strong><code>volatile</code> 关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性</strong>。</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h1><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a><code>ThreadLocal</code> 简介</h2><ul>
<li>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的 <code>ThreadLocal</code> 类正是为了解决这样的问题。</li>
<li><code>ThreadLocal</code> 类主要解决的就是让每个线程绑定自己的值，可以将 <code>ThreadLocal</code> 类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</li>
<li>如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 <code>ThreadLocal</code> 变量名的由来。</li>
<li>可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</li>
</ul>
<h2 id="ThreadLocal-示例"><a href="#ThreadLocal-示例" class="headerlink" title="ThreadLocal 示例"></a><code>ThreadLocal</code> 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name = "</span> + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">" default Formatter = "</span> + formatter.get().toPattern());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name = "</span> + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">" formatter = "</span> + formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample example = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(example, i + <span class="string">""</span>);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread Name = <span class="number">0</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">0</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">1</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">2</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">1</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">2</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">3</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">3</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">4</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">4</span> formatter = y/M/d ah:mm</span><br></pre></td></tr></table></figure>
<ul>
<li>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</li>
<li>创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java 8 的知识，使用一个新的方法 <code>withInitial()</code>，将 <code>Supplier</code> 功能接口作为参数。</li>
</ul>
<h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a><code>ThreadLocal</code> 原理</h2><ul>
<li>从 <code>Thread</code> 类源代码入手：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与此线程有关的ThreadLocal值。该map由ThreadLocal类维护。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与此线程有关的InheritableThreadLocal值。该map由InheritableThreadLocal类维护。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从上面 <code>Thread</code> 类源码可以看出 <code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量，可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。</li>
<li>默认情况下这两个变量都是 <code>null</code>，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code> 或 <code>get</code> 方法时才创建它们，实际上调用这两个方法的时候，我们调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code>、<code>set()</code> 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过上面这些内容，我们足以得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code> 的封装，传递了变量值</strong>。</li>
<li><code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code> 可以访问到该线程的 <code>ThreadLocalMap</code> 对象。</li>
<li><strong>每个 <code>Thread</code> 中都具备一个 <code>ThreadLocalMap</code>，而 <code>ThreadLocalMap</code> 可以存储以 <code>ThreadLocal</code> 为 key ，<code>Object</code> 对象为 value 的键值对</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>比如，在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code> 内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code> 的 key 就是 <code>ThreadLocal</code> 对象，value 就是 <code>ThreadLocal</code> 对象调用 <code>set</code> 方法设置的值。</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/ThreadLocal数据结构.jpg" alt="ThreadLocal数据结构"></p>
<ul>
<li><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类。</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/ThreadLocal内部类.png" alt="ThreadLocal内部类"></p>
<h2 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a><code>ThreadLocal</code> 内存泄露问题</h2><ul>
<li><strong><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用</strong>。</li>
<li>所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 <code>null</code> 的 <code>Entry</code>。</li>
<li>假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</li>
<li><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 <code>null</code> 的记录。使用完 <code>ThreadLocal</code> 方法后，最好手动调用 <code>remove()</code> 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>弱引用介绍：<ul>
<li>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</li>
<li>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li>
<li>弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li>
</ul>
</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><ul>
<li><strong>池化技术</strong>相比大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</li>
<li><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</li>
<li><strong>使用线程池的好处：</strong><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
</li>
</ul>
<h2 id="实现-Runnable-和-Callable-接口的区别"><a href="#实现-Runnable-和-Callable-接口的区别" class="headerlink" title="实现 Runnable 和 Callable 接口的区别"></a>实现 <code>Runnable</code> 和 <code>Callable</code> 接口的区别</h2><ul>
<li><code>Runnable</code> 自 Java 1.0 以来一直存在，但 <code>Callable</code> 仅在 Java 1.5 中引入，目的就是为了来处理 <code>Runnable</code> 不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</li>
<li><strong>工具类 <code>Executors</code></strong> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。使用 <code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被线程执行，没有返回值，也无法抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行-execute-和-submit-方法的区别"><a href="#执行-execute-和-submit-方法的区别" class="headerlink" title="执行 execute() 和 submit() 方法的区别"></a>执行 <code>execute()</code> 和 <code>submit()</code> 方法的区别</h2><ol>
<li><strong><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</strong>；</li>
<li><strong><code>submit()</code> 方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout, TimeUnit unit)</code> 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h2><ol>
<li><strong>通过 <code>ThreadPoolExecutor</code> 构造方法实现：</strong><ul>
<li>在 <code>ThreadPoolExecutor</code> 类中提供了四个构造方法：<img src="/2020/05/28/javase-sumary-multithreading/ThreadPoolExecutor构造方法.png" alt="ThreadPoolExecutor构造方法"></li>
<li>解释下一下构造器中各个参数的含义:<ul>
<li><strong><code>corePoolSize</code>：核心池的大小</strong>。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 <code>prestartAllCoreThreads()</code> 或者 <code>prestartCoreThread()</code> 方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 <code>corePoolSize</code> 个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 <code>corePoolSize</code> 后，就会把到达的任务放到缓存队列当中。</li>
<li><strong><code>maximumPoolSize</code>：线程池最大线程数</strong>，表示在线程池中最多能创建多少个线程。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>keepAliveTime</code>：表示线程没有任务执行时最多保持多久时间会终止</strong>。默认情况下，只有当线程池中的线程数大于 <code>corePoolSize</code> 时，<code>keepAliveTime</code> 才会起作用，直到线程池中的线程数不大于 <code>corePoolSize</code>，即当线程池中的线程数大于 <code>corePoolSize</code> 时，如果一个线程空闲的时间达到 <code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过 <code>corePoolSize</code>。但是如果调用了 <code>allowCoreThreadTimeOut(boolean)</code> 方法，在线程池中的线程数不大于 <code>corePoolSize</code> 时，<code>keepAliveTime</code> 参数也会起作用，直到线程池中的线程数为 0。</li>
<li><strong><code>unit</code>：参数 <code>keepAliveTime</code> 的时间单位</strong>，有 7 种取值，在 <code>TimeUnit</code> 类中有 7 种静态属性：<code>DAYS</code>、<code>HOURS</code>、<code>MINUTES</code>、<code>SECONDS</code>、<code>MILLISECONDS</code>、<code>MICROSECONDS</code>、<code>NANOSECONDS</code>。</li>
<li><strong><code>workQueue</code>：一个阻塞队列，用来存储等待执行的任务</strong>。一般来说，这里的阻塞队列有以下 4 种选择：<code>ArrayBlockingQueue</code>、<code>PriorityBlockingQueue</code> 、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code>。<code>ArrayBlockingQueue</code> 和 <code>PriorityBlockingQueue</code> 使用较少，一般使用 <code>LinkedBlockingQueue</code> 和 <code>SynchronousQueue</code>。线程池的排队策略与 <code>BlockingQueue</code> 有关。</li>
<li><strong><code>threadFactory</code>：线程工厂</strong>，主要用来创建新的线程。</li>
<li><strong><code>handler</code>：表示饱和策略（当线程池达到饱和拒绝处理任务时的策略）</strong>，有以下 4 种取值：<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出 <code>RejectedExecutionException</code> 异常；</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：直接丢弃任务，但是不抛出异常；</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务（最早未处理的任务），然后重新尝试执行任务（重复此过程）；</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。当最大池被填满时，此策略提供可伸缩队列，会降低对于新任务提交速度，影响程序的整体性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现：</strong> <ul>
<li>可以创建 4 种类型的 <code>ThreadPoolExecutor</code>。<img src="/2020/05/28/javase-sumary-multithreading/Executors创建线程池的几个方法.png" alt="Executors创建线程池的几个方法"></li>
<li><strong><code>FixedThreadPool</code>：</strong>该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong>方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong>该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong><code>ScheduledThreadPool</code>：</strong>方法返回一个调度型线程池，支持定时及周期性任务执行。</li>
<li>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<code>Executors</code> 返回线程池对象的弊端如下：<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ：允许请求的队列长度为 <code>Integer.MAX_VALUE</code>，可能堆积大量的请求，从而导致 OOM（OutOfMemory）。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ：允许创建的线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="一个简单的线程池-Demo"><a href="#一个简单的线程池-Demo" class="headerlink" title="一个简单的线程池 Demo"></a>一个简单的线程池 Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">// 通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建Runnable对象</span></span><br><span class="line">            Runnable task = <span class="keyword">new</span> Task();</span><br><span class="line">            <span class="comment">// 执行Runnable</span></span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure>
<h2 id="线程池的实现原理剖析"><a href="#线程池的实现原理剖析" class="headerlink" title="线程池的实现原理剖析"></a>线程池的实现原理剖析</h2><ul>
<li>为了搞懂线程池的原理，首先分析一下 <code>execute</code> 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面会涉及到 3 步 操作</span></span><br><span class="line">        <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">        <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">        <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="comment">// 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过下图可以更好的对上面这 3 步做一个展示：</li>
</ul>
<p><img src="/2020/05/28/javase-sumary-multithreading/图解线程池实现原理.png" alt="图解线程池实现原理"></p>
<h1 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a><code>Atomic</code> 原子类</h1><h2 id="认识-Atomic-原子类"><a href="#认识-Atomic-原子类" class="headerlink" title="认识 Atomic 原子类"></a>认识 <code>Atomic</code> 原子类</h2><ul>
<li>这里 <code>Atomic</code> 是指一个操作是不可中断的。即在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</li>
<li>所以，所谓原子类，就是具有原子/原子操作特征的类。</li>
<li>并发包 <code>java.util.concurrent</code> 的原子类都存放在 <code>java.util.concurrent.atomic</code> 下。<img src="/2020/05/28/javase-sumary-multithreading/JUC原子类概览.png" alt="JUC原子类概览"></li>
<li>JUC 包中的原子类有 4 类：<ol>
<li>基本类型：使用原子的方式更新基本类型<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
</li>
<li>数组类型：使用原子的方式更新数组里的某个元素<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
</li>
<li>引用类型：<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
</li>
<li>对象的属性修改类型：<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="AtomicInteger-的使用"><a href="#AtomicInteger-的使用" class="headerlink" title="AtomicInteger 的使用"></a><code>AtomicInteger</code> 的使用</h2><ul>
<li><code>AtomicInteger</code> 类常用方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">// 获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> <span class="comment">// 获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">// 获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">// 如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> <span class="comment">// 最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>AtomicInteger</code> 类的使用示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>AtomicInteger</code> 之后，不用对 <code>increment()</code> 方法加锁也可以保证线程安全。</li>
</ul>
<h2 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="AtomicInteger 类的原理"></a><code>AtomicInteger</code> 类的原理</h2><ul>
<li><code>AtomicInteger</code> 线程安全原理简单分析，部分源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>AtomicInteger</code> 类主要利用 CAS + <code>volatile</code> 和 <code>native</code> 方法来保证原子操作，从而避免 synchronized 的高开销</strong>，执行效率大为提升。</li>
<li>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。<code>UnSafe</code> 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 <code>volatile</code> 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</li>
</ul>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h2><ul>
<li>AQS 的全称为 <strong><code>AbstractQueuedSynchronizer</code>（抽象队列式同步器）</strong>，这个类在 <code>java.util.concurrent.locks</code> 包下面。</li>
<li>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</li>
</ul>
<h2 id="AQS-原理分析"><a href="#AQS-原理分析" class="headerlink" title="AQS 原理分析"></a>AQS 原理分析</h2><h3 id="AQS-原理概况"><a href="#AQS-原理概况" class="headerlink" title="AQS 原理概况"></a>AQS 原理概况</h3><ul>
<li>AQS 核心思想是，<strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中</strong>。</li>
<li><strong>CLH</strong>（Craig, Landin, and Hagersten）队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</li>
<li>看个 AQS 的原理图：<img src="/2020/05/28/javase-sumary-multithreading/AQS原理图.png" alt="AQS原理图"></li>
<li>AQS 使用一个 <code>int</code> 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。<strong>AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<ul>
<li>状态信息通过 <code>protected</code> 类型的 <code>getState</code>，<code>setState</code>，<code>compareAndSetState</code> 进行操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><ul>
<li><strong>AQS 定义两种资源共享方式：</strong><ul>
<li><strong>Exclusive（独占）：</strong>只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁。</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。</li>
</ul>
</li>
<li><strong>Share（共享）：</strong>多个线程可同时执行，如 <code>Semaphore</code> / <code>CountDownLatch</code>。</li>
</ul>
</li>
<li><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</li>
<li>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</li>
</ul>
<h3 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h3><ul>
<li>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
</li>
<li>这和以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。<ul>
<li>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。</li>
<li>举个很简单的例子假如我们要去一个地方的步骤是：购票 <code>buyTicket()</code> → 安检 <code>securityCheck()</code> → 乘坐某某工具回家 <code>ride()</code> → 到达目的地 <code>arrive()</code>。</li>
<li>我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了 <code>ride()</code> 方法，其他方法的实现几乎相同。</li>
<li>我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改  <code>ride()</code> 方法。</li>
</ul>
</li>
<li><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively() <span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>) <span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>) <span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>) <span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>) <span class="comment">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 <code>final</code>，所以无法被其他类使用，只有这几个方法可以被其他类使用。</li>
<li>以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state + 1</code>。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state = 0</code>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</li>
<li>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 <code>N</code>（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 <code>countDown()</code> 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即 <code>state = 0</code>），会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</li>
<li>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 <code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 <code>ReentrantReadWriteLock</code>。</li>
</ul>
<h2 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h2><ul>
<li><strong><code>Semaphore</code>（信号量）- 允许多个线程同时访问：</strong><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>（信号量）可以指定多个线程同时访问某个资源。</li>
<li><strong><code>CountDownLatch</code>（倒计时器）：</strong><code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常<strong>用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行</strong>。</li>
<li><strong><code>CyclicBarrier</code>（循环栅栏）：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活</strong>。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>喜欢就支持小方方一下吧~</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="Flexia 微信支付"/>
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="Flexia 支付宝"/>
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/JavaSE/" rel="tag"><i class="fa fa-tag"></i> JavaSE</a>
          
            <a href="/tags/JavaSE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" rel="tag"><i class="fa fa-tag"></i> JavaSE面试总结</a>
          
            <a href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> Java多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/27/javase-sumary-collections.html" rel="next" title="JavaSE总结（集合篇）">
                <i class="fa fa-chevron-left"></i> JavaSE总结（集合篇）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/04/javase-sumary-jvm.html" rel="prev" title="JavaSE总结（JVM篇）">
                JavaSE总结（JVM篇） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Flexia"/>
            
              <p class="site-author-name" itemprop="name">Flexia</p>
              <div class="site-description motion-element" itemprop="description">小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/fangfengxin" title="GitHub &rarr; https://github.com/fangfengxin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:fangfengxin98@163.com" title="E-Mail &rarr; mailto:fangfengxin98@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是进程和线程？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是进程和线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程与进程的关系、区别及优缺点"><span class="nav-number">1.2.</span> <span class="nav-text">线程与进程的关系、区别及优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发与并行的区别"><span class="nav-number">1.3.</span> <span class="nav-text">并发与并行的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用多线程？"><span class="nav-number">1.4.</span> <span class="nav-text">为什么要使用多线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用多线程可能带来什么问题？"><span class="nav-number">1.5.</span> <span class="nav-text">使用多线程可能带来什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的生命周期和状态"><span class="nav-number">1.6.</span> <span class="nav-text">线程的生命周期和状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是上下文切换？"><span class="nav-number">1.7.</span> <span class="nav-text">什么是上下文切换？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程死锁的概念及避免方式"><span class="nav-number">1.8.</span> <span class="nav-text">线程死锁的概念及避免方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#认识线程死锁"><span class="nav-number">1.8.1.</span> <span class="nav-text">认识线程死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何避免线程死锁？"><span class="nav-number">1.8.2.</span> <span class="nav-text">如何避免线程死锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-与-wait-方法的区别和共同点"><span class="nav-number">1.9.</span> <span class="nav-text">sleep() 与 wait() 方法的区别和共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么调用-start-方法时会调用-run-方法？为什么不能直接调用-run-方法？"><span class="nav-number">1.10.</span> <span class="nav-text">为什么调用 start() 方法时会调用 run() 方法？为什么不能直接调用 run() 方法？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized-关键字"><span class="nav-number">2.</span> <span class="nav-text">synchronized 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#认识-synchronized-关键字"><span class="nav-number">2.1.</span> <span class="nav-text">认识 synchronized 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-关键字最主要的-3-种使用方式"><span class="nav-number">2.2.</span> <span class="nav-text">synchronized 关键字最主要的 3 种使用方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双重检验锁实现单例模式（线程安全）"><span class="nav-number">2.3.</span> <span class="nav-text">双重检验锁实现单例模式（线程安全）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-关键字的底层实现原理"><span class="nav-number">2.4.</span> <span class="nav-text">synchronized 关键字的底层实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步语句块"><span class="nav-number">2.4.1.</span> <span class="nav-text">同步语句块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步方法"><span class="nav-number">2.4.2.</span> <span class="nav-text">同步方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-1-6-之后的-synchronized-关键字底层做了哪些优化？"><span class="nav-number">2.5.</span> <span class="nav-text">JDK 1.6 之后的 synchronized 关键字底层做了哪些优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">2.5.1.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-number">2.5.2.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁与适应性自旋锁"><span class="nav-number">2.5.3.</span> <span class="nav-text">自旋锁与适应性自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁消除"><span class="nav-number">2.5.4.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁粗化"><span class="nav-number">2.5.5.</span> <span class="nav-text">锁粗化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized-和-ReenTrantLock-的对比"><span class="nav-number">2.6.</span> <span class="nav-text">Synchronized 和 ReenTrantLock 的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile-关键字"><span class="nav-number">3.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-内存模型"><span class="nav-number">3.1.</span> <span class="nav-text">Java 内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发编程的-3-个重要特性"><span class="nav-number">3.2.</span> <span class="nav-text">并发编程的 3 个重要特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-和-volatile-的区别"><span class="nav-number">3.3.</span> <span class="nav-text">synchronized 和 volatile 的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">4.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-简介"><span class="nav-number">4.1.</span> <span class="nav-text">ThreadLocal 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-示例"><span class="nav-number">4.2.</span> <span class="nav-text">ThreadLocal 示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-原理"><span class="nav-number">4.3.</span> <span class="nav-text">ThreadLocal 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-内存泄露问题"><span class="nav-number">4.4.</span> <span class="nav-text">ThreadLocal 内存泄露问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程池"><span class="nav-number">5.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用线程池？"><span class="nav-number">5.1.</span> <span class="nav-text">为什么要使用线程池？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-Runnable-和-Callable-接口的区别"><span class="nav-number">5.2.</span> <span class="nav-text">实现 Runnable 和 Callable 接口的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行-execute-和-submit-方法的区别"><span class="nav-number">5.3.</span> <span class="nav-text">执行 execute() 和 submit() 方法的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何创建线程池？"><span class="nav-number">5.4.</span> <span class="nav-text">如何创建线程池？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的线程池-Demo"><span class="nav-number">5.5.</span> <span class="nav-text">一个简单的线程池 Demo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的实现原理剖析"><span class="nav-number">5.6.</span> <span class="nav-text">线程池的实现原理剖析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Atomic-原子类"><span class="nav-number">6.</span> <span class="nav-text">Atomic 原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#认识-Atomic-原子类"><span class="nav-number">6.1.</span> <span class="nav-text">认识 Atomic 原子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicInteger-的使用"><span class="nav-number">6.2.</span> <span class="nav-text">AtomicInteger 的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicInteger-类的原理"><span class="nav-number">6.3.</span> <span class="nav-text">AtomicInteger 类的原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS"><span class="nav-number">7.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-介绍"><span class="nav-number">7.1.</span> <span class="nav-text">AQS 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-原理分析"><span class="nav-number">7.2.</span> <span class="nav-text">AQS 原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-原理概况"><span class="nav-number">7.2.1.</span> <span class="nav-text">AQS 原理概况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-对资源的共享方式"><span class="nav-number">7.2.2.</span> <span class="nav-text">AQS 对资源的共享方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-底层使用了模板方法模式"><span class="nav-number">7.2.3.</span> <span class="nav-text">AQS 底层使用了模板方法模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-组件总结"><span class="nav-number">7.3.</span> <span class="nav-text">AQS 组件总结</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Flexia</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">743k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">11:15</span>
  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color='0,0,0' opacity='1' zIndex='-1' count='20' src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  
  

<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '7kWTdJsaz4FTWvD11vJ68LrU-gzGzoHsz',
    appKey: 'IagQj5azVtsiUPyjWRrvasm6',
    placeholder: '要不要说点啥……',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  


  

</body>
</html>
