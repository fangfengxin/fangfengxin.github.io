<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="google-site-verification" content="N8ofSn2GrmJ51OE3RhiifNsuUcNAfC7JAukwhpY-WiY"><link rel="stylesheet" href="https://fonts.cat.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.2.0"><link rel="mask-icon" href="/images/logo.png?v=7.2.0" color="#222"><link rel="manifest" href="/images/site.webmanifest"><meta name="msapplication-config" content="/images/browserconfig.xml"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!0},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},copycode:{enable:!0,show_result:!0,style:"default"},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"}}</script><meta name="description" content="图像增强 图像增强技术是最基本和最常用的一种图像处理技术，也常作为其他图像处理技术之前的预处理手段 图像增强的目的是通过对图像的特定加工，以将被处理的图像转化为对具体应用来说视觉质量和效果更好或更有用的图像 目前常用的图像增强技术根据根据其处理所进行的空间不同，可分为基于空域（图像域）的方法和基于变换域的方法两类  空域增强：点操作 空域：像素位置所在的空间，也称图像空间 空域图像增强：直接作用于"><meta name="keywords" content="图像处理,图像增强,空域增强,点操作,模板操作"><meta property="og:type" content="article"><meta property="og:title" content="《图像处理》空域图像增强"><meta property="og:url" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.html"><meta property="og:site_name" content="SmallFun&#39;s Blog"><meta property="og:description" content="图像增强 图像增强技术是最基本和最常用的一种图像处理技术，也常作为其他图像处理技术之前的预处理手段 图像增强的目的是通过对图像的特定加工，以将被处理的图像转化为对具体应用来说视觉质量和效果更好或更有用的图像 目前常用的图像增强技术根据根据其处理所进行的空间不同，可分为基于空域（图像域）的方法和基于变换域的方法两类  空域增强：点操作 空域：像素位置所在的空间，也称图像空间 空域图像增强：直接作用于"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/旋转变换轴不在原点的情况.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/五种典型的坐标变换示意.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/旋转变换的分解1.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/旋转变换的分解2.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/灰度映射原理.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/图像求反灰度映射.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/增强对比度灰度映射.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/动态范围压缩灰度映射.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/伽马校正示例.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/灰度统计直方图.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/不同类型图像及其直方图示例.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/直方图均衡化计算列表.jpg"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/直方图均衡化效果.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/直方图规定化计算列表.jpg"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/单映射规则绘图示例.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/组映射规则绘图示例.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/邻接、连接、通路、连通之间的关系.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/3种范数和3种距离.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/用3×3的模板进行模板操作的示意图.jpg"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/空域滤波增强技术分类.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/1-D高斯模板系数.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/8个边缘保持平滑模板.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/两种拉普拉斯算子模板.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/拉普拉斯算子与高频提升滤波的比较.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/线性滤波不能区分图像中有用的特征和噪声.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/1-D中值滤波示例.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/邻域平均和中值滤波的比较.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/一些用于中值滤波的模板.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/实现2-D中值滤波的3种方法的结果.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/两个差分模板.png"><meta property="og:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/局部增强效果示例.png"><meta property="og:updated_time" content="2019-10-20T12:36:23.233Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《图像处理》空域图像增强"><meta name="twitter:description" content="图像增强 图像增强技术是最基本和最常用的一种图像处理技术，也常作为其他图像处理技术之前的预处理手段 图像增强的目的是通过对图像的特定加工，以将被处理的图像转化为对具体应用来说视觉质量和效果更好或更有用的图像 目前常用的图像增强技术根据根据其处理所进行的空间不同，可分为基于空域（图像域）的方法和基于变换域的方法两类  空域增强：点操作 空域：像素位置所在的空间，也称图像空间 空域图像增强：直接作用于"><meta name="twitter:image" content="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/旋转变换轴不在原点的情况.png"><link rel="canonical" href="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>《图像处理》空域图像增强 | SmallFun's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-145696891-1"></script><script>var host=window.location.hostname;if("localhost"!==host){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-145696891-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ccc4ebbe605a1363703684938a4b4c40";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">SmallFun's Blog</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">稍稍记录小方方的学习之路啦</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><a href="https://github.com/fangfengxin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://fangfengxin.top/2019/07/20/spatial-domain-enhancement-by-book-image-processing.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Fengxin Fang"><meta itemprop="description" content="小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SmallFun's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">《图像处理》空域图像增强</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-20 21:30:43" itemprop="dateCreated datePublished" datetime="2019-07-20T21:30:43+08:00">2019-07-20</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-20 20:36:23" itemprop="dateModified" datetime="2019-10-20T20:36:23+08:00">2019-10-20</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/《图像处理》章毓晋/" itemprop="url" rel="index"><span itemprop="name">《图像处理》章毓晋</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">评论数：</span><a href="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.html" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span title="本文字数">17k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">16 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h1><ul><li>图像增强技术是最基本和最常用的一种图像处理技术，也常作为其他图像处理技术之前的预处理手段</li><li>图像增强的目的是通过对图像的特定加工，以将被处理的图像转化为对具体应用来说视觉质量和效果更好或更有用的图像</li><li>目前常用的图像增强技术根据根据其处理所进行的空间不同，可分为基于空域（图像域）的方法和基于变换域的方法两类</li></ul><h1 id="空域增强：点操作"><a href="#空域增强：点操作" class="headerlink" title="空域增强：点操作"></a>空域增强：点操作</h1><ul><li>空域：像素位置所在的空间，也称图像空间</li><li>空域图像增强：直接作用于像素，在图像空间进行的增强</li><li>点操作<ul><li>增强操作仅定义在每个像素点的位置上（增强操作仅利用了单个像素的信息）</li><li>种类<ul><li>几何点操作：改变像素的坐标位置 (x,y)</li><li>灰度点操作：改变像素的灰度 f</li></ul></li></ul></li></ul><h2 id="图像坐标变换"><a href="#图像坐标变换" class="headerlink" title="图像坐标变换"></a>图像坐标变换</h2><ul><li>图像（空间/几何）坐标变换是一种位置映射操作，涉及的是图像空间里各个坐标位置间的转换及方式</li></ul><h3 id="基本坐标变换"><a href="#基本坐标变换" class="headerlink" title="基本坐标变换"></a>基本坐标变换</h3><ul><li>变换的表示<ul><li>$\begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}\begin{bmatrix}{a}&amp;{b}&amp;{c}\end{bmatrix}^T\ =\ 0\ \Leftrightarrow\ {点} (x,y) {在直线} ax\ +\ by\ +\ c\ =\ 0 {上}$，这样点矢量 $\begin{bmatrix}{x}&amp;{y}\end{bmatrix}^T$ 就用一个 3-D 矢量 $\begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}^T$ 来表示了</li><li><strong>齐次坐标</strong>：<ul><li>如果空间中的点用矢量形式表示为 $\boldsymbol \omega = \begin{bmatrix}{x}&amp;{y}&amp;{z}\end{bmatrix}^T$，则对应的齐次坐标可表示为 ${\boldsymbol \omega}_h = \begin{bmatrix}{kx}&amp;{ky}&amp;{kz}&amp;{k}\end{bmatrix}^T,k$ 为非零常数</li></ul></li><li><strong>坐标变换</strong>：<ul><li>设原坐标的矢量为 $\boldsymbol v = \begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}^T$，变换后坐标的矢量为 $\boldsymbol v’ = \begin{bmatrix}{x’}&amp;{y’}&amp;{1}\end{bmatrix}^T$，则坐标变换可借助矩阵写为 $\boldsymbol v’ = A_{3{\times}3}\boldsymbol v$</li><li>令 $\boldsymbol v_{1}, \boldsymbol v_{2}, \cdots, \boldsymbol v_{m}$ 代表 m 个点的坐标矢量，则对一个其列由这些列矢量组成的 3 × m 矩阵 $\boldsymbol V$，可用一个 3 × 3 矩阵 $A$ 同时变换所有的点，即 $\boldsymbol V’ = A\boldsymbol V$</li></ul></li></ul></li><li><strong>平移变换</strong><ul><li>平移变换矩阵 $T = \begin{bmatrix}<br>{1}&amp;{0}&amp;{T_{x}}\\<br>{0}&amp;{1}&amp;{T_{y}}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li></ul></li><li><strong>放缩变换</strong>（尺寸变换）<ul><li>放缩变换矩阵 $S = \begin{bmatrix}<br>{S_{x}}&amp;{0}&amp;{0}\\<br>{0}&amp;{S_{y}}&amp;{0}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li></ul></li><li><strong>旋转变换</strong><ul><li>旋转轴垂直于图像平面，旋转角 $\gamma$ 按从旋转轴正向看原点而<strong>顺时针</strong>（从 Y 轴向 X 轴旋转）定义</li><li>旋转轴位于坐标原点时，旋转变换矩阵 $R_{\gamma} = \begin{bmatrix}<br>{\cos{\gamma}}&amp;{\sin{\gamma}}&amp;{0}\\<br>{-\sin{\gamma}}&amp;{\cos{\gamma}}&amp;{0}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li><li>旋转轴不在坐标原点时，<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/旋转变换轴不在原点的情况.png" alt></li></ul></li></ul><h3 id="坐标变换扩展"><a href="#坐标变换扩展" class="headerlink" title="坐标变换扩展"></a>坐标变换扩展</h3><ul><li><strong>反变换</strong><ul><li>基本坐标变换反向进行</li><li>平移变换逆矩阵 $T^{-1} = \begin{bmatrix}<br>{1}&amp;{0}&amp;{-T_{x}}\\<br>{0}&amp;{1}&amp;{-T_{y}}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li><li>放缩变换逆矩阵 $S^{-1} = \begin{bmatrix}<br>{\frac{1}{S_{x}}}&amp;{0}&amp;{0}\\<br>{0}&amp;{\frac{1}{S_{y}}}&amp;{0}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li><li>绕在原点的旋转轴顺时针旋转 $\gamma$ 角度的逆矩阵 ${R_{\gamma}}^{-1} = \begin{bmatrix}<br>{\cos{\gamma}}&amp;{-\sin{\gamma}}&amp;{0}\\<br>{\sin{\gamma}}&amp;{\cos{\gamma}}&amp;{0}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix} = {R_{\gamma}}^T$</li></ul></li><li><p><strong>变换级联</strong></p><ul><li>多个不同变换接续进行，如旋转变换的旋转轴不在原点时的旋转</li></ul></li><li><strong>3-点映射变换</strong><ul><li>将矩形映射为平行四边形，而将三角形映射为另一个三角形的变换</li><li>除平移、放缩、旋转变换外还有拉伸变换和剪切变换</li><li><strong>拉伸变换</strong><ul><li>在一个方向上放大，而在其正交方向上缩小的变换</li><li>放缩变换的一种特例，放缩系数互为倒数</li><li>设拉伸系数为 L，则拉伸变换矩阵 $\boldsymbol L = \begin{bmatrix}<br>{L}&amp;{0}&amp;{0}\\<br>{0}&amp;{1/L}&amp;{0}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li></ul></li><li><strong>剪切变换</strong><ul><li>仅像素的水平坐标或垂直坐标之一发生（与像素的垂直或水平坐标数值相关的）平移变化</li><li>水平剪切变换矩阵 $\boldsymbol J_{h} = \begin{bmatrix}<br>{1}&amp;{J_{x}}&amp;{0}\\<br>{0}&amp;{1}&amp;{0}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li><li>垂直剪切变换矩阵 $\boldsymbol J_{v} = \begin{bmatrix}<br>{1}&amp;{0}&amp;{0}\\<br>{J_{y}}&amp;{1}&amp;{0}\\<br>{0}&amp;{0}&amp;{1}\\<br>\end{bmatrix}$</li></ul></li><li>五种典型的坐标变换示意<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/五种典型的坐标变换示意.png" alt></li></ul></li><li><strong>旋转变换的分解</strong><ul><li>通过结合剪以及水平和垂直方向的放缩来实现快速旋转，但是放缩操作需额外的计算，还可能导致分辨率减小<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/旋转变换的分解1.png" alt></li><li>为避免放缩操作，可将图像旋转分解为 3 个 1-D 剪切变换的级联以加速<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/旋转变换的分解2.png" alt></li></ul></li></ul><h2 id="图像间运算"><a href="#图像间运算" class="headerlink" title="图像间运算"></a>图像间运算</h2><ul><li>图像间的运算指以图像为单位进行的操作（按数组方式进行），运算的结果是一幅新图像</li></ul><h3 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h3><ul><li>算术运算<ul><li>一般用于<strong>灰度图像</strong></li><li>设有分别属于两幅图像对应位置的两个像素 p 和 q</li><li>加法：p + q</li><li>减法：p - q</li><li>乘法：p × q（也可写为 pq）</li><li>除法：p ÷ q</li><li>将两个像素的灰度值通过相应运算得到一个新的灰度值作为对应输出图像中同一位置处像素的灰度值</li></ul></li><li>逻辑运算<ul><li>只用于<strong>二值图像</strong>（0 和 1）</li><li>补（COMPLEMENT）：NOT q（也可写为 $\bar{q}$）</li><li>与（AND）：p AND q（也可写为 p ▪ q）</li><li>或（OR）：p OR q（也可写为 p + q）</li><li>异或（XOR）：p XOR q（也可写为 p ⊕ q）</li></ul></li></ul><h3 id="图像间算术运算的应用"><a href="#图像间算术运算的应用" class="headerlink" title="图像间算术运算的应用"></a>图像间算术运算的应用</h3><ul><li>图像间加法的应用<ul><li>用于图像平均以减少和去除图像采集中混入的噪声</li><li>实际采集到的图像 g(x,y) 可看作是由原始场景图像 f(x,y) 和噪声图像 e(x,y) 叠加而成的，即 g(x,y) = f(x,y) + e(x,y)，假设图像在各点的噪声是互不相关的，且噪声具有零均值的统计特性</li><li>将 M 个图像相加再求平均得到一幅新的图像，即 $\bar{g}(x,y)={\frac{1}{M}}\sum_{i=1}^{M}g_{i}(x,y)$</li><li>可以证明新图像的期望值为原始场景图像 $E\{\bar{g}(x,y)\}=f(x,y)$</li><li>如果考虑新图像和噪声图像各自的均方差之间的关系，则有 $\sigma_{\bar{g}(x,y)} = \sqrt{\frac{1}{M}} \times \sigma_{e(x,y)}$</li><li>可见随着平均图数量增加，噪声在每个像素位置的影响将越来越小</li></ul></li><li>图像间减法的应用<ul><li>两图相减可把差异凸显出来</li><li>医学图像处理：消除背景，医学成像的基本工具之一</li><li>运动检测：对时间上相邻的两幅图像求差可以将图像中目标的位置和形状变化凸显出来</li></ul></li><li>图像间乘法和除法的应用<ul><li>校正由于照明或传感器的非均匀性所造成的图像明暗变化</li><li>模板运算</li><li>彩色空间中的转换</li></ul></li></ul><h2 id="图像灰度映射"><a href="#图像灰度映射" class="headerlink" title="图像灰度映射"></a>图像灰度映射</h2><h3 id="灰度映射原理"><a href="#灰度映射原理" class="headerlink" title="灰度映射原理"></a>灰度映射原理</h3><ul><li>图像灰度映射要根据原始图像中的每个像素的灰度值，按照某种映射规则，直接将其变换或转化为另一灰度值，从而达到增强图像视觉效果的目的</li><li>灰度映射函数 $t=E_{H}(s)$，t 为增强灰度值，s 为原始灰度值</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/灰度映射原理.png" alt></li></ul><h3 id="典型灰度映射"><a href="#典型灰度映射" class="headerlink" title="典型灰度映射"></a>典型灰度映射</h3><ul><li><strong>图像求反</strong><ul><li>将原图灰度值翻转，使白变黑，使黑变白</li><li>照片和底片关系就是这样</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/图像求反灰度映射.png" alt></li></ul></li><li><strong>增强对比度</strong><ul><li>增加图像各相邻部分的灰度差别，具体通过增加图像中某两个灰度值之间的动态范围来进行</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/增强对比度灰度映射.png" alt></li></ul></li><li><strong>动态范围压缩</strong><ul><li>如果原图动态范围太大，超出显示设备允许的动态范围，会导致细节丢失，此时需要对原图进行一定的灰度范围压缩，常用压缩方式是借助对数形式的灰度映射函数 $t=Clog(1+|s|)$</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/动态范围压缩灰度映射.png" alt></li></ul></li><li><strong>伽马校正</strong><ul><li>借助<strong>指数变换</strong>映射的增强技术 $t=Cs^{\gamma}$</li><li>当 $\gamma &lt; 1$ 时，变换的结果是输入中较窄的低灰度范围被映射到输出中较宽的灰度范围，而同时输入中较宽的高灰度范围被映射到输出中较窄的灰度范围</li><li>许多图像获取、显示、打印设备的输出响应与输入激励满足对数变换的规律，为校正其响应为线性的，需进行指数变换，如常见的 CRT 显示器的亮度-电压响应满足指数变换规律，直接显示的效果会暗许多，校正后显示结果基本与原图一致</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/伽马校正示例.png" alt></li></ul></li></ul><h2 id="直方图变换"><a href="#直方图变换" class="headerlink" title="直方图变换"></a>直方图变换</h2><ul><li>直方图变换（也叫直方图修正）是以概率论为基础，通过改变图像的直方图来改变图像中各像素的灰度，以达到图像增强的目的</li></ul><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><ul><li>直方图均衡化借助图像的直方图表达来进行，目标是<strong>平衡不同灰度级像素的数量</strong></li><li>灰度统计<strong>直方图</strong><ul><li>提供了图像像素的灰度值分布情况</li><li>是一个以灰度值为自变量的 <strong>1-D的离散函数</strong> $h(k) = n_{k} \quad k=0,1,\cdots,L-1$</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/灰度统计直方图.png" alt></li><li>直方图的均值和方差也是图像灰度的均值和方差</li><li>图像的视觉效果和其直方图有对应关系</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/不同类型图像及其直方图示例.png" alt></li></ul></li><li>灰度统计<strong>累积直方图</strong><ul><li>也是一个 1-D 离散函数</li><li>可以表示成 $H(k) = \sum_{i=0}^{k}n_{i} \quad k=0,1,\cdots,L-1$</li><li>累积直方图中列 k 的高度给出图像中灰度值小于和等于 k 的像素的总个数</li></ul></li><li>直方图均衡化原理<ul><li>直方图均衡化主要用于<strong>增强动态范围偏小的图像的对比度</strong></li><li>基本思想：把原始图像的<strong>直方图变换为均匀分布的形式</strong>，增加像素之间灰度值差别的动态范围，从而达到增强图像整体对比度的结果</li><li>归一化直方图<ul><li>将直方图以<strong>归一化的概率形式表达</strong>给出了对各灰度值在图像中所占的数量比例</li><li>$p_{s}(s_{k}) = \frac{n_{k}}{N} \quad 0 \leq s_{k} \leq 1 \quad k = 0,1,\cdots,L-1$</li><li>$s_{k}$ 为图像 f(x,y) 的第 k 级灰度值，N是图像中像素的总个数，L 是灰度级的数量</li></ul></li><li>增强函数 $E_{H}(s)$<ul><li>两个条件<ul><li>$E_{H}(s)$ 在 $0 \leq s \leq 1$ 范围内是单值单增函数 $\Longrightarrow$ 各灰度级在变换后仍<strong>保持排列次序</strong></li><li>对 $0 \leq s \leq 1$ 有 $0 \leq E_{H}(s) \leq 1$ $\Longrightarrow$ 变换前后图像的<strong>灰度值动态范围保持一致性</strong></li></ul></li><li><strong>累积分布函数</strong><ul><li>$t_{k} = E_{H}(s_{k}) = \sum_{i=0}^k\frac{n_{i}}{N} = \sum_{i=0}^k{p_{s}(s_{i})} \quad 0 \leq s_{k} \leq 1 \quad k = 0,1,\cdots,L-1$</li><li>提供了图像像素灰度值得累积分布情况</li><li>$t_{k}$ 是 k 的单值单增函数</li><li>灰度值取值范围一致，$0 \leq t_{k} \leq 1$</li><li>将 s 的分布转换为 t 的均匀分布</li></ul></li></ul></li><li>取整扩展<ul><li>$t_{k} = int[t_{k} \times (L-1) + 0.5]$</li></ul></li><li>确定映射对应关系<ul><li>$s_{k} \rightarrow t_{k}$</li></ul></li><li>根据映射关系计算均衡化直方图</li></ul></li><li>直方图均衡化的列表计算<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/直方图均衡化计算列表.jpg" alt></li><li>直方图均衡化效果<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/直方图均衡化效果.png" alt></li></ul><h3 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h3><ul><li>直方图均衡化：能自动增强图像整体对比度，但实际增强效果不易控制，结果总是得到全局均衡化的直方图</li><li>直方图规定化：有选择地增强某个特定灰度值范围内的对比度，使图像灰度值的分布满足特定的要求</li><li>直方图规定化原理<ul><li>要调整原始图像的直方图去逼近所规定的目标直方图</li><li>三个步骤<ul><li>对原始直方图进行灰度均衡化</li><li>$t_{k} = E_{H_{s}}(s_{i}) = \sum_{i=0}^k{p_{s}(s_{i})} \quad k = 0,1,\cdots,L-1$</li><li>规定需要的直方图，并计算能使规定的直方图均衡化的变换</li><li>$v_{l} = E_{H_{u}}(u_{j}) = \sum_{j=0}^l{p_{u}(u_{j})} \quad l = 0,1,\cdots,L-1$</li><li>将步骤 1 得到的变换反转过来，即将原始直方图（灰度级数 M）对应映射到规定直方图（灰度级数 N）<ul><li>单映射规则（SML）</li><li>从大到小依次找到使 $| \sum_{i=0}^k{p_{s}(s_{i})} - \sum_{j=0}^l{p_{u}(u_{j})} |$ 最小的 k 和 l，然后将 $p_{s}(s_{i})$ 分别对应到 $p_{u}(u_{j})$ 去</li><li><strong>组映射规则（GML）</strong></li><li>设有一个整数函数 $I(l), 0 \leq l \leq N-1$，满足 $0 \leq I(0) \leq \cdots \leq I(l) \leq \cdots \leq I(N-1) \leq M-1$。现在要确定能使 $| \sum_{i=0}^{I(l)}{p_{s}(s_{i})} - \sum_{j=0}^l{p_{u}(u_{j})} |$达到最小的 $I(l)$，然后分组对应</li></ul></li></ul></li></ul></li><li>直方图规定化的列表计算<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/直方图规定化计算列表.jpg" alt></li><li>直方图规定化的绘图计算<ul><li>将直方图画成一长条，每一段对应直方图的一项</li><li>单映射规则是从原始累积直方图的各项依次向规定累计直方图进行映射，每次选择最接近的数值，即遵循最短（最垂直）的连线<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/单映射规则绘图示例.png" alt></li><li>组映射规则是<strong>从规定累积直方图</strong>的各项依次向原始累积直方图进行，遵循最短（最垂直）的连线<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/组映射规则绘图示例.png" alt></li></ul></li><li>两种映射规则的比较<ul><li>单映射规则：有偏的映射规则，最大误差为 $p_{u}(u_{j})/2$</li><li>组映射规则：统计无偏的映射规则，最大误差为 $p_{s}(s_{i})/2$</li><li>$\because N \leq M \quad \therefore p_{s}(s_{i})/2 \leq p_{u}(u_{j})/2$</li></ul></li><li>直方图均衡化和直方图规定化<ul><li>直方图规定化是直方图变换或直方图修正的一般形式</li><li>直方图均衡化可看作使用完全水平的直方图作为规定直方图的直方图规定化</li></ul></li></ul><h1 id="空域增强：模板操作"><a href="#空域增强：模板操作" class="headerlink" title="空域增强：模板操作"></a>空域增强：模板操作</h1><ul><li>像素在图像空间是按某种规律排列的，相互之间有一定的联系，而相邻或接近的像素之间有更密切的联系，常可结合在一起考虑</li><li>在图像处理中，常用模板来组合相邻或接近的像素，根据这些像素的统计特性或局部运算来进行操作，称为模板操作或模板运算</li><li>利用模板操作来进行图像增强常称为滤波，可以是线性的也可以是非线性的</li><li>由于模板操作涉图像中的局部区域，所以也可方便地进行局部增强</li></ul><h2 id="像素间联系"><a href="#像素间联系" class="headerlink" title="像素间联系"></a>像素间联系</h2><h3 id="像素的邻域和邻接"><a href="#像素的邻域和邻接" class="headerlink" title="像素的邻域和邻接"></a>像素的邻域和邻接</h3><ul><li>邻域：由一个像素周围与其关系最密切的近邻像素组成的集合<ul><li>4-邻域 $N_{4}(p)$：由像素 p 的垂直（上、下）和水平（左、右）共 4 个近邻像素组成</li><li>对角邻域 $N_{D}(p)$：由像素 P 的 对角（左上、右上、左下、右下）共 4 个近邻像素组成</li><li>8-邻域 $N_{8}(P)$：由像素 p 的 4 个 4-邻域像素和 4 个对角邻域像素合起来构成</li></ul></li><li>邻接：一种像素间的空间接近关系<ul><li>4-邻接</li><li>对角邻接</li><li>8-邻接</li></ul></li></ul><h3 id="像素间的连接和连通"><a href="#像素间的连接和连通" class="headerlink" title="像素间的连接和连通"></a>像素间的连接和连通</h3><ul><li>连接：两个像素间的一种空间和属性关系<ul><li>连接与否<ol><li>空间上邻接</li><li>灰度值满足某个特定的相似准则（灰度值相等或同在一个灰度值集合中取值）</li></ol></li><li>两种常用的连接（设 V 是定义连接的灰度值集合）<ul><li>4-连接：2 个像素 p 和 r 在 V 中取值，且 r 在 $N_{4}(p)$ 中</li><li>8-连接：2 个像素 p 和 r 在 V 中取值，且 r 在 $N_{8}(p)$ 中</li></ul></li><li>两个连接的像素一定是邻接的，反之则不一定</li></ul></li><li>连通：连通是连接的推广<ul><li>通路<ul><li>从具有坐标 $(x, y)$ 的像素 p 到具有坐标 $(s, t)$ 的像素 q 的一条通路由一系列具有坐标 $(x_{0}, y_{0}), (x_{1}, y_{1}), \cdots, (x_{n}, y_{n})$ 的独立像素组成，这里 $(x_{0}, y_{0}) = (x, y), (x_{n}, y_{n}) = (s, t)$，且 $(x_{i}, y_{i})$ 与 $(x_{i-1}, y_{i-1})$ 邻接，其中 1 ≤ i ≤ n，n为通路长度</li><li>根据所采用的邻接定义不同，可得到不同的通路<ul><li>4-通路</li><li>8-通路</li></ul></li><li>这里对通路的定义仅考虑了像素坐标空间上的联系，没有考虑像素属性空间上的联系</li></ul></li><li>连通<ul><li>通路建立了两个像素 p 和 q 之间的空间联系，如果这条通路上的所有像素的灰度值均满足某个特定的相似准则，即两两邻接的像素也是连接的，则可以说像素 p 和 q 是连通的</li><li>根据所采用的连接定义的不同，可得到不同的连通<ul><li>4-连通</li><li>8-连通</li></ul></li><li>当 n = 1 时，连通转化为其特例 —— 连接</li></ul></li></ul></li><li>邻接、连接、通路、连通之间的关系<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/邻接、连接、通路、连通之间的关系.png" alt></li></ul><h3 id="像素集合的邻接、连接和连通"><a href="#像素集合的邻接、连接和连通" class="headerlink" title="像素集合的邻接、连接和连通"></a>像素集合的邻接、连接和连通</h3><ul><li>子集：图像中（部分）像素的集合，是图像的一部分</li><li>图像子集邻接：S 的一个或一些像素与 T 的一个或一些像素邻接</li><li>图像子集连接：图像子集邻接且邻接像素的灰度值满足特定的相似准则，即 S 的一个或一些像素与 T 的一个或一些像素连接</li><li>连通组元：由在同一个图像子集中的与同一个像素相连通的所有像素构成</li><li>连通集：只有一个连通组元（即所有像素都互相连通）的图像子集</li><li>区域：一幅图像里的每个连通集构成该图像的一个区域<ul><li>简单连通：区域没有孔</li><li>多重连通：区域有孔</li></ul></li><li>轮廓：即区域的边界，是该区域的一个子集，将该区域与其他区域分离开<ul><li>组成一个区域的边界像素本身属于该区域而在其邻域中有不属于该区域的像素</li></ul></li></ul><h3 id="像素间的距离"><a href="#像素间的距离" class="headerlink" title="像素间的距离"></a>像素间的距离</h3><ul><li>距离量度函数 <code>D(p,q)</code><ul><li>D(p,q) ≥ 0 (D(p,q) = 0 当且仅当 p = q) → 距离恒正</li><li>D(p,q) = D(q,p) → 距离是相对的，与起终点无关</li><li>D(p,q) ≤ D(p,r) + D(r,q) → 沿直线距离最短</li></ul></li><li>测度空间 <code>(A,d)</code><ul><li>A 为抽象集合</li><li>d 为从集合 A 向实数集 R 映射的距离度量函数（d: A × A → R）</li></ul></li><li>2-D 图像中的 3 种距离<ul><li>欧氏距离（范数为 2） $D_{E}(p,q) = \sqrt{(x-s)^2 + (y-t)^2}$</li><li>城区距离（曼哈顿距离，范数为 1） $D_{4}(p,q) = |x-s|+|y-t|$</li><li>棋盘距离（切比雪夫距离，范数为 ∞） $D_{8}(p,q) = \max(|x-s|,|y-t|)$</li></ul></li><li>用距离定义邻域<ul><li>$N_{4}(p) = \{r|D_{4}(p,r) = 1\}$</li><li>$N_{8}(p) = \{r|D_{8}(p,r) = 1\}$</li></ul></li><li><a href="https://blog.csdn.net/alinawly/article/details/80804727" target="_blank" rel="noopener">范数和距离</a><ul><li>函数的范数可表示为 ${\Vert f \Vert}_{m} = [\int|f(x)|^m dx]^{1/m}$</li><li><strong>闵可夫斯基（Minkowski）距离</strong>度量为 $D_{m}(p,q) = [|x-s|^m + |y-t|^m ]^{1/m}$，对应范数为参数 m</li><li>考虑与原点为单位距离的点的集合<ul><li>m = 1 → 菱形</li><li>m = 2 → 圆</li><li>m = ∞ → 正方形</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/3种范数和3种距离.png" alt></li></ul></li></ul></li></ul><h2 id="模板运算"><a href="#模板运算" class="headerlink" title="模板运算"></a>模板运算</h2><ul><li>模板：一般可看作尺寸为 n × n (n 为较小的奇数) 的小图像，在其各位置上的值常称为系数值，系数值由功能确定</li><li>模板运算：将赋予某个像素的值作为它本身灰度值和其相邻像素灰度值的函数</li><li>滤波：利用像素本身以及其邻域像素的灰度关系进行图像增强的方法</li><li>滤波器：实现滤波功能的模板</li></ul><h3 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h3><ul><li>模板卷积：用模板与需处理图像在图像空间进行卷积的运算过程</li><li>模板卷积过程不能原地完成，所以输出结果要是用另一幅图像</li><li>模板卷积步骤<ol><li>将模板在输入图像中漫游，并将模板中心与图像中某个像素位置重合</li><li>将模板上的各个系数与模板下各对应像素的灰度值相乘</li><li>将所有乘积相加（为保持灰度范围，常将结果再除以模板系数之和）</li><li>将上述结果（模板的输出响应）赋给输出图像中对应模板中心位置的像素</li></ol></li><li>用 3 × 3 的模板进行模板操作的示意图<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/用3×3的模板进行模板操作的示意图.jpg" alt></li></ul><h3 id="模板排序"><a href="#模板排序" class="headerlink" title="模板排序"></a>模板排序</h3><ul><li>模板排序：用模板来提取需处理图像中与模板同尺寸的图像子集并将其中像素根据其幅度值排序的运算过程</li><li>模板排序过程也不能原地完成</li><li>模板排序步骤<ol><li>将模板在输入图象中漫游，并将模板中心与图象中某个象素位置重合</li><li>读取模板下输入图象中各对应象素的灰度值</li><li>将这些灰度值进行排序，一般将它们从小到大排成一列（单增）</li><li>根据运算目的从排序结果中选一个序，取出该序象素的灰度值</li><li>将取出的灰度值赋给输出图象中对应模板中心位置的象素</li></ol></li><li>模板排序中<ul><li>模板只划定像素范围，系数均看作 1 且不影响赋值</li><li>赋给输出图像的值必定是输入图像中与模板对应的像素值中的一个</li><li>模板只是为了选取像素，因而不一定是方形的，或者说，虽然用方形模板，但其中有些系数取 0</li></ul></li></ul><h3 id="图像边界处的模板运算"><a href="#图像边界处的模板运算" class="headerlink" title="图像边界处的模板运算"></a>图像边界处的模板运算</h3><ul><li>当模板中心对应输入图像的边界像素时，其邻域范围有可能扩展到输入图像的边界之外</li><li>解决方法<ul><li>忽略边界处的像素<ul><li>仅处理图像内部与边界距离大于等于模板半径 r 的像素</li></ul></li><li>将输入图像进行扩展<ul><li>在图像的 4 条边界外各增加/扩展一个 r 行或 r 列的带</li><li>新增行列中的像素的幅度值<ul><li>取为 0</li><li>取为原图像中 4-邻接像素的值（4 个角上的取为 8-邻接像素的值）</li><li>将图像在水平和垂直方向上均看作周期循环的（最后一行后是第一行，最后一列后是第一列）</li><li>利用外插技术，根据接近边界处行列像素的幅度值以一定的规则进行外推</li></ul></li><li>上述确定幅度值的方法都对边界像素给予了特殊的权重，并会使图像的平均灰度发生小的改变</li></ul></li></ul></li></ul><h3 id="空域滤波分类"><a href="#空域滤波分类" class="headerlink" title="空域滤波分类"></a>空域滤波分类</h3><ul><li>将模板运算用于图像空域增强一般称为<strong>空域滤波</strong></li><li>根据滤波功能分类<ul><li>平滑滤波<ul><li>减弱或消除图像中的高频率分量（高频分量对应图像中区域边缘等灰度值具有较大较快变化的部分，滤去后可减少局部灰度起伏，使图像变得比较平滑）</li><li>消除噪声（噪声的空间相关性较弱，对应较高的空间频率）</li></ul></li><li>锐化滤波<ul><li>减弱或消除图像中的低频率分量（低频分量对应图像中灰度值缓慢变化的区域，与图像的整体特性有关，滤去可使图像反差增加，边缘明显）</li><li>增强被模糊的细节或目标的边缘</li></ul></li></ul></li><li>根据滤波运算特点分类<ul><li>从统计的角度看，滤波是一种估计，它基于一组观察结果来估计未观察的量</li><li>线性滤波：对观察结果进行线性组合，理论基础比较成熟</li><li>非线性滤波：对观察结果的逻辑组合，理论基础较弱</li></ul></li><li>空域滤波增强技术分类<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/空域滤波增强技术分类.png" alt></li></ul><h2 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h2><ul><li>线性滤波既可以得到平滑的效果（图像反差减少），也可以得到锐化的效果（图像反差增加），主要取决于所用模板的系数值</li><li>线性滤波基于<strong>模板卷积</strong>进行</li></ul><h3 id="线性平滑滤波"><a href="#线性平滑滤波" class="headerlink" title="线性平滑滤波"></a>线性平滑滤波</h3><ul><li><strong>邻域平均</strong><ul><li>用一个像素邻域的平均值作为滤波结果</li><li>滤波模板的所有系数都取为 1</li><li>为保持灰度值范围，卷积结果要除以系数总个数再行赋值</li><li>$g(x,y) = {1 \over n^2} \sum_{(s,t) \in N(x,y)}f(s,t)$</li><li>N(x,y) 对应 f(x,y) 中 (x,y) 的 n × n 邻域</li></ul></li><li><strong>加权平均</strong><ul><li>离中心近的像素应对滤波结果有较大的贡献</li><li>将接近模板中心的系数取得比模板周边的系数大</li><li>$g(x,y) = \frac{\sum_{(s,t) \in N(x,y)}\; w(s,t)f(s,t)}{\sum_{(s,t) \in N(x,y)}\; w(s,t)}$</li></ul></li><li><strong>高斯平均</strong><ul><li>加权平均的一种特例</li><li>根据高斯分布（标准正态分布）来确定模板系数</li><li>${1 \over 273}\begin{bmatrix}<br>1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\<br>4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\<br>7 &amp; 26 &amp; 41 &amp; 26 &amp; 7 \\<br>4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\<br>1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\<br>\end{bmatrix}$</li><li>模板分解<ul><li>一个 2-D 高斯卷积可分解为顺序执行的两个 1-D 高斯卷积，即一个 2-D 高斯平均模板可拆分成两个 1-D 高斯平均模板</li><li>${1 \over 16}\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>2 &amp; 4 &amp; 2 \\<br>1 &amp; 2 &amp; 1 \\<br>\end{bmatrix} = {1 \over 4}\begin{bmatrix}<br>1 \\<br>2 \\<br>1 \\<br>\end{bmatrix}{1 \over 4}\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>\end{bmatrix}$</li><li>计算量为 <code>O(n²)</code> 的单个 n × n 模板被计算量为 <code>O(n)</code> 的两个 1 × n 模板所替换</li><li>对 n &gt; 3，总可以借助模板分解减少计算量</li></ul></li><li>1-D 离散模板<ul><li>可对高斯函数在整数位置 <code>-n,…,0,…,+n</code> 采样，具体可取 n = 2σ + 1（σ 为高斯方差），而模板尺寸为 s = 2n + 1</li><li>对高斯函数的简单近似可借助杨辉三角进行<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/1-D高斯模板系数.png" alt></li></ul></li><li>高斯滤波器<ul><li>特点<ul><li>线性的</li><li>与位置无关的</li><li>旋转对称的（各向同性的）</li><li>可以控制效果的（有一个控制参数）</li><li>可以连续多次使用的</li><li>可分离的（2-D 可用 1-D 的来计算）</li><li>不能递归执行</li></ul></li><li>线性滤波器都会改变图像中的噪声方差<ul><li>一个线性滤波器 $h(x,y)$ 会使噪声方差乘以因子 $\sum\sum h(x,y)$</li><li>对于高斯滤波器，这个因子是 $1 \over 4\pi\sigma^2$</li><li>取 $\sigma = {n \over 2\sqrt{\pi}}$，可使高斯滤波器与一个 n × n 的邻域平均滤波器具有相同的效果</li></ul></li></ul></li></ul></li><li><strong>边缘保持平滑</strong><ul><li>为了避免局部平均会模糊不同区域之间的边缘，考虑选择只在不包含边缘的邻域中进行平均</li><li>取中心像素的8个不同邻域，对每个邻域都统计其像素的灰度方差，并将灰度方差最小（方差小的邻域中像素灰度级的变化小，包含边缘的概率也小）的那个邻域中的像素均值赋给中心像素<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/8个边缘保持平滑模板.png" alt></li></ul></li></ul><h3 id="线性锐化滤波"><a href="#线性锐化滤波" class="headerlink" title="线性锐化滤波"></a>线性锐化滤波</h3><ul><li><strong>拉普拉斯算子</strong><ul><li>线性锐化滤波可借助模板卷积实现<ul><li>对应积分运算的模板卷积可以平滑图像，对应微分运算的模板卷积可以锐化图像</li><li>锐化模板系数的取值在中心为正而周围原理中心处为负</li></ul></li><li>拉普拉斯算子是一个<strong>各向同性</strong>的二阶微分算子<ul><li>$\nabla^2 f = {\partial^2 f \over \partial x^2} + {\partial^2 f \over \partial y^2}$</li><li>两个二阶偏导数可借助差分来计算</li><li>$\begin{cases}<br>{\partial^2 f \over \partial x^2} = 2f(x,y) - f(x+1,y) - f(x-1,y)\\<br>{\partial^2 f \over \partial y^2} = 2f(x,y) - f(x,y+1) - f(x,y-1)\\<br>\end{cases}$</li><li>可得到</li><li>$\nabla^2 f(x,y) = 4(x,y) - f(x+1,y) - f(x-1,y) - f(x,y+1) - f(x,y-1)$</li><li>据此得到的模板仅考虑了中心像素的 4-邻域，类似地也可以考虑 8-邻域</li></ul></li><li>两种拉普拉斯算子模板<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/两种拉普拉斯算子模板.png" alt><ul><li>两种模板系数之和均为 0<ul><li>灰度值为常数或变化很小的区域的卷积输出为 0 或很小</li><li>输出图的平均灰度值为 0，图中一部分像素灰度值小于 0</li></ul></li><li>通过变换将输出灰度值范围变回 [0, L-1]<ul><li>图像处理中只考虑大于或等于 0 的灰度值</li><li>变换后才能正常显示</li></ul></li></ul></li><li>拉普拉斯算子可增强图像中的灰度不连续边缘，减弱灰度值缓慢变化区域的对比度，将结果叠加到原始图像上，就可以得到锐化后的图像</li></ul></li><li><strong>高频提升滤波</strong><ul><li>图像锐化的效果可以通过叠加图像微分结果取得，也可通过减除图像积分结果取得</li><li>用原始图像 f(x,y) 减去平滑或模糊图像 g(x,y) 就得到<strong>非锐化掩模</strong> h(x,y)，如将非锐化掩模加到原始图像上就能锐化图像</li><li>进一步，把原始图像乘以一个放大倍数 A 再减去平滑图像就可实现<strong>高频提升滤波</strong></li><li>$h_{b}(x,y) = Af(x,y) - g(x,y) = (A-1)f(x,y) + h(x,y)$<ul><li>A = 1 → 非锐化掩模（平滑时丢失的锐化分量）</li><li>A &gt; 1 → 加权的原始图像与非锐化掩模相加（使原始图像锐化）</li><li>A = 2 → 非锐化掩模化<ol><li>平滑原始图像</li><li>从原始图像中减去平滑后的效果</li><li>将上述结果加到原始图像上</li></ol></li></ul></li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/拉普拉斯算子与高频提升滤波的比较.png" alt></li></ul></li></ul><h2 id="非线性滤波"><a href="#非线性滤波" class="headerlink" title="非线性滤波"></a>非线性滤波</h2><ul><li>线性滤波常不能区分图像中有用的内容和无用的噪声<ul><li>在 1-D 傅里叶空间对原始图像加上白噪声，两者的频谱直接叠加。线性滤波将两者的傅里叶变换相乘，结果在每个频率处信号和噪声的强度都由相同的因子所消弱。图像信噪比保持原值，并不增加<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/线性滤波不能区分图像中有用的特征和噪声.png" alt></li></ul></li><li>非线性滤波可区分图像中有用的内容和无用的噪声<ul><li>三个方向发展：逻辑、几何、代数</li><li>分为三种：基于集合的、基于形状的、基于排序的<ul><li>基于形状的非线性滤波围绕数学形态学进行，而基于形状的形态操作建立在集合论的基础上，并可在一定条件下简化成传统的逻辑表达</li></ul></li></ul></li></ul><h3 id="非线性平滑滤波"><a href="#非线性平滑滤波" class="headerlink" title="非线性平滑滤波"></a>非线性平滑滤波</h3><ul><li><strong>中值滤波原理</strong><ul><li>中值滤波依靠<strong>模板排序</strong>来实现</li><li>考虑 1-D 信号，设模板尺寸为 M = 2r+1，r 为模板半径，给定 1-D 信号序列 {fi}, i = 1, 2, … , N.</li><li>则中值滤波输出为 $g_{j} = median [f_{j-r}, f_{j-r+1}, \cdots, f_{j}, \cdots, f_{j+r}]$</li><li>上述定义的操作常称为游程中值，可以通过滑动奇数长度的模板来实现</li><li>中值滤波适合用于对脉冲噪声的消除<ul><li>脉冲噪声会导致受影响的像素值发生明显变化成为野点</li><li>平均滤波不加区别地平均对应模板的所有像素值，而中值滤波则忽略野点，所以不会模糊图像</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/1-D中值滤波示例.png" alt></li></ul></li><li>考虑一个长度为 L 的信号 $f(i) =<br>\begin{cases}<br>= 0 &amp; {i &lt; 0} \\<br>\neq 0 &amp; {i = 0}\\<br>\neq 0 &amp; {i = L - 1}\\<br>= 0 &amp; {i \geq L - 1}\\<br>\end{cases}$<ul><li>L ≤ r → 输出完全是 0，脉冲全被消除</li><li>如果信号仅包含长度至少为 r+1 的常数段 → 长度小于等于 2r+1 的中值滤波模板对信号滤波并不会使信号发生任何变化</li></ul></li><li>根信号<ul><li>不受中值滤波影响的信号</li><li>一个信号使用一个长度为 2r+1 的中值滤波的根信号的充分条件是该信号局部单调变化且阶数为 r+1（该信号的长度为 r+1 的段均为单调的）</li></ul></li><li>中值滤波的一些特性<ul><li>可以很好地消除孤立尖峰</li><li>有可能导致尖峰附近的边缘偏移，且元素多的更易偏移</li><li>中值滤波趋向于产生为常数的片段</li></ul></li></ul></li><li>2-D 中值滤波<ul><li>$g_{median}(x,y) = median_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>输出值大于等于模板中一半像素的值，又小于等于模板中另一半像素的值</li><li>一般情况下，图像中尺寸小于模板尺寸一半的过亮或过暗区域将会在滤波后被消除掉</li><li>中值滤波既能消除噪声又能较好地保持图像的细节<ul><li>中值滤波的主要功能就是让与周围像素灰度值的差比较大的像素改取与周围像素值接近的值，这样它对孤立的噪声像素的消除能力是很强的</li><li>又由于它不是简单的取均值，所以产生的模糊比较少</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/邻域平均和中值滤波的比较.png" alt></li></ul></li></ul></li><li>中值滤波的模板<ul><li>中值滤波的效果与所用模板的尺寸有关，也与模板中参与运算的像素个数有关<ul><li>有实验表明，当使用超过包含 9 — 13 个像素的模板来消除图像中的噪声时，计算量的增加比消噪效果的改善更为明显，所以常可使用稀疏的模板来减少运算量<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/一些用于中值滤波的模板.png" alt></li></ul></li><li>中值滤波的效果还与所用模板的形状或模板中参与计算的像素所构成的图案的形状有关<ul><li>方形：对图像细节不敏感，会滤除细线并消除边缘上的角点，也常在常数灰度区域产生条纹</li><li>十字交叉：能保留较细的水平线和垂直线，但有可能将对角线滤除</li><li>X 形：仅保留对角线</li></ul></li></ul></li><li>2-D 中值计算<ul><li>为提高计算速度，常试图顺序使用两个 1-D 中值滤波模板以实现类似于 2-D 中值滤波模板的效果，但他们并不严格相等</li><li>3 种方法<ol><li>直接使用 2-D 模板</li><li>先使用第 1 个 1-D 模板，再使用第 2 个 1-D 模板</li><li>先使用第 2 个 1-D 模板，再使用第 1 个 1-D 模板</li></ol></li><li>中值计算是非线性的，因而计算结果有可能相同，也有可能不同</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/实现2-D中值滤波的3种方法的结果.png" alt></li><li>不严格分解<ul><li>这并不只是非线性滤波模板的特性，有些线性滤波模板也不能准确分解</li><li>究其原因是在一个 n × n 模板中的独立系数个数是 n²，这比在 n × 1 或 1 × n 分量模板中的独立系数个数要多得多</li></ul></li><li>中值滤波器<ul><li>不可分离，但使用优化算法可使它的运行时间与可分离滤波器基本相同</li><li>不能预测图像边缘是否会变化，也不能确定变化程度，还很难估计噪声消除的效果</li></ul></li></ul></li><li><strong>序统计滤波</strong><ul><li>百分比滤波均基于模板排序来工作，所以是一种序统计滤波</li><li>中值滤波：选取灰度序列中位于 50% 位置的像素作为滤波结果<ul><li>$g_{median}(x,y) = median_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可以消除椒盐噪声</li><li>趋向于在图像中产生具有常数灰度的区域</li></ul></li><li>最大值滤波：选取灰度序列中位于 100% 位置的像素作为滤波结果<ul><li>$g_{max}(x,y) = \max_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可用来检测图像中最亮的点，并可减弱暗（低取值）的椒噪声</li><li>趋向于在图像中产生具有（高）常数灰度的区域</li></ul></li><li>最小值滤波：选取灰度序列中位于 0% 位置的像素作为滤波结果<ul><li>$g_{min}(x,y) = \min_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可用来检测图像中最暗的点，并可减弱亮（高取值）的盐噪声</li><li>趋向于在图像中产生具有（低）常数灰度的区域</li></ul></li><li>中点滤波：取最大值和最小值中点的那个值作为滤波的输出<ul><li>$g_{mid}(x,y) = {1 \over 2}\{ g_{max}(x,y) + g_{min}(x,y) \}$</li><li>结合了排序滤波和平均滤波两种方式的优点</li><li>对多种随机分布的噪声（如高斯噪声、均匀噪声）都比较有效</li></ul></li></ul></li><li><strong>最频值滤波</strong><ul><li>最频值：代表一个分布中最有可能出现的值</li><li>最频值滤波：用最频值作为滤波的输出<ul><li>可以消除噪声（尤其是脉冲噪声）</li><li>可以锐化目标边缘<ul><li>在接近边缘的邻域中，最频值滤波会将最频值移动到更靠近边缘中心的位置，从而使边缘更加尖锐</li><li>这与会模糊边缘的平均滤波不同</li></ul></li></ul></li><li>一个区域灰度分布的均值、中值、最频值都与直方图密切相关<ul><li>均值：直方图均值</li><li>中值：直方图中值</li><li>最频值：统计值最大的灰度值</li><li>直方图对称且仅有一个峰 → 均值、中值、最频值都为该峰</li><li>直方图仅有一个峰但左右不对称 → 最频值对应该峰，中值比均值更接近最频值</li></ul></li></ul></li></ul><h3 id="非线性锐化滤波"><a href="#非线性锐化滤波" class="headerlink" title="非线性锐化滤波"></a>非线性锐化滤波</h3><ul><li><strong>基于梯度的锐化滤波</strong><ul><li>利用微分可以锐化图像（积分平滑图像），最常用的微分方法是利用梯度</li><li>一个连续函数 f(x,y) 的梯度是一个矢量 $\nabla f = \begin{bmatrix} {\partial f \over \partial x} &amp; {\partial f \over \partial y}\\ \end{bmatrix}^T = \begin{bmatrix} G_{x} &amp; G_{y} \end{bmatrix}^T$</li><li>在离散空间，微分用差分实现，下面是两个常用的差分卷积模板，分别计算沿 X 和 Y 方向的差分<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/两个差分模板.png" alt></li><li>实际锐化滤波中常只使用梯度矢量的幅度（模）</li><li>非线性组合模板的输出值（矢量转化为标量）<ul><li>以 2 为范数计算（对应欧氏距离）：$\vert \nabla f_{(2)} \vert = mag(\nabla f) = [ G_{x}^2 + G_{y}^2 ] ^ {1/2}$</li><li>以 1 为范数计算（对应城区距离）：$\vert \nabla f_{(1)} \vert = \vert G_{x} \vert + \vert G_{y} \vert$</li><li>以 ∞ 为范数计算（对应棋盘距离）：$\vert \nabla f_{(∞)} \vert = max\{ {\vert G_{x} \vert}, {\vert G_{y} \vert} \}$</li></ul></li></ul></li><li><strong>最大-最小锐化变换</strong><ul><li>一种将最大值滤波和最小值滤波结合使用的图像增强技术，可以锐化模糊的边缘并让模糊的目标清晰起来</li><li>这种方法可迭代进行，在每次迭代中将一个模板覆盖区域里的中心像素值与该区域里的最大值和最小值进行比较，然后将中心像素值用与其较接近的极值（最大值或最小值）替换</li><li>最大-最小锐化变换 $S[f(x,y)] = \begin{cases}<br>g_{max}(x,y) &amp; {如果 g_{max}(x,y) - f(x,y) \leq f(x,y) - g_{min}(x,y)} \\<br>g_{min}(x,y) &amp; {其它} \\<br>\end{cases}$</li><li>迭代进行 $S^{n+1}[f(x,y)] = S \{ S^n[f(x,y)] \}$</li></ul></li><li>锐化滤波模板的通用性质<ol><li>零位移：通过检测和加强图像中对应边缘的部分来增强图像的视觉效果，但不应该改变图像中边缘的位置，一阶微分滤波模板应是反对称的</li><li>消除均值：任意阶的微分滤波模板都不应该对常数值有响应，也即所有系数和为 0</li><li>对称性质：零位移暗示一阶微分算子一般有奇数个反对称的系数，则沿一个方向的卷积计算可简化，对 2r+1 个系数只需要 r 次乘法，2r-1 次加法</li></ol></li></ul><h3 id="线性和非线性混合滤波"><a href="#线性和非线性混合滤波" class="headerlink" title="线性和非线性混合滤波"></a>线性和非线性混合滤波</h3><ul><li>将线性滤波运算和中值滤波运算混合串联起来，先对较大的区域进行计算量较小的线性滤波操作，然后再计算线性滤波输出的中值，作为混合滤波的最终输出<ul><li>1-D 信号 f(i)</li><li>$g(i) = MED[H_{1}(f(i)), H_{2}(f(i)), \cdots, H_{M}(f(i))]$</li><li>2-D 图像 f(x,y)</li><li>$g(x,y) = MED \{ {1 \over 2}[f(x,y-2) + f(x,y-1)], {1 \over 2}[f(x,y+1) + f(x,y+2)], \\<br>f(x,y), {1 \over 2}[f(x+2,y) + f(x+1,y)], {1 \over 2}[f(x-1,y) + f(x-2,y)]\}$</li></ul></li></ul><h2 id="局部增强"><a href="#局部增强" class="headerlink" title="局部增强"></a>局部增强</h2><ul><li>全局增强：把一幅图像作为一个整体</li><li>局部增强：对图像某些局部区域的细节进行增强</li><li>用全局增强不能保证在所关心区域的局部区域得到所需要的增强效果</li><li>局部增强多了一个选择确定局部区域的步骤，直接利用局部信息以达到局部增强的目的</li><li><strong>直方图变换局部增强</strong><ul><li>直方图变换是空域增强中最常采用的方法，也很容易用于图像的局部增强</li><li>先将图像分成一系列小区域（子图像），对各小区域进行直方图变换，从而使各个小区域得到不同的增强效果</li><li>由于增强是对局部区域分别进行的，增强效果在小区域的边界上有可能不协调，所以实际中常将图像划分为有些互相重叠的小区域以减小这种影响</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.htm/局部增强效果示例.png" alt></li><li>点操作中的直方图变换虽然可以使动态范围增加，但增强图像中的灰度级数并不会较原始图像变得更多，只是灰度级数间的距离增加</li><li>直方图变换局部增强在增加动态范围的同时也可以增加全图中的灰度级数，避免了像素间的生硬过渡，视觉效果较柔和</li></ul></li><li><strong>基于均值和方差的局部增强</strong><ul><li>局部增强也可在对图像增强时直接利用局部信息以实现对不同的局部或不同的像素进行不同的增强</li><li>常用的局部信息主要是每个像素的邻域内所有像素的灰度均值和灰度方差<ul><li>灰度均值：平均亮度的测度</li><li>灰度方差：亮度反差（对比度）的测度</li></ul></li><li>利用灰度均值和灰度方差来选择需要增强的像素<ul><li>例如需要增强图像中灰度比较大但方差比较小的区域</li><li>$g(x,y) = \begin{cases}<br>Ef(x,y) &amp; {M \leq km(x,y) 且 \sigma(x,y) \leq lS} \\<br>f(x,y) &amp; {其它} \\<br>\end{cases}$</li><li>$m(x,y), \sigma(x,y)$ 分别是以像素 $(x,y)$ 为中心的邻域像素的灰度均值和均方差值</li><li>$M, S$ 是 $f(x,y)$ 的灰度均值和均方差值</li><li>$k, l$ 是比例常数（可都取 &lt; 0.5）</li><li>$E$ 是增强系数（&gt; 2）</li></ul></li><li>利用每个像素的邻域内所有像素的均值和方差这两个特性进行<ul><li>如要把输入图 f(x,y) 根据各个像素的邻域特性增强成输出图 g(x,y)，需要在每个像素位置 (x,y) 进行如下变换</li><li>$g(x,y) = A(x,y)[f(x,y) - m(x,y)] + m(x,y)$</li><li>其中 $A(x,y) = k {M \over \sigma(x,y)} \; 0 &lt; k &lt; 1$ 称为局部增益函数</li><li>A 与 f - m 相乘能放大图像的局部变化。由于 A(x,y) 反比于均方差，所以在图像对比度较小的区域得到较大的增益，局部对比度增强。最后加上 m 是为了恢复平均灰度值</li></ul></li></ul></li></ul></div><div><div id="reward-container"><div>喜欢就支持小方方一下吧~</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Fengxin Fang 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Fengxin Fang 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/图像处理/" rel="tag"><i class="fa fa-tag"></i> 图像处理</a><a href="/tags/图像增强/" rel="tag"><i class="fa fa-tag"></i> 图像增强</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/07/16/introduction-by-book-image-processing.html" rel="next" title="《图像处理》绪论"><i class="fa fa-chevron-left"></i> 《图像处理》绪论</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/07/31/ubuntu-question.html" rel="prev" title="Ubuntu问题汇总">Ubuntu问题汇总<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Fengxin Fang"><p class="site-author-name" itemprop="name">Fengxin Fang</p><div class="site-description motion-element" itemprop="description">小方方跨到计算机，要开始学习各种计算机知识啦，加油嗷~</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">91</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/fangfengxin" title="GitHub &rarr; https://github.com/fangfengxin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:fangfengxin98@163.com" title="E-Mail &rarr; mailto:fangfengxin98@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#图像增强"><span class="nav-number">1.</span> <span class="nav-text">图像增强</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#空域增强：点操作"><span class="nav-number">2.</span> <span class="nav-text">空域增强：点操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图像坐标变换"><span class="nav-number">2.1.</span> <span class="nav-text">图像坐标变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本坐标变换"><span class="nav-number">2.1.1.</span> <span class="nav-text">基本坐标变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#坐标变换扩展"><span class="nav-number">2.1.2.</span> <span class="nav-text">坐标变换扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图像间运算"><span class="nav-number">2.2.</span> <span class="nav-text">图像间运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算术和逻辑运算"><span class="nav-number">2.2.1.</span> <span class="nav-text">算术和逻辑运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图像间算术运算的应用"><span class="nav-number">2.2.2.</span> <span class="nav-text">图像间算术运算的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图像灰度映射"><span class="nav-number">2.3.</span> <span class="nav-text">图像灰度映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#灰度映射原理"><span class="nav-number">2.3.1.</span> <span class="nav-text">灰度映射原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型灰度映射"><span class="nav-number">2.3.2.</span> <span class="nav-text">典型灰度映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直方图变换"><span class="nav-number">2.4.</span> <span class="nav-text">直方图变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#直方图均衡化"><span class="nav-number">2.4.1.</span> <span class="nav-text">直方图均衡化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直方图规定化"><span class="nav-number">2.4.2.</span> <span class="nav-text">直方图规定化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#空域增强：模板操作"><span class="nav-number">3.</span> <span class="nav-text">空域增强：模板操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#像素间联系"><span class="nav-number">3.1.</span> <span class="nav-text">像素间联系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#像素的邻域和邻接"><span class="nav-number">3.1.1.</span> <span class="nav-text">像素的邻域和邻接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#像素间的连接和连通"><span class="nav-number">3.1.2.</span> <span class="nav-text">像素间的连接和连通</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#像素集合的邻接、连接和连通"><span class="nav-number">3.1.3.</span> <span class="nav-text">像素集合的邻接、连接和连通</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#像素间的距离"><span class="nav-number">3.1.4.</span> <span class="nav-text">像素间的距离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板运算"><span class="nav-number">3.2.</span> <span class="nav-text">模板运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模板卷积"><span class="nav-number">3.2.1.</span> <span class="nav-text">模板卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板排序"><span class="nav-number">3.2.2.</span> <span class="nav-text">模板排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图像边界处的模板运算"><span class="nav-number">3.2.3.</span> <span class="nav-text">图像边界处的模板运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空域滤波分类"><span class="nav-number">3.2.4.</span> <span class="nav-text">空域滤波分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性滤波"><span class="nav-number">3.3.</span> <span class="nav-text">线性滤波</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线性平滑滤波"><span class="nav-number">3.3.1.</span> <span class="nav-text">线性平滑滤波</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性锐化滤波"><span class="nav-number">3.3.2.</span> <span class="nav-text">线性锐化滤波</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非线性滤波"><span class="nav-number">3.4.</span> <span class="nav-text">非线性滤波</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非线性平滑滤波"><span class="nav-number">3.4.1.</span> <span class="nav-text">非线性平滑滤波</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非线性锐化滤波"><span class="nav-number">3.4.2.</span> <span class="nav-text">非线性锐化滤波</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性和非线性混合滤波"><span class="nav-number">3.4.3.</span> <span class="nav-text">线性和非线性混合滤波</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部增强"><span class="nav-number">3.5.</span> <span class="nav-text">局部增强</span></a></li></ol></li></ol></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span><span class="with-love" id="animate"><i class="fa fa-snowflake-o"></i></span> <span class="author" itemprop="copyrightHolder">Fengxin Fang</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">138k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">2:05</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,0" opacity="1" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.2.0"></script><script src="/js/motion.js?v=7.2.0"></script><script src="/js/affix.js?v=7.2.0"></script><script src="/js/schemes/pisces.js?v=7.2.0"></script><script src="/js/scrollspy.js?v=7.2.0"></script><script src="/js/post-details.js?v=7.2.0"></script><script src="/js/next-boot.js?v=7.2.0"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return-1<GUEST.indexOf(e)}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"7kWTdJsaz4FTWvD11vJ68LrU-gzGzoHsz",appKey:"IagQj5azVtsiUPyjWRrvasm6",placeholder:"要不要说点啥……",avatar:"mm",meta:guest,pageSize:"10",visitor:!1,lang:"zh-cn"})</script><script>// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>