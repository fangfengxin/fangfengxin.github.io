<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络基础知识总结</title>
      <link href="/2020/07/28/computer-network-fundmental.html"/>
      <url>/2020/07/28/computer-network-fundmental.html</url>
      
        <content type="html"><![CDATA[<h1 id="OSI-与-TCP-IP-各层的结构和功能"><a href="#OSI-与-TCP-IP-各层的结构和功能" class="headerlink" title="OSI 与 TCP/IP 各层的结构和功能"></a>OSI 与 TCP/IP 各层的结构和功能</h1><p><img src="/2020/07/28/computer-network-fundmental/五层体系结构.png" alt></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><strong>应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</strong></li><li>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 <strong>DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等。<ul><li><strong>DNS（域名系统，Domain Name System）：</strong>是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。</li><li><strong>HTTP 协议（超文本传输协议，HyperText Transfer Protocol）：</strong>是互联网上应用最为广泛的一种网络协议，所有的 WWW（万维网）文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</li></ul></li><li>我们把应用层交互的数据单元称为报文。</li></ul><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><ul><li><strong>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</strong></li><li>“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</li><li>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</li><li><strong>运输层主要使用以下两种协议：</strong><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol），提供<strong>面向连接</strong>的，<strong>可靠</strong>的数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol），提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol></li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li><strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong></li><li>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称<strong>数据报</strong>。</li><li>互联网是由大量的异构网络通过路由器相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li><strong>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong></li><li>在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</li><li>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>在物理层上所传送的数据单位是比特。 <strong>物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>，使其上面的数据链路层不必考虑网络的具体传输介质是什么。</li><li>“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2020/07/28/computer-network-fundmental/七层体系结构图.png" alt></p><h1 id="TCP-的三次握手和四次挥手"><a href="#TCP-的三次握手和四次挥手" class="headerlink" title="TCP 的三次握手和四次挥手"></a>TCP 的三次握手和四次挥手</h1><h2 id="TCP-三次握手详解"><a href="#TCP-三次握手详解" class="headerlink" title="TCP 三次握手详解"></a>TCP 三次握手详解</h2><ul><li><strong>什么是三次握手？</strong><ul><li>第一次握手：客户端发送带有 SYN 标志的数据包给服务端；</li><li>第二次握手：服务端发送带有 SYN/ACK 标志的数据包给客户端；</li><li>第三次握手：客户端–发送带有带有 ACK 标志的数据包给服务端。</li></ul></li></ul><p><img src="/2020/07/28/computer-network-fundmental/三次握手.png" alt></p><ul><li><strong>为什么要使用三次握手？</strong><ul><li>三次握手的目的是建立可靠的通信信道。说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</li><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常；</li><li>第二次握手：Client 确认了自己发送、接收正常，对方发送、接收正常；Server 确认了对方发送正常，自己接收正常；</li><li>第三次握手：Client 确认了自己发送、接收正常，对方发送、接收正常；Server 确认了自己发送、接收正常，对方发送、接收正常；</li><li>所以三次握手就能确认双发收发功能都正常，缺一不可。</li></ul></li><li><strong>为什么要传回 SYN？</strong><ul><li>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</li></ul></li><li><strong>为什么传了 SYN 还要传 ACK？</strong><ul><li>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</li></ul></li></ul><blockquote><p>SYN 是 TCP/IP 建立连接时使用的同步信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h2 id="TCP-四次挥手详解"><a href="#TCP-四次挥手详解" class="headerlink" title="TCP 四次挥手详解"></a>TCP 四次挥手详解</h2><ul><li><strong>断开一个 TCP 连接则需要“四次挥手”：</strong><ul><li>客户端发送一个 FIN，用来关闭客户端到服务器的数据传送。</li><li>服务器收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号。</li><li>服务器关闭与客户端的连接，发送一个 FIN 给客户端。</li><li>客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1。</li></ul></li></ul><p><img src="/2020/07/28/computer-network-fundmental/TCP四次挥手.png" alt></p><ul><li><strong>为什么是三次握手四次挥手？</strong><ul><li>建立连接的时候， 服务器收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li><li>而<strong>关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接。</strong></li><li>因此，服务器的 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li></ul></li><li>详细可参考文章 <a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">两张动图-彻底明白TCP的三次握手与四次挥手</a> 。</li></ul><h1 id="TCP-与-UDP-协议的区别"><a href="#TCP-与-UDP-协议的区别" class="headerlink" title="TCP 与 UDP 协议的区别"></a>TCP 与 UDP 协议的区别</h1><p><img src="/2020/07/28/computer-network-fundmental/tcp-vs-udp.jpg" alt></p><ul><li>UDP 在传送数据之前不需要先建立连接，远程主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如语音、视频、直播等。</li><li>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</li></ul><h1 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h1><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议：</strong> 每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h1 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h1><ul><li><strong>自动重传请求</strong>（Automatic Repeat reQuest，ARQ）:<ul><li>是 OSI 模型中数据链路层和传输层的错误纠正协议之一。</li><li>它通过使用<strong>确认</strong>和<strong>超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</li><li>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</li></ul></li></ul><h2 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a>停止等待 ARQ 协议</h2><ul><li><strong>什么是停止等待 ARQ 协议？</strong><ul><li>停止等待协议是为了实现可靠传输的。</li><li>基本原理是<strong>每发完一个分组就停止发送，等待对方确认</strong>（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</li><li>在停止等待协议中，<strong>若接收方收到重复分组，就丢弃该分组，但同时还要发送确认</strong>。</li></ul></li><li>停止等待 ARQ 协议的优缺点：<ul><li>优点：简单</li><li>缺点：信道利用率低，等待时间长</li></ul></li><li><strong>停止等待 ARQ 协议的处理机制：</strong><ol><li><strong>无差错情况：</strong><ul><li>发送方发送分组，接收方在规定时间内收到并回复确认，发送方继续发送。</li></ul></li><li><strong>超时重传：</strong><ul><li>超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。</li><li>因此每发送完一个分组需要设置一个超时计时器，其重传时间应比分组传输的平均往返时间更长一些。这种自动重传方式常称为<strong>自动重传请求 ARQ</strong>。</li><li>另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</li></ul></li><li><strong>确认丢失和确认迟到：</strong><ul><li><strong>确认丢失：</strong><ul><li>确认消息在传输过程丢失。</li><li>当 A 发送 M 消息，B 收到后，B 向 A 发送了一个 M 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M 消息。</li><li>B 再次收到该消息后采取以下两点措施：<ol><li>丢弃这个重复的 M 消息，不向上层交付。</li><li>向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li></ol></li></ul></li><li><strong>确认迟到：</strong><ul><li>确认消息在传输过程中迟到。</li><li>A 发送 M 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M）。</li><li>此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M 的确认消息（A 也收到了 2 份确认消息）。</li><li>处理如下：<ol><li>A 收到重复的确认后，直接丢弃。</li><li>B 收到重复的 M 后，也直接丢弃重复的 M。</li></ol></li></ul></li></ul></li></ol></li></ul><h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><ul><li>连续 ARQ 协议可提高信道利用率，通常结合滑动窗口协议来使用。</li><li><strong>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。</strong></li><li><strong>接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</strong></li><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如发送方发送了 5 条消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 <strong>Go-Back-N（回退 N 步）</strong>，表示需要退回来重传已经发送过的 N 个消息。</li></ul><h1 id="TCP-的滑动窗口和流量控制"><a href="#TCP-的滑动窗口和流量控制" class="headerlink" title="TCP 的滑动窗口和流量控制"></a>TCP 的滑动窗口和流量控制</h1><ul><li><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></li><li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</li></ul><h1 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h1><ul><li><strong>什么是拥塞和拥塞控制？</strong><ul><li>在某段时间，若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏。这种情况就叫拥塞。</li><li>拥塞控制就是为了<strong>防止过多的数据注入到网络中</strong>，这样就可以使网络中的路由器或链路不致过载。</li></ul></li><li>拥塞控制与流量控制的区别：<ul><li>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li>相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li></ul></li><li><strong>如何进行拥塞控制？</strong><ul><li>TCP 发送方要维持一个<strong>拥塞窗口（cwnd）</strong>状态变量：<ul><li>拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。</li><li>发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</li></ul></li><li>TCP 发送方维护一个<strong>慢启动门限（ssthresh）</strong>状态变量：<ul><li>当 cwnd &lt; ssthresh 时，使用慢启动算法；</li><li>当 cwnd &gt;= ssthresh 时，使用拥塞避免算法。</li></ul></li></ul></li><li><strong>TCP 采用的 4 种拥塞控制算法：</strong><ol><li><strong>慢启动：</strong><ul><li>当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为还不知道网络的综合情况。</li><li>较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。</li><li>慢启动阶段，<strong>cwnd 初始值为 1，每收到一个 ACK，cwnd 加 1，每经过一个往返时间（RTT），cwnd 加倍。（指数增长）</strong></li><li>当拥塞空口 cwnd 到达慢启动门限 ssthresh 后，使用拥塞避免算法。</li></ul></li><li><strong>拥塞避免：</strong><ul><li><strong>拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。（线性增长）</strong></li><li>一旦发生超时重传，就判断网络出现拥塞，将 ssthresh 更新为当前 cwnd 的一半，并将 cwnd 恢复到 1，重新开始慢启动算法。</li></ul></li><li><strong>快速重传：</strong><ul><li>快速重传是指，<strong>使发送方尽快进行重传，而不是等超时计时器超时再重传。</strong></li><li>要求接收方收到报文段就进行确认，收到失序报文段时对已收到的连续报文段进行<strong>重复确认</strong>。</li><li><strong>发送方收到 3 个连续的重复 ACK，就将相应的报文段立即重传</strong>，不需要等到该报文段的超时计时器超时再重传。</li><li>这样，对个别丢失的报文段，发送方不会超时重传，也不会认为网络发生了拥塞。</li></ul></li><li><strong>快速恢复：</strong><ul><li>快速恢复是指在收到三个重复的 ACK 后，发送方<strong>将慢启动门限 ssthresh 和拥塞窗口 cwnd 调整为当前窗口的一半，继续执行拥塞避免算法。</strong></li></ul></li></ol></li></ul><h1 id="浏览器访问网页的过程中发生了什么？"><a href="#浏览器访问网页的过程中发生了什么？" class="headerlink" title="浏览器访问网页的过程中发生了什么？"></a>浏览器访问网页的过程中发生了什么？</h1><ol><li><strong>URL 解析</strong><ul><li>如果是非 URL 结构字符串，使用默认搜索引擎搜索该字符串；</li><li>如果是 URL 结构字符串，则会构建完整的 URL 结构，浏览器进程将完整的 URL 通过进程间通信发送给网络进程。</li></ul></li><li><strong>DNS 域名解析</strong><ul><li>网络进程接收到 URL 后，进行 DNS 解析域名得到对应的 IP 地址，然后通过 ARP 解析 IP 得到对应的 MAC 地址。</li><li>DNS 域名解析为以下几个步骤：<ul><li>查询浏览器缓存</li><li>查询本地操作系统缓存（即本地 hosts 文件）</li><li>查询路由器缓存</li><li>查询网络服务提供商（ISP）DNS 服务器</li><li>查询根域名服务器（gTLD）递归解析</li></ul></li></ul></li><li><strong>与服务器建立 TCP 连接</strong></li><li><strong>发送 HTTP 请求</strong></li><li><strong>服务器处理请求并返回 HTTP 报文</strong><ul><li>如果 Web 缓存存在，先检查 Web 缓存中是否储存了被请求对象的副本。</li><li>如果有，Web 缓存向服务器发送一个条件 GET 请求执行最新检查，请求首部包含 If-Modified-Since（值为缓存的对象中的 Last-Modified 值），服务器作出响应。</li><li>如果对象未修改，响应报文状态码为 304（Not Modified），不包含被请求对象。Web 缓存直接向浏览器转发缓存的对象副本作为 HTTP 响应。</li><li>如果对象被修改过，服务器向 Web 缓存发送具有被请求对象的响应报文，Web 缓存在将对象转发到浏览器的同时，在本地缓存该对象，并储存该对象的 Last-Modified 值。</li></ul></li><li><strong>断开 TCP 连接</strong></li><li><strong>浏览器解析渲染页面</strong></li></ol><h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><ul><li>当访问一个网页时，浏览器会向网页所在服务器发出请求。在浏览器接收并显示网页之前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头用以响应浏览器的请求。</li><li>下面是常见的 HTTP 状态码：<ul><li>200：请求成功</li><li>301：资源（网页等）被永久转移到其它 URL</li><li>404：请求的资源（网页等）不存在</li><li>500：内部服务器错误</li></ul></li><li><strong>HTTP 状态码分类：</strong><ul><li><code>1**</code>：信息，服务器收到请求，需要请求者继续执行操作</li><li><code>2**</code>：成功，操作被成功接收并处理</li><li><code>3**</code>：重定向，需要进一步的操作以完成请求</li><li><code>4**</code>：客户端错误，请求包含语法错误或无法完成请求</li><li><code>5**</code>：服务器错误，服务器在处理请求的过程中发生了错误</li></ul></li><li>HTTP 状态码列表：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">英文名称</th><th style="text-align:left">中文描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>100</strong></td><td style="text-align:left"><strong>Continue</strong></td><td style="text-align:left">继续。客户端应继续其请求</td></tr><tr><td style="text-align:left">101</td><td style="text-align:left">Switching Protocols</td><td style="text-align:left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td style="text-align:left"><strong>200</strong></td><td style="text-align:left"><strong>OK</strong></td><td style="text-align:left">请求成功。一般用于 GET 与 POST 请求</td></tr><tr><td style="text-align:left">201</td><td style="text-align:left">Created</td><td style="text-align:left">已创建。成功请求并创建了新的资源</td></tr><tr><td style="text-align:left">202</td><td style="text-align:left">Accepted</td><td style="text-align:left">已接受。已经接受请求，但未处理完成</td></tr><tr><td style="text-align:left">203</td><td style="text-align:left">Non-Authoritative Information</td><td style="text-align:left">未授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本</td></tr><tr><td style="text-align:left"><strong>204</strong></td><td style="text-align:left"><strong>No Content</strong></td><td style="text-align:left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td style="text-align:left">205</td><td style="text-align:left">Reset Content</td><td style="text-align:left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td style="text-align:left"><strong>206</strong></td><td style="text-align:left"><strong>Partial Content</strong></td><td style="text-align:left">部分内容。服务器成功处理了部分 GET 请求</td></tr><tr><td style="text-align:left">300</td><td style="text-align:left">Multiple Choices</td><td style="text-align:left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td style="text-align:left"><strong>301</strong></td><td style="text-align:left"><strong>Moved Permanently</strong></td><td style="text-align:left">永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替</td></tr><tr><td style="text-align:left"><strong>302</strong></td><td style="text-align:left"><strong>Found</strong></td><td style="text-align:left">临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI</td></tr><tr><td style="text-align:left"><strong>303</strong></td><td style="text-align:left"><strong>See Other</strong></td><td style="text-align:left">查看其它地址。与 301 类似。使用 GET 和 POST 请求查看</td></tr><tr><td style="text-align:left"><strong>304</strong></td><td style="text-align:left"><strong>Not Modified</strong></td><td style="text-align:left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td style="text-align:left">305</td><td style="text-align:left">Use Proxy</td><td style="text-align:left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td style="text-align:left">306</td><td style="text-align:left">Unused</td><td style="text-align:left">未使用。已经被废弃的 HTTP 状态码</td></tr><tr><td style="text-align:left"><strong>307</strong></td><td style="text-align:left"><strong>Temporary Redirect</strong></td><td style="text-align:left">临时重定向。与 302 类似。使用 GET 请求重定向</td></tr><tr><td style="text-align:left">308</td><td style="text-align:left">Permanent Redirect</td><td style="text-align:left">永久重定向。</td></tr><tr><td style="text-align:left"><strong>400</strong></td><td style="text-align:left"><strong>Bad Request</strong></td><td style="text-align:left">错误请求。客户端请求的语法错误，服务器无法理解</td></tr><tr><td style="text-align:left"><strong>401</strong></td><td style="text-align:left"><strong>Unauthorized</strong></td><td style="text-align:left">未授权。请求要求用户的身份认证</td></tr><tr><td style="text-align:left">402</td><td style="text-align:left">Payment Required</td><td style="text-align:left">保留，将来使用</td></tr><tr><td style="text-align:left"><strong>403</strong></td><td style="text-align:left"><strong>Forbidden</strong></td><td style="text-align:left">禁止访问。服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td style="text-align:left"><strong>404</strong></td><td style="text-align:left"><strong>Not Found</strong></td><td style="text-align:left">未找到。服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td style="text-align:left">405</td><td style="text-align:left">Method Not Allowed</td><td style="text-align:left">方法不允许使用。客户端请求中的方法被禁止</td></tr><tr><td style="text-align:left">406</td><td style="text-align:left">Not Acceptable</td><td style="text-align:left">无法接受。服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td style="text-align:left">407</td><td style="text-align:left">Proxy Authentication Required</td><td style="text-align:left">要求代理身份认证。请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权</td></tr><tr><td style="text-align:left">408</td><td style="text-align:left">Request Time-out</td><td style="text-align:left">请求超时。服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td style="text-align:left">409</td><td style="text-align:left">Conflict</td><td style="text-align:left">冲突。服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td style="text-align:left">410</td><td style="text-align:left">Gone</td><td style="text-align:left">已失效。客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置</td></tr><tr><td style="text-align:left">411</td><td style="text-align:left">Length Required</td><td style="text-align:left">需要内容长度头。服务器无法处理客户端发送的不带 Content-Length 的请求信息</td></tr><tr><td style="text-align:left">412</td><td style="text-align:left">Precondition Failed</td><td style="text-align:left">预处理失败。客户端请求信息的先决条件错误</td></tr><tr><td style="text-align:left">413</td><td style="text-align:left">Request Entity Too Large</td><td style="text-align:left">请求实体过长。由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息</td></tr><tr><td style="text-align:left">414</td><td style="text-align:left">Request-URI Too Large</td><td style="text-align:left">请求 URI 过长。请求的 URI 过长（URI 通常为网址），服务器无法处理</td></tr><tr><td style="text-align:left">415</td><td style="text-align:left">Unsupported Media Type</td><td style="text-align:left">媒体类型不支持。服务器无法处理请求附带的媒体格式</td></tr><tr><td style="text-align:left">416</td><td style="text-align:left">Requested range not satisfiable</td><td style="text-align:left">请求范围不合要求。客户端请求的范围无效</td></tr><tr><td style="text-align:left">417</td><td style="text-align:left">Expectation Failed</td><td style="text-align:left">预期结果失败。服务器无法满足 Expect 的请求头信息</td></tr><tr><td style="text-align:left"><strong>500</strong></td><td style="text-align:left"><strong>Internal Server Error</strong></td><td style="text-align:left">内部服务器错误。服务器内部错误，无法完成请求</td></tr><tr><td style="text-align:left">501</td><td style="text-align:left">Not Implemented</td><td style="text-align:left">未实现。服务器不支持请求的功能，无法完成请求</td></tr><tr><td style="text-align:left">502</td><td style="text-align:left">Bad Gateway</td><td style="text-align:left">网关错误。作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td style="text-align:left"><strong>503</strong></td><td style="text-align:left"><strong>Service Unavailable</strong></td><td style="text-align:left">服务不可用。由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</td></tr><tr><td style="text-align:left">504</td><td style="text-align:left">Gateway Time-out</td><td style="text-align:left">网关超时。充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td style="text-align:left">505</td><td style="text-align:left">HTTP Version not supported</td><td style="text-align:left">HTTP 版本不受支持。服务器不支持请求的 HTTP 协议的版本，无法完成处理</td></tr></tbody></table></div><h1 id="TCP-IP-协议与-HTTP-协议的关系"><a href="#TCP-IP-协议与-HTTP-协议的关系" class="headerlink" title="TCP/IP 协议与 HTTP 协议的关系"></a>TCP/IP 协议与 HTTP 协议的关系</h1><ul><li>HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议。</li><li>IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP 协议是可靠的、面向连接的。</li></ul><p><img src="/2020/07/28/computer-network-fundmental/各种协议与HTTP协议之间的关系.png" alt></p><h1 id="HTTP-长连接与短连接"><a href="#HTTP-长连接与短连接" class="headerlink" title="HTTP 长连接与短连接"></a>HTTP 长连接与短连接</h1><ul><li>在 HTTP/1.0 中默认使用<strong>短连接</strong>。<ul><li>客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。</li><li>当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</li></ul></li><li>而从 HTTP/1.1 起，默认使用<strong>长连接</strong>，用以保持连接特性。<ul><li>使用长连接的 HTTP 协议会在响应头加入 <strong><code>Connection: keep-alive</code></strong>。</li><li>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</li><li>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</li><li>实现长连接需要客户端和服务端都支持长连接。</li></ul></li><li><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></li><li>长连接和短连接的比较：<ul><li><strong>短连接</strong>对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户<strong>请求频繁</strong>，将在 <strong>TCP 的建立和关闭操作上浪费时间和带宽</strong>。</li><li><strong>长连接</strong>可以<strong>省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。不过这里<strong>存在一个问题</strong>，<strong>存活功能的探测周期太长</strong>，还有就是它只是探测 TCP 连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，<strong>Client 与 Server 之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，Server 会保持过多连接</strong>，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。</li></ul></li></ul><h1 id="无状态的-HTTP-协议如何保存用户状态？"><a href="#无状态的-HTTP-协议如何保存用户状态？" class="headerlink" title="无状态的 HTTP 协议如何保存用户状态？"></a>无状态的 HTTP 协议如何保存用户状态？</h1><ul><li>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？</li><li><strong>Session 机制</strong>的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</li><li>在服务端保存 Session 的方法很多，最常用的就是内存和数据库（比如是使用内存数据库 Redis 保存）。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</li><li><strong>Cookie 被禁用怎么办?</strong>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</li></ul><h1 id="Cookie-的作用是什么？和-Session-有什么区别？"><a href="#Cookie-的作用是什么？和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么？和 Session 有什么区别？"></a>Cookie 的作用是什么？和 Session 有什么区别？</h1><ul><li>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</li><li><strong>Cookie 一般用来保存用户信息。</strong><ol><li>在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动把登录的一些基本信息给填了；</li><li>一般的网站都会有保持登录也就是说下次再访问网站的时候就不需要重新登录了，这是因为用户登录的时候存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可（为了安全考虑，重新登录一般要将 Token 重写）；</li><li>登录一次网站后访问网站其他页面不需要重新登录。</li></ol></li><li><strong>Session 的主要作用就是通过服务端记录用户的状态。</strong><ul><li>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li></ul></li><li><strong>Cookie 存储在客户端中，而 Session 存储在服务器上</strong>，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</li></ul><h1 id="HTTP-1-0-和-HTTP-1-1-的区别"><a href="#HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 的区别"></a>HTTP 1.0 和 HTTP 1.1 的区别</h1><ul><li>HTTP 1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP 1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP 1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：<ol><li><strong>长连接与短连接</strong>：<strong>在 HTTP/1.0 中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的，每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1 起，默认使用长连接</strong>，默认开启 <code>Connection: keep-alive</code>。<strong>HTTP/1.1 的持续连接有非流水线方式和流水线方式</strong>。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码</strong>：在 HTTP 1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong>：在 HTTP 1.0 中主要使用 header 里的 If-Modified-Since 和 Expires来做为缓存判断的标准，HTTP 1.1 则引入了更多的缓存控制策略例如 Entity tag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>：HTTP 1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP 1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol></li></ul><h1 id="URI-和-URL-的区别"><a href="#URI-和-URL-的区别" class="headerlink" title="URI 和 URL 的区别"></a>URI 和 URL 的区别</h1><ul><li><strong>URI（Uniform Resource Identifier）是统一资源标志符，可以唯一标识一个资源。</strong></li><li><strong>URL（Uniform Resource Location）是统一资源定位符，可以提供该资源的路径。</strong>它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li><li>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</li></ul><h1 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h1><ol><li><p><strong>端口：</strong></p><ul><li>HTTP 的 URL 由 <code>http://</code> 起始且默认使用端口 <code>80</code>，而 HTTPS 的 URL 由 <code>https://</code> 起始且默认使用端口 <code>443</code>。</li></ul></li><li><p><strong>安全性和资源消耗：</strong></p><ul><li><p><strong>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文</strong>，客户端和服务器端都无法验证对方的身份。<strong>HTTPS是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</strong>所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p></li><li><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等。</p></li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot框架</title>
      <link href="/2020/06/30/spring-boot.html"/>
      <url>/2020/06/30/spring-boot.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-简介"><a href="#Spring-Boot-简介" class="headerlink" title="Spring Boot 简介"></a>Spring Boot 简介</h1><h2 id="原有-Spring-优缺点分析"><a href="#原有-Spring-优缺点分析" class="headerlink" title="原有 Spring 优缺点分析"></a>原有 Spring 优缺点分析</h2><h3 id="Spring-的优点分析"><a href="#Spring-的优点分析" class="headerlink" title="Spring 的优点分析"></a>Spring 的优点分析</h3><ul><li>Spring 是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的轻量级代替品。</li><li>无需开发重量级的 Enterprise JavaBean（EJB），Spring 为企业级 Java 开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的 Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。</li></ul><h3 id="Spring-的缺点分析"><a href="#Spring-的缺点分析" class="headerlink" title="Spring 的缺点分析"></a>Spring 的缺点分析</h3><ul><li>虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring 用 XML 配置，而且是很多 XML 配置。Spring 2.5 引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式 XML 配置。Spring 3.0 引入了基于 Java 的配置，这是一种类型安全的可重构配置方式，可以代替 XML。</li><li><strong>复杂的配置</strong>：项目中的各种配置都代表了开发时的损耗。因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。</li><li><strong>混乱的依赖管理</strong>：项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</li></ul><h2 id="Spring-Boot-的概述"><a href="#Spring-Boot-的概述" class="headerlink" title="Spring Boot 的概述"></a>Spring Boot 的概述</h2><h3 id="Spring-Boot-解决上述-Spring-的缺点"><a href="#Spring-Boot-解决上述-Spring-的缺点" class="headerlink" title="Spring Boot 解决上述 Spring 的缺点"></a>Spring Boot 解决上述 Spring 的缺点</h3><ul><li>Spring Boot 对上述 Spring 的缺点进行的改善和优化，基于<strong>约定优于配置</strong>的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</li></ul><h3 id="Spring-Boot-的特点"><a href="#Spring-Boot-的特点" class="headerlink" title="Spring Boot 的特点"></a>Spring Boot 的特点</h3><ul><li>为基于 Spring 的开发提供更快的入门体验。</li><li>开箱即用，没有代码生成，也无需 XML 配置。同时也可以修改默认值来满足特定的需求。</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。</li><li>Spring Boot 不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。</li></ul><h3 id="Spring-Boot-的核心功能"><a href="#Spring-Boot-的核心功能" class="headerlink" title="Spring Boot 的核心功能"></a>Spring Boot 的核心功能</h3><ul><li><strong>起步依赖：</strong><ul><li>起步依赖本质上是一个 Maven 项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</li><li>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</li></ul></li><li><strong>自动配置：</strong><ul><li>Spring Boot 的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring 配置应该用哪个，不该用哪个。该过程是 Spring 自动完成的。</li></ul></li></ul><h1 id="Spring-Boot-快速入门"><a href="#Spring-Boot-快速入门" class="headerlink" title="Spring Boot 快速入门"></a>Spring Boot 快速入门</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="创建-Maven-工程并添加-Spring-Boot-的起步依赖"><a href="#创建-Maven-工程并添加-Spring-Boot-的起步依赖" class="headerlink" title="创建 Maven 工程并添加 Spring Boot 的起步依赖"></a>创建 Maven 工程并添加 Spring Boot 的起步依赖</h3><ul><li>Spring Boot 要求，项目要继承 Spring Boot 的起步依赖 <code>spring-boot-starter-parent</code>。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 所有的SpringBoot工程都要继承spring-boot-starter-parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Spring Boot 要集成 Spring MVC 进行 Controller 的开发，所以项目要导入 web 的起步依赖。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 起步依赖：每一个起步依赖背后都是一堆的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写-Spring-Boot-引导类"><a href="#编写-Spring-Boot-引导类" class="headerlink" title="编写 Spring Boot 引导类"></a>编写 Spring Boot 引导类</h3><ul><li>要通过 Spring Boot 提供的引导类启动 Spring Boot 才可以进行访问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flexia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明该类是一个SpringBoot引导类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringBootApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// main是Java程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// run方法表示运行SpringBoot的引导类</span></span><br><span class="line">        <span class="comment">// 参数就是SpringBoot引导类的字节码对象</span></span><br><span class="line">        SpringApplication.run(MySpringBootApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-Controller"><a href="#编写-Controller" class="headerlink" title="编写 Controller"></a>编写 Controller</h3><ul><li>在引导类 <code>MySpringBootApplication</code> 同级包或者子级包中创建 <code>QuickStartController</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flexia.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"quick"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello springboot quick start"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>执行 Spring Boot 引导类的主方法，控制台打印日志如下：</li></ul><p><img src="/2020/06/30/spring-boot/springboot启动后的控制台显示.png" alt></p><ul><li>通过日志发现，<code>Tomcat started on port(s): 8080 (http) with context path &#39;&#39;</code>。</li><li>Tomcat 已经起步，端口监听 8080，web 应用的虚拟工程名称为空。</li><li>打开浏览器访问 URL 地址为：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 。</li></ul><p><img src="/2020/06/30/spring-boot/springboot快速启动浏览器访问.png" alt></p><h2 id="快速入门解析"><a href="#快速入门解析" class="headerlink" title="快速入门解析"></a>快速入门解析</h2><h3 id="Spring-Boot-代码解析"><a href="#Spring-Boot-代码解析" class="headerlink" title="Spring Boot 代码解析"></a>Spring Boot 代码解析</h3><ul><li><strong><code>@SpringBootApplication</code>：标注 Spring Boot 的引导类</strong>，该注解具备多种功能！</li><li><strong><code>SpringApplication.run(MySpringBootApplication.class)</code> 代表运行 Spring Boot 的引导类，参数为 Spring Boot 引导类的字节码对象。</strong></li></ul><h3 id="Spring-Boot-工程热部署"><a href="#Spring-Boot-工程热部署" class="headerlink" title="Spring Boot 工程热部署"></a>Spring Boot 工程热部署</h3><ul><li>在开发中反复修改类、页面等资源，每次修改后都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间。</li><li>可以在修改代码后不重启就能生效，在 pom.xml 中添加如下配置就可以实现这样的功能，称之为热部署。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 热部署配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：IDEA 进行 Spring Boot 热部署失败原因。出现这种情况，并不是热部署配置问题，其根本原因是因为 Intellij IEDA 默认情况下不会自动编译，需要对 IDEA 进行自动编译的设置，如下：</li></ul><p><img src="/2020/06/30/spring-boot/idea热部署配置-1.png" alt></p><ul><li>然后 <code>Shift+Ctrl+Alt+/</code>，选择 <code>Registry</code>：</li></ul><p><img src="/2020/06/30/spring-boot/idea热部署配置-2.png" alt></p><h3 id="使用-IDEA-快速创建-Spring-Boot-项目"><a href="#使用-IDEA-快速创建-Spring-Boot-项目" class="headerlink" title="使用 IDEA 快速创建 Spring Boot 项目"></a>使用 IDEA 快速创建 Spring Boot 项目</h3><p><img src="/2020/06/30/spring-boot/idea快速构建springboot项目-1.png" alt></p><p><img src="/2020/06/30/spring-boot/idea快速构建springboot项目-2.png" alt></p><p><img src="/2020/06/30/spring-boot/idea快速构建springboot项目-3.png" alt></p><p><img src="/2020/06/30/spring-boot/idea快速构建springboot项目-4.png" alt></p><p><img src="/2020/06/30/spring-boot/idea快速构建springboot项目-5.png" alt></p><ul><li>通过 IDEA 快速创建的 Spring Boot 项目的 <code>pom.xml</code> 中已经导入了 web 的起步依赖坐标：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.flexia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-quickstart-2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-quickstart-2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring-Boot-原理分析"><a href="#Spring-Boot-原理分析" class="headerlink" title="Spring Boot 原理分析"></a>Spring Boot 原理分析</h1><h2 id="起步依赖原理分析"><a href="#起步依赖原理分析" class="headerlink" title="起步依赖原理分析"></a>起步依赖原理分析</h2><h3 id="分析-spring-boot-starter-parent"><a href="#分析-spring-boot-starter-parent" class="headerlink" title="分析 spring-boot-starter-parent"></a>分析 spring-boot-starter-parent</h3><ul><li>打开 <code>spring-boot-starter-parent</code> 的 <code>pom.xml</code>，XML 配置如下（只摘抄了部分重点配置）：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>再打开 <code>spring-boot-dependencies</code> 的 <code>pom.xml</code>，XML 配置如下（只摘抄了部分重点配置）：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.12<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.80<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.16.1<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>从 <code>spring-boot-dependencies</code> 的 <code>pom.xml</code> 中可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以 Spring Boot 工程继承 <code>spring-boot-starter-parent</code> 后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</strong></li></ul><h3 id="分析-spring-boot-starter-web"><a href="#分析-spring-boot-starter-web" class="headerlink" title="分析 spring-boot-starter-web"></a>分析 spring-boot-starter-web</h3><ul><li>打开 <code>spring-boot-starter-web</code> 的 <code>pom.xml</code>，XML 配置如下（只摘抄了部分重点配置）：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>从 <code>spring-boot-starter-web</code> 的 <code>pom.xml</code> 中可以发现，<code>spring-boot-starter-web</code> 就是将 web 开发要使用的 <code>spring-web</code>、<code>spring-webmvc</code> 等坐标进行了“打包”，这样工程只要引入 <code>spring-boot-starter-web</code> 起步依赖的坐标就可以进行 web 开发了，同样体现了依赖传递的作用。</strong></li></ul><h2 id="自动配置原理分析"><a href="#自动配置原理分析" class="headerlink" title="自动配置原理分析"></a>自动配置原理分析</h2><ul><li>查看引导类 <code>MySpringBootApplication</code> 上的注解 <code>@SpringBootApplication</code> 的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">                                  <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>@SpringBootConfiguration</code>：等同于 <code>@Configuration</code>，标注该类是 Spring 的一个配置类。</strong></li><li><strong><code>@EnableAutoConfiguration</code>：Spring Boot 自动配置功能开启。</strong></li><li>查看注解 <code>@EnableAutoConfiguration</code> 的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中，<code>@Import(AutoConfigurationImportSelector.class)</code> 导入了 <code>AutoConfigurationImportSelector</code> 类，查看 <code>AutoConfigurationImportSelector</code> 源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> ... </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125;</span><br><span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                             getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中，<code>SpringFactoriesLoader.loadFactoryNames()</code> 方法的作用就是从 <code>META-INF/spring.factories</code> 文件中读取指定类对应的类名称列表。</li></ul><p><img src="/2020/06/30/spring-boot/META_spring_factories文件的位置.png" alt></p><ul><li><code>spring.factories</code> 文件中有关自动配置的配置信息如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><ul><li>上面配置文件存在大量的以 <code>AutoConfiguration</code> 为结尾的类名称，这些类就是存有自动配置信息的类，而 <code>SpringApplication</code> 在获取这些类名后再加载。</li><li>以 <code>ServletWebServerFactoryAutoConfiguration</code> 为例来分析源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ServletRequest.class)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ServerProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="line">         ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="line">         ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="line">         ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerFactoryAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中，<code>@EnableConfigurationProperties(ServerProperties.class)</code> 代表加载 <code>ServerProperties</code> 服务器配置属性类，进入 <code>ServerProperties</code> 源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server HTTP port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Network address to which the server should bind.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress address;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中，<code>prefix = &quot;server&quot;</code> 表示 Spring Boot 配置文件中的前缀，Spring Boot 会将配置文件中以 <code>server</code> 开始的属性映射到该类的字段中。映射关系如下：</li></ul><p><img src="/2020/06/30/spring-boot/自动配置中的映射流程.png" alt></p><h1 id="Spring-Boot-的配置文件"><a href="#Spring-Boot-的配置文件" class="headerlink" title="Spring Boot 的配置文件"></a>Spring Boot 的配置文件</h1><h2 id="Spring-Boot-配置文件类型"><a href="#Spring-Boot-配置文件类型" class="headerlink" title="Spring Boot 配置文件类型"></a>Spring Boot 配置文件类型</h2><h3 id="Spring-Boot-配置文件类型和作用"><a href="#Spring-Boot-配置文件类型和作用" class="headerlink" title="Spring Boot 配置文件类型和作用"></a>Spring Boot 配置文件类型和作用</h3><ul><li>Spring Boot 是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用 <code>application.properties</code> 或者 <code>application.yml</code>（<code>application.yaml</code>）进行配置。</li><li>Spring Boot 默认会从 <code>resources</code> 目录下加载 <code>application.properties</code> 或 <code>application.yml</code>（<code>application.yaml</code>）文件。</li><li>其中，<code>application.properties</code> 文件是键值对类型的文件，之前一直在使用，所以此处不再对 <code>properties</code> 文件的格式进行阐述。除了 <code>properties</code> 文件外，Spring Boot 还可以使用 <code>yml</code> 文件进行配置，下面对 <code>yml</code> 文件进行讲解。</li></ul><h3 id="application-yml-配置文件"><a href="#application-yml-配置文件" class="headerlink" title="application.yml 配置文件"></a>application.yml 配置文件</h3><h4 id="yml-配置文件简介"><a href="#yml-配置文件简介" class="headerlink" title="yml 配置文件简介"></a>yml 配置文件简介</h4><ul><li>YML 文件格式是 YAML（YAML Aint Markup Language）编写的文件格式。</li><li>YAML 是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持 YAML 库的不同的编程语言程序导入，比如： C/C++、Ruby、Python、Java、Perl、C#、PHP等。</li><li>YML 文件是以数据为核心的，比传统的 XML 方式更加简洁。</li><li>YML 文件的扩展名可以使用 <code>.yml</code> 或者 <code>.yaml</code>。</li></ul><h4 id="yml-配置文件的语法"><a href="#yml-配置文件的语法" class="headerlink" title="yml 配置文件的语法"></a>yml 配置文件的语法</h4><h5 id="配置普通数据"><a href="#配置普通数据" class="headerlink" title="配置普通数据"></a>配置普通数据</h5><ul><li>语法： <code>key: value</code></li><li>注意：<code>value</code> 之前有一个空格。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通数据的配置</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">张三</span></span><br></pre></td></tr></table></figure><h5 id="配置对象数据"><a href="#配置对象数据" class="headerlink" title="配置对象数据"></a>配置对象数据</h5><ul><li>语法：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> </span><br><span class="line"><span class="attr">  key1:</span> <span class="string">value1</span></span><br><span class="line"><span class="attr">  key2:</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="string">或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span> <span class="string">&#123;key1:</span> <span class="string">value1,</span> <span class="attr">key2:</span> <span class="string">value2&#125;</span></span><br></pre></td></tr></table></figure><ul><li>注意：key 前面的空格个数不限定，在 yml 语法中，相同缩进代表同一个级别。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对象的配置</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">张三</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行内对象配置</span></span><br><span class="line"><span class="attr">person:</span> <span class="string">&#123;name:</span> <span class="string">张三,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="配置-Map-数据"><a href="#配置-Map-数据" class="headerlink" title="配置 Map 数据"></a>配置 Map 数据</h5><ul><li>同上面的对象写法。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Map配置</span></span><br><span class="line"><span class="attr">map:</span> </span><br><span class="line"><span class="attr">  key1:</span> <span class="string">value1</span></span><br><span class="line"><span class="attr">  key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure><h5 id="配置数组（List、Set）数据"><a href="#配置数组（List、Set）数据" class="headerlink" title="配置数组（List、Set）数据"></a>配置数组（List、Set）数据</h5><ul><li>语法： </li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">value1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="string">或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span> <span class="string">[value1,value2]</span></span><br></pre></td></tr></table></figure><ul><li>注意：<code>value</code> 与之间的 <code>-</code> 之间存在一个空格。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集合的配置（字符串）</span></span><br><span class="line"><span class="attr">city:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">北京</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">武汉</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">上海</span></span><br><span class="line"></span><br><span class="line"><span class="string">或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">city:</span> <span class="string">[北京,</span> <span class="string">武汉,</span> <span class="string">上海]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合的配置（对象）</span></span><br><span class="line"><span class="attr">students:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">张三</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">李四</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="string">或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">students:</span> <span class="string">[&#123;name:</span> <span class="string">张三,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;,</span> <span class="string">&#123;name:</span> <span class="string">李四,</span> <span class="attr">age:</span> <span class="number">20</span><span class="string">&#125;]</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-配置信息的查询"><a href="#Spring-Boot-配置信息的查询" class="headerlink" title="Spring Boot 配置信息的查询"></a>Spring Boot 配置信息的查询</h3><ul><li>上面提及过，Spring Boot 的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？可以查阅 Spring Boot 的官方文档。</li><li>文档 URL：<a href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/appendix-application-properties.html#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/appendix-application-properties.html#common-application-properties</a> 。</li><li>常用的配置摘抄如下：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QUARTZ SCHEDULER (QuartzProperties)</span></span><br><span class="line"><span class="meta">spring.quartz.jdbc.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.quartz.jdbc.schema</span>=<span class="string">classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">memory # Quartz job store type.</span></span><br><span class="line"><span class="meta">spring.quartz.properties.*</span>= <span class="string"># Additional Quartz Scheduler properties.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># WEB PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080 # Server HTTP port.</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>= <span class="string"># Context path of the application.</span></span><br><span class="line"><span class="meta">server.servlet.path</span>=<span class="string">/ # Path of the main dispatcher servlet.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP encoding (HttpEncodingProperties)</span></span><br><span class="line"><span class="meta">spring.http.encoding.charset</span>=<span class="string">UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type" header if not set explicitly.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JACKSON (JacksonProperties)</span></span><br><span class="line"><span class="meta">spring.jackson.date-format</span>= <span class="string"># Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING MVC (WebMvcProperties)</span></span><br><span class="line"><span class="meta">spring.mvc.servlet.load-on-startup</span>=<span class="string">-1 # Load on startup priority of the dispatcher servlet.</span></span><br><span class="line"><span class="meta">spring.mvc.static-path-pattern</span>=<span class="string">/** # Path pattern used for static resources.</span></span><br><span class="line"><span class="meta">spring.mvc.view.prefix</span>= <span class="string"># Spring MVC view prefix.</span></span><br><span class="line"><span class="meta">spring.mvc.view.suffix</span>= <span class="string"># Spring MVC view suffix.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>= <span class="string"># Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>= <span class="string"># Login password of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>= <span class="string"># JDBC URL of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>= <span class="string"># Login username of the database.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JEST (Elasticsearch HTTP client) (JestProperties)</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.password</span>= <span class="string"># Login password.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.proxy.host</span>= <span class="string"># Proxy host the HTTP client should use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.proxy.port</span>= <span class="string"># Proxy port the HTTP client should use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.read-timeout</span>=<span class="string">3s # Read timeout.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.username</span>= <span class="string"># Login username.</span></span><br></pre></td></tr></table></figure><ul><li><strong>可以通过配置 <code>application.poperties</code> 或者 <code>application.yml</code> 来修改 Spring Boot 的默认配置。</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8888</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/demo</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">  servlet:</span></span><br><span class="line"><span class="attr">    context-path:</span> <span class="string">/demo</span></span><br></pre></td></tr></table></figure><h2 id="配置文件与配置类的属性映射方式"><a href="#配置文件与配置类的属性映射方式" class="headerlink" title="配置文件与配置类的属性映射方式"></a>配置文件与配置类的属性映射方式</h2><h3 id="使用注解-Value-映射"><a href="#使用注解-Value-映射" class="headerlink" title="使用注解 @Value 映射"></a>使用注解 @Value 映射</h3><ul><li><strong>可以通过 <code>@Value</code> 注解将配置文件中的值映射到一个 Spring 管理的 Bean 的字段上。</strong></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">张三</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.age&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/quick"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: "</span> + name  +<span class="string">", age: "</span>+ age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/30/spring-boot/@Value注解进行属性映射.png" alt></p><h3 id="使用注解-ConfigurationProperties-映射"><a href="#使用注解-ConfigurationProperties-映射" class="headerlink" title="使用注解 @ConfigurationProperties 映射"></a>使用注解 @ConfigurationProperties 映射</h3><ul><li><strong>通过注解 <code>@ConfigurationProperties(prefix = &quot;配置文件中的key的前缀&quot;)</code> 可以将配置文件中的配置自动与实体进行映射。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick2Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"quick2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: "</span> + name  +<span class="string">", age: "</span>+ age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/30/spring-boot/@ConfigurationProperties注解进行属性映射.png" alt></p><ul><li>注意：<strong>使用 <code>@ConfigurationProperties</code> 方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供 <code>set</code> 方法才可以，而使用 <code>@Value</code> 注解修饰的字段不需要提供 <code>set</code> 方法。</strong></li></ul><h1 id="Spring-Boot-与整合其他技术"><a href="#Spring-Boot-与整合其他技术" class="headerlink" title="Spring Boot 与整合其他技术"></a>Spring Boot 与整合其他技术</h1><h2 id="Spring-Boot-整合-MyBatis"><a href="#Spring-Boot-整合-MyBatis" class="headerlink" title="Spring Boot 整合 MyBatis"></a>Spring Boot 整合 MyBatis</h2><h3 id="添加-MyBatis-的起步依赖"><a href="#添加-MyBatis-的起步依赖" class="headerlink" title="添加 MyBatis 的起步依赖"></a>添加 MyBatis 的起步依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加数据库驱动坐标"><a href="#添加数据库驱动坐标" class="headerlink" title="添加数据库驱动坐标"></a>添加数据库驱动坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL连接驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加数据库连接信息"><a href="#添加数据库连接信息" class="headerlink" title="添加数据库连接信息"></a>添加数据库连接信息</h3><ul><li>在 <code>application.properties</code> 中添加数据库的连接信息。</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库连接信息</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql:///test</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h3 id="创建-user-表"><a href="#创建-user-表" class="headerlink" title="创建 user 表"></a>创建 user 表</h3><ul><li>在 test 数据库中创建 user 表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for `user`</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>       <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`name`</span>     <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">10</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'zhangsan'</span>, <span class="string">'123'</span>, <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'lisi'</span>, <span class="string">'123'</span>, <span class="string">'李四'</span>);</span><br></pre></td></tr></table></figure><h3 id="创建实体-Bean"><a href="#创建实体-Bean" class="headerlink" title="创建实体 Bean"></a>创建实体 Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-Mapper"><a href="#编写-Mapper" class="headerlink" title="编写 Mapper"></a>编写 Mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意：<code>@Mapper</code> 标记该类是一个 MyBatis 的 <code>mapper</code> 接口，可以被 Spring Boot 自动扫描到 Spring 上下文中。</strong></li></ul><h3 id="在-application-properties-中添加-MyBatis-的信息"><a href="#在-application-properties-中添加-MyBatis-的信息" class="headerlink" title="在 application.properties 中添加 MyBatis 的信息"></a>在 application.properties 中添加 MyBatis 的信息</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置mybatis信息</span></span><br><span class="line"><span class="comment"># pojo别名扫描包</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.itheima.domain</span></span><br></pre></td></tr></table></figure><h3 id="编写测试-Controller"><a href="#编写测试-Controller" class="headerlink" title="编写测试 Controller"></a>编写测试 Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/queryUser"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserList();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/30/spring-boot/springboot整合mybatis测试结果.png" alt></p><h2 id="Spring-Boot-整合-Junit"><a href="#Spring-Boot-整合-Junit" class="headerlink" title="Spring Boot 整合 Junit"></a>Spring Boot 整合 Junit</h2><h3 id="添加-Junit-的起步依赖"><a href="#添加-Junit-的起步依赖" class="headerlink" title="添加 Junit 的起步依赖"></a>添加 Junit 的起步依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--测试的起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flexia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.flexia.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.flexia.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = &#123;SpringBootMybatisApplication.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : userMapper.queryUserList()) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>@SpringBootTest</code> 的属性指定的是引导类的字节码对象。</strong></li></ul><h3 id="控制台打印信息"><a href="#控制台打印信息" class="headerlink" title="控制台打印信息"></a>控制台打印信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=<span class="number">1</span>, username=<span class="string">'zhangsan'</span>, password=<span class="string">'123'</span>, name=<span class="string">'张三'</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">2</span>, username=<span class="string">'lisi'</span>, password=<span class="string">'123'</span>, name=<span class="string">'李四'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-整合-Spring-Data-JPA"><a href="#Spring-Boot-整合-Spring-Data-JPA" class="headerlink" title="Spring Boot 整合 Spring Data JPA"></a>Spring Boot 整合 Spring Data JPA</h2><h3 id="添加-Spring-Data-JPA-的起步依赖"><a href="#添加-Spring-Data-JPA-的起步依赖" class="headerlink" title="添加 Spring Data JPA 的起步依赖"></a>添加 Spring Data JPA 的起步依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- springBoot JPA 的起步依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加数据库驱动依赖"><a href="#添加数据库驱动依赖" class="headerlink" title="添加数据库驱动依赖"></a>添加数据库驱动依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL连接驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-application-properties-中配置数据库和-jpa-的相关属性"><a href="#在-application-properties-中配置数据库和-jpa-的相关属性" class="headerlink" title="在 application.properties 中配置数据库和 jpa 的相关属性"></a>在 application.properties 中配置数据库和 jpa 的相关属性</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库连接信息</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql:///test</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JPA Configuration:</span></span><br><span class="line"><span class="meta">spring.jpa.database</span>=<span class="string">MySQL</span></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.jpa.generate-ddl</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming_strategy</span>=<span class="string">org.hibernate.cfg.ImprovedNamingStrategy</span></span><br></pre></td></tr></table></figure><h3 id="创建实体配置实体"><a href="#创建实体配置实体" class="headerlink" title="创建实体配置实体"></a>创建实体配置实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主键</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-UserRepository"><a href="#编写-UserRepository" class="headerlink" title="编写 UserRepository"></a>编写 UserRepository</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试类-1"><a href="#编写测试类-1" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>(classes = SpringBootJpaApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制台打印信息-1"><a href="#控制台打印信息-1" class="headerlink" title="控制台打印信息"></a>控制台打印信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.password as password3_0_, user0_.username as username4_0_ from user user0_</span><br><span class="line">User&#123;id=<span class="number">1</span>, username=<span class="string">'zhangsan'</span>, password=<span class="string">'123'</span>, name=<span class="string">'张三'</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">2</span>, username=<span class="string">'lisi'</span>, password=<span class="string">'123'</span>, name=<span class="string">'李四'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-整合-Redis"><a href="#Spring-Boot-整合-Redis" class="headerlink" title="Spring Boot 整合 Redis"></a>Spring Boot 整合 Redis</h2><h3 id="添加-redis-的起步依赖"><a href="#添加-redis-的起步依赖" class="headerlink" title="添加 redis 的起步依赖"></a>添加 redis 的起步依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置使用redis启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-redis-的连接信息"><a href="#配置-redis-的连接信息" class="headerlink" title="配置 redis 的连接信息"></a>配置 redis 的连接信息</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure><h3 id="注入-RedisTemplate-测试-redis-操作"><a href="#注入-RedisTemplate-测试-redis-操作" class="headerlink" title="注入 RedisTemplate 测试 redis 操作"></a>注入 RedisTemplate 测试 redis 操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>(classes = SpringBootJpaApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">// 从redis中获得数据，数据的形式json字符串</span></span><br><span class="line">        String userListJson = redisTemplate.boundValueOps(<span class="string">"user.findAll"</span>).get();</span><br><span class="line">        <span class="comment">// 判断redis中是否存在数据</span></span><br><span class="line">        <span class="keyword">if</span> (userListJson==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 不存在数据，从数据库查询</span></span><br><span class="line">            List&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">            <span class="comment">// 将查询的数据存储到redis缓存中</span></span><br><span class="line">            <span class="comment">// 先将list集合转换为json格式的字符串，使用jackson进行转换</span></span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            userListJson = objectMapper.writeValueAsString(users);</span><br><span class="line">            redisTemplate.boundValueOps(<span class="string">"user.findAll"</span>).set(userListJson);</span><br><span class="line">            System.out.println(<span class="string">"====从数据库中获得user的数据===="</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"====从redis缓存中获得user的数据===="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数据在控制台打印</span></span><br><span class="line">        System.out.println(userListJson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一次运行测试：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">====从数据库中获得user的数据====</span><br><span class="line">[&#123;<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"username"</span>:<span class="string">"zhangsan"</span>,<span class="string">"password"</span>:<span class="string">"123"</span>,<span class="string">"name"</span>:<span class="string">"张三"</span>&#125;,&#123;<span class="string">"id"</span>:<span class="number">2</span>,<span class="string">"username"</span>:<span class="string">"lisi"</span>,<span class="string">"password"</span>:<span class="string">"123"</span>,<span class="string">"name"</span>:<span class="string">"李四"</span>&#125;]</span><br></pre></td></tr></table></figure><ul><li>第二次运行测试：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">====从redis缓存中获得user的数据====</span><br><span class="line">[&#123;<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"username"</span>:<span class="string">"zhangsan"</span>,<span class="string">"password"</span>:<span class="string">"123"</span>,<span class="string">"name"</span>:<span class="string">"张三"</span>&#125;,&#123;<span class="string">"id"</span>:<span class="number">2</span>,<span class="string">"username"</span>:<span class="string">"lisi"</span>,<span class="string">"password"</span>:<span class="string">"123"</span>,<span class="string">"name"</span>:<span class="string">"李四"</span>&#125;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合</title>
      <link href="/2020/06/27/ssm.html"/>
      <url>/2020/06/27/ssm.html</url>
      
        <content type="html"><![CDATA[<h1 id="搭建整合环境"><a href="#搭建整合环境" class="headerlink" title="搭建整合环境"></a>搭建整合环境</h1><ul><li>整合说明：<ul><li>SSM 整合可以使用多种方式，这里选择 XML + 注解的方式。</li></ul></li><li>整合思路：<ol><li>搭建整合的环境；</li><li>先把 Spring 的配置搭建完成；</li><li>再使用 Spring 整合 SpringMVC 框架；</li><li>最后使用 Spring 整合 MyBatis 框架。</li></ol></li></ul><p><img src="/2020/06/27/ssm/ssm整合的说明.bmp" alt></p><h2 id="创建数据库和表结构"><a href="#创建数据库和表结构" class="headerlink" title="创建数据库和表结构"></a>创建数据库和表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> ssm;</span><br><span class="line"><span class="keyword">use</span> ssm;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(</span><br><span class="line">    <span class="keyword">id</span>    <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span>  <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    money <span class="keyword">double</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="创建-Maven-工程并导入依赖"><a href="#创建-Maven-工程并导入依赖" class="headerlink" title="创建 Maven 工程并导入依赖"></a>创建 Maven 工程并导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>2.0.0-alpha1<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1-b03<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- log start --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">// Setter/Getter/toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写-dao-接口"><a href="#编写-dao-接口" class="headerlink" title="编写 dao 接口"></a>编写 dao 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户dao接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写-service-接口和实现类"><a href="#编写-service-接口和实现类" class="headerlink" title="编写 service 接口和实现类"></a>编写 service 接口和实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户service接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> domain.Account;</span><br><span class="line"><span class="keyword">import</span> service.AccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务层：查询所有账户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务层：保存账户..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搭建-Spring-开发环境"><a href="#搭建-Spring-开发环境" class="headerlink" title="搭建 Spring 开发环境"></a>搭建 Spring 开发环境</h1><h2 id="创建-applicationContext-xml-配置文件"><a href="#创建-applicationContext-xml-配置文件" class="headerlink" title="创建 applicationContext.xml 配置文件"></a>创建 applicationContext.xml 配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置spring创建容器时要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--制定扫包规则，不扫描@Controller注解的java类，其他的还是要扫描 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用注解配置-service"><a href="#使用注解配置-service" class="headerlink" title="使用注解配置 service"></a>使用注解配置 service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试-Spring-能否独立运行"><a href="#测试-Spring-能否独立运行" class="headerlink" title="测试 Spring 能否独立运行"></a>测试 Spring 能否独立运行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.example.service.AccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        AccountService as = ac.getBean(<span class="string">"accountService"</span>, AccountService.class);</span><br><span class="line">        as.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">业务层：查询所有账户...</span><br></pre></td></tr></table></figure><h1 id="Spring-整合-Spring-MVC-框架"><a href="#Spring-整合-Spring-MVC-框架" class="headerlink" title="Spring 整合 Spring MVC 框架"></a>Spring 整合 Spring MVC 框架</h1><h2 id="搭建-Spring-MVC-开发环境"><a href="#搭建-Spring-MVC-开发环境" class="headerlink" title="搭建 Spring MVC 开发环境"></a>搭建 Spring MVC 开发环境</h2><h3 id="在-web-xml-中配置核心控制器和中文过滤器"><a href="#在-web-xml-中配置核心控制器和中文过滤器" class="headerlink" title="在 web.xml 中配置核心控制器和中文过滤器"></a>在 web.xml 中配置核心控制器和中文过滤器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 解决中文乱码的过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置前端控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载springmvc.xml配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启动服务器立即创建该servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建-springmvc-xml-配置文件"><a href="#创建-springmvc-xml-配置文件" class="headerlink" title="创建 springmvc.xml 配置文件"></a>创建 springmvc.xml 配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描，只扫描Controller注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 过滤静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/css/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span> <span class="attr">location</span>=<span class="string">"/images/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启springmvc对注解的支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写-AccountController-类和-JSP-页面进行测试"><a href="#编写-AccountController-类和-JSP-页面进行测试" class="headerlink" title="编写 AccountController 类和 JSP 页面进行测试"></a>编写 AccountController 类和 JSP 页面进行测试</h3><ul><li><code>index.jsp</code> 页面：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"account/findAll"</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>list.jsp</code> 页面：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>查询的所有账户<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>AccountController</code> 类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户web</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"表现层：查询所有账户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/27/ssm/测试springmvc环境.png" alt></p><h2 id="Spring-整合-Spring-MVC"><a href="#Spring-整合-Spring-MVC" class="headerlink" title="Spring 整合 Spring MVC"></a>Spring 整合 Spring MVC</h2><h3 id="整合说明"><a href="#整合说明" class="headerlink" title="整合说明"></a>整合说明</h3><ul><li>Spring MVC 和 Spring 的整合目标是在 controller 方法中可以调用 service 方法。</li><li>但是在启动服务器后，只会加载 Spring MVC 的配置文件，并不会加载 Spring 的配置文件，这样 controller 中无法自动注入 service 对象，进而不能调用 service 方法。</li><li>因此需要在启动服务器的时候同时加载 Spring 的配置文件。</li></ul><p><img src="/2020/06/27/ssm/启动服务器加载spring的配置文件.bmp" alt="启动服务器加载spring的配置文件"></p><h3 id="在-web-xml-中配置监听器实现启动服务器创建-Spring-容器"><a href="#在-web-xml-中配置监听器实现启动服务器创建-Spring-容器" class="headerlink" title="在 web.xml 中配置监听器实现启动服务器创建 Spring 容器"></a>在 web.xml 中配置监听器实现启动服务器创建 Spring 容器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置配置文件的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改-AccountController-类进行测试"><a href="#修改-AccountController-类进行测试" class="headerlink" title="修改 AccountController 类进行测试"></a>修改 AccountController 类进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"表现层：查询所有账户..."</span>);</span><br><span class="line">        <span class="comment">// 调用service的方法</span></span><br><span class="line">        accountService.findAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/27/ssm/spring整合springmvc测试结果.png" alt></p><h1 id="Spring-整合-MyBatis-框架"><a href="#Spring-整合-MyBatis-框架" class="headerlink" title="Spring 整合 MyBatis 框架"></a>Spring 整合 MyBatis 框架</h1><h2 id="搭建-MyBatis-开发环境"><a href="#搭建-MyBatis-开发环境" class="headerlink" title="搭建 MyBatis 开发环境"></a>搭建 MyBatis 开发环境</h2><h3 id="编写-SqlMapConfig-xml-配置文件"><a href="#编写-SqlMapConfig-xml-配置文件" class="headerlink" title="编写 SqlMapConfig.xml 配置文件"></a>编写 SqlMapConfig.xml 配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载jdbc配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbcConfig.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入映射配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;mapper class="org.example.dao.AccountDao"/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.example.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">properties文件中的内容：</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:///ssm</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><h3 id="使用注解配置-AccountDao-接口"><a href="#使用注解配置-AccountDao-接口" class="headerlink" title="使用注解配置 AccountDao 接口"></a>使用注解配置 AccountDao 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into account(name,money) values(#&#123;name&#125;,#&#123;money&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        AccountDao accountDao = session.getMapper(AccountDao.class);</span><br><span class="line">        List&lt;Account&gt; accounts = accountDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Account account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        AccountDao accountDao = session.getMapper(AccountDao.class);</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setName(<span class="string">"hustffx"</span>);</span><br><span class="line">        account.setMoney(<span class="number">400.0</span>);</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account&#123;id=<span class="number">1</span>, name=<span class="string">'test'</span>, money=<span class="number">200.0</span>&#125;</span><br><span class="line">Account&#123;id=<span class="number">2</span>, name=<span class="string">'flexia'</span>, money=<span class="number">300.0</span>&#125;</span><br><span class="line">Account&#123;id=<span class="number">3</span>, name=<span class="string">'hustffx'</span>, money=<span class="number">400.0</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-整合-MyBatis-框架-1"><a href="#Spring-整合-MyBatis-框架-1" class="headerlink" title="Spring 整合 MyBatis 框架"></a>Spring 整合 MyBatis 框架</h2><h3 id="整合说明-1"><a href="#整合说明-1" class="headerlink" title="整合说明"></a>整合说明</h3><ul><li>Spring 整合 MyBatis 的目标是在 service 方法中调用 dao 方法。</li><li>service 对象已经在 Spring 中配置，需要把 MyBatis 配置产生的代理 dao 对象也配置到 Spring 容器中。</li><li>整合思路：把 MyBatis 配置文件中的内容配置到 Spring 配置文件中，同时把 MyBatis 配置文件的内容清掉。</li></ul><h3 id="Spring-接管-MyBatis-的-Session-工厂"><a href="#Spring-接管-MyBatis-的-Session-工厂" class="headerlink" title="Spring 接管 MyBatis 的 Session 工厂"></a>Spring 接管 MyBatis 的 Session 工厂</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载jdbc配置信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbcConfig.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置自动扫描所有-Mapper-接口和文件"><a href="#配置自动扫描所有-Mapper-接口和文件" class="headerlink" title="配置自动扫描所有 Mapper 接口和文件"></a>配置自动扫描所有 Mapper 接口和文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置dao接口所在的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"org.example.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-Spring-声明式事务管理"><a href="#配置-Spring-声明式事务管理" class="headerlink" title="配置 Spring 声明式事务管理"></a>配置 Spring 声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring框架声明式事务管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置AOP增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">pointcut</span>=<span class="string">"execution(* org.example.service.impl.*ServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改相关类和页面进行测试"><a href="#修改相关类和页面进行测试" class="headerlink" title="修改相关类和页面进行测试"></a>修改相关类和页面进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务层：查询所有账户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务层：保存账户..."</span>);</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"表现层：查询所有账户..."</span>);</span><br><span class="line">        <span class="comment">// 调用service的方法</span></span><br><span class="line">        List&lt;Account&gt; accounts = accountService.findAll();</span><br><span class="line">        model.addAttribute(<span class="string">"list"</span>, accounts);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"表现层：保存账户..."</span>);</span><br><span class="line">        <span class="comment">// 调用service的方法</span></span><br><span class="line">        accountService.saveAccount(account);</span><br><span class="line">        <span class="comment">// 重定向</span></span><br><span class="line">        response.sendRedirect(request.getContextPath() + <span class="string">"/account/findAll"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">isELIgnored</span>=<span class="string">"false"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"c"</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>查询的所有账户<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;list&#125;"</span> <span class="attr">var</span>=<span class="string">"account"</span>&gt;</span></span><br><span class="line">        $&#123;account.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/27/ssm/ssm整合完成测试结果.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> SSM框架整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> SSM框架整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架</title>
      <link href="/2020/06/25/springmvc.html"/>
      <url>/2020/06/25/springmvc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC-基本概念"><a href="#Spring-MVC-基本概念" class="headerlink" title="Spring MVC 基本概念"></a>Spring MVC 基本概念</h1><h2 id="三层架构和-MVC"><a href="#三层架构和-MVC" class="headerlink" title="三层架构和 MVC"></a>三层架构和 MVC</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 架构，也就是浏览器/服务器。</li><li>在 JavaEE 开发中，几乎全都是基于 B/S 架构的开发。那么在 B/S 架构中，系统标准的三层架构包括：表现层、业务层、持久层。</li><li>三层架构中，每一层各司其职：<ul><li><strong>表现层</strong>：即 Web 层，负责接收客户端请求，向客户端响应结果。</li><li><strong>业务层</strong>：即 Service 层，负责业务逻辑处理。WEB 层依赖业务层，但是业务层不依赖 Web 层。</li><li><strong>持久层</strong>：即 Dao 层，负责数据持久化。通俗的讲，持久层就是和数据库交互，对数据库表进行增删改查。</li></ul></li></ul><h3 id="MVC-设计模型"><a href="#MVC-设计模型" class="headerlink" title="MVC 设计模型"></a>MVC 设计模型</h3><ul><li>MVC 设计模型：<ul><li>全名是 Model View Controller（模型视图控制器）。</li><li>是一种用于设计创建 WEB 应用程序表现层的模式。</li></ul></li><li>MVC 中每个部分各司其职：<ul><li><strong>Model</strong>：数据模型，JavaBean 的类，用来进行数据封装。</li><li><strong>View</strong>：通常指 JSP 或 HTML，用来展示数据给用户。</li><li><strong>Controller</strong>：用来接收用户的请求，是整个处理流程的控制器，如用来进行数据校验等。</li></ul></li></ul><p><img src="/2020/06/25/springmvc/三层架构.bmp" alt></p><h2 id="Spring-MVC-概述"><a href="#Spring-MVC-概述" class="headerlink" title="Spring MVC 概述"></a>Spring MVC 概述</h2><h3 id="什么是-Spring-MVC"><a href="#什么是-Spring-MVC" class="headerlink" title="什么是 Spring MVC"></a>什么是 Spring MVC</h3><ul><li>Spring MVC 是一种基于 Java 实现的 MVC 设计模型的请求驱动类型的轻量级 Web 框架。</li><li>Spring MVC 属于 Spring FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。</li><li>使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的<br>  Spring MVC 框架或集成其他 MVC 开发框架。</li><li>Spring MVC 通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。</li></ul><h3 id="Spring-MVC-在三层架构中的位置"><a href="#Spring-MVC-在三层架构中的位置" class="headerlink" title="Spring MVC 在三层架构中的位置"></a>Spring MVC 在三层架构中的位置</h3><ul><li>Spring MVC 是一个表现层的框架。</li></ul><p><img src="/2020/06/25/springmvc/SSM框架的架构.jpg" alt></p><h3 id="Spring-MVC-的优势"><a href="#Spring-MVC-的优势" class="headerlink" title="Spring MVC 的优势"></a>Spring MVC 的优势</h3><ul><li>清晰的角色划分：<ul><li>前端控制器（<code>DispatcherServlet</code>）</li><li>处理器映射（<code>HandlerMapping</code>）</li><li>处理器适配器（<code>HandlerAdapter</code>）</li><li>视图解析器（<code>ViewResolver</code>）</li><li>处理器或页面控制器（<code>Controller</code>）</li><li>验证器（ <code>Validator</code>）</li><li>命令对象（<code>Command</code> 请求参数绑定到的对象就叫命令对象）</li><li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</li></ul></li><li>分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。</li><li>由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。</li><li>和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。</li><li>可适配，通过 <code>HandlerAdapter</code> 可以支持任意的类作为处理器。</li><li>可定制性，<code>HandlerMapping</code>、<code>ViewResolver</code> 等能够非常简单的定制。</li><li>功能强大的数据验证、格式化、绑定机制。</li><li>利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。</li><li>本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</li><li>强大的 JSP 标签库，使 JSP 编写更容易。 </li><li>还有比如 RESTful 风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。</li></ul><h1 id="Spring-MVC-入门"><a href="#Spring-MVC-入门" class="headerlink" title="Spring MVC 入门"></a>Spring MVC 入门</h1><p><img src="/2020/06/25/springmvc/入门案例需求.bmp" alt></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="在-pom-xml-中引入坐标"><a href="#在-pom-xml-中引入坐标" class="headerlink" title="在 pom.xml 中引入坐标"></a>在 pom.xml 中引入坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 版本锁定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-web-xml-中配置核心控制器"><a href="#在-web-xml-中配置核心控制器" class="headerlink" title="在 web.xml 中配置核心控制器"></a>在 web.xml 中配置核心控制器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC的核心控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置servlet启动时加载对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写-springmvc-xml-配置文件"><a href="#编写-springmvc-xml-配置文件" class="headerlink" title="编写 springmvc.xml 配置文件"></a>编写 springmvc.xml 配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Spring创建容器时要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启SpringMVC框架注解的支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写-index-jsp"><a href="#编写-index-jsp" class="headerlink" title="编写 index.jsp"></a>编写 index.jsp</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"hello"</span>&gt;</span>入门案例<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写-HelloController-控制器类"><a href="#编写-HelloController-控制器类" class="headerlink" title="编写 HelloController 控制器类"></a>编写 HelloController 控制器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello SpringMVC"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-WEB-INF-目录下创建-pages-文件夹并编写-success-jsp"><a href="#在-WEB-INF-目录下创建-pages-文件夹并编写-success-jsp" class="headerlink" title="在 WEB-INF 目录下创建 pages 文件夹并编写 success.jsp"></a>在 WEB-INF 目录下创建 pages 文件夹并编写 success.jsp</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>入门成功<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-Tomcat-服务器"><a href="#配置-Tomcat-服务器" class="headerlink" title="配置 Tomcat 服务器"></a>配置 Tomcat 服务器</h3><p><img src="/2020/06/25/springmvc/tomcat服务器配置-1.png" alt></p><p><img src="/2020/06/25/springmvc/tomcat服务器配置-2.png" alt></p><p><img src="/2020/06/25/springmvc/tomcat服务器配置-3.png" alt></p><h3 id="启动-Tomcat-服务器"><a href="#启动-Tomcat-服务器" class="headerlink" title="启动 Tomcat 服务器"></a>启动 Tomcat 服务器</h3><p><img src="/2020/06/25/springmvc/入门案例测试-1.png" alt></p><p><img src="/2020/06/25/springmvc/入门案例测试-2.png" alt></p><p><img src="/2020/06/25/springmvc/入门案例测试-3.png" alt></p><h2 id="Spring-MVC-执行过程及原理分析"><a href="#Spring-MVC-执行过程及原理分析" class="headerlink" title="Spring MVC 执行过程及原理分析"></a>Spring MVC 执行过程及原理分析</h2><h3 id="案例的执行过程"><a href="#案例的执行过程" class="headerlink" title="案例的执行过程"></a>案例的执行过程</h3><ol><li>当启动 Tomcat 服务器的时候，因为配置了 <code>load-on-startup</code> 标签，所以会创建 <code>DispatcherServlet</code> 对象，就会加载 <code>springmvc.xml</code> 配置文件。</li><li>开启了注解扫描，那么 <code>HelloController</code> 对象就会被创建。</li><li>从 <code>index.jsp</code> 发送请求，请求会先到达 <code>DispatcherServlet</code> 核心控制器，该 <code>Servlet</code> 并不处理请求，而是把请求转发出去。</li><li>转发的路径是根据请求 URL，匹配 <code>@RequestMapping</code> 中的内容。根据配置 <code>@RequestMapping</code> 注解找到执行的具体方法。</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的 JSP 文件。</li><li>Tomcat 服务器渲染页面，做出响应。</li></ol><p><img src="/2020/06/25/springmvc/案例执行过程.bmp" alt></p><h3 id="Spring-MVC-执行原理"><a href="#Spring-MVC-执行原理" class="headerlink" title="Spring MVC 执行原理"></a>Spring MVC 执行原理</h3><p><img src="/2020/06/25/springmvc/springmvc执行流程原理.bmp" alt></p><h2 id="Spring-MVC-涉及的组件"><a href="#Spring-MVC-涉及的组件" class="headerlink" title="Spring MVC 涉及的组件"></a>Spring MVC 涉及的组件</h2><h3 id="前端控制器-DisPatcherServlet"><a href="#前端控制器-DisPatcherServlet" class="headerlink" title="前端控制器 DisPatcherServlet"></a>前端控制器 DisPatcherServlet</h3><ul><li>用户请求到达前端控制器，它就相当于 MVC 模式中的 C。</li><li><strong><code>DispatcherServlet</code> 是整个流程控制的中心，由它调用其它组件处理用户的请求</strong>。</li><li><code>DispatcherServlet</code> 的存在降低了组件之间的耦合性。</li></ul><h3 id="处理器映射器-HandlerMapping"><a href="#处理器映射器-HandlerMapping" class="headerlink" title="处理器映射器 HandlerMapping"></a>处理器映射器 HandlerMapping</h3><ul><li><strong><code>HandlerMapping</code> 负责根据用户请求找到 <code>Handler</code> 即处理器</strong>。</li><li>Spring MVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li></ul><h3 id="处理器-Handler"><a href="#处理器-Handler" class="headerlink" title="处理器 Handler"></a>处理器 Handler</h3><ul><li><code>Handler</code> 就是开发中要编写的具体业务控制器。</li><li><strong>由 <code>DispatcherServlet</code> 把用户请求转发到 <code>Handler</code>。</strong></li><li><strong>由 <code>Handler</code> 对具体的用户请求进行处理。</strong></li></ul><h3 id="处理器适配器-HandlerAdapter"><a href="#处理器适配器-HandlerAdapter" class="headerlink" title="处理器适配器 HandlerAdapter"></a>处理器适配器 HandlerAdapter</h3><ul><li><strong>通过 <code>HandlerAdapter</code> 对处理器进行执行</strong>。</li><li>这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</li></ul><h3 id="视图解析器-ViewResolver"><a href="#视图解析器-ViewResolver" class="headerlink" title="视图解析器 ViewResolver"></a>视图解析器 ViewResolver</h3><ul><li><code>ViewResolver</code> 负责将处理结果生成 <code>View</code> 视图。</li><li><strong><code>ViewResolver</code> 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 <code>View</code> 视图对象，最后对 <code>View</code> 进行渲染将处理结果通过页面展示给用户</strong>。</li></ul><h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图 View"></a>视图 View</h3><ul><li>Spring MVC 框架提供了很多的 <code>View</code> 视图类型的支持，包括 jstlView、freemarkerView、pdfView 等，最常用的视图就是 jsp。</li><li>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ul><h3 id="lt-mvc-annotation-driven-gt-标签说明"><a href="#lt-mvc-annotation-driven-gt-标签说明" class="headerlink" title="&lt;mvc:annotation-driven&gt; 标签说明"></a><code>&lt;mvc:annotation-driven&gt;</code> 标签说明</h3><ul><li>在 Spring MVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 Spring MVC 的三大组件。</li><li>在入门案例中配置了 <code>DisPatcherServlet</code> 和 <code>InternalResourceViewResolver</code>，为什么没有看见有关 <code>HandlerMapping</code> 和 <code>HandlerAdapter</code> 的配置呢？</li><li><strong>使用 <code>&lt;mvc:annotation-driven&gt;</code> 会自动加载 <code>RequestMappingHandlerMapping</code>（处理映射器）和 <code>RequestMappingHandlerAdapter</code>（处理适配器），可以在 <code>springmvc.xml</code> 配置文件中使用 <code>&lt;mvc:annotation-driven&gt;</code> 替代注解处理器和适配器的配置</strong>。</li></ul><h2 id="RequestMapping-注解"><a href="#RequestMapping-注解" class="headerlink" title="@RequestMapping 注解"></a>@RequestMapping 注解</h2><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>@RequestMapping</code> 注解的源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用：</strong><ul><li><strong>是建立请求 URL 和处理方法之间的对应关系。</strong></li></ul></li><li><strong>出现位置：</strong><ul><li><strong>类上：请求 URL 的第一级访问目录。</strong><ul><li>此处不写的话，就相当于应用的根目录。</li><li>写的话需要以 <code>/</code> 开头。 </li><li>它出现的目的是为了使 URL 可以按照模块化管理。</li></ul></li><li><strong>方法上：请求 URL 的第二级访问目录。</strong></li></ul></li><li><strong>属性：</strong><ul><li><strong><code>path</code>：用于指定请求的 URL。</strong><ul><li>它和 <code>value</code> 属性的作用是一样的。</li></ul></li><li><strong><code>method</code>：用于指定请求的方式。</strong></li><li><strong><code>params</code>：用于指定限制请求参数的条件。</strong><ul><li>支持简单的表达式。</li><li>要求请求参数的 key 和 value 必须和配置的一模一样。</li><li><code>params = {&quot;xxx&quot;}</code>，表示请求参数必须有 <code>xxx</code>。</li><li><code>params = {&quot;moeny!100&quot;}</code>，表示请求参数中 <code>money</code> 不能是 100。</li></ul></li><li><strong><code>headers</code>：用于指定限制请求消息头的条件。</strong><ul><li>发送的请求必须包含指定的请求头。</li></ul></li><li>注意：以上 4 个属性只要出现 2 个或以上时，他们的关系是与（&amp;）的关系。</li></ul></li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="出现位置示例"><a href="#出现位置示例" class="headerlink" title="出现位置示例"></a>出现位置示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试RequestMapping注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/testRequestMapping"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test RequestMapping annotation..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"user/testRequestMapping"</span>&gt;</span>RequestMapping注解<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：不要在访问 URL 前面加 <code>/</code>，否则无法找到资源。</li></ul><h4 id="method-属性示例"><a href="#method-属性示例" class="headerlink" title="method 属性示例"></a>method 属性示例</h4><ul><li><code>method</code> 属性的类型是 <code>RequestMethod[]</code>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestMethod &#123;</span><br><span class="line">GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/testRequestMapping"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test RequestMapping annotation..."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/指定method为post的报错信息.png" alt></p><h4 id="params-属性示例"><a href="#params-属性示例" class="headerlink" title="params 属性示例"></a>params 属性示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/testRequestMapping"</span>,</span><br><span class="line">                params = &#123;<span class="string">"username"</span>, <span class="string">"money!100"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test RequestMapping annotation..."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"user/testRequestMapping?username=hustffx&amp;money=100"</span>&gt;</span>RequestMapping注解<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/指定params的报错信息.png" alt></p><h4 id="headers-属性示例"><a href="#headers-属性示例" class="headerlink" title="headers 属性示例"></a>headers 属性示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/testRequestMapping"</span>,</span><br><span class="line">                method = RequestMethod.GET,</span><br><span class="line">                params = &#123;<span class="string">"username"</span>, <span class="string">"money=100"</span>&#125;,</span><br><span class="line">                headers = &#123;<span class="string">"Accept"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test RequestMapping annotation..."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h1><h2 id="请求参数的绑定机制"><a href="#请求参数的绑定机制" class="headerlink" title="请求参数的绑定机制"></a>请求参数的绑定机制</h2><ul><li>表单提交的数据都是 <code>key=value</code> 格式的，如 <code>username=haha&amp;password=123</code>。</li><li>Spring MVC 的请求参数绑定过程是<strong>把表单提交的请求参数，作为控制器中方法的参数</strong>进行绑定的。</li><li>Spring MVC 绑定请求参数是自动实现的，要求提交表单的 <code>name</code> 和参数的名称是相同的。</li></ul><h2 id="支持的数据类型及使用方式"><a href="#支持的数据类型及使用方式" class="headerlink" title="支持的数据类型及使用方式"></a>支持的数据类型及使用方式</h2><ol><li>基本数据类型和 <code>String</code> 类型。</li><li>实体类型（JavaBean）。</li><li>集合类型（<code>List</code>、<code>Map</code> 集合等）。</li></ol><h3 id="基本类型和-String-类型作为参数"><a href="#基本类型和-String-类型作为参数" class="headerlink" title="基本类型和 String 类型作为参数"></a>基本类型和 String 类型作为参数</h3><ul><li>如果是基本类型或者 <code>String</code> 类型，要求<strong>参数名称必须和控制器中方法的形参名称保持一致，严格区分大小写</strong>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--请求参数的绑定--%</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"param/testParam?username=hustffx&amp;password=1234"</span>&gt;</span>请求参数绑定<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数绑定入门</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testParam"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了testParam..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"用户名："</span> + username);</span><br><span class="line">        System.out.println(<span class="string">"密码："</span> + password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行了testParam...</span><br><span class="line">用户名：hustffx</span><br><span class="line">密码：<span class="number">1234</span></span><br></pre></td></tr></table></figure><h3 id="JavaBean-实体类型作为参数"><a href="#JavaBean-实体类型作为参数" class="headerlink" title="JavaBean 实体类型作为参数"></a>JavaBean 实体类型作为参数</h3><ul><li>如果是 JavaBean 类型，或者它的关联对象，要求<strong>表单中参数名称和 JavaBean 类的属性名称保持一致，并且控制器方法的参数类型是 JavaBean 类型</strong>。</li><li><strong>如果一个 JavaBean 类中包含其他的引用类型，那么表单的 <code>name</code> 属性需要编写成 <code>对象.属性</code></strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"param/saveAccount"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.name"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.age"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数绑定将数据封装到JavaBean的类中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/saveAccount"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了saveAccount..."</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行了saveAccount...</span><br><span class="line">Account&#123;username=<span class="string">'哈哈'</span>, password=<span class="string">'12345'</span>, money=<span class="number">123.0</span>, user=User&#123;name=<span class="string">'方'</span>, age=<span class="number">22</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaBean-类中包含集合类型参数"><a href="#JavaBean-类中包含集合类型参数" class="headerlink" title="JavaBean 类中包含集合类型参数"></a>JavaBean 类中包含集合类型参数</h3><ul><li>如果是集合类型，有两种方式：<ol><li>要求集合类型的请求参数必须在 JavaBean 类中，在表单中请求参数名称要和 JavaBean 中集合属性名称相同。 <strong>给 <code>List</code> 集合中的元素赋值，使用下标。 给 <code>Map</code> 集合中的元素赋值，使用键值对</strong>。</li><li>接收的请求参数是 json 格式数据。需要借助一个注解实现。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; map;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--把数据封装到Account类中，类中存在list和map集合--%</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"param/saveAccount"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"list[0].name"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"list[0].age"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"map['one'].name"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"map['one'].age"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行了saveAccount...</span><br><span class="line">Account&#123;username=<span class="string">'呵呵'</span>, password=<span class="string">'123'</span>, money=<span class="number">456.0</span>, list=[User&#123;name=<span class="string">'方方'</span>, age=<span class="number">22</span>&#125;], map=&#123;one=User&#123;name=<span class="string">'小方方'</span>, age=<span class="number">18</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="请求参数中文乱码的解决"><a href="#请求参数中文乱码的解决" class="headerlink" title="请求参数中文乱码的解决"></a>请求参数中文乱码的解决</h2><h3 id="POST-请求方式"><a href="#POST-请求方式" class="headerlink" title="POST 请求方式"></a>POST 请求方式</h3><ul><li>在 <code>web.xml</code> 中配置 Spring 提供的过滤器类。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置解决中文乱码的过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置过滤器中的属性值，指定字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 过滤所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="GET-请求方式"><a href="#GET-请求方式" class="headerlink" title="GET 请求方式"></a>GET 请求方式</h3><ul><li>Tomcat 对 GET 和 POST 请求处理方式是不同的，GET 请求的编码问题，要改 Tomcat 的 <code>server.xml</code> 配置文件。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> <span class="attr">useBodyEncodingForURI</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果遇到 ajax 请求仍然乱码，把 <code>useBodyEncodingForURI=&quot;true&quot;</code> 改为 <code>URIEncoding=&quot;UTF-8&quot;</code> 即可。</li></ul><h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><ul><li><strong>表单提交的任何数据类型全部都是字符串类型</strong>，但是后台定义 <code>Integer</code> 类型，数据也可以封装上，说明 <strong>Spring 框架内部会默认进行数据类型转换</strong>。</li><li>如果想自定义数据类型转换，可以实现 <code>Converter</code> 接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Converter</code> 接口中有两个泛型，其中 <code>S</code> 表示接收的类型，<code>T</code> 表示目标类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串转日期的转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串转换为日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"请传入要转换的日期"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = df.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>springmvc.xml</code> 配置文件中注册自定义类型转换器，Spring 配置类型转换器的机制是<strong>将自定义的转换器注册到类型转换服务中去</strong>。</li><li>在 <code>mvc:annotation-driven</code> 标签中引用配置的类型转换服务。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置类型转换器工厂 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给工厂注入一个新的类型转换器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置自定义类型转换器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"utils.StringToDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启Spring对MVC注解的支持 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引用自定义类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用原始-Servlet-API-对象作为方法参数"><a href="#使用原始-Servlet-API-对象作为方法参数" class="headerlink" title="使用原始 Servlet API 对象作为方法参数"></a>使用原始 Servlet API 对象作为方法参数</h2><ul><li>Spring MVC 还支持使用原始 Servlet API 对象作为控制器方法的参数。</li><li>支持的原始 Servlet API 对象有： <ul><li><code>HttpServletRequest</code></li><li><code>HttpServletResponse</code></li><li><code>HttpSession</code></li><li><code>java.security.Principal</code></li><li><code>Locale</code></li><li><code>InputStream</code></li><li><code>OutputStream</code></li><li><code>Reader</code></li><li><code>Writer</code></li></ul></li><li>可以把上述对象，直接写在控制的方法参数中使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原生的 Servlet API</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testServletAPI"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testServletAPI</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 HttpSession session)</span> </span>&#123;</span><br><span class="line">        System.out.println(request);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"param/testServletAPI"</span>&gt;</span>测试原始ServletAPI<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.connector.RequestFacade@<span class="number">44</span>b0b762</span><br><span class="line">org.apache.catalina.connector.ResponseFacade@<span class="number">249</span>ae56b</span><br><span class="line">org.apache.catalina.session.StandardSessionFacade@<span class="number">77</span>ade9bf</span><br></pre></td></tr></table></figure><h1 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h1><h2 id="RequestParam-注解"><a href="#RequestParam-注解" class="headerlink" title="@RequestParam 注解"></a>@RequestParam 注解</h2><ul><li>作用：<ul><li><strong>把请求中指定名称的参数给控制器中的形参赋值</strong>。</li></ul></li><li>属性：<ul><li><code>name</code>：请求参数中的名称。作用与 <code>value</code> 属性一样。</li><li><code>required</code>：请求参数中是否必须提供此参数。默认值是 <code>true</code>，表示必须提供，如果不提供将报错。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"anno/testRequestParam?name=haha"</span>&gt;</span>RequestParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试RequestParam注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testRequestParam"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>, required = <span class="keyword">false</span>)</span> String username) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testRequestParam执行了"</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testRequestParam执行了</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><h2 id="RequestBody-注解"><a href="#RequestBody-注解" class="headerlink" title="@RequestBody 注解"></a>@RequestBody 注解</h2><ul><li>作用：<ul><li><strong>用于获取请求体内容</strong>。</li><li>直接使用得到是 <code>key=value&amp;key=value...</code> 结构的数据。</li><li><strong>GET 请求方式不适用</strong>。</li></ul></li><li>属性：<ul><li><code>required</code>：是否必须有请求体。默认值是 <code>true</code>，此时 GET 请求方式会报错。如果取值为 <code>false</code>，GET 请求得到的是 <code>null</code>。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"anno/testRequestBody"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试RequestBody注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testRequestBody"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(@RequestBody String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testRequestBody执行了"</span>);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testRequestBody执行了</span><br><span class="line">username=ffx&amp;age=<span class="number">22</span></span><br></pre></td></tr></table></figure><h2 id="PathVariable-注解"><a href="#PathVariable-注解" class="headerlink" title="@PathVariable 注解"></a>@PathVariable 注解</h2><ul><li>作用：<ul><li><strong>用于绑定 URL 中的占位符</strong>。</li><li>例如：请求 URL 中 <code>/delete/{id}</code>，这个 <code>{id}</code> 就是 URL 占位符。 </li><li>URL 支持占位符是 Spring 3.0 之后加入的，是 Spring MVC 支持 REST 风格 URL 的一个重要标志。</li></ul></li><li>属性：<ul><li><code>name</code>：用于指定 URL 中占位符名称。作用与 <code>value</code> 相同。</li><li><code>required</code>：是否必须提供占位符。</li></ul></li><li><strong>REST 风格 URL：</strong><ul><li>REST（Representational State Transfer）描述了一个架构样式的网络系统，比如 Web 应用程序。</li><li>在目前主流的三种 Web 服务交互方案中，REST 相比于 SOAP（Simple Object Access protocol，简单对象访问协议）以及 XML-RPC 更加简单明了，无论是对 URL 的处理还是对 Payload 的编码，REST 都倾向于用更加简单轻量的方法设计和实现。</li><li><strong>RESTful 的优点：结构清晰、符合标准、易于理解、扩展方便。</strong></li><li><strong>RESTful 的特性：请求路径一样，可以根据不同的请求方式去执行后台的不同方法。</strong></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"anno/testPathVariable/10"</span>&gt;</span>PathVariable<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试PathVariable注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testPathVariable/&#123;sid&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(name = <span class="string">"sid"</span>)</span> String id) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testPathVariable执行了"</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testPathVariable执行了</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="RequestHeader-注解"><a href="#RequestHeader-注解" class="headerlink" title="@RequestHeader 注解"></a>@RequestHeader 注解</h2><ul><li>作用：<ul><li>用于获取请求消息头。</li></ul></li><li>属性：<ul><li><code>name</code>：提供消息头名称。作用与 <code>value</code> 一样。</li><li><code>required</code>：是否必须有此消息头。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"anno/testRequestHeader"</span>&gt;</span>RequestHeader<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试RequestHeader注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> header</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testRequestHeader"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestHeader</span><span class="params">(@RequestHeader(name = <span class="string">"Accept"</span>)</span> String header) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testRequestHeader执行了"</span>);</span><br><span class="line">        System.out.println(header);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testRequestHeader执行了</span><br><span class="line">text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br></pre></td></tr></table></figure><h2 id="CookieValue-注解"><a href="#CookieValue-注解" class="headerlink" title="@CookieValue 注解"></a>@CookieValue 注解</h2><ul><li>作用：<ul><li><strong>用于把指定 cookie 名称的值传入控制器方法参数。</strong></li></ul></li><li>属性：<ul><li><code>name</code>：指定 cookie 的名称。与 <code>value</code> 作用相同。</li><li><code>required</code>：是否必须有此 cookie。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"anno/testCookieValue"</span>&gt;</span>CookieValue<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试CookieValue注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookieValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testCookieValue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testCookieValue</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String cookieValue) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testRequestHeader执行了"</span>);</span><br><span class="line">        System.out.println(cookieValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testRequestHeader执行了</span><br><span class="line">BDA6B29A37AE5845C578AD92DF143EF0</span><br></pre></td></tr></table></figure><h2 id="ModelAttribute-注解"><a href="#ModelAttribute-注解" class="headerlink" title="@ModelAttribute 注解"></a>@ModelAttribute 注解</h2><ul><li>作用：<ul><li>该注解是 Spring MVC 4.3 版本以后新加入的。它可以用于修饰方法和参数。</li><li><strong>出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。</strong>它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。</li><li><strong>出现在参数上，获取指定的数据给参数赋值。</strong></li></ul></li><li>属性：<ul><li><strong><code>value</code>：用于获取数据的 key。key 可以是 JavaBean 的属性名称，也可以是 <code>Map</code> 结构的 key。</strong>作用与 <code>name</code> 相同。</li></ul></li><li>应用场景：<ul><li>当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。</li></ul></li></ul><h3 id="修饰的方法有返回值"><a href="#修饰的方法有返回值" class="headerlink" title="修饰的方法有返回值"></a>修饰的方法有返回值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"anno/testModelAttribute"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试ModelAttribute注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testModelAttribute执行了"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法会先执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">showUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"showUser执行了"</span>);</span><br><span class="line">        <span class="comment">// 通过用户查询数据库（模拟）</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showUser执行了</span><br><span class="line">testModelAttribute执行了</span><br><span class="line">User&#123;name&#x3D;&#39;flexia&#39;, age&#x3D;22, birthday&#x3D;Mon Jun 22 18:46:04 CST 2020&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰的方法没有返回值"><a href="#修饰的方法没有返回值" class="headerlink" title="修饰的方法没有返回值"></a>修饰的方法没有返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试ModelAttribute注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(@ModelAttribute(<span class="string">"abc"</span>)</span> User user) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testModelAttribute执行了"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法会先执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">(String name, Map&lt;String, User&gt; map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"showUser执行了"</span>);</span><br><span class="line">        <span class="comment">// 通过用户查询数据库（模拟）</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        map.put(<span class="string">"abc"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showUser执行了</span><br><span class="line">testModelAttribute执行了</span><br><span class="line">User&#123;name&#x3D;&#39;test&#39;, age&#x3D;22, birthday&#x3D;Mon Jun 22 18:51:05 CST 2020&#125;</span><br></pre></td></tr></table></figure><h2 id="SessionAttributes-注解"><a href="#SessionAttributes-注解" class="headerlink" title="@SessionAttributes 注解"></a>@SessionAttributes 注解</h2><ul><li>作用：<ul><li><strong>用于多次执行控制器方法间的参数共享。</strong></li></ul></li><li>属性：<ul><li><code>value</code>：用于指定存入的属性名称。作用与 <code>name</code> 相同。</li><li><code>type</code>：用于指定存入的数据类型。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>入门成功<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    $&#123; requestScope.name &#125;</span><br><span class="line">    $&#123; sessionScope &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SessionAttribute --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"anno/testSessionAttribute"</span>&gt;</span>testSessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"anno/getSessionAttribute"</span>&gt;</span>getSessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"anno/delSessionAttribute"</span>&gt;</span>delSessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(value = &#123;<span class="string">"name"</span>, <span class="string">"age"</span>&#125;, types = &#123;String.class, Integer.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试SessionAttributes注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testSessionAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testSessionAttribute</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testSessionAttribute执行了"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>, <span class="string">"方方"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出SessionAttribute</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getSessionAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSessionAttribute</span><span class="params">(ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getSessionAttributes执行了"</span>);</span><br><span class="line">        String username = (String) modelMap.get(<span class="string">"name"</span>);</span><br><span class="line">        Integer password = (Integer) modelMap.get(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(username + <span class="string">", "</span> + password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除SessionAttribute</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/delSessionAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delSessionAttribute</span><span class="params">(SessionStatus status)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delSessionAttributes执行了"</span>);</span><br><span class="line">        status.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">testSessionAttribute执行了</span><br><span class="line">getSessionAttributes执行了</span><br><span class="line">方方, 18</span><br><span class="line">delSessionAttributes执行了</span><br><span class="line">getSessionAttributes执行了</span><br><span class="line">null, null</span><br></pre></td></tr></table></figure><h1 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a>响应数据和结果视图</h1><h2 id="返回值分类"><a href="#返回值分类" class="headerlink" title="返回值分类"></a>返回值分类</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>Controller 方法返回字符串可以<strong>指定逻辑视图名</strong>，通过视图解析器解析为物理视图地址。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testString"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testString</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testString方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 模拟从数据库中查询出User对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"test"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"1234"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/响应结果为String.png" alt></p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><ul><li>前面已经介绍，<strong>Servlet 原始 API 可以作为控制器中方法的参数</strong>。</li><li>当处理器方法返回值为 <code>void</code> 时，可以借助 Servlet 原始 API 来进行处理。</li><li>使用 <code>request</code> 将<strong>请求转发</strong>到另一个页面：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testVoid"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testString方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 编写请求转发的程序，请求转发是一次请求，不用编写项目名</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/success.jsp"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/响应结果为void-请求转发.png" alt></p><ul><li>也可以通过 <code>response</code> <strong>重定向</strong>页面：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testVoid"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testString方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 重定向是两次请求，不能直接请求WEB-INF下的文件</span></span><br><span class="line">        response.sendRedirect(request.getContextPath() + <span class="string">"/redirect.jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/响应结果为void-重定向.png" alt></p><ul><li>也可以通过 <code>response</code> <strong>直接响应</strong>结果给浏览器，比如响应 json 数据：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testVoid"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testString方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 直接响应</span></span><br><span class="line">        <span class="comment">// 设置中文乱码</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        response.getWriter().print(<span class="string">"hello, 小方方"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/响应结果为void-直接响应.png" alt></p><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><ul><li><code>ModelAndView</code> 是 Spring MVC 提供的一个对象，该对象也可以用作控制器方法的返回值。</li><li>该对象中有两个方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAndView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add an attribute to the model.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">addObject</span><span class="params">(String attributeName, @Nullable Object attributeValue)</span> </span>&#123;</span><br><span class="line">        getModelMap().addAttribute(attributeName, attributeValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set a view name for this ModelAndView, to be resolved by the</span></span><br><span class="line"><span class="comment">     * DispatcherServlet via a ViewResolver. Will override any</span></span><br><span class="line"><span class="comment">     * pre-existing view name or View.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewName</span><span class="params">(@Nullable String viewName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = viewName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"response/testModelAndView"</span>&gt;</span>testModelAndView<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testModelAndView"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testModelAndView方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 创建ModelAndView对象</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 模拟从数据库中查询出User对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"test"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"1234"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 把user对象存储到mv对象中，也会把user对象存入到request对象中</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="comment">// 跳转到哪个页面</span></span><br><span class="line">        mv.setViewName(<span class="string">"success"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/响应结果为ModelAndView.png" alt></p><h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><h3 id="forward-转发"><a href="#forward-转发" class="headerlink" title="forward 转发"></a>forward 转发</h3><ul><li>Controller 方法在提供了 <code>String</code> 类型的返回值之后，默认就是请求转发。</li><li>可以使用 <code>forward</code> 关键字显式进行请求转发。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"response/testForwardOrRedirect"</span>&gt;</span>testForwardOrRedirect<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testForwardOrRedirect"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testForwardOrRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testForwardOrRedirect方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 请求转发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/WEB-INF/pages/success.jsp"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要注意的是，如果用了 <code>forward</code>，则路径必须写成实际视图 URL，不能写逻辑视图。 它相当于 <code>request.getRequestDispatcher(&quot;url&quot;).forward(request,response)</code>。</li><li>使用请求转发，既可以转发到 JSP 页面，也可以转发到其他的控制器方法。</li></ul><h3 id="redirect-重定向"><a href="#redirect-重定向" class="headerlink" title="redirect 重定向"></a>redirect 重定向</h3><ul><li>Controller 方法提供了一个 <code>String</code> 类型返回值之后，它需要在返回值里使用 <code>redirect</code> 关键字进行重定向。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testForwardOrRedirect"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testForwardOrRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testForwardOrRedirect方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 重定向</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/redirect.jsp"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它相当于 <code>response.sendRedirect(url)</code>。需要注意的是，如果是重定向到 JSP 页面，则 JSP 页面不能写在 WEB-INF 目录中，否则无法找到。</li></ul><h2 id="ResponseBody-响应-json-数据"><a href="#ResponseBody-响应-json-数据" class="headerlink" title="@ResponseBody 响应 json 数据"></a>@ResponseBody 响应 json 数据</h2><ul><li><strong><code>@ResponseBody</code> 注解用于将 Controller 的方法返回的对象，通过 <code>HttpMessageConverter</code> 接口转换为指定格式的数据，如 json，xml 等，通过 <code>Response</code> 响应给客户端。</strong></li></ul><h3 id="配置-DispatcherServlet-不拦截静态资源"><a href="#配置-DispatcherServlet-不拦截静态资源" class="headerlink" title="配置 DispatcherServlet 不拦截静态资源"></a>配置 DispatcherServlet 不拦截静态资源</h3><ul><li><code>DispatcherServlet</code> 会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。</li><li>解决问题就是需要配置静态资源不进行拦截，在 <code>springmvc.xml</code> 配置文件添加如下配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置前端控制器，哪些静态资源不拦截 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- location表示路径，mapping表示文件，**表示该目录下的文件以及子目录的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/css/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span> <span class="attr">location</span>=<span class="string">"/images/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-RequestBody-获取请求体数据"><a href="#使用-RequestBody-获取请求体数据" class="headerlink" title="使用 @RequestBody 获取请求体数据"></a>使用 @RequestBody 获取请求体数据</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 页面加载，绑定单击事件</span></span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 发送ajax请求</span></span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 编写json格式，设置属性和值</span></span></span><br><span class="line"><span class="actionscript">                    url: <span class="string">"response/testJson"</span>,</span></span><br><span class="line"><span class="actionscript">                    contentType: <span class="string">"application/json;charset=UTF-8"</span>,</span></span><br><span class="line"><span class="actionscript">                    data: <span class="string">'&#123;"username":"testJson","password":"1234","age":18&#125;'</span>,</span></span><br><span class="line"><span class="actionscript">                    dataType: <span class="string">"json"</span>,</span></span><br><span class="line"><span class="actionscript">                    type: <span class="string">"post"</span>,</span></span><br><span class="line"><span class="actionscript">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                        <span class="comment">// data是服务器端响应的数据，进行解析</span></span></span><br><span class="line"><span class="actionscript">                        alert(data.username + <span class="string">" "</span> + data.password + <span class="string">" "</span> + data.age);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试异步请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>发送ajax请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testJson"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson</span><span class="params">(@RequestBody String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testJson方法执行了"</span>);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-RequestBody-把-json-字符串转换为-JavaBean-对象"><a href="#使用-RequestBody-把-json-字符串转换为-JavaBean-对象" class="headerlink" title="使用 @RequestBody 把 json 字符串转换为 JavaBean 对象"></a>使用 @RequestBody 把 json 字符串转换为 JavaBean 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testJson"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testJson方法执行了"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-ResponseBody-把-JavaBean-对象转换为-json-字符串"><a href="#使用-ResponseBody-把-JavaBean-对象转换为-json-字符串" class="headerlink" title="使用 @ResponseBody 把 JavaBean 对象转换为 json 字符串"></a>使用 @ResponseBody 把 JavaBean 对象转换为 json 字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/response"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟异步请求响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testJson"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">testJson</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testJson方法执行了"</span>);</span><br><span class="line">        <span class="comment">// 客户端发送ajax请求传的是json字符串，后端把json字符串封装到user对象中</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">// 作响应，模拟查询数据库</span></span><br><span class="line">        user.setUsername(<span class="string">"testAjax"</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/响应json数据.png" alt></p><h3 id="JavaBean-对象和-json-字符串之间的转换需要使用-jackson-的-jar-包"><a href="#JavaBean-对象和-json-字符串之间的转换需要使用-jackson-的-jar-包" class="headerlink" title="JavaBean 对象和 json 字符串之间的转换需要使用 jackson 的 jar 包"></a>JavaBean 对象和 json 字符串之间的转换需要使用 jackson 的 jar 包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring-MVC-实现文件上传"><a href="#Spring-MVC-实现文件上传" class="headerlink" title="Spring MVC 实现文件上传"></a>Spring MVC 实现文件上传</h1><h2 id="文件上传的原理"><a href="#文件上传的原理" class="headerlink" title="文件上传的原理"></a>文件上传的原理</h2><h3 id="文件上传的必要前提"><a href="#文件上传的必要前提" class="headerlink" title="文件上传的必要前提"></a>文件上传的必要前提</h3><ol><li><strong><code>form</code> 表单的 <code>enctype</code> 取值必须是 <code>multipart/form-data</code> 。</strong><ul><li><code>enctype</code>：是表单请求正文的类型。</li><li>默认值是：<code>application/x-www-form-urlencoded</code>。</li></ul></li><li><strong><code>method</code> 属性取值必须是 <code>post</code>。</strong></li><li><strong>提供一个文件选择域 <code>&lt;input type=&quot;file&quot;/&gt;</code>。</strong></li></ol><h3 id="文件上传的原理分析"><a href="#文件上传的原理分析" class="headerlink" title="文件上传的原理分析"></a>文件上传的原理分析</h3><ul><li>当 <code>form</code> 表单的 <code>enctype</code> 取值不是默认值后，<code>request.getParameter()</code> 将失效。</li><li>当 <code>form</code> 表单的 <code>enctype</code> 取值为 <code>application/x-www-form-urlencoded</code> 时，<code>form</code> 表单的正文内容是 <code>key=value&amp;key=value&amp;key=value</code>。</li><li>当 <code>form</code> 表单的 <code>enctype</code> 取值为 <code>mutilpart/form-data</code> 时，它会<strong>将表单的数据处理为一条消息，以标签为单元，用分隔符分开。</strong>既可以上传键值对，也可以上传文件等二进制数据。当上传的字段是文件时，会有 <code>Content-Type</code> 来说明文件类型，<code>Content-Disposition</code> 用来说明字段的一些信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------7de1a433602ac          分界符</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;userName&quot;     协议头</span><br><span class="line">aaa                                                 协议的正文</span><br><span class="line">-----------------------------7de1a433602ac</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;xxx\b.txt&quot;</span><br><span class="line">Content-Type: text&#x2F;plain                            协议的类型（MIME类型）</span><br><span class="line">bbb</span><br><span class="line">-----------------------------7de1a433602ac--</span><br></pre></td></tr></table></figure><h3 id="传统方式实现文件上传"><a href="#传统方式实现文件上传" class="headerlink" title="传统方式实现文件上传"></a>传统方式实现文件上传</h3><ul><li>导入坐标：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写文件上传的 JSP 页面：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>文件上传<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"user/fileupload1"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        选择文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"upload"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写文件上传的 Controller 控制器：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传统方式上传文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileupload1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload1</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传统方式文件上传..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用fileupload组件完成文件上传</span></span><br><span class="line">        <span class="comment">// 上传的位置</span></span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads/"</span>);</span><br><span class="line">        <span class="comment">// 判断该路径是否存在</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析request对象，获取上传的文件项</span></span><br><span class="line">        DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">        List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (FileItem item : items) &#123;</span><br><span class="line">            <span class="comment">// 判断当前item对象是否是上传文件选项</span></span><br><span class="line">            <span class="keyword">if</span> (!item.isFormField()) &#123;</span><br><span class="line">                <span class="comment">// 上传文件项</span></span><br><span class="line">                <span class="comment">// 获取上传文件的名称</span></span><br><span class="line">                String filename = item.getName();</span><br><span class="line">                <span class="comment">// 把文件的名称设置成唯一值uuid</span></span><br><span class="line">                String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">                filename = uuid + <span class="string">"_"</span> + filename;</span><br><span class="line">                <span class="comment">// 完成文件上传</span></span><br><span class="line">                item.write(<span class="keyword">new</span> File(path, filename));</span><br><span class="line">                <span class="comment">// 删除临时文件</span></span><br><span class="line">                item.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-MVC-方式的文件上传"><a href="#Spring-MVC-方式的文件上传" class="headerlink" title="Spring MVC 方式的文件上传"></a>Spring MVC 方式的文件上传</h2><ul><li><strong>Spring MVC 框架提供了 <code>MultipartFile</code> 对象，该对象表示上传的文件，要求变量名称必须和表单 <code>file</code> 标签的 <code>name</code> 属性名称相同。</strong></li></ul><p><img src="/2020/06/25/springmvc/springmvc上传文件的原理.bmp" alt></p><h3 id="编写控制器"><a href="#编写控制器" class="headerlink" title="编写控制器"></a>编写控制器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpringMVC方式上传文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> upload </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileupload2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload2</span><span class="params">(HttpServletRequest request, MultipartFile upload)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringMVC方式文件上传..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上传的位置</span></span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads/"</span>);</span><br><span class="line">        <span class="comment">// 判断该路径是否存在</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取上传文件的名称</span></span><br><span class="line">        String filename = upload.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 把文件的名称设置成唯一值uuid</span></span><br><span class="line">        String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        filename = uuid + <span class="string">"_"</span> + filename;</span><br><span class="line">        <span class="comment">// 完成文件上传</span></span><br><span class="line">        upload.transferTo(<span class="keyword">new</span> File(path, filename));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件解析器"><a href="#配置文件解析器" class="headerlink" title="配置文件解析器"></a>配置文件解析器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件解析器对象，要求id名称必须是multipartResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"10485760"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意： 文件上传的解析器 <code>id</code> 是固定的，不能起别的名称，否则无法实现请求参数的绑定（不光是文件，其他字段也将无法绑定）。</li></ul><h2 id="跨服务器方式的文件上传"><a href="#跨服务器方式的文件上传" class="headerlink" title="跨服务器方式的文件上传"></a>跨服务器方式的文件上传</h2><h3 id="分服务器的目的"><a href="#分服务器的目的" class="headerlink" title="分服务器的目的"></a>分服务器的目的</h3><ul><li>在实际开发中，我们会有很多处理不同功能的服务器。例如：<ul><li>应用服务器：负责部署我们的应用。</li><li>数据库服务器：运行我们的数据库。</li><li>缓存和消息服务器：负责处理大并发访问的缓存和消息。</li><li>文件服务器：负责存储用户上传文件的服务器。</li></ul></li><li>注意：此处说的不是服务器集群。</li><li>分服务器处理的目的是让服务器各司其职，从而提高我们项目的运行效率。</li></ul><h3 id="准备两个-Tomcat-服务器，并创建一个用于存放文件的-Web-工程"><a href="#准备两个-Tomcat-服务器，并创建一个用于存放文件的-Web-工程" class="headerlink" title="准备两个 Tomcat 服务器，并创建一个用于存放文件的 Web 工程"></a>准备两个 Tomcat 服务器，并创建一个用于存放文件的 Web 工程</h3><ul><li>在 Tomcat 根目录下 <code>/conf/web.xml</code> 中添加配置，使所有 Tomcat 服务器允许读写操作。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>readonly<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在 web 目录下创建 uploads 文件夹，用于存放上传的文件。</li></ul><h3 id="导入必要坐标"><a href="#导入必要坐标" class="headerlink" title="导入必要坐标"></a>导入必要坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写控制器实现跨服务器上传文件"><a href="#编写控制器实现跨服务器上传文件" class="headerlink" title="编写控制器实现跨服务器上传文件"></a>编写控制器实现跨服务器上传文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨服务器方式上传文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> upload</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileupload3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload3</span><span class="params">(MultipartFile upload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"跨服务器方式文件上传..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义上传文件服务器路径</span></span><br><span class="line">        String path = <span class="string">"http://localhost:9090/fileuploadserver_war/uploads/"</span>;</span><br><span class="line">        <span class="comment">// 获取上传文件的名称</span></span><br><span class="line">        String filename = upload.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 设置文件名使用UTF-8编码，解决带有中文名称的文件上传报错问题</span></span><br><span class="line">        filename = URLEncoder.encode(filename, <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 把文件的名称设置成唯一值uuid</span></span><br><span class="line">        String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        filename = uuid + <span class="string">"_"</span> + filename;</span><br><span class="line">        <span class="comment">// 创建客户端对象</span></span><br><span class="line">        Client client = Client.create();</span><br><span class="line">        <span class="comment">// 和图片服务器连接</span></span><br><span class="line">        WebResource webResource = client.resource(path + filename);</span><br><span class="line">        <span class="comment">// 上传文件</span></span><br><span class="line">        webResource.put(upload.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-MVC-中的异常处理"><a href="#Spring-MVC-中的异常处理" class="headerlink" title="Spring MVC 中的异常处理"></a>Spring MVC 中的异常处理</h1><h2 id="异常处理的思路"><a href="#异常处理的思路" class="headerlink" title="异常处理的思路"></a>异常处理的思路</h2><ul><li>系统中异常包括两类：预期异常和运行时异常 <code>RuntimeException</code>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 </li><li><strong>系统的 dao、service、controller 出现异常都通过 throws Exception 向上抛出，最后由 Spring MVC 前端控制器交由异常处理器进行异常处理。</strong></li></ul><p><img src="/2020/06/25/springmvc/springmvc异常处理的思路.bmp" alt></p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="编写异常类"><a href="#编写异常类" class="headerlink" title="编写异常类"></a>编写异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储提示信息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写错误页面"><a href="#编写错误页面" class="headerlink" title="编写错误页面"></a>编写错误页面</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">isELIgnored</span>=<span class="string">"false"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>执行失败<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    $&#123;errorMsg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到异常对象</span></span><br><span class="line">        CustomException e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> CustomException) &#123;</span><br><span class="line">            e = (CustomException) ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            e = <span class="keyword">new</span> CustomException(<span class="string">"系统正在维护"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ModelAndView对象</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"errorMsg"</span>, e.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置异常处理器"><a href="#配置异常处理器" class="headerlink" title="配置异常处理器"></a>配置异常处理器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置异常处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customExceptionResolver"</span> <span class="attr">class</span>=<span class="string">"exception.CustomExceptionResolver"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试异常处理结果"><a href="#测试异常处理结果" class="headerlink" title="测试异常处理结果"></a>测试异常处理结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testException"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testException</span><span class="params">()</span> <span class="keyword">throws</span> CustomException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testException..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="comment">// 抛出自定义异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"查询所有用户出现错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>异常处理<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"user/testException"</span>&gt;</span>异常处理<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/测试异常处理的执行结果.png" alt></p><h1 id="Spring-MVC-中的拦截器"><a href="#Spring-MVC-中的拦截器" class="headerlink" title="Spring MVC 中的拦截器"></a>Spring MVC 中的拦截器</h1><h2 id="拦截器概述"><a href="#拦截器概述" class="headerlink" title="拦截器概述"></a>拦截器概述</h2><ul><li>Spring MVC 框架中的拦截器用于对处理器进行预处理和后处理的技术。</li><li>可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。</li><li>拦截器和过滤器的功能比较类似，但是也有区别：<ul><li>过滤器是 <code>servlet</code> 规范中的一部分，任何 java web 工程都可以使用。</li><li>拦截器是 Spring MVC 框架自己的，只有使用了 Spring MVC 框架的工程才能用。</li><li>过滤器在 <code>url-pattern</code> 中配置了 <code>/*</code> 之后，可以对所有要访问的资源拦截。</li><li>拦截器只会拦截访问的控制器方法，如果访问的是 jsp、html、css、image 或者 js，是不会进行拦截的。</li></ul></li><li>拦截器也是 AOP 思想的一种实现方式。</li><li>想要自定义拦截器，需要实现 <code>HandlerInterceptor</code> 接口。</li></ul><p><img src="/2020/06/25/springmvc/拦截器.bmp" alt></p><h2 id="自定义拦截器的步骤"><a href="#自定义拦截器的步骤" class="headerlink" title="自定义拦截器的步骤"></a>自定义拦截器的步骤</h2><h3 id="编写拦截器类，实现-HandlerInterceptor-接口，重写需要的方法"><a href="#编写拦截器类，实现-HandlerInterceptor-接口，重写需要的方法" class="headerlink" title="编写拦截器类，实现 HandlerInterceptor 接口，重写需要的方法"></a>编写拦截器类，实现 HandlerInterceptor 接口，重写需要的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理，在controller方法执行前，进行拦截的方法</span></span><br><span class="line"><span class="comment">     * return true 放行</span></span><br><span class="line"><span class="comment">     * return false 拦截</span></span><br><span class="line"><span class="comment">     * 可以使用转发或者重定向直接跳转到指定的页面。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置拦截器类"><a href="#配置拦截器类" class="headerlink" title="配置拦截器类"></a>配置拦截器类</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要拦截的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/user/*"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册拦截器对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.interceptor.MyInterceptor1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写控制器类"><a href="#编写控制器类" class="headerlink" title="编写控制器类"></a>编写控制器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testInterceptor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testInterceptor执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写相关页面并测试"><a href="#编写相关页面并测试" class="headerlink" title="编写相关页面并测试"></a>编写相关页面并测试</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>执行成功<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">System.out.println</span>("<span class="attr">success.jsp</span>也执行了<span class="attr">...</span>"); %&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyInterceptor执行了...</span><br><span class="line">testInterceptor执行了...</span><br><span class="line">success.jsp也执行了...</span><br></pre></td></tr></table></figure><h2 id="HandlerInterceptor-接口中的方法"><a href="#HandlerInterceptor-接口中的方法" class="headerlink" title="HandlerInterceptor 接口中的方法"></a>HandlerInterceptor 接口中的方法</h2><ul><li><code>HandlerInterceptor</code> 接口的源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截执行程序的执行。</span></span><br><span class="line"><span class="comment">     * 在HandlerMapping确定适当的处理程序对象之后，</span></span><br><span class="line"><span class="comment">     * 但在HandlerAdapter调用处理程序之前调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                              HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截执行程序的执行。</span></span><br><span class="line"><span class="comment">     * 在HandlerAdapter实际调用处理程序之后，</span></span><br><span class="line"><span class="comment">     * 但在DispatcherServlet呈现视图之前调用。</span></span><br><span class="line"><span class="comment">     * 可以通过给定的ModelAndView将其他模型对象公开给视图。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成请求处理后（即渲染视图后）的回调。</span></span><br><span class="line"><span class="comment">     * 将在处理程序执行的任何结果上被调用，从而允许进行适当的资源清理。</span></span><br><span class="line"><span class="comment">     * 注意：仅当此拦截器的preHandle方法成功完成并返回true时才会调用！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="preHandler-方法"><a href="#preHandler-方法" class="headerlink" title="preHandler 方法"></a>preHandler 方法</h3><ul><li><code>preHandle</code> 方法是 controller 方法执行前拦截的方法：<ol><li>可以使用 <code>request</code> 或者 <code>response</code> 跳转到指定的页面。</li><li><code>return true</code> 放行，执行下一个拦截器，如果没有拦截器，执行 controller 中的方法。</li><li><code>return false</code> 不放行，不会执行 controller 中的方法。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor预处理方法执行了..."</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/error.jsp"</span>).forward(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/拦截器导向error界面.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyInterceptor预处理方法执行了...</span><br></pre></td></tr></table></figure><h3 id="postHandler-方法"><a href="#postHandler-方法" class="headerlink" title="postHandler 方法"></a>postHandler 方法</h3><ul><li><code>postHandle</code> 是 controller 方法执行后执行的方法，在 JSP 视图执行前。<ol><li>可以使用 <code>request</code> 或者 <code>response</code> 跳转到指定的页面</li><li>如果指定了跳转的页面，那么 controller 方法跳转的页面将不会显示。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor预处理方法执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor后处理方法执行了..."</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/error.jsp"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/拦截器导向error界面.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyInterceptor预处理方法执行了...</span><br><span class="line">testInterceptor执行了...</span><br><span class="line">MyInterceptor后处理方法执行了...</span><br><span class="line">success.jsp也执行了...</span><br></pre></td></tr></table></figure><h3 id="afterCompletion-方法"><a href="#afterCompletion-方法" class="headerlink" title="afterCompletion 方法"></a>afterCompletion 方法</h3><ul><li><code>postHandle</code> 方法是在 JSP 执行后执行，<code>request</code> 或者 <code>response</code> 不能再跳转页面了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor预处理方法执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor后处理方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成请求处理后（即渲染视图后）的回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor完成请求处理后的回调方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/25/springmvc/拦截器简单流程.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyInterceptor预处理方法执行了...</span><br><span class="line">testInterceptor执行了...</span><br><span class="line">MyInterceptor后处理方法执行了...</span><br><span class="line">success.jsp也执行了...</span><br><span class="line">MyInterceptor完成请求处理后的回调方法执行了...</span><br></pre></td></tr></table></figure><h2 id="拦截器链的执行流程"><a href="#拦截器链的执行流程" class="headerlink" title="拦截器链的执行流程"></a>拦截器链的执行流程</h2><ul><li>配置两个拦截器：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要拦截的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/user/*"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册拦截器对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.interceptor.MyInterceptor1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要拦截的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册拦截器对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.interceptor.MyInterceptor2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="正常流程测试"><a href="#正常流程测试" class="headerlink" title="正常流程测试"></a>正常流程测试</h3><ul><li>拦截器 1：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor1预处理方法执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor1后处理方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor1完成请求处理后的回调方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拦截器 2：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor2</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2预处理方法执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2后处理方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2完成请求处理后的回调方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果显示 success.jsp 界面，控制台输出如下内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyInterceptor1预处理方法执行了...</span><br><span class="line">MyInterceptor2预处理方法执行了...</span><br><span class="line">testInterceptor执行了...</span><br><span class="line">MyInterceptor2后处理方法执行了...</span><br><span class="line">MyInterceptor1后处理方法执行了...</span><br><span class="line">success.jsp也执行了...</span><br><span class="line">MyInterceptor2完成请求处理后的回调方法执行了...</span><br><span class="line">MyInterceptor1完成请求处理后的回调方法执行了...</span><br></pre></td></tr></table></figure><h3 id="中断流程测试"><a href="#中断流程测试" class="headerlink" title="中断流程测试"></a>中断流程测试</h3><ul><li>拦截器 2：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor2</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2预处理方法执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2后处理方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2完成请求处理后的回调方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果显示空白页面，控制台输出如下结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyInterceptor1预处理方法执行了...</span><br><span class="line">MyInterceptor2预处理方法执行了...</span><br><span class="line">MyInterceptor1完成请求处理后的回调方法执行了...</span><br></pre></td></tr></table></figure><h3 id="两个拦截器的执行流程总结"><a href="#两个拦截器的执行流程总结" class="headerlink" title="两个拦截器的执行流程总结"></a>两个拦截器的执行流程总结</h3><p><img src="/2020/06/25/springmvc/两个拦截器的执行流程.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架（2）</title>
      <link href="/2020/06/19/spring-2.html"/>
      <url>/2020/06/19/spring-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="案例：转账需要事务控制"><a href="#案例：转账需要事务控制" class="headerlink" title="案例：转账需要事务控制"></a>案例：转账需要事务控制</h1><ul><li>在上一节基于 XML 配置的 CRUD 案例中添加转账方法。</li></ul><h2 id="添加转账相关方法"><a href="#添加转账相关方法" class="headerlink" title="添加转账相关方法"></a>添加转账相关方法</h2><h3 id="业务层添加转账方法"><a href="#业务层添加转账方法" class="headerlink" title="业务层添加转账方法"></a>业务层添加转账方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName 转出账户名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName 转入账户名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money      转账金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据名称查询转出账户</span></span><br><span class="line">        Account source = accountDao.findByName(sourceName);</span><br><span class="line">        <span class="comment">// 根据名称查询转入账户</span></span><br><span class="line">        Account target = accountDao.findByName(targetName);</span><br><span class="line">        <span class="comment">// 转出账户减钱</span></span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        <span class="comment">// 转入账户加钱</span></span><br><span class="line">        target.setMoney(target.getMoney() + money);</span><br><span class="line">        <span class="comment">// 更新转出账户</span></span><br><span class="line">        accountDao.update(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟转账异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新转入账户</span></span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久层添加-findByName-方法"><a href="#持久层添加-findByName-方法" class="headerlink" title="持久层添加 findByName() 方法"></a>持久层添加 findByName() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称查询账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果有唯一的结果就返回，如果没有结果就返回null，如果结果集超过一个就抛出异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findByName</span><span class="params">(String accountName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunner</span><span class="params">(QueryRunner runner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runner = runner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Account&gt; accounts = runner.query(<span class="string">"select * from account where name = ?"</span>,</span><br><span class="line">                    <span class="keyword">new</span> BeanListHandler&lt;&gt;(Account.class), accountName);</span><br><span class="line">            <span class="keyword">if</span> (accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一，数据有问题"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            account = accounts.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试转账案例"><a href="#测试转账案例" class="headerlink" title="测试转账案例"></a>测试转账案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:bean.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService as;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        as.transfer(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="number">500F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行时，由于执行有异常，转账失败。</li><li>但是因为每次执行持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性）。</li></ul><h2 id="开启事务控制"><a href="#开启事务控制" class="headerlink" title="开启事务控制"></a>开启事务控制</h2><ul><li>让业务层来控制事务的提交和回滚。</li></ul><h3 id="编写连接工具类-ConnectionUtils"><a href="#编写连接工具类-ConnectionUtils" class="headerlink" title="编写连接工具类 ConnectionUtils"></a>编写连接工具类 ConnectionUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接的工具类，用于从数据源中获取一个连接，并且实现与线程的绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程上的连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回与当前线程绑定的连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = tl.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = dataSource.getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接释放后，从线程中移除已关闭的连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写事务管理工具类-TransactionManager"><a href="#编写事务管理工具类-TransactionManager" class="headerlink" title="编写事务管理工具类 TransactionManager"></a>编写事务管理工具类 TransactionManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务管理工具类，包含开启事务、提交事务、回滚事务和释放连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().close();</span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造业务层实现类"><a href="#改造业务层实现类" class="headerlink" title="改造业务层实现类"></a>改造业务层实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(TransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            transactionManager.beginTransaction();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findByName(sourceName);</span><br><span class="line">            <span class="comment">// 根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findByName(targetName);</span><br><span class="line">            <span class="comment">// 转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney() - money);</span><br><span class="line">            <span class="comment">// 转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney() + money);</span><br><span class="line">            <span class="comment">// 更新转出账户</span></span><br><span class="line">            accountDao.update(source);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟转账异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新转入账户</span></span><br><span class="line">            accountDao.update(target);</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            transactionManager.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            transactionManager.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放连接</span></span><br><span class="line">            transactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改造持久层实现类"><a href="#改造持久层实现类" class="headerlink" title="改造持久层实现类"></a>改造持久层实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunner</span><span class="params">(QueryRunner runner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runner = runner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(),</span><br><span class="line">                    <span class="string">"select * from account where name = ?"</span>,</span><br><span class="line">                    <span class="keyword">new</span> BeanListHandler&lt;&gt;(Account.class), accountName);</span><br><span class="line">            <span class="keyword">if</span> (accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一，数据有问题"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            account = accounts.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-XML-配置文件"><a href="#修改-XML-配置文件" class="headerlink" title="修改 XML 配置文件"></a>修改 XML 配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Dao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入QueryRunner --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"runner"</span> <span class="attr">ref</span>=<span class="string">"runner"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置QueryRunner --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接数据源的必备信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置管理连接的工具类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionUtils"</span> <span class="attr">class</span>=<span class="string">"utils.ConnectionUtils"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"utils.TransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过对业务层的改造，已经实现了事务控制。</li><li>但是产生了新的问题，业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了。</li><li>试想一下，如果此时提交、回滚、释放资源中任何一个方法名变更，都需要修改业务层的代码，况且这还只是一个业务层实现类，而实际的项目中这种业务层实现类可能有十几个甚至几十个。</li></ul><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="动态代理介绍"><a href="#动态代理介绍" class="headerlink" title="动态代理介绍"></a>动态代理介绍</h2><ul><li>特点：<ul><li><strong>字节码随用随创建，随用随加载</strong>。</li><li>它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。</li></ul></li><li>作用：<ul><li>不修改源码的基础上对方法增强。</li></ul></li><li>分类：<ul><li><strong>基于接口的动态代理</strong>：<ul><li>涉及的类：<code>Proxy</code>。</li><li>提供者：JDK 官方。</li><li>要求：<strong>被代理类最少实现一个接口</strong>。</li></ul></li><li><strong>基于子类的动态代理</strong>：<ul><li>涉及的类：<code>Enhancer</code>。</li><li>提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。</li><li>要求：<strong>被代理类不能是用 <code>final</code> 修饰的类（最终类）</strong>。</li></ul></li></ul></li></ul><h2 id="如何创建动态代理对象"><a href="#如何创建动态代理对象" class="headerlink" title="如何创建动态代理对象"></a>如何创建动态代理对象</h2><h3 id="使用-JDK-官方的-Proxy-类创建代理对象"><a href="#使用-JDK-官方的-Proxy-类创建代理对象" class="headerlink" title="使用 JDK 官方的 Proxy 类创建代理对象"></a>使用 JDK 官方的 Proxy 类创建代理对象</h3><ul><li>创建代理对象：<ul><li>使用 <code>Proxy</code> 类中的 <code>newProxyInstance()</code> 方法。</li></ul></li><li>要求：<ul><li>被代理类必须实现至少一个接口。</li></ul></li><li>方法参数：<ul><li><code>ClassLoader</code>：和被代理对象使用相同的类加载器。</li><li><code>Class[]</code>：和被代理对象具有相同的行为（实现相同的接口）。</li><li><code>InvocationHandler</code>：<strong>如何代理，用于提供增强的方法</strong>（策略模式：数据有了，目的明确，如何达成目标，就是策略）。</li></ul></li><li><code>InvocationHandler</code> 接口中只有一个方法 <code>invoke()</code> ：<ul><li>作用：<strong>执行被代理对象的任何接口方法都会经过该 <code>invoke</code> 方法</strong>。</li><li>参数含义：<ul><li><code>proxy</code>：代理对象的引用。</li><li><code>method</code>：当前执行的方法对象。</li><li><code>args</code>：当前执行方法所需的参数。</li></ul></li><li>返回值：和被代理对象方法有相同的返回值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对生产厂家要求的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销售产品，并拿到钱："</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提供售后服务，并拿到钱："</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一个消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生产厂家</span></span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        <span class="comment">// 代理商</span></span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(</span><br><span class="line">                producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 接收方法返回值</span></span><br><span class="line">                        Object returnValue;</span><br><span class="line">                        <span class="comment">// 获取方法执行的参数</span></span><br><span class="line">                        Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">// 判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">                            returnValue = method.invoke(producer, money * <span class="number">0.8f</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            returnValue = method.invoke(producer, money);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 代理商进行销售</span></span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-CGLib-的-Enhancer-类创建代理对象"><a href="#使用-CGLib-的-Enhancer-类创建代理对象" class="headerlink" title="使用 CGLib 的 Enhancer 类创建代理对象"></a>使用 CGLib 的 Enhancer 类创建代理对象</h3><ul><li>创建代理对象：<ul><li>使用 <code>Enhancer</code> 类中的 <code>create()</code> 方法。</li></ul></li><li>要求：<ul><li>被代理类不能是最终类。</li></ul></li><li>方法参数：<ul><li><code>Class</code>：被代理对象的字节码。</li><li><code>Callback</code>：如何代理，用于提供增强的方法。一般使用该接口的子接口 <code>MethodIntercepter</code> 的实现类。</li></ul></li><li><code>MethodIntercepter</code> 接口中仅有一个 <code>intercept()</code> 方法：<ul><li>作用：<strong>执行被代理对象的任何接口方法都会经过该 <code>intercept</code> 方法</strong>。</li><li>参数含义：<ul><li><code>obj</code>：代理对象的引用。</li><li><code>method</code>：当前执行的方法对象。</li><li><code>args</code>：当前执行方法所需的参数。</li><li><code>proxy</code>：当前执行方法的代理对象。</li></ul></li><li>返回值：和被代理对象方法有相同的返回值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销售产品，并拿到钱："</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提供售后服务，并拿到钱："</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一个消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生产厂家</span></span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理商</span></span><br><span class="line">        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 接收方法返回值</span></span><br><span class="line">                Object returnValue;</span><br><span class="line">                <span class="comment">// 获取方法执行的参数</span></span><br><span class="line">                Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money * <span class="number">0.8f</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cglibProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用动态代理实现转账案例中的事务控制"><a href="#使用动态代理实现转账案例中的事务控制" class="headerlink" title="使用动态代理实现转账案例中的事务控制"></a>使用动态代理实现转账案例中的事务控制</h2><ul><li>使用工厂来创建业务层的动态代理对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建 Service 代理对象的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountService</span><span class="params">(AccountService accountService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountService = accountService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(TransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Service 的代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">getAccountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (AccountService) Proxy.newProxyInstance(</span><br><span class="line">                accountService.getClass().getClassLoader(),</span><br><span class="line">                accountService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 添加事务支持</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">                        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            transactionManager.beginTransaction();</span><br><span class="line">                            rtValue = method.invoke(accountService, args);</span><br><span class="line">                            transactionManager.commit();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            transactionManager.rollback();</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            transactionManager.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> rtValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层实现类可以得到简化：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        accountDao.delete(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Transferring..."</span>);</span><br><span class="line">        Account source = accountDao.findByName(sourceName);</span><br><span class="line">        Account target = accountDao.findByName(targetName);</span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        target.setMoney(target.getMoney() + money);</span><br><span class="line">        accountDao.update(source);</span><br><span class="line">        <span class="comment">// 模拟转账异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改 XML 配置文件内容：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置BeanFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactory"</span> <span class="attr">class</span>=<span class="string">"factory.BeanFactory"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入Service --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountService"</span> <span class="attr">ref</span>=<span class="string">"accountService"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入事务管理器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置代理Service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAccountService"</span> <span class="attr">factory-bean</span>=<span class="string">"beanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Dao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入QueryRunner --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"runner"</span> <span class="attr">ref</span>=<span class="string">"runner"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"utils.TransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置管理连接的工具类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionUtils"</span> <span class="attr">class</span>=<span class="string">"utils.ConnectionUtils"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接数据源的必备信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置QueryRunner --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Spring-中的-AOP"><a href="#Spring-中的-AOP" class="headerlink" title="Spring 中的 AOP"></a>Spring 中的 AOP</h1><h2 id="AOP-的概念"><a href="#AOP-的概念" class="headerlink" title="AOP 的概念"></a>AOP 的概念</h2><ul><li>AOP（Aspect Oriented Programming，<strong>面向切面编程</strong>）：<ul><li>AOP 是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</li><li>AOP 是 OOP 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。</li></ul></li><li>作用及优势：<ul><li><strong>在程序运行期间，不修改源码对已有方法进行增强</strong>。</li><li>减少重复代码，提高开发效率，维护方便。</li></ul></li><li>实现方式：<ul><li>使用<strong>动态代理</strong>技术。</li></ul></li><li>总结：<ul><li>简单来说，AOP 就是把程序中重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有方法进行增强。</li></ul></li></ul><h2 id="Spring-中-AOP-的细节"><a href="#Spring-中-AOP-的细节" class="headerlink" title="Spring 中 AOP 的细节"></a>Spring 中 AOP 的细节</h2><h3 id="AOP-相关术语"><a href="#AOP-相关术语" class="headerlink" title="AOP 相关术语"></a>AOP 相关术语</h3><ul><li>Joinpoint（连接点）：<ul><li>所谓连接点是指那些被拦截到的点。</li><li>在 Spring 中，这些点指的是方法，因为 Spring 只支持方法类型的连接点。</li></ul></li><li>Pointcut（切入点）：<ul><li>所谓切入点是指要对哪些 Joinpoint 进行拦截的定义。</li></ul></li><li>Advice（通知/增强）：<ul><li>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。</li><li>通知的类型：前置通知、后置通知、异常通知、最终通知、环绕通知。</li></ul></li><li>Introduction（引介）：<ul><li>引介是一种特殊的通知，在不修改类代码的前提下，Introduction 可以在运行期为类动态地添加一些方法或 Field。</li></ul></li><li>Target（目标对象）：<ul><li>代理的目标对象。</li></ul></li><li>Weaving（织入）：<ul><li>是指把增强应用到目标对象来创建新的代理对象的过程。 </li><li>Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</li></ul></li><li>Proxy（代理）：<ul><li>一个类被 AOP 织入增强后，就产生一个结果代理类。</li></ul></li><li>Aspect（切面）：<ul><li>是切入点和通知（引介）的结合。</li></ul></li></ul><h3 id="学习-Spring-中的-AOP-要明确的事"><a href="#学习-Spring-中的-AOP-要明确的事" class="headerlink" title="学习 Spring 中的 AOP 要明确的事"></a>学习 Spring 中的 AOP 要明确的事</h3><ul><li>开发阶段：<ul><li>编写核心业务代码（开发主线）。</li><li>把公用代码抽取出来，制作成通知（开发阶段最后再做）。 </li><li>在配置文件中，声明切入点与通知间的关系，即切面。</li></ul></li><li>运行阶段：<ul><li>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</li></ul></li></ul><h3 id="代理的选择"><a href="#代理的选择" class="headerlink" title="代理的选择"></a>代理的选择</h3><ul><li>在 Spring 中，框架会根据目标是否实现了接口来决定采用哪种动态代理方式。</li></ul><h2 id="基于-XML-的-AOP-配置"><a href="#基于-XML-的-AOP-配置" class="headerlink" title="基于 XML 的 AOP 配置"></a>基于 XML 的 AOP 配置</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="准备必要代码"><a href="#准备必要代码" class="headerlink" title="准备必要代码"></a>准备必要代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟更新账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟查询账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层接口实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存了账户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新了账户"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询了账户"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于记录日志的工具类，提供了公共代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于打印日志，计划让其在切入点方法（即业务层方法）之前执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Logger类中的printLog方法开始记录日志了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导入-AOP-相关的坐标"><a href="#导入-AOP-相关的坐标" class="headerlink" title="导入 AOP 相关的坐标"></a>导入 AOP 相关的坐标</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="创建-Spring-配置文件并导入约束"><a href="#创建-Spring-配置文件并导入约束" class="headerlink" title="创建 Spring 配置文件并导入约束"></a>创建 Spring 配置文件并导入约束</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-Spring-的-IoC"><a href="#配置-Spring-的-IoC" class="headerlink" title="配置 Spring 的 IoC"></a>配置 Spring 的 IoC</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring的IoC，把Service对象配置进来 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="AOP-配置步骤"><a href="#AOP-配置步骤" class="headerlink" title="AOP 配置步骤"></a>AOP 配置步骤</h3><h4 id="通知类用-bean-配置"><a href="#通知类用-bean-配置" class="headerlink" title="通知类用 bean 配置"></a>通知类用 bean 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置通知类Logger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logger"</span> <span class="attr">class</span>=<span class="string">"utils.Logger"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-aop-config-声明-AOP-配置"><a href="#使用-aop-config-声明-AOP-配置" class="headerlink" title="使用 aop:config 声明 AOP 配置"></a>使用 aop:config 声明 AOP 配置</h4><ul><li><strong><code>aop:config</code> 标签：</strong><ul><li>作用：<strong>用于声明开始 AOP 的配置</strong>。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开始配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- AOP配置的代码都写在此处 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-aop-aspect-配置切面"><a href="#使用-aop-aspect-配置切面" class="headerlink" title="使用 aop:aspect 配置切面"></a>使用 aop:aspect 配置切面</h4><ul><li><strong><code>aop:aspect</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置切面</strong>。</li></ul></li><li>属性：<ul><li><code>id</code>：给切面提供一个唯一标识。</li><li><strong><code>ref</code>：引用配置好的通知类 <code>bean</code> 的 <code>id</code></strong>。</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开始配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置通知的类型要写在此处 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-aop-pointcut-配置切入点表达式"><a href="#使用-aop-pointcut-配置切入点表达式" class="headerlink" title="使用 aop:pointcut 配置切入点表达式"></a>使用 aop:pointcut 配置切入点表达式</h4><ul><li><strong><code>aop:pointcut</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置切入点表达式</strong>。就是指定对哪些类的哪些方法进行增强。</li></ul></li><li>属性：<ul><li><code>id</code>：用于给切入点表达式提供一个唯一标识。</li><li><code>expression</code>：用于定义切入点表达式。</li></ul></li><li>配置位置：<ul><li><code>aop:pointcut</code> 标签写在 <code>aop:aspect</code> 标签内部只能当前切面使用。</li><li>还可以写在 <code>aop:aspect</code> 外面，此时就变成了所有切面可用</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切入点表达式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"saveAccount"</span> <span class="attr">expression</span>=<span class="string">"execution(public void service.impl.AccountServiceImpl.saveAccount())"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-aop-xxx-配置通知的类型"><a href="#使用-aop-xxx-配置通知的类型" class="headerlink" title="使用 aop:xxx 配置通知的类型"></a>使用 aop:xxx 配置通知的类型</h4><ul><li><strong><code>aop:before</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置前置通知</strong>。指定增强的方法在切入点方法之前执行。</li></ul></li><li>属性（下面未注明属性的通知类型标签同此处）：<ul><li><code>method</code>：用于指定通知类中的增强方法名称。</li><li><strong><code>ponitcut-ref</code>：用于指定切入点的表达式的引用</strong>。</li><li><strong><code>poinitcut</code>：用于指定切入点表达式</strong>。</li></ul></li><li>执行时间点： 切入点方法执行之前执行。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"saveAccount"</span> <span class="attr">expression</span>=<span class="string">"execution(public void service.impl.AccountServiceImpl.saveAccount())"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置通知的类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"printLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"saveAccount"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><ul><li>切入点表达式的写法：<ul><li>关键字：<ul><li><code>execution(表达式)</code></li></ul></li><li>表达式语法：<ul><li><strong><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></strong></li></ul></li><li>写法说明：<ul><li>全匹配方式：<ul><li><code>public void service.impl.AccountServiceImpl.saveAccount()</code></li></ul></li><li>访问修饰符可以省略：<ul><li><code>void service.impl.AccountServiceImpl.saveAccount()</code></li></ul></li><li>返回值可以使用通配符 <code>*</code>，表示任意返回值：<ul><li><code>* service.impl.AccountServiceImpl.saveAccount()</code></li></ul></li><li>包名可以使用 <code>*</code> 号，表示任意包，但是有几级包，需要写几个 <code>*</code>：<ul><li><code>* *.*.AccountServiceImpl.saveAccount()</code></li></ul></li><li>使用 <code>..</code> 来表示当前包及其子包：<ul><li><code>* *..AccountServiceImpl.saveAccount()</code></li></ul></li><li>类名可以使用 <code>*</code> 号，表示任意类:<ul><li><code>* *..*.saveAccount()</code></li></ul></li><li>方法名可以使用 <code>*</code> 号，表示任意方法:<ul><li><code>* *..*.*()</code></li></ul></li><li>参数列表：<ul><li>可以直接写数据类型：<ul><li>基本类型直接写名称，如 <code>int</code>。</li><li>引用类型写 <code>包名.类名</code> 的方式，如 <code>java.lang.String</code>。</li></ul></li><li>可以使用通配符 <code>*</code> 表示任意类型，但是必须有参数。</li><li>可以使用 <code>..</code> 表示有无参数均可，有参数可以是任意类型。</li></ul></li><li>全通配写法：<ul><li><code>* *..*.*(..)</code></li></ul></li></ul></li><li><strong>注意</strong>：<ul><li><strong>通常情况下，都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类</strong>。</li><li><strong><code>execution(* service.impl.*.*(..))</code></strong></li></ul></li></ul></li></ul><h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><p><img src="/2020/06/19/spring-2/通知的类型.jpg" alt="通知的类型"></p><h4 id="常见的-4-种配置通知类型"><a href="#常见的-4-种配置通知类型" class="headerlink" title="常见的 4 种配置通知类型"></a>常见的 4 种配置通知类型</h4><ul><li><strong><code>aop:before</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置前置通知</strong>。指定增强的方法在切入点方法之前执行。</li></ul></li><li>执行时间点： 切入点方法执行之前执行。</li></ul></li><li><strong><code>aop:after-returning</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置后置通知</strong>。</li></ul></li><li>执行时间点： <ul><li>切入点方法正常执行之后。</li><li><strong>后置通知和异常通知只能有一个执行</strong>。</li></ul></li></ul></li><li><strong><code>aop:after-throwing</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置异常通知</strong>。</li></ul></li><li>执行时间点：<ul><li>切入点方法执行产生异常后执行。</li><li><strong>异常通知和后置通知只能执行一个</strong>。</li></ul></li></ul></li><li><strong><code>aop:after</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置最终通知</strong>。</li></ul></li><li>执行时间点：<ul><li><strong>无论切入点方法执行时是否有异常，它都会在其后面执行</strong>。</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开始配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置前置通知：在切入点方法执行之前执行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturningPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring-中的环绕通知"><a href="#Spring-中的环绕通知" class="headerlink" title="Spring 中的环绕通知"></a>Spring 中的环绕通知</h4><h5 id="配置环绕通知"><a href="#配置环绕通知" class="headerlink" title="配置环绕通知"></a>配置环绕通知</h5><ul><li><strong><code>aop:around</code> 标签</strong>：<ul><li>作用：<ul><li><strong>用于配置环绕通知</strong>。</li></ul></li><li>注意：<ul><li><strong>通常情况下，环绕通知都是独立使用的</strong>。</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置环绕通知 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="编写环绕通知"><a href="#编写环绕通知" class="headerlink" title="编写环绕通知"></a>编写环绕通知</h5><ul><li>如果是按照前置通知的样子来写：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundPrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕通知Logger类中的aroundPrintLog方法开始记录日志了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环绕通知Logger类中的aroundPrintLog方法开始记录日志了</span><br></pre></td></tr></table></figure><ul><li>问题：<ul><li>当配置了环绕通知之后，切入点方法没有执行，而环绕通知方法执行了。</li></ul></li><li>分析：<ul><li>对比动态代理案例中的环绕通知代码可以发现，动态代理的环绕通知有明确的切入点方法调用，而此处代码中没有。</li></ul></li><li>解决：<ul><li><strong>Spring 框架提供了一个接口 <code>ProceedingJoinPoint</code>。该接口有一个方法 <code>proceed()</code>，调用此方法就相当于明确调用切入点方法</strong>。</li><li><strong>该接口可以作为环绕通知的方法参数，在程序执行时，spring 框架会自动提供该接口的实现类用于使用</strong>。</li></ul></li><li>说明：<ul><li><strong>环绕通知是 Spring 框架提供的一种可以在代码中手动控制增强代码什么时候执行的方式</strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到方法执行所需的参数</span></span><br><span class="line">            Object[] args = pjp.getArgs();</span><br><span class="line">            System.out.println(<span class="string">"前置：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">            <span class="comment">// 明确调用业务层方法（切入点方法）</span></span><br><span class="line">            rtValue = pjp.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">"后置：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">"异常：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"最终：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前置：Logger类中的aroundPrintLog方法开始记录日志</span><br><span class="line">保存了账户</span><br><span class="line">后置：Logger类中的aroundPrintLog方法开始记录日志</span><br><span class="line">最终：Logger类中的aroundPrintLog方法开始记录日志</span><br></pre></td></tr></table></figure><h2 id="基于注解的-AOP-配置"><a href="#基于注解的-AOP-配置" class="headerlink" title="基于注解的 AOP 配置"></a>基于注解的 AOP 配置</h2><h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="准备必要代码并导入坐标"><a href="#准备必要代码并导入坐标" class="headerlink" title="准备必要代码并导入坐标"></a>准备必要代码并导入坐标</h4><ul><li>同基于 XML 的 AOP 配置。</li></ul><h4 id="在配置文件中导入-context-命名空间"><a href="#在配置文件中导入-context-命名空间" class="headerlink" title="在配置文件中导入 context 命名空间"></a>在配置文件中导入 context 命名空间</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="把资源使用注解配置"><a href="#把资源使用注解配置" class="headerlink" title="把资源使用注解配置"></a>把资源使用注解配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在配置文件中指定-Spring-要扫描的包"><a href="#在配置文件中指定-Spring-要扫描的包" class="headerlink" title="在配置文件中指定 Spring 要扫描的包"></a>在配置文件中指定 Spring 要扫描的包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring创建容器时要扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"service"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"utils"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><h4 id="把通知类也使用注解配置"><a href="#把通知类也使用注解配置" class="headerlink" title="把通知类也使用注解配置"></a>把通知类也使用注解配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在通知类上使用-Aspect-注解声明为切面"><a href="#在通知类上使用-Aspect-注解声明为切面" class="headerlink" title="在通知类上使用 @Aspect 注解声明为切面"></a>在通知类上使用 @Aspect 注解声明为切面</h4><ul><li><code>@Aspect</code> 注解：<ul><li>把当前类声明为切面。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在增强的方法上使用注解配置通知"><a href="#在增强的方法上使用注解配置通知" class="headerlink" title="在增强的方法上使用注解配置通知"></a>在增强的方法上使用注解配置通知</h4><ul><li><code>@Before</code> 注解：<ul><li>作用：把当前方法看成是前置通知。</li><li>属性 <code>value</code>：用于指定切入点表达式，还可以指定切入点表达式的引用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知Logger类中的beforePrintLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@AfterReturning</code> 注解：<ul><li>作用：把当前方法看成是后置通知。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(* service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知Logger类中的afterReturningPrintLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@AfterThrowing</code> 注解：<ul><li>作用：把当前方法看成是异常通知。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(* service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingPrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@After</code> 注解：<ul><li>作用：把当前方法看成是最终通知。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPrintLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知Logger类中的afterPrintLog方法开始记录日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-Spring-配置文件中开启-Spring-对注解-AOP-的支持"><a href="#在-Spring-配置文件中开启-Spring-对注解-AOP-的支持" class="headerlink" title="在 Spring 配置文件中开启 Spring 对注解 AOP 的支持"></a>在 Spring 配置文件中开启 Spring 对注解 AOP 的支持</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring开启注解AOP的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="环绕通知注解配置"><a href="#环绕通知注解配置" class="headerlink" title="环绕通知注解配置"></a>环绕通知注解配置</h4><ul><li><code>@Around</code> 注解：<ul><li>作用： 把当前方法看成是环绕通知。</li><li>注意：环绕通知一般单独使用，不与其他通知类型混用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到方法执行所需的参数</span></span><br><span class="line">            Object[] args = pjp.getArgs();</span><br><span class="line">            System.out.println(<span class="string">"前置：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">            <span class="comment">// 明确调用业务层方法（切入点方法）</span></span><br><span class="line">            rtValue = pjp.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">"后置：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">"异常：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"最终：Logger类中的aroundPrintLog方法开始记录日志"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切入点表达式注解配置"><a href="#切入点表达式注解配置" class="headerlink" title="切入点表达式注解配置"></a>切入点表达式注解配置</h3><ul><li><code>@Pointcut</code> 注解：<ul><li>作用： 指定切入点表达式。</li><li>属性：value：指定表达式的内容。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pt()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：在通知注解中配置切入点表达式时，不能省略 <code>()</code>。</li></ul><h3 id="不使用-XML-配置的方式"><a href="#不使用-XML-配置的方式" class="headerlink" title="不使用 XML 配置的方式"></a>不使用 XML 配置的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"service"</span>, <span class="string">"utils"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-中的-JdbcTemplate"><a href="#Spring-中的-JdbcTemplate" class="headerlink" title="Spring 中的 JdbcTemplate"></a>Spring 中的 JdbcTemplate</h1><h2 id="JdbcTemplate-概述"><a href="#JdbcTemplate-概述" class="headerlink" title="JdbcTemplate 概述"></a>JdbcTemplate 概述</h2><ul><li><code>JdbcTemplate</code> 是 Spring 框架中提供的一个模板类，是对原始 Jdbc API 的简单封装。</li><li>Spring 框架为我们提供了很多的操作模板类。<ul><li>操作关系型数据的：<code>JdbcTemplate</code>、<code>HibernateTemplate</code></li><li>操作 nosql 数据库的：<code>RedisTemplate</code></li><li>操作消息队列的：<code>JmsTemplate</code></li></ul></li></ul><h2 id="JdbcTemplate-对象的创建"><a href="#JdbcTemplate-对象的创建" class="headerlink" title="JdbcTemplate 对象的创建"></a>JdbcTemplate 对象的创建</h2><ul><li>参考源码一探究竟:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> <span class="keyword">extends</span> <span class="title">JdbcAccessor</span> <span class="keyword">implements</span> <span class="title">JdbcOperations</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">setDataSource(dataSource);</span><br><span class="line">afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcTemplate</span><span class="params">(DataSource dataSource, <span class="keyword">boolean</span> lazyInit)</span> </span>&#123;</span><br><span class="line">setDataSource(dataSource);</span><br><span class="line">setLazyInit(lazyInit);</span><br><span class="line">afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>除默认构造函数外，都需要提供一个数据源。</li><li>既然有 <code>set</code> 方法，依据 Spring 的依赖注入，可以在配置文件中配置这些对象。</li></ul><h2 id="Spring-中配置数据源"><a href="#Spring-中配置数据源" class="headerlink" title="Spring 中配置数据源"></a>Spring 中配置数据源</h2><h3 id="导入坐标"><a href="#导入坐标" class="headerlink" title="导入坐标"></a>导入坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-Spring-内置数据源"><a href="#配置-Spring-内置数据源" class="headerlink" title="配置 Spring 内置数据源"></a>配置 Spring 内置数据源</h3><ul><li>Spring 框架提供了一个内置数据源，可以使用。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将数据库连接的信息配置到属性文件中"><a href="#将数据库连接的信息配置到属性文件中" class="headerlink" title="将数据库连接的信息配置到属性文件中"></a>将数据库连接的信息配置到属性文件中</h3><h4 id="定义属性文件-jdbcConfig-properties"><a href="#定义属性文件-jdbcConfig-properties" class="headerlink" title="定义属性文件 jdbcConfig.properties"></a>定义属性文件 jdbcConfig.properties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/springdb</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><h4 id="引入外部属性文件"><a href="#引入外部属性文件" class="headerlink" title="引入外部属性文件"></a>引入外部属性文件</h4><ul><li>这里罗列两种引入外部属性文件的方式：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入外部的属性文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"props"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"jdbcConfig.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"jdbcConfig.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JdbcTemplate-的-CRUD-操作"><a href="#JdbcTemplate-的-CRUD-操作" class="headerlink" title="JdbcTemplate 的 CRUD 操作"></a>JdbcTemplate 的 CRUD 操作</h2><h3 id="在-Spring-配置文件中配置-JdbcTemplate"><a href="#在-Spring-配置文件中配置-JdbcTemplate" class="headerlink" title="在 Spring 配置文件中配置 JdbcTemplate"></a>在 Spring 配置文件中配置 JdbcTemplate</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置JdbcTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JdbcTemplate-的基本使用"><a href="#JdbcTemplate-的基本使用" class="headerlink" title="JdbcTemplate 的基本使用"></a>JdbcTemplate 的基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTemplate最基本的用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// spring的内置数据源</span></span><br><span class="line">        DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        ds.setUrl(<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>);</span><br><span class="line">        ds.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        ds.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        </span><br><span class="line">        JdbcTemplate jt = <span class="keyword">new</span> JdbcTemplate(ds);</span><br><span class="line">        jt.execute(<span class="string">"insert into account(name,money) values('ddd',1000)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line">        jt.execute(<span class="string">"insert into account(name,money) values('eee',1000)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CUD-操作"><a href="#CUD-操作" class="headerlink" title="CUD 操作"></a>CUD 操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTemplate的CRUD操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">        jt.update(<span class="string">"insert into account(name,money) values(?,?)"</span>, <span class="string">"fff"</span>, <span class="number">2000f</span>);</span><br><span class="line">        jt.update(<span class="string">"update account set name = ?, money = ? where id = ?"</span>, <span class="string">"test"</span>, <span class="number">3000</span>, <span class="number">4</span>);</span><br><span class="line">        jt.update(<span class="string">"delete from account where id = ?"</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><ul><li>使用 <code>RowMapper</code> 的方式（常用的方式）。</li></ul><h4 id="查询所有操作"><a href="#查询所有操作" class="headerlink" title="查询所有操作"></a>查询所有操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">        List&lt;Account&gt; accounts = jt.query(<span class="string">"select * from account where money &gt; ?"</span>, <span class="keyword">new</span> AccountRowMapper(), <span class="number">1000f</span>);</span><br><span class="line">        <span class="keyword">for</span> (Account account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Account的封装策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把结果集的数据封装到Account中，然后由spring把每个Account加到集合中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setId(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">        account.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">        account.setMoney(resultSet.getFloat(<span class="string">"money"</span>));</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询一个操作"><a href="#查询一个操作" class="headerlink" title="查询一个操作"></a>查询一个操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">        List&lt;Account&gt; accounts = jt.query(<span class="string">"select * from account where id = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), <span class="number">1</span>);</span><br><span class="line">        System.out.println(accounts.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询返回一行一列操作"><a href="#查询返回一行一列操作" class="headerlink" title="查询返回一行一列操作"></a>查询返回一行一列操作</h4><ul><li>查询返回一行一列：<ul><li>使用聚合函数，在不使用 <code>group by</code> 字句时，都是返回一行一列。</li><li>最常用的就是分页中获取总记录条数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">        Long count = jt.queryForObject(<span class="string">"select count(*) from account where money &gt; ?"</span>, Long.class, <span class="number">1000f</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在持久层中使用-JdbcTemplate"><a href="#在持久层中使用-JdbcTemplate" class="headerlink" title="在持久层中使用 JdbcTemplate"></a>在持久层中使用 JdbcTemplate</h2><h3 id="准备实体类和持久层接口"><a href="#准备实体类和持久层接口" class="headerlink" title="准备实体类和持久层接口"></a>准备实体类和持久层接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findById</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称查询账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findByName</span><span class="params">(Integer accountName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一种方式：在-Dao-中定义-JdbcTemplate"><a href="#第一种方式：在-Dao-中定义-JdbcTemplate" class="headerlink" title="第一种方式：在 Dao 中定义 JdbcTemplate"></a>第一种方式：在 Dao 中定义 JdbcTemplate</h3><ul><li>在持久层接口的实现类中定义 <code>JdbcTemplate</code> 对象，需要注入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcTemplate</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">"select * from account where id = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty() ? <span class="keyword">null</span> : accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByName</span><span class="params">(Integer accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">"select * from account where name = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountName);</span><br><span class="line">        <span class="keyword">if</span> (accounts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update account set name = ?, money = ? where id = ?"</span>,</span><br><span class="line">                account.getName(), account.getMoney(), account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置账户的持久层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">ref</span>=<span class="string">"jdbcTemplate"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这种方式很直接，但是有一个小问题：<ul><li>Dao 有很多时，每个 Dao 都有一些重复性的代码。</li><li>比如，<code>JdbcTemplate</code> 对象的定义和 <code>set</code> 方法，都会重复使用。</li></ul></li></ul><h3 id="第二种方式：让-Dao-继承-JdbcDaoSupport"><a href="#第二种方式：让-Dao-继承-JdbcDaoSupport" class="headerlink" title="第二种方式：让 Dao 继承 JdbcDaoSupport"></a>第二种方式：让 Dao 继承 JdbcDaoSupport</h3><ul><li><code>JdbcDaoSupport</code> 是 Spring 框架提供的一个类，该类中定义了一个 <code>JdbcTemplate</code> 对象，可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源。具体源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.jdbcTemplate == <span class="keyword">null</span> || dataSource != <span class="keyword">this</span>.jdbcTemplate.getDataSource()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.jdbcTemplate = createJdbcTemplate(dataSource);</span><br><span class="line">            initTemplateConfig();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setJdbcTemplate</span><span class="params">(@Nullable JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">        initTemplateConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以直接注入 <code>jdbcTemplate</code> 对象。在 <code>jdbcTemplate</code> 对象不存在时，直接注入数据源 <code>DataSource</code> 就会直接创建 <code>jdbcTemplate</code> 对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl2</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getJdbcTemplate()方法是从父类上继承下来的</span></span><br><span class="line">        List&lt;Account&gt; accounts = getJdbcTemplate().query(<span class="string">"select * from account where id = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty() ? <span class="keyword">null</span> : accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByName</span><span class="params">(Integer accountName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getJdbcTemplate()方法是从父类上继承下来的</span></span><br><span class="line">        List&lt;Account&gt; accounts = getJdbcTemplate().query(<span class="string">"select * from account where name = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountName);</span><br><span class="line">        <span class="keyword">if</span> (accounts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getJdbcTemplate()方法是从父类上继承下来的</span></span><br><span class="line">        getJdbcTemplate().update(<span class="string">"update account set name = ?, money = ? where id = ?"</span>,</span><br><span class="line">                account.getName(), account.getMoney(), account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置账户的持久层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="两种方式的比较"><a href="#两种方式的比较" class="headerlink" title="两种方式的比较"></a>两种方式的比较</h3><ul><li>第一种在 Dao 类中定义 <code>JdbcTemplate</code> 的方式，适用于所有配置方式（XML 和注解都可以）。</li><li>第二种让 Dao 继承 <code>JdbcDaoSupport</code> 的方式，只能用于基于 XML 的方式，注解不能使用（因为无法在源码中加注解实现注入数据）。</li></ul><h1 id="Spring-中的事务控制"><a href="#Spring-中的事务控制" class="headerlink" title="Spring 中的事务控制"></a>Spring 中的事务控制</h1><h2 id="Spring-事务控制要明确的事情"><a href="#Spring-事务控制要明确的事情" class="headerlink" title="Spring 事务控制要明确的事情"></a>Spring 事务控制要明确的事情</h2><ol><li>JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计业务层的事务处理解决方案。</li><li>Spring 框架提供了一组事务控制的接口。这组接口是在 spring-tx 中。</li><li>Spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现。</li></ol><h2 id="Spring-中事务控制的-API-介绍"><a href="#Spring-中事务控制的-API-介绍" class="headerlink" title="Spring 中事务控制的 API 介绍"></a>Spring 中事务控制的 API 介绍</h2><h3 id="PlatformTransactionManager-接口"><a href="#PlatformTransactionManager-接口" class="headerlink" title="PlatformTransactionManager 接口"></a>PlatformTransactionManager 接口</h3><ul><li><code>PlatformTransactionManager</code> 接口是 Spring 的事务管理器，它里面提供了常用的操作事务的方法：<ul><li><code>TransactionStatus getTransaction(TransactionDefinition definition)</code>：获取事务状态信息。</li><li><code>void commit(TransactionStatus status)</code>：提交事务。</li><li><code>void rollback(TransactionStatus status)</code>：回滚事务。</li></ul></li><li>真正管理事务的对象：<ul><li><code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>：使用 Spring JDBC 或 iBatis 进行持久化数据时使用 。</li><li><code>org.springframework.orm.hibernate5.HibernateTransactionManager</code>：使用 Hibernate 版本进行持久化数据时使用。</li></ul></li></ul><h3 id="TransactionDefinition-接口"><a href="#TransactionDefinition-接口" class="headerlink" title="TransactionDefinition 接口"></a>TransactionDefinition 接口</h3><ul><li><code>TransactionDefinition</code> 接口是事务的定义信息对象，里面有如下方法：<ul><li><code>String getName()</code>：获取事务对象名称。</li><li><code>int getIsolationLevel()</code>：获取<strong>事务隔离级别</strong>。<ul><li><code>ISOLATION_DEFAULT</code>：默认级别，归属下面某一种。</li><li><code>ISOLATION_READ_UNCOMMITTED</code>：可以读取未提交数据。</li><li><code>ISOLATION_READ_COMMITTED</code>：只能读取已提交数据（解决脏读问题）。</li><li><code>ISOLATION_REPEATABLE_READ</code>：是否读取其他事务提交修改后的数据（解决不可重复读问题）。</li><li><code>ISOLATION_SERIALIZABLE</code>：是否读取其他事务提交添加的数据（解决幻读问题）。</li></ul></li><li><code>int getPropagationBehavior()</code>：获取<strong>事务传播行为</strong>。<ul><li><code>REQUIRED</code>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）。</li><li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）。</li><li><code>MANDATORY</code>：使用当前的事务，如果当前没有事务，就抛出异常。</li><li><code>REQUIERS_NEW</code>：新建事务，如果当前在事务中，把当前事务挂起。</li><li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><code>NEVER</code>：以非事务方式运行，如果当前存在事务，抛出异常。</li><li><code>NESTED</code>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 <code>REQUIRED</code> 类似的操作。</li></ul></li><li><code>int getTimeout()</code>：获取事务超时时间。<ul><li>默认值是 -1，没有超时限制。如果有，以秒为单位进行设置。</li></ul></li><li><code>boolean isReadOnly()</code>：获取事务是否只读。<ul><li>建议查询时设置为只读。</li></ul></li></ul></li></ul><h3 id="TransactionStatus-接口"><a href="#TransactionStatus-接口" class="headerlink" title="TransactionStatus 接口"></a>TransactionStatus 接口</h3><ul><li><code>TransactionStatus</code> 接口提供的是事务具体的运行状态：<ul><li><code>void flush()</code>：刷新事务。</li><li><code>boolean hasSavepoint()</code>：获取是否存在存储点。</li><li><code>boolean isCompleted()</code>：获取事务是否完成。</li><li><code>boolean isNewTransaction()</code>：获取事务是否为新事务。</li><li><code>boolean isRollbackOnly()</code>：获取事务是否回滚。</li><li><code>void setRollbackOnly()</code>：设置事务回滚。</li></ul></li></ul><h2 id="基于-XML-的声明式事务控制"><a href="#基于-XML-的声明式事务控制" class="headerlink" title="基于 XML 的声明式事务控制"></a>基于 XML 的声明式事务控制</h2><h3 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="导入坐标-1"><a href="#导入坐标-1" class="headerlink" title="导入坐标"></a>导入坐标</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="创建-Spring-的配置文件并导入约束"><a href="#创建-Spring-的配置文件并导入约束" class="headerlink" title="创建 Spring 的配置文件并导入约束"></a>创建 Spring 的配置文件并导入约束</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="准备实体类"><a href="#准备实体类" class="headerlink" title="准备实体类"></a>准备实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写业务层接口和实现类"><a href="#编写业务层接口和实现类" class="headerlink" title="编写业务层接口和实现类"></a>编写业务层接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询账户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findById</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Transferring..."</span>);</span><br><span class="line">        <span class="comment">// 根据名称查询转出账户</span></span><br><span class="line">        Account source = accountDao.findByName(sourceName);</span><br><span class="line">        <span class="comment">// 根据名称查询转入账户</span></span><br><span class="line">        Account target = accountDao.findByName(targetName);</span><br><span class="line">        <span class="comment">// 转出账户减钱</span></span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        <span class="comment">// 转入账户加钱</span></span><br><span class="line">        target.setMoney(target.getMoney() + money);</span><br><span class="line">        <span class="comment">// 更新转出账户</span></span><br><span class="line">        accountDao.update(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟转账异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新转入账户</span></span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写持久层接口和实现类"><a href="#编写持久层接口和实现类" class="headerlink" title="编写持久层接口和实现类"></a>编写持久层接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findById</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称查询账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findByName</span><span class="params">(String accountName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = getJdbcTemplate().query(<span class="string">"select * from account where id = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty() ? <span class="keyword">null</span> : accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = getJdbcTemplate().query(<span class="string">"select * from account where name = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountName);</span><br><span class="line">        <span class="keyword">if</span> (accounts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        getJdbcTemplate().update(<span class="string">"update account set name = ?, money = ? where id = ?"</span>,</span><br><span class="line">                account.getName(), account.getMoney(), account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在配置文件中配置业务层和持久层"><a href="#在配置文件中配置业务层和持久层" class="headerlink" title="在配置文件中配置业务层和持久层"></a>在配置文件中配置业务层和持久层</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置账户的业务层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置账户的持久层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入外部的属性文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"jdbcConfig.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置步骤-1"><a href="#配置步骤-1" class="headerlink" title="配置步骤"></a>配置步骤</h3><h4 id="配置事务管理器"><a href="#配置事务管理器" class="headerlink" title="配置事务管理器"></a>配置事务管理器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置事务的通知引用事务管理器"><a href="#配置事务的通知引用事务管理器" class="headerlink" title="配置事务的通知引用事务管理器"></a>配置事务的通知引用事务管理器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务的通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置事物的属性"><a href="#配置事物的属性" class="headerlink" title="配置事物的属性"></a>配置事物的属性</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务的通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定方法名称：是业务核心方法</span></span><br><span class="line"><span class="comment">             read-only：是否是只读事务。默认false，不只读。</span></span><br><span class="line"><span class="comment">             isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。</span></span><br><span class="line"><span class="comment">             propagation：指定事务的传播行为。</span></span><br><span class="line"><span class="comment">             timeout：指定超时时间。默认值为：-1。永不超时。</span></span><br><span class="line"><span class="comment">             rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。</span></span><br><span class="line"><span class="comment">             no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-AOP-切入点表达式"><a href="#配置-AOP-切入点表达式" class="headerlink" title="配置 AOP 切入点表达式"></a>配置 AOP 切入点表达式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置切入点表达式和事务通知之间的对应关系"><a href="#配置切入点表达式和事务通知之间的对应关系" class="headerlink" title="配置切入点表达式和事务通知之间的对应关系"></a>配置切入点表达式和事务通知之间的对应关系</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 建立事务通知与切入点表达式的对应关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h2><h3 id="环境搭建-3"><a href="#环境搭建-3" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>需要的坐标、配置文件的约束、实体类都跟基于 XML 的一样。</li></ul><h4 id="让-Spring-管理业务层"><a href="#让-Spring-管理业务层" class="headerlink" title="让 Spring 管理业务层"></a>让 Spring 管理业务层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="让-Spring-管理持久层"><a href="#让-Spring-管理持久层" class="headerlink" title="让 Spring 管理持久层"></a>让 Spring 管理持久层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置步骤-2"><a href="#配置步骤-2" class="headerlink" title="配置步骤"></a>配置步骤</h3><h4 id="配置事务管理器并注入数据源"><a href="#配置事务管理器并注入数据源" class="headerlink" title="配置事务管理器并注入数据源"></a>配置事务管理器并注入数据源</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在业务层使用-Transactional-注解"><a href="#在业务层使用-Transactional-注解" class="headerlink" title="在业务层使用 @Transactional 注解"></a>在业务层使用 @Transactional 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.SUPPORTS, readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED, readOnly = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Transferring..."</span>);</span><br><span class="line">        <span class="comment">// 根据名称查询转出账户</span></span><br><span class="line">        Account source = accountDao.findByName(sourceName);</span><br><span class="line">        <span class="comment">// 根据名称查询转入账户</span></span><br><span class="line">        Account target = accountDao.findByName(targetName);</span><br><span class="line">        <span class="comment">// 转出账户减钱</span></span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        <span class="comment">// 转入账户加钱</span></span><br><span class="line">        target.setMoney(target.getMoney() + money);</span><br><span class="line">        <span class="comment">// 更新转出账户</span></span><br><span class="line">        accountDao.update(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟转账异常</span></span><br><span class="line">        <span class="comment">// int i = 1 / 0;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新转入账户</span></span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Transactional</code> 注解的属性和 XML 中的属性含义一致。</li><li>该注解可以出现在接口上、类上和方法上。 <ul><li>出现接口上，表示该接口的所有实现类都有事务支持。</li><li>出现在类上，表示类中所有方法有事务支持。</li><li>出现在方法上，表示方法有事务支持。 </li><li>以上三个位置的优先级：方法 &gt; 类 &gt; 接口。</li></ul></li></ul><h4 id="在配置文件中开启-Spring-对注解事务的支持"><a href="#在配置文件中开启-Spring-对注解事务的支持" class="headerlink" title="在配置文件中开启 Spring 对注解事务的支持"></a>在配置文件中开启 Spring 对注解事务的支持</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启spring对注解事务的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="不使用-XML-的方式（纯注解）"><a href="#不使用-XML-的方式（纯注解）" class="headerlink" title="不使用 XML 的方式（纯注解）"></a>不使用 XML 的方式（纯注解）</h3><ul><li>创建配置类逐步替代配置文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring的配置类，相当于bean.xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"service"</span>, <span class="string">"dao"</span>&#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123;JdbcConfig.class, TransactionConfig.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和连接数据库相关的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbcConfig.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建JdbcTemplate对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建数据源对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和事务相关的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建事务管理器对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">createTransactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层代码无需改变。</li><li>持久层实现类不能采用继承 <code>JdbcDaoSupport</code> 的方式实现，改为在类中定义 <code>JdbcTemplate</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">"select * from account where id = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty() ? <span class="keyword">null</span> : accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">"select * from account where name = ?"</span>,</span><br><span class="line">                <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class), accountName);</span><br><span class="line">        <span class="keyword">if</span> (accounts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update account set name = ?, money = ? where id = ?"</span>,</span><br><span class="line">                account.getName(), account.getMoney(), account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-的编程式事务控制"><a href="#Spring-的编程式事务控制" class="headerlink" title="Spring 的编程式事务控制"></a>Spring 的编程式事务控制</h2><ul><li>使用 <code>TransactionTemplate</code> 事务模板接口进行编程式事务控制。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionTemplate</span><span class="params">(TransactionTemplate transactionTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionTemplate = transactionTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transactionTemplate.execute(status -&gt; accountDao.findAccountById(accountId));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"transfer...."</span>);</span><br><span class="line">            <span class="comment">// 根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">// 根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">// 转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney() - money);</span><br><span class="line">            <span class="comment">// 转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney() + money);</span><br><span class="line">            <span class="comment">// 更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置业务层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionTemplate"</span> <span class="attr">ref</span>=<span class="string">"transactionTemplate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置账户的持久层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务模板对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架（1）</title>
      <link href="/2020/06/16/spring-1.html"/>
      <url>/2020/06/16/spring-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-概述"><a href="#Spring-概述" class="headerlink" title="Spring 概述"></a>Spring 概述</h1><h2 id="什么是-Spring"><a href="#什么是-Spring" class="headerlink" title="什么是 Spring"></a>什么是 Spring</h2><ul><li>Spring 是分层的 Java SE/EE 应用 <strong>full-stack</strong> 轻量级开源框架，以 <strong>IoC（Inverse Of Control，反转控制）</strong>和 <strong>AOP（Aspect Oriented Programming，面向切面编程）</strong>为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</li></ul><h2 id="Spring-的优势"><a href="#Spring-的优势" class="headerlink" title="Spring 的优势"></a>Spring 的优势</h2><ul><li><strong>方便解耦，简化开发</strong><ul><li>通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</li></ul></li><li><strong>AOP 编程的支持</strong><ul><li>通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付。</li></ul></li><li><strong>声明式事务的支持</strong><ul><li>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。</li></ul></li><li><strong>方便程序的测试</strong><ul><li>可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</li></ul></li><li><strong>方便集成各种优秀框架</strong><ul><li>Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。</li></ul></li><li><strong>降低 JavaEE API 的使用难度</strong><ul><li>Spring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。</li></ul></li><li><strong>Java 源码是经典学习范例</strong><ul><li>Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无疑是 Java 技术的最佳实践的范例。</li></ul></li></ul><h2 id="Spring-的体系结构"><a href="#Spring-的体系结构" class="headerlink" title="Spring 的体系结构"></a>Spring 的体系结构</h2><p><img src="/2020/06/16/spring-1/Spring体系结构.jpg" alt="Spring体系结构"></p><h1 id="IoC-的概念和作用"><a href="#IoC-的概念和作用" class="headerlink" title="IoC 的概念和作用"></a>IoC 的概念和作用</h1><h2 id="什么是程序的耦合"><a href="#什么是程序的耦合" class="headerlink" title="什么是程序的耦合"></a>什么是程序的耦合</h2><ul><li>耦合性（Coupling），也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差（降低耦合性，可以提高其独立性）。耦合性存在于各个领域，而非软件设计中独有的。</li><li>在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。<strong>划分模块的一个准则就是高内聚低耦合</strong>。</li><li>耦合的分类：<ul><li><strong>内容耦合：</strong>当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。</li><li><strong>公共耦合：</strong>两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li><li><strong>外部耦合：</strong>一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</li><li><strong>控制耦合：</strong>一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。</li><li><strong>标记耦合：</strong>若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。</li><li><strong>数据耦合：</strong>模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。</li><li><strong>非直接耦合：</strong>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</li></ul></li><li>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上应采用以下原则：如果模块间必须存在耦合，就<strong>尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合</strong>。</li></ul><h2 id="解决程序耦合的思路"><a href="#解决程序耦合的思路" class="headerlink" title="解决程序耦合的思路"></a>解决程序耦合的思路</h2><ul><li>早期我们的JDBC操作，注册驱动时，我们为什么不使用 <code>DriverManager</code> 的 <code>register</code> 方法，而是采用 <code>Class.forName</code> 的方式？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///springdb"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        PreparedStatement pstmt = conn.prepareStatement(<span class="string">"select * from account"</span>);</span><br><span class="line">        ResultSet rs = pstmt.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        rs.close();</span><br><span class="line">        pstmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<ul><li>如果我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如Oracle），需要修改源码来重新数据库驱动。这显然不是我们想要的。</li><li>通过反射来注册驱动，此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 MySQL 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的）。</li><li>同时，也产生了一个新的问题，MySQL 驱动的全限定类名字符串是在 Java 类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用配置文件配置。</li></ul></li><li><p><strong>解耦：降低程序间的依赖关系</strong>。</p></li><li><p>在实际开发中应该做到，<strong>编译期不依赖，运行时才依赖</strong>。</p></li><li>解耦的思路：<ol><li>使用反射来创建对象，而避免使用 <code>new</code> 关键字。</li><li>通过读取配置文件，来获取要创建的对象全限定类名。</li></ol></li></ul><h2 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h2><ul><li>在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就可以。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。</li><li>持久层：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存了账户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (accountDao == <span class="keyword">null</span>) &#123;</span><br><span class="line">            accountDao = (AccountDao) BeanFactory.getBean(<span class="string">"accountDao"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建三层对象的工厂：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个Properties对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个Map容器，用于存放已经创建的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块为Properties对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取配置文件</span></span><br><span class="line">            props = <span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"bean.properties"</span>);</span><br><span class="line">            props.load(in);</span><br><span class="line">            <span class="comment">// 实例化容器</span></span><br><span class="line">            beans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出配置文件中所有的key</span></span><br><span class="line">            Enumeration&lt;Object&gt; keys = props.keys();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 取出每个key</span></span><br><span class="line">                String key = keys.nextElement().toString();</span><br><span class="line">                <span class="comment">// 根据key获取value</span></span><br><span class="line">                String beanPath = props.getProperty(key);</span><br><span class="line">                Object value = Class.forName(beanPath).getDeclaredConstructor().newInstance();</span><br><span class="line">                beans.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"初始化properties失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Bean的名称获取bean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accountDao=dao.impl.AccountDaoImpl</span><br><span class="line">accountService=service.impl.AccountServiceImpl</span><br></pre></td></tr></table></figure><ul><li>测试类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AccountService as;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            as = (AccountService) BeanFactory.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">            System.out.println(as);</span><br><span class="line">            as.saveAccount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制反转（Inverse-of-Control）"><a href="#控制反转（Inverse-of-Control）" class="headerlink" title="控制反转（Inverse of Control）"></a>控制反转（Inverse of Control）</h2><ul><li>创建的三层对象存放到哪里？<ul><li>由于有多个对象，所以需要一个集合进行存放。</li><li>可以选择 <code>Map</code> 或者 <code>List</code> 来存放三层对象。称之为容器。</li><li>到底选 <code>Map</code> 还是 <code>List</code> 就看有没有查找需求，有查找需求选 <code>Map</code>。</li></ul></li><li>什么是工厂？<ul><li>工厂就是负责从容器中获取指定对象的类。</li><li>这时候获取对象的方式发生了变化。</li><li>原来在获取对象时，都是采用 new 的方式，是主动的。<img src="/2020/06/16/spring-1/获取对象1.jpg" alt></li><li>现在获取对象向工厂要，由工厂查找或创建对象，是被动的。<img src="/2020/06/16/spring-1/获取对象2.jpg" alt></li><li>这种被动接收的方式获取对象的思想就是控制反转，它是 Spring 框架的核心之一。</li></ul></li><li><strong>控制反转（Inverse of Control）</strong>：<ul><li><strong>把对象创建的控制权交给框架，是框架的重要特征</strong>。</li><li>作用：削减计算机程序的耦合，降低代码中的依赖关系。</li></ul></li></ul><h1 id="使用-Spring-的-IoC-解决程序耦合"><a href="#使用-Spring-的-IoC-解决程序耦合" class="headerlink" title="使用 Spring 的 IoC 解决程序耦合"></a>使用 Spring 的 IoC 解决程序耦合</h1><h2 id="基于-XML-的-IoC-配置"><a href="#基于-XML-的-IoC-配置" class="headerlink" title="基于 XML 的 IoC 配置"></a>基于 XML 的 IoC 配置</h2><h3 id="案例前期准备"><a href="#案例前期准备" class="headerlink" title="案例前期准备"></a>案例前期准备</h3><h4 id="创建业务层接口和实现类"><a href="#创建业务层接口和实现类" class="headerlink" title="创建业务层接口和实现类"></a>创建业务层接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处的依赖关系有待解决</span></span><br><span class="line">        accountDao = <span class="keyword">new</span> AccountDaoImpl();</span><br><span class="line">        <span class="comment">// 用于Debug验证BeanFactory和ApplicationContext创建对象的时机</span></span><br><span class="line">        System.out.println(<span class="string">"AccountService对象创建完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建持久层接口和实现类"><a href="#创建持久层接口和实现类" class="headerlink" title="创建持久层接口和实现类"></a>创建持久层接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存了账户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导入-Spring-的相关坐标"><a href="#导入-Spring-的相关坐标" class="headerlink" title="导入 Spring 的相关坐标"></a>导入 Spring 的相关坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-ClassPath-下创建一个-XML-文件并配置-Service-和-Dao"><a href="#在-ClassPath-下创建一个-XML-文件并配置-Service-和-Dao" class="headerlink" title="在 ClassPath 下创建一个 XML 文件并配置 Service 和 Dao"></a>在 ClassPath 下创建一个 XML 文件并配置 Service 和 Dao</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 把对象的创建交给spring来管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取spring的IoC容器，并根据id获取对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testApplicationContext();</span><br><span class="line">        testBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取核心容器对象</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        AccountDao ad = ac.getBean(<span class="string">"accountDao"</span>, AccountDao.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(as);</span><br><span class="line">        System.out.println(ad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"bean.xml"</span>);</span><br><span class="line">        BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br><span class="line">        AccountService as = factory.getBean(<span class="string">"accountService"</span>, AccountService.class);</span><br><span class="line">        System.out.println(as);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-基于-XML-的-IoC-细节"><a href="#Spring-基于-XML-的-IoC-细节" class="headerlink" title="Spring 基于 XML 的 IoC 细节"></a>Spring 基于 XML 的 IoC 细节</h2><h3 id="Spring-中工厂的类结构"><a href="#Spring-中工厂的类结构" class="headerlink" title="Spring 中工厂的类结构"></a>Spring 中工厂的类结构</h3><p><img src="/2020/06/16/spring-1/ApplicationContext.png" alt="ApplicationContext"></p><h4 id="BeanFactory-和-ApplicationContext-的区别"><a href="#BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="BeanFactory 和 ApplicationContext 的区别"></a><code>BeanFactory</code> 和 <code>ApplicationContext</code> 的区别</h4><ul><li><code>BeanFactory</code> 才是 Spring 容器中的顶层接口。</li><li><code>ApplicationContext</code> 是它的子接口。</li><li><code>BeanFactory</code> 和 <code>ApplicationContext</code> 的区别是创建对象的时间点不一样。<ul><li><strong><code>ApplicationContext</code>：只要一读取配置文件，默认情况下就会创建对象（立即加载）（单例对象适用）</strong>。</li><li><strong><code>BeanFactory</code>：什么时候使用什么时候创建对象（延迟加载）（多例对象适用）</strong>。</li></ul></li></ul><h4 id="ApplicationContext-接口的实现类"><a href="#ApplicationContext-接口的实现类" class="headerlink" title="ApplicationContext 接口的实现类"></a><code>ApplicationContext</code> 接口的实现类</h4><ul><li><code>ClassPathXmlApplicationContext</code>：它是从<strong>类的根路径</strong>下加载配置文件（推荐使用这种）。</li><li><code>FileSystemXmlApplicationContext</code>：它是从<strong>磁盘路径</strong>上加载配置文件，配置文件可以在磁盘的任意位置。</li><li><code>AnnotationConfigApplicationContext</code>：当我们使用注解配置容器对象时，需要使用此类来创建 Spring 容器。它用来<strong>读取注解</strong>。</li></ul><h3 id="IoC-中-bean-标签和管理对象细节"><a href="#IoC-中-bean-标签和管理对象细节" class="headerlink" title="IoC 中 bean 标签和管理对象细节"></a>IoC 中 <code>bean</code> 标签和管理对象细节</h3><h4 id="bean-标签"><a href="#bean-标签" class="headerlink" title="bean 标签"></a><code>bean</code> 标签</h4><ul><li>作用：<ul><li>用于配置让 Spring 来创建对象，并存入 IoC 容器中。</li><li><strong>默认情况下它调用的是类中的无参构造函数</strong>。如果没有无参构造函数则不能创建成功。</li></ul></li><li>属性：<ul><li><strong><code>id</code>：给对象在容器中提供一个唯一标识。用于获取对象</strong>。</li><li><strong><code>class</code>：指定类的全限定类名。用于反射创建对象</strong>。默认情况下调用无参构造函数。</li><li><code>scope</code>：指定对象的作用范围。<ul><li><code>singleton</code>：单例的（默认值）。</li><li><code>prototype</code>：多例的。</li><li><code>request</code>：作用于 WEB 应用的请求范围。</li><li><code>session</code>：作用于 WEB 应用的会话范围。</li><li><code>global-session</code>：作用于集群环境的会话范围。如果没有集群环境，就相当于 <code>session</code>。</li></ul></li><li><code>init-method</code>：指定类中的初始化方法名称。</li><li><code>destroy-method</code>：指定类中销毁方法名称。</li></ul></li></ul><h4 id="实例化-bean-的-3-种方式"><a href="#实例化-bean-的-3-种方式" class="headerlink" title="实例化 bean 的 3 种方式"></a>实例化 <code>bean</code> 的 3 种方式</h4><h5 id="第一种方式：使用默认构造函数创建对象"><a href="#第一种方式：使用默认构造函数创建对象" class="headerlink" title="第一种方式：使用默认构造函数创建对象"></a>第一种方式：使用默认构造函数创建对象</h5><ul><li>在 Spring 的配置文件中使用 <code>bean</code> 标签，配以 <code>id</code> 和 <code>class</code> 属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建 <code>bean</code> 对象，此时如果类中没有默认构造函数，则对象无法创建。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第二种方式：Spring-管理静态工厂（使用静态工厂的方法创建对象）"><a href="#第二种方式：Spring-管理静态工厂（使用静态工厂的方法创建对象）" class="headerlink" title="第二种方式：Spring 管理静态工厂（使用静态工厂的方法创建对象）"></a>第二种方式：Spring 管理静态工厂（使用静态工厂的方法创建对象）</h5><ul><li>在 <code>bean</code> 标签中配以 <code>id</code>、<code>class</code> 和 <code>factory-method</code> 属性，调用 <code>class</code> 对应的静态工厂中的静态方法 <code>factory-method</code> 创建对象，并存入 Spring 容器。<ul><li><code>id</code>：指定 <code>bean</code> 的唯一标识，用于从容器中获取对象。</li><li><code>class</code>：指定静态工厂的全限定类名。</li><li><code>factory-method</code>：指定生产对象的静态方法。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一个静态工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AccountService <span class="title">getAccountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"factory.StaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第三种方式：Spring-管理实例工厂（使用实例工厂的方法创建对象）"><a href="#第三种方式：Spring-管理实例工厂（使用实例工厂的方法创建对象）" class="headerlink" title="第三种方式：Spring 管理实例工厂（使用实例工厂的方法创建对象）"></a>第三种方式：Spring 管理实例工厂（使用实例工厂的方法创建对象）</h5><ul><li>先把工厂的创建交给 Spring 来管理。 然后在使用工厂的 <code>bean</code> 来调用里面的方法创建需要的对象。<ul><li><code>factory-bean</code>：用于指定实例工厂 <code>bean</code> 的 <code>id</code>。</li><li><code>factory-method</code>：用于指定实例工厂中创建对象的方法。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一个工厂类（该类可能是jar包中的，我们无法通过修改源码的方式提供默认构造函数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">getAccountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"factory.InstanceFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="bean-的作用范围和生命周期"><a href="#bean-的作用范围和生命周期" class="headerlink" title="bean 的作用范围和生命周期"></a><code>bean</code> 的作用范围和生命周期</h4><ul><li>修改 <code>AccountServiceImpl</code> 类以便测试：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AccountService对象创建完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service中的saveAccount方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象初始化了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象销毁了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例对象：scope-quot-singleton-quot"><a href="#单例对象：scope-quot-singleton-quot" class="headerlink" title="单例对象：scope=&quot;singleton&quot;"></a>单例对象：<code>scope=&quot;singleton&quot;</code></h5><ul><li>一个应用只有一个对象的实例。它的作用范围就是整个应用。</li><li>生命周期：<ul><li>对象出生：当应用加载，创建容器时，对象就被创建了（<strong>立即加载</strong>）。</li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">        <span class="comment">// 主动销毁容器</span></span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AccountService对象创建完成</span><br><span class="line">对象初始化了</span><br><span class="line">service中的saveAccount方法执行了</span><br><span class="line">对象销毁了</span><br></pre></td></tr></table></figure><ul><li>结果表明单例对象在容器销毁时同时被销毁。</li></ul><h5 id="多例对象：scope-quot-prototype-quot"><a href="#多例对象：scope-quot-prototype-quot" class="headerlink" title="多例对象：scope=&quot;prototype&quot;"></a>多例对象：<code>scope=&quot;prototype&quot;</code></h5><ul><li>每次访问对象时，都会重新创建对象实例。</li><li>生命周期：<ul><li>对象出生：当使用对象时，创建新的对象实例（<strong>延迟加载</strong>）。</li><li>对象活着：只要对象在使用中，就一直活着。</li><li>对象死亡：当对象长时间不用时，被 Java 的垃圾回收器回收了。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">"prototype"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AccountService对象创建完成</span><br><span class="line">对象初始化了</span><br><span class="line">service中的saveAccount方法执行了</span><br></pre></td></tr></table></figure><ul><li>结果表明多例对象在容器销毁后并没有被销毁，说明多例对象的生命周期与容器并不相同。</li></ul><h3 id="Spring-的依赖注入"><a href="#Spring-的依赖注入" class="headerlink" title="Spring 的依赖注入"></a>Spring 的依赖注入</h3><ul><li><strong>依赖注入（Dependency Injection）：</strong><ul><li><strong>就是依赖关系的维护，是 Spring 框架核心 IoC 的具体实现</strong>。</li><li>通过控制反转，将对象的创建交给 Spring，但是代码中不可能出现没有依赖的情况。IoC 只是降低程序间的依赖关系，但不会消除依赖。依赖关系的维护都交给 Spring 来管理。</li><li>比如，业务层需要调用持久层的方法，坐等框架把持久层对象传入业务层，而不用自己去获取。</li></ul></li><li>能注入的数据有三类：<ol><li>基本类型和 <code>String</code>；</li><li>其他 <code>bean</code> 类型（配置文件或注解配置过的 <code>bean</code>）；</li><li>复杂类型或集合类型。</li></ol></li><li>注入的方式有三种：<ol><li>使用构造函数提供；</li><li>使用 <code>set</code> 方法提供；</li><li>使用注解提供。</li></ol></li></ul><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><ul><li>顾名思义，就是<strong>使用类中的构造函数，给成员变量赋值</strong>。</li><li>赋值操作不是自己做，而是通过配置的方式，让 Spring 框架来注入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, Integer age, Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service中的saveAccount方法执行了..."</span> + name + <span class="string">", "</span> + age + <span class="string">", "</span> + birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数注入：<ul><li><strong>使用的标签：<code>constructor-arg</code></strong></li><li>标签出现的位置：<code>bean</code> 标签的内部</li><li>标签中的属性：<ul><li><code>type</code>：用于指定要注入的数据类型，该数据类型也是构造函数中某个或某些参数的类型。</li><li><code>index</code>：用于指定参数在构造函数参数列表的索引位置。索引的位置是从 0 开始。</li><li><strong><code>name</code>：</strong>用于指定参数在构造函数中的名称（常用）。</li><li><strong><code>value</code>：</strong>用于提供基本类型和 <code>String</code> 类型的数据。</li><li><strong><code>ref</code>：</strong>用于指定其他的 <code>bean</code> 类型数据，就是在 Spring 的 IoC 核心容器中出现过的 <code>bean</code> 对象。</li></ul></li><li>优势：在获取 <code>bean</code> 对象时，注入数据是必须的操作，否则对象无法创建成功。</li><li>弊端：改变了 <code>bean</code> 对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 构造函数注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置一个日期对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service中的saveAccount方法执行了...test, <span class="number">18</span>, Sun Jun <span class="number">14</span> <span class="number">09</span>:<span class="number">49</span>:<span class="number">55</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure><h4 id="set-方法注入"><a href="#set-方法注入" class="headerlink" title="set 方法注入"></a><code>set</code> 方法注入</h4><ul><li>顾名思义，就是在类中提供需要注入成员的 <code>set</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl2</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service中的saveAccount方法执行了..."</span> + name + <span class="string">", "</span> + age + <span class="string">", "</span> + birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>set</code> 方法注入：<ul><li><strong>使用的标签：<code>property</code></strong></li><li>标签出现的位置：<code>bean</code> 标签的内部</li><li>标签中的属性：<ul><li><strong><code>name</code>：</strong>用于指定注入时所调用的 <code>set</code> 方法名称，找的是类中 <code>set</code> 方法后面的部分。</li><li><strong><code>value</code>：</strong>用于提供基本类型和 <code>String</code> 类型的数据。</li><li><strong><code>ref</code>：</strong>用于指定其他的 <code>bean</code> 类型数据，就是在 Spring 的 IoC 核心容器中出现过的 <code>bean</code> 对象。</li></ul></li><li>优势：创建对象时没有明确的限制，可以直接使用默认构造函数。</li><li>弊端：如果有某个成员必须有值，则获取对象时有可能 <code>set</code> 方法没有执行。</li><li>实际开发中，此种方式用的较多。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- set方法注入，更常用的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService2"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"TEST"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"22"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        AccountService as2 = (AccountService) ac.getBean(<span class="string">"accountService2"</span>);</span><br><span class="line">        as2.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service中的saveAccount方法执行了...TEST, <span class="number">22</span>, Sun Jun <span class="number">14</span> <span class="number">11</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure><h4 id="集合类型注入"><a href="#集合类型注入" class="headerlink" title="集合类型注入"></a>集合类型注入</h4><ul><li>顾名思义，就是给类中的集合成员传值，它用的也是 <code>set</code> 方法注入的方式，只不过变量的数据类型都是集合。这里介绍注入 <code>数组</code>、<code>List</code>、<code>Set</code>、<code>Map</code>、<code>Properties</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl3</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] strs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Properties props;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>集合数据注入：<ul><li><code>List</code> 结构的：<code>array</code>、<code>list</code>、<code>set</code> </li><li><code>Map</code> 结构的：<code>map</code>、<code>entry</code>、<code>props</code>、<code>prop</code> </li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService3"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl3"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给数组注入数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"strs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入list集合数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入set集合数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入Map数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testA"</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入properties数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testA"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        AccountService as3 = (AccountService) ac.getBean(<span class="string">"accountService3"</span>);</span><br><span class="line">        as3.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[AAA, BBB, CCC]</span><br><span class="line">[AAA, BBB, CCC]</span><br><span class="line">[AAA, BBB, CCC]</span><br><span class="line">&#123;testB=ddd, testA=ccc&#125;</span><br><span class="line">&#123;testB=bbb, testA=aaa&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-基于注解的-IoC-配置及细节"><a href="#Spring-基于注解的-IoC-配置及细节" class="headerlink" title="Spring 基于注解的 IoC 配置及细节"></a>Spring 基于注解的 IoC 配置及细节</h2><ul><li>注解配置和 XML 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>导入依赖：同 XML 配置方式。</li><li>使用 <code>@Component</code> 注解配置管理的资源：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建 Spring 的 XML 配置文件并开启对注解的支持：<ul><li>基于注解整合时，导入约束时需要多导入一个 <code>context</code> 名称空间下的约束。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 告知spring在创建容器时要扫描的包，配置所需要的标签不是</span></span><br><span class="line"><span class="comment">         在beans的约束中，而是一个名称为context名称空间和约束中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"service"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取核心容器对象</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        System.out.println(as);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.impl.AccountServiceImpl@<span class="number">3e27</span>aa33</span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>曾经的 XML 配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">""</span> <span class="attr">init-method</span>=<span class="string">""</span> <span class="attr">destroy-method</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span> | <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用于创建对象的注解"><a href="#用于创建对象的注解" class="headerlink" title="用于创建对象的注解"></a>用于创建对象的注解</h4><ul><li><strong>和在 XML 配置文件中编写一个 <code>&lt;bean&gt;</code> 标签实现的功能是一样的</strong>。</li></ul><h5 id="Component-注解"><a href="#Component-注解" class="headerlink" title="@Component 注解"></a><code>@Component</code> 注解</h5><ul><li>作用：<ul><li>把当前类对象存入 Spring 容器中，让 Spring 来管理资源。</li><li>相当于在 XML 中配置一个 <code>bean</code>。</li></ul></li><li>属性： <ul><li><code>value</code>：指定 <code>bean</code> 的 <code>id</code>。如果不指定 <code>value</code> 属性，默认 <code>bean</code> 的 <code>id</code> 是当前类的类名（首字母小写）。</li></ul></li></ul><h5 id="三个衍生注解-Controller、-Service、-Reposity"><a href="#三个衍生注解-Controller、-Service、-Reposity" class="headerlink" title="三个衍生注解 @Controller、@Service、@Reposity"></a>三个衍生注解 <code>@Controller</code>、<code>@Service</code>、<code>@Reposity</code></h5><ul><li>三个注解都是针对 <code>@Component</code> 的衍生注解，他们的作用和属性一模一样。</li><li>只不过这三个注解提供了更明确的语义化：<ul><li><code>@Controller</code>：一般用于表现层的注解。</li><li><code>@Service</code>：一般用于业务层的注解。</li><li><code>@Repository</code>：一般用于持久层的注解。</li></ul></li><li>细节：<ul><li><strong>如果注解中有且只有一个属性要赋值时，且名称是 <code>value</code>，<code>value</code> 在赋值时可以不写</strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用于注入数据的注解"><a href="#用于注入数据的注解" class="headerlink" title="用于注入数据的注解"></a>用于注入数据的注解</h4><ul><li><strong>和在 XML 配置文件中的 <code>bean</code> 标签中写一个 <code>&lt;property&gt;</code> 标签的作用是一样的</strong>。</li></ul><h5 id="Autowired-注解"><a href="#Autowired-注解" class="headerlink" title="@Autowired 注解"></a><code>@Autowired</code> 注解</h5><ul><li>作用：<ul><li><strong>自动按照类型注入</strong>。只要容器中有唯一的一个 <code>bean</code> 对象类型和要注入的变量类型匹配，就可以注入成功。</li><li><strong>只能注入其他 <code>bean</code> 类型。当有多个类型匹配时，使用要注入的对象变量名称作为 <code>bean</code> 的 <code>id</code>，在 <code>Spring</code> 容器查找</strong>，找到了也可以注入成功。找不到就报错。</li></ul></li><li>出现位置：<ul><li>可以是变量上，也可以是方法上。</li></ul></li><li>细节：<ul><li><strong>当使用注解注入属性时，<code>set</code> 方法可以省略</strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存了账户111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl2</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存了账户222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取核心容器对象</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        System.out.println(as);</span><br><span class="line"></span><br><span class="line">        AccountDao ad = ac.getBean(<span class="string">"accountDaoImpl"</span>, AccountDao.class);</span><br><span class="line">        System.out.println(ad);</span><br><span class="line"></span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service.impl.AccountServiceImpl@<span class="number">75437611</span></span><br><span class="line">dao.impl.AccountDaoImpl@<span class="number">350</span>aac89</span><br><span class="line">保存了账户<span class="number">222</span></span><br></pre></td></tr></table></figure><h5 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier 注解"></a><code>@Qualifier</code> 注解</h5><ul><li>作用：<ul><li><strong>在自动按照类型注入的基础之上，再按照 <code>Bean</code> 的 <code>id</code> 注入</strong>。</li><li><strong>在给字段注入时不能独立使用，必须和 <code>@Autowired</code> 一起使用</strong>。</li><li>但是<strong>给方法参数注入时，可以独立使用</strong>。</li></ul></li><li>属性：<ul><li><code>value</code>：指定 <code>bean</code> 的 <code>id</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"accountDaoImpl"</span>)</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service.impl.AccountServiceImpl@<span class="number">75437611</span></span><br><span class="line">dao.impl.AccountDaoImpl@<span class="number">350</span>aac89</span><br><span class="line">保存了账户<span class="number">111</span></span><br></pre></td></tr></table></figure><h5 id="Resource-注解"><a href="#Resource-注解" class="headerlink" title="@Resource 注解"></a><code>@Resource</code> 注解</h5><ul><li>作用：<ul><li><strong>直接按照 <code>Bean</code> 的 <code>id</code> 注入</strong>。</li><li>它也<strong>只能注入其他 <code>bean</code> 类型</strong>。 </li><li>可以独立使用。</li></ul></li><li>属性：<ul><li><strong><code>name</code>：指定 <code>bean</code> 的 <code>id</code></strong>。如果不指定则默认使用字段名作为 <code>id</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="comment">// @Resource(name="accountDaoImpl")</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service.impl.AccountServiceImpl@<span class="number">6</span>caf0677</span><br><span class="line">dao.impl.AccountDaoImpl@<span class="number">413</span>d1baf</span><br><span class="line">保存了账户<span class="number">222</span></span><br></pre></td></tr></table></figure><h5 id="Value-注解"><a href="#Value-注解" class="headerlink" title="@Value 注解"></a><code>@Value</code> 注解</h5><ul><li>作用：<ul><li><strong>用于注入基本数据类型和 <code>String</code> 类型的数据</strong>。</li></ul></li><li>属性：<ul><li><strong><code>value</code>：用于指定数据的值</strong>。它可以使用 SpEL（即 Spring 中的 el 表达式）。</li></ul></li></ul><h5 id="注入数据的注解小结"><a href="#注入数据的注解小结" class="headerlink" title="注入数据的注解小结"></a>注入数据的注解小结</h5><ul><li><code>@Autowired</code>、<code>@Qualifier</code>、<code>@Resource</code> 三个注解只能注入其他 <code>bean</code> 类型的数据。</li><li><code>@Value</code> 注解用于注入基本数据类型和 <code>String</code> 类型。</li><li>集合类型的数据只能通过 XML 配置来实现注入。</li></ul><h4 id="用于改变作用范围的注解"><a href="#用于改变作用范围的注解" class="headerlink" title="用于改变作用范围的注解"></a>用于改变作用范围的注解</h4><ul><li>和在 <code>bean</code> 标签中使用 <code>scope</code> 属性实现的功能是一样的。</li></ul><h5 id="Scope-注解"><a href="#Scope-注解" class="headerlink" title="@Scope 注解"></a><code>@Scope</code> 注解</h5><ul><li>作用：<ul><li>用于指定 <code>bean</code> 的作用范围。</li></ul></li><li>属性：<ul><li>value：指定范围的值。常用取值：<code>singleton</code> <code>prototype</code> <code>request</code> <code>session</code> <code>globalsession</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"></span><br><span class="line">        AccountService as1 = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        AccountService as2 = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(as1 == as2); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="与生命周期相关的注解"><a href="#与生命周期相关的注解" class="headerlink" title="与生命周期相关的注解"></a>与生命周期相关的注解</h4><ul><li>和在 <code>bean</code> 标签中使用 <code>init-method</code> 和 <code>destroy-method</code> 的作用是一样的。</li></ul><h5 id="PostConstruct-注解"><a href="#PostConstruct-注解" class="headerlink" title="@PostConstruct 注解"></a><code>@PostConstruct</code> 注解</h5><ul><li>作用：用于指定初始化方法。</li></ul><h5 id="PreDestroy-注解"><a href="#PreDestroy-注解" class="headerlink" title="@PreDestroy 注解"></a><code>@PreDestroy</code> 注解</h5><ul><li>作用：用于指定销毁方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化方法执行了</span><br><span class="line">销毁方法执行了</span><br></pre></td></tr></table></figure><h2 id="关于-Spring-注解和-XML-的选择问题"><a href="#关于-Spring-注解和-XML-的选择问题" class="headerlink" title="关于 Spring 注解和 XML 的选择问题"></a>关于 Spring 注解和 XML 的选择问题</h2><ul><li>注解的优势：配置简单，维护方便（找到类，就相当于找到了对应的配置）。</li><li>XML 的优势：修改时，不用改源码。不涉及重新编译和部署。</li><li>Spring 管理 <code>Bean</code> 方式的比较：</li></ul><div class="table-container"><table><thead><tr><th>比较内容</th><th>基于 XML 配置</th><th>基于注解配置</th></tr></thead><tbody><tr><td><code>Bean</code> 定义</td><td><code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code></td><td><code>@Component</code><br><code>@Repository</code><br><code>@Service</code><br><code>@Controller</code></td></tr><tr><td><code>Bean</code> 名称</td><td>通过 <code>id</code> 或 <code>name</code> 指定</td><td><code>@Component(&quot;名称&quot;)</code></td></tr><tr><td><code>Bean</code> 注入</td><td><code>&lt;property&gt;</code> 标签<br>p 命名空间</td><td><code>@Autowired</code> 按类型注入<br><code>@Qualifier</code> 按名称注入</td></tr><tr><td>生命周期和<br><code>Bean</code> 作用范围</td><td><code>init-method</code><br><code>destroy-method</code><br><code>scope</code></td><td><code>@PostConstruct</code><br><code>@PreDestroy</code><br><code>@Scope</code></td></tr><tr><td>适合场景</td><td><code>Bean</code> 来自第三方</td><td><code>Bean</code> 的实现类由用户自己开发</td></tr></tbody></table></div><h1 id="IoC-案例编写"><a href="#IoC-案例编写" class="headerlink" title="IoC 案例编写"></a>IoC 案例编写</h1><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="在-Maven-工程中导入坐标"><a href="#在-Maven-工程中导入坐标" class="headerlink" title="在 Maven 工程中导入坐标"></a>在 Maven 工程中导入坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建数据库和实体类"><a href="#创建数据库和实体类" class="headerlink" title="创建数据库和实体类"></a>创建数据库和实体类</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">40</span>),</span><br><span class="line">money <span class="built_in">float</span></span><br><span class="line">)<span class="built_in">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>,money) <span class="keyword">values</span>(<span class="string">'aaa'</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>,money) <span class="keyword">values</span>(<span class="string">'bbb'</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>,money) <span class="keyword">values</span>(<span class="string">'ccc'</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写持久层代码"><a href="#编写持久层代码" class="headerlink" title="编写持久层代码"></a>编写持久层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询一个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findById</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用DBUtils类库进行SQL查询</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunner</span><span class="params">(QueryRunner runner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runner = runner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            accounts = runner.query(<span class="string">"select * from account"</span>,</span><br><span class="line">                    <span class="keyword">new</span> BeanListHandler&lt;&gt;(Account.class));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            account = runner.query(<span class="string">"select * from account where id = ?"</span>,</span><br><span class="line">                    <span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class), accountId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runner.update(<span class="string">"insert into account(name,money) values(?,?)"</span>,</span><br><span class="line">                    account.getName(), account.getMoney());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runner.update(<span class="string">"update account set name = ?, money = ? where id = ?"</span>,</span><br><span class="line">                    account.getName(), account.getMoney(), account.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runner.update(<span class="string">"delete from account where id = ?"</span>, accountId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写业务层代码"><a href="#编写业务层代码" class="headerlink" title="编写业务层代码"></a>编写业务层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询一个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findById</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        accountDao.delete(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Dao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"runner"</span> <span class="attr">ref</span>=<span class="string">"runner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置QueryRunner --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接数据源的必备信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountService as;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        as = ac.getBean(<span class="string">"accountService"</span>, AccountService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = as.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Account account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = as.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setName(<span class="string">"test"</span>);</span><br><span class="line">        account.setMoney(<span class="number">1234F</span>);</span><br><span class="line">        as.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = as.findById(<span class="number">4</span>);</span><br><span class="line">        account.setMoney(<span class="number">2345F</span>);</span><br><span class="line">        as.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        as.delete(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试中的问题：<ul><li>每个测试方法都重新获取了一次 Spring 的核心容器，造成了不必要的重复代码，增加了开发的工作量。</li><li>把容器的获取定义到类中，这种方式虽然能解决问题，但是仍需要自己写代码来获取容器。</li><li>能不能测试时直接就编写测试方法，而不需要手动编码来获取容器呢？</li></ul></li></ul><h2 id="改用注解进行配置"><a href="#改用注解进行配置" class="headerlink" title="改用注解进行配置"></a>改用注解进行配置</h2><ul><li>给业务层加注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        accountDao.delete(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给持久层加注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            accounts = runner.query(<span class="string">"select * from account"</span>,</span><br><span class="line">                    <span class="keyword">new</span> BeanListHandler&lt;&gt;(Account.class));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            account = runner.query(<span class="string">"select * from account where id = ?"</span>,</span><br><span class="line">                    <span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class), accountId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runner.update(<span class="string">"insert into account(name,money) values(?,?)"</span>,</span><br><span class="line">                    account.getName(), account.getMoney());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runner.update(<span class="string">"update account set name = ?, money = ? where id = ?"</span>,</span><br><span class="line">                    account.getName(), account.getMoney(), account.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runner.update(<span class="string">"delete from account where id = ?"</span>, accountId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给配置文件添加 <code>context</code> 命名空间：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 告知Spring在创建容器时要扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"service"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"dao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置QueryRunner --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接数据源的必备信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以发现，之所以现在离不开 XML 配置文件，是因为有一句很关键的配置，告知 Spring 框架在读取配置文件创建容器时，扫描注解，依据注解创建对象，并存入容器中。如果它也能用注解配置，那么就离脱离 XML 文件又进了一步。</li><li>另外，数据源和 <code>JdbcTemplate</code> 的配置也需要注解来实现。</li></ul><h1 id="Spring-中的新注解"><a href="#Spring-中的新注解" class="headerlink" title="Spring 中的新注解"></a>Spring 中的新注解</h1><h2 id="Configuration-注解"><a href="#Configuration-注解" class="headerlink" title="@Configuration 注解"></a><code>@Configuration</code> 注解</h2><ul><li>作用：<ul><li>用于<strong>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</strong>。</li></ul></li><li>属性：<ul><li><code>value</code>：用于指定配置类的字节码。</li></ul></li><li>细节：<ul><li>获取容器时需要使用 <code>new AnnotationApplicationContext(有@Configuration注解的类.class)</code>。</li><li><strong>当配置类作为 <code>AnnotationConfigApplicationContext</code> 对象创建的参数时，<code>@Configuration</code> 注解可以不写</strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该类是一个配置类，它的作用与 bean.xml 是一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把配置文件用类来代替了，但是如何配置创建容器时要扫描的包呢？</li></ul><h2 id="ComponentScan-注解"><a href="#ComponentScan-注解" class="headerlink" title="@ComponentScan 注解"></a><code>@ComponentScan</code> 注解</h2><ul><li>作用：<ul><li>用于<strong>指定 Spring 在初始化容器时要扫描的包</strong>。</li><li>作用和在 Spring 的 XML 配置文件中的 <code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code> 是一样的。</li></ul></li><li>属性：<ul><li><code>basePackages</code>：用于指定要扫描的包。和该注解中的 <code>value</code> 属性作用一样。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"service"</span>, <span class="string">"dao"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>已经配置好了要扫描的包，但是数据源和 <code>JdbcTemplate</code> 对象如何从配置文件中移除呢？</li></ul><h2 id="Bean-注解"><a href="#Bean-注解" class="headerlink" title="@Bean 注解"></a><code>@Bean</code> 注解</h2><ul><li>作用：<ul><li><strong>该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 Spring 容器</strong>。</li></ul></li><li>属性：<ul><li><code>name</code>：给当前 <code>@Bean</code> 注解方法创建的对象指定一个名称（即 <code>bean</code> 的 <code>id</code>）。和 <code>value</code> 属性作用一样。如果不指定，默认使用当前方法的名称。</li></ul></li><li>细节：<ul><li>当使用注解配置方法时，如果方法有参数，Spring 框架会去容器中查找有没有可用的 <code>bean</code> 对象。查找的方式和 <code>@Autowired</code> 注解是一样的。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个 QueryRunner 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"runner"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">createQueryRunner</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建数据源对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds.setDriverClass(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">            ds.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/springdb"</span>);</span><br><span class="line">            ds.setUser(<span class="string">"root"</span>);</span><br><span class="line">            ds.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PropertyVetoException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>已经把数据源和 <code>QueryRunner</code> 从配置文件中移除了，此时可以删除 <code>bean.xml</code> 了。</li><li>但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？</li></ul><h2 id="PropertySource-注解"><a href="#PropertySource-注解" class="headerlink" title="@PropertySource 注解"></a><code>@PropertySource</code> 注解</h2><ul><li>作用：<ul><li><strong>用于加载 <code>properties</code> 文件中的配置</strong>。</li></ul></li><li>属性：<ul><li><code>value[]</code>：用于指定 <code>properties</code> 文件位置。如果是<strong>在类路径下，需要写上 <code>classpath:</code></strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/springdb</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbcConfig.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个 QueryRunner 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"runner"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">createQueryRunner</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建数据源对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds.setDriverClass(driver);</span><br><span class="line">            ds.setJdbcUrl(url);</span><br><span class="line">            ds.setUser(username);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PropertyVetoException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时已经有了两个配置类，但是他们还没有关系。如何建立他们的关系呢？</li></ul><h2 id="Import-注解"><a href="#Import-注解" class="headerlink" title="@Import 注解"></a><code>@Import</code> 注解</h2><ul><li>作用：<ul><li><strong>用于导入其他的配置类</strong>。</li></ul></li><li>属性：<ul><li><code>value[]</code>：用于指定其他配置类的字节码。</li></ul></li><li>细节：<ul><li>在引入其他配置类时，可以不用再写 <code>@Configuration</code> 注解。当然，写上也没问题。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"service"</span>, <span class="string">"dao"</span>&#125;)</span><br><span class="line"><span class="meta">@Import</span>(JdbcConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-整合-Junit"><a href="#Spring-整合-Junit" class="headerlink" title="Spring 整合 Junit"></a>Spring 整合 Junit</h1><h2 id="测试类中的问题"><a href="#测试类中的问题" class="headerlink" title="测试类中的问题"></a>测试类中的问题</h2><ul><li>问题：<ul><li>在测试类中，每个测试类都要通过显式创建 <code>AppilicationContext</code> 对象主动获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</li></ul></li><li>解决思路：<ul><li>针对上述问题，需要的是程序能自动创建容器。一旦程序能自动创建 Spring 容器，就无须手动创建了，问题也就解决了。</li><li>但显然，Junit 是无法主动实现的，因为它自己都无法知晓是否使用了 Spring 框架，更不用说自动读取配置文件或配置类创建 Spring 容器了。</li><li>不过好在，Junit 暴露了一个注解，可以替换掉它的运行器。</li><li>这时，需要依靠 Spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器，只需要告诉它配置文件在哪就行了。</li></ul></li></ul><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="添加-spring-test-坐标"><a href="#添加-spring-test-坐标" class="headerlink" title="添加 spring-test 坐标"></a>添加 spring-test 坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-RunWith-注解替换原有的运行器"><a href="#使用-RunWith-注解替换原有的运行器" class="headerlink" title="使用 @RunWith 注解替换原有的运行器"></a>使用 <code>@RunWith</code> 注解替换原有的运行器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-ContextConfiguration-注解指定-spring-配置文件（或类）的位置"><a href="#使用-ContextConfiguration-注解指定-spring-配置文件（或类）的位置" class="headerlink" title="使用 @ContextConfiguration 注解指定 spring 配置文件（或类）的位置"></a>使用 <code>@ContextConfiguration</code> 注解指定 spring 配置文件（或类）的位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = SpringConfiguration.class)</span><br><span class="line"><span class="comment">// @ContextConfiguration(locations = "classpath:bean.xml")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@ContextConfiguration</code> 注解：<ul><li><code>locations</code> 属性：用于指定配置文件的位置。如果是类路径下，需要用 <code>classpath:</code> 表明。</li><li><code>classes</code> 属性：用于指定注解的类。当不使用 XML 配置时，需要用此属性指定注解类的位置。</li></ul></li></ul><h3 id="使用-Autowired-给测试类中的变量注入数据"><a href="#使用-Autowired-给测试类中的变量注入数据" class="headerlink" title="使用 @Autowired 给测试类中的变量注入数据"></a>使用 <code>@Autowired</code> 给测试类中的变量注入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = SpringConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService as;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么不把测试类配置到-XML-文件中？"><a href="#为什么不把测试类配置到-XML-文件中？" class="headerlink" title="为什么不把测试类配置到 XML 文件中？"></a>为什么不把测试类配置到 XML 文件中？</h2><ul><li>测试类同样可以配置到 XML 配置文件中，为什么不采用这种方式呢？<ol><li>当我们在 XML 中配置了一个 <code>bean</code>，Spring 加载配置文件创建容器时，就会创建对象。</li><li>测试类只是在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用，那么存在于容器中就会造成资源的浪费。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis框架（2）</title>
      <link href="/2020/06/11/mybatis-2.html"/>
      <url>/2020/06/11/mybatis-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-的连接池技术"><a href="#MyBatis-的连接池技术" class="headerlink" title="MyBatis 的连接池技术"></a>MyBatis 的连接池技术</h1><ul><li>连接池就是用于存储连接的一个容器，其实就是一个集合，该集合必须是线程安全的，不能两个线程拿到同一个连接。该集合还必须实现队列的 FIFO 特性。使用连接池技术可以减少获取连接所消耗的时间。</li><li>MyBatis 中采用自己的连接池技术。在 MyBatis 的 <code>SqlMapConfig.xml</code> 配置文件中，通过 <code>&lt;dataSource type=&quot;POOLED&quot;&gt;</code> 来实现 MyBatis 中连接池的配置。</li></ul><h2 id="MyBatis-连接池的分类"><a href="#MyBatis-连接池的分类" class="headerlink" title="MyBatis 连接池的分类"></a>MyBatis 连接池的分类</h2><ul><li>MyBatis 提供了 3 种方式配置连接池：<ul><li><code>POOLED</code>：使用连接池的数据源。采用传统的 <code>javax.sql.DataSource</code> 规范中的连接池，MyBatis 中有针对的实现。</li><li><code>UNPOOLED</code>：不使用连接池的数据源。采用传统的获取连接的方式，虽然也实现了 <code>javax.sql.DataSource</code> 接口，但没有使用池的思想。</li><li><code>JNDI</code>：采用服务器提供的 JNDI 技术实现，来获取 <code>DataSource</code> 对象，不同的服务器能拿到的 <code>DataSource</code> 是不一样的。如果不是 WEB 或 Maven 的 war 工程是不能使用的。</li></ul></li></ul><p><img src="/2020/06/11/mybatis-2/mybatis中的3种连接池实现.png" alt="mybatis中的3种连接池实现"></p><ul><li>相应地，MyBatis 内部分别定义了实现了 <code>java.sql.DataSource</code> 接口的 <code>UnpooledDataSource</code> 和 <code>PooledDataSource</code> 类来表示 <code>UNPOOLED</code>、<code>POOLED</code> 类型的数据源。</li><li><code>PooledDataSource</code> 持有一个 <code>UnpooledDataSource</code> 的引用，当 <code>PooledDataSource</code> 需要创建 <code>java.sql.Connection</code> 实例对象时，还是通过 <code>UnpooledDataSource</code> 来创建，<code>PooledDataSource</code> 只是提供了一种缓存连接池机制。</li></ul><h2 id="MyBatis-中-DataSource-的存取"><a href="#MyBatis-中-DataSource-的存取" class="headerlink" title="MyBatis 中 DataSource 的存取"></a>MyBatis 中 <code>DataSource</code> 的存取</h2><ul><li>MyBatis 是通过工厂模式来创建数据源 <code>DataSource</code> 对象的，MyBatis 定义了抽象的工厂接口 <code>DataSourceFactory</code>，通过其 <code>getDataSource()</code> 方法返回数据源 <code>DataSource</code>。<code>DataSourceFactory</code> 源码具体如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.datasource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyBatis 创建了 <code>DataSource</code> 实例后，会将其放到 <code>Configuration</code> 对象内的 <code>Environment</code> 对象中，供以后使用。</li></ul><h2 id="MyBatis-中连接的获取过程分析"><a href="#MyBatis-中连接的获取过程分析" class="headerlink" title="MyBatis 中连接的获取过程分析"></a>MyBatis 中连接的获取过程分析</h2><ul><li>当创建 <code>SqlSession</code> 对象并需要执行 SQL 语句时，MyBatis 才会去调用 <code>dataSource</code> 对象来创建 <code>java.sql.Connection</code> 对象。也就是说，<code>java.sql.Connection</code> 对象的创建一直延迟到执行 SQL 语句的时候。</li><li>获取连接的源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.popConnection(<span class="keyword">this</span>.dataSource.getUsername(), <span class="keyword">this</span>.dataSource.getPassword()).getProxyConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.popConnection(username, password).getProxyConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">while</span>(conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.state) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.state.idleConnections.isEmpty()) &#123;</span><br><span class="line">                    conn = (PooledConnection)<span class="keyword">this</span>.state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(<span class="string">"Checked out connection "</span> + conn.getRealHashCode() + <span class="string">" from pool."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state.activeConnections.size() &lt; <span class="keyword">this</span>.poolMaximumActiveConnections) &#123;</span><br><span class="line">                    conn = <span class="keyword">new</span> PooledConnection(<span class="keyword">this</span>.dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(<span class="string">"Created connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    PooledConnection oldestActiveConnection = (PooledConnection)<span class="keyword">this</span>.state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>真正连接打开的时间点，只是在执行 SQL 语句时，才会进行。</li><li>可以进一步发现，数据库连接是最为宝贵的资源，只有在要用到的时候，才去获取并打开连接，用完了就再立即将数据库连接归还到连接池中。</li></ul><h1 id="MyBatis-的事务控制"><a href="#MyBatis-的事务控制" class="headerlink" title="MyBatis 的事务控制"></a>MyBatis 的事务控制</h1><ul><li>MyBatis 通过 <code>SqlSession</code> 对象的 <code>commit</code> 和 <code>rollback</code> 方法实现事务的提交和回滚。</li><li><strong>MyBatis 中事务的提交方式，本质上就是调用 JDBC 的 <code>setAutoCommit()</code> 来实现事务控制</strong>。</li><li>之前的 CUD 操作过程中，我们都要手动进行事务的提交，主要原因就是在连接池中取出的连接，都会将调用 <code>connection.setAutoCommit(false)</code> 方法，这样就必须使用 <code>sqlSession.commit()</code> 方法，相当于使用了 JDBC 中的 <code>connection.commit()</code> 方法实现事务提交。</li><li>可以调用 <code>factory.openSession(true)</code> 方法，设置 MyBatis 的事务自动提交。</li><li>就编程而言，设置为自动提交方式为 <code>false</code> 再根据情况决定是否进行提交，这种方式更常用。因为可以根据业务情况来决定提交是否进行提交。</li></ul><h1 id="MyBatis-的动态-SQL"><a href="#MyBatis-的动态-SQL" class="headerlink" title="MyBatis 的动态 SQL"></a>MyBatis 的动态 SQL</h1><ul><li>MyBatis 的映射文件中，前面案例中的 SQL 都是比较简单的，有些时候业务逻辑复杂时，SQL 是动态变化的，此时在前面学习中的 SQL 就不能满足要求了。</li></ul><h2 id="动态-SQL-之-lt-if-gt-标签"><a href="#动态-SQL-之-lt-if-gt-标签" class="headerlink" title="动态 SQL 之 &lt;if&gt; 标签"></a>动态 SQL 之 <code>&lt;if&gt;</code> 标签</h2><ul><li>根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 <code>id</code> 如果不为空时可以根据 <code>id</code> 查询，如果 <code>username</code> 不同空时还要加入用户名作为条件。这种情况在多条件组合查询中经常会碰到。</li></ul><h3 id="持久层-Dao-接口"><a href="#持久层-Dao-接口" class="headerlink" title="持久层 Dao 接口"></a>持久层 Dao 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户信息查询用户列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久层-Dao-映射配置"><a href="#持久层-Dao-映射配置" class="headerlink" title="持久层 Dao 映射配置"></a>持久层 Dao 映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user where 1 = 1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">            and username like #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address != null"</span>&gt;</span></span><br><span class="line">            and address like #&#123;address&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意事项：<ul><li><strong><code>&lt;if&gt;</code> 标签的 <code>test</code> 属性中写的是对象的属性名，如果是包装类对象需要使用 OGNL 表达式的写法</strong>。</li><li>另外需要注意 <code>where 1 = 1</code> 的作用。</li></ul></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisDataSourceAndTxTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"%王%"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"%金燕龙%"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = mapper.findByUser(user);</span><br><span class="line">        <span class="keyword">for</span> (User u : users) &#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态-SQL-之-lt-where-gt-标签"><a href="#动态-SQL-之-lt-where-gt-标签" class="headerlink" title="动态 SQL 之 &lt;where&gt; 标签"></a>动态 SQL 之 <code>&lt;where&gt;</code> 标签</h2><ul><li>为了简化上面 <code>where 1 = 1</code> 的条件封装，可以采用 <code>&lt;where&gt;</code> 标签来简化开发。</li><li>修改映射配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">                and username like #&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address != null"</span>&gt;</span></span><br><span class="line">                and address like #&#123;address&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;where&gt;</code> 标签可以自动处理第一个 <code>and</code>。</li></ul><h2 id="动态-SQL-之-lt-foreach-gt-标签"><a href="#动态-SQL-之-lt-foreach-gt-标签" class="headerlink" title="动态 SQL 之 &lt;foreach&gt; 标签"></a>动态 SQL 之 <code>&lt;foreach&gt;</code> 标签</h2><ul><li>传入多个 <code>id</code> 查询用户信息，用下边两个 SQL 实现：<ul><li><code>SELECT * FROM USERS WHERE username LIKE &#39;%张%&#39; AND (id =10 OR id =89 OR id=16)</code></li><li><code>SELECT * FROM USERS WHERE username LIKE &#39;%张%&#39; AND id IN (10,89,16)</code></li></ul></li><li>那么在进行范围查询的时候，如何将一个集合作为参数动态传递？</li></ul><h3 id="在-QueryVo-中加入一个-List-集合用于封装参数"><a href="#在-QueryVo-中加入一个-List-集合用于封装参数" class="headerlink" title="在 QueryVo 中加入一个 List 集合用于封装参数"></a>在 <code>QueryVo</code> 中加入一个 <code>List</code> 集合用于封装参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ids;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIds</span><span class="params">(List&lt;Integer&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ids = ids;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久层-Dao"><a href="#持久层-Dao" class="headerlink" title="持久层 Dao"></a>持久层 Dao</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id集合查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findInIds</span><span class="params">(QueryVo vo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久层-Dao-映射配置-1"><a href="#持久层-Dao-映射配置-1" class="headerlink" title="持久层 Dao 映射配置"></a>持久层 Dao 映射配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findInIds"</span> <span class="attr">parameterType</span>=<span class="string">"QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null and ids.size() &gt; 0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"and id in ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"uid"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                    #&#123;uid&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SQL 语句是 <code>select * from user where id in (?)</code>。</li><li><code>&lt;foreach&gt;</code> 标签用于遍历集合。<ul><li><code>collection</code>：代表要遍历的集合元素，注意编写时不要写 <code>#{}</code>。</li><li><code>open</code>：代表语句的开始部分。</li><li><code>close</code>：代表结束部分。</li><li><code>item</code>：代表遍历集合的每个元素，生成的变量名。</li><li><code>separator</code>：代表分隔符。</li></ul></li></ul><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisDataSourceAndTxTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindInIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryVo vo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">        vo.setIds(List.of(<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">46</span>, <span class="number">57</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = mapper.findInIds(vo);</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyBatis-中简化编写的-SQL-片段"><a href="#MyBatis-中简化编写的-SQL-片段" class="headerlink" title="MyBatis 中简化编写的 SQL 片段"></a>MyBatis 中简化编写的 SQL 片段</h2><h3 id="定义代码片段"><a href="#定义代码片段" class="headerlink" title="定义代码片段"></a>定义代码片段</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义代码片段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"defaultSql"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="引用代码片段"><a href="#引用代码片段" class="headerlink" title="引用代码片段"></a>引用代码片段</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"defaultSql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">                and username like #&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address != null"</span>&gt;</span></span><br><span class="line">                and address like #&#123;address&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="MyBatis-的多表关联查询"><a href="#MyBatis-的多表关联查询" class="headerlink" title="MyBatis 的多表关联查询"></a>MyBatis 的多表关联查询</h1><h2 id="MyBatis-多表查询之一对一（多对一）"><a href="#MyBatis-多表查询之一对一（多对一）" class="headerlink" title="MyBatis 多表查询之一对一（多对一）"></a>MyBatis 多表查询之一对一（多对一）</h2><ul><li>MyBatis 中将多对一关系看成一对一关系进行处理。因为多对一关系中，多的一方任意一个都只能对应一个一的一方。</li><li>现有数据库，一个用户可以拥有多个账户，但是每个账户只能对应一个用户。</li><li>实现查询账户信息时，也要查询账户所对应的用户信息。</li></ul><h3 id="方式一：创建输出类型"><a href="#方式一：创建输出类型" class="headerlink" title="方式一：创建输出类型"></a>方式一：创建输出类型</h3><ul><li>定义专门的 pojo 类作为输出类型，其中定义了 SQL 查询结果集所有的字段。此方法较为简单，企业中使用普遍。</li></ul><h4 id="定义账户信息实体类"><a href="#定义账户信息实体类" class="headerlink" title="定义账户信息实体类"></a>定义账户信息实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写-SQL-语句"><a href="#编写-SQL-语句" class="headerlink" title="编写 SQL 语句"></a>编写 SQL 语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> account.*,</span><br><span class="line">       user.username,</span><br><span class="line">       user.address</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">account</span>,</span><br><span class="line">     <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> account.uid = user.id</span><br></pre></td></tr></table></figure><ul><li>数据库查询结果如下：</li></ul><p><img src="/2020/06/11/mybatis-2/查询所有账户信息结果.png" alt></p><h4 id="定义-AccountUser-类"><a href="#定义-AccountUser-类" class="headerlink" title="定义 AccountUser 类"></a>定义 <code>AccountUser</code> 类</h4><ul><li>为了能够封装上面 SQL 语句的查询结果，定义 <code>AccountUser</code> 类中要包含账户信息同时还要包含用户信息，所以我们要在定义 <code>AccountUser</code> 类时可以继承 <code>Account</code> 类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountUser</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"  AccountUser&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义账户的持久层-Dao-接口"><a href="#定义账户的持久层-Dao-接口" class="headerlink" title="定义账户的持久层 Dao 接口"></a>定义账户的持久层 Dao 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户，同时包含用户姓名和地址信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;AccountUser&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义-AccountUser-xml-映射配置信息"><a href="#定义-AccountUser-xml-映射配置信息" class="headerlink" title="定义 AccountUser.xml 映射配置信息"></a>定义 <code>AccountUser.xml</code> 映射配置信息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.AccountDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"AccountUser"</span>&gt;</span></span><br><span class="line">        select a.*, u.username, u.address</span><br><span class="line">        from account a, user u</span><br><span class="line">        where u.id = a.uid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：因为上面查询的结果中包含了账户信息同时还包含了用户信息，所以返回值类型 <code>returnType</code> 的值设置为 <code>AccountUser</code> 类型，这样就可以接收账户信息和用户信息了。</li></ul><h4 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream config;</span><br><span class="line">    <span class="keyword">private</span> SqlSession session;</span><br><span class="line">    <span class="keyword">private</span> AccountDao mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        config = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(config);</span><br><span class="line">        session = factory.openSession();</span><br><span class="line">        mapper = session.getMapper(AccountDao.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 在关闭资源之前，提交事务</span></span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        config.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;AccountUser&gt; accounts = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (AccountUser account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account&#123;id=<span class="number">1</span>, uid=<span class="number">41</span>, money=<span class="number">1000.0</span>&#125;  AccountUser&#123;username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>&#125;</span><br><span class="line">Account&#123;id=<span class="number">2</span>, uid=<span class="number">45</span>, money=<span class="number">1000.0</span>&#125;  AccountUser&#123;username=<span class="string">'传智播客'</span>, address=<span class="string">'北京金燕龙'</span>&#125;</span><br><span class="line">Account&#123;id=<span class="number">3</span>, uid=<span class="number">41</span>, money=<span class="number">2000.0</span>&#125;  AccountUser&#123;username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二：使用组合"><a href="#方式二：使用组合" class="headerlink" title="方式二：使用组合"></a>方式二：使用组合</h3><ul><li>通过面向对象的 <code>Has-A</code> 关系得知，可以在 <code>Account</code> 类中加入一个 <code>User</code> 类的对象来代表这个账户是哪个用户的。</li><li>使用 <code>resultMap</code>，定义专门的 <code>resultMap</code> 用于映射一对一查询结果。</li></ul><h4 id="修改-Account-类"><a href="#修改-Account-类" class="headerlink" title="修改 Account 类"></a>修改 <code>Account</code> 类</h4><ul><li>在 <code>Account</code> 类中加入 <code>User</code> 类的对象作为 <code>Account</code> 类的一个属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改-AccountDao-接口中的方法"><a href="#修改-AccountDao-接口中的方法" class="headerlink" title="修改 AccountDao 接口中的方法"></a>修改 <code>AccountDao</code> 接口中的方法</h4><ul><li>将返回值改回 <code>Account</code> 类型。</li><li>因为 <code>Account</code> 类中包含了一个 User 类的对象，它可以封装账户所对应的用户信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户，同时包含用户姓名和地址信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重新定义-AccountDao-xml-文件"><a href="#重新定义-AccountDao-xml-文件" class="headerlink" title="重新定义 AccountDao.xml 文件"></a>重新定义 <code>AccountDao.xml</code> 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.AccountDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 建立account和user的对应关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountUserMap"</span> <span class="attr">type</span>=<span class="string">"Account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用于指定从表方的引用实体属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"accountUserMap"</span>&gt;</span></span><br><span class="line">        select u.*, a.id as aid, a.uid, a.money</span><br><span class="line">        from account a, user u</span><br><span class="line">        where a.uid = u.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Account account : accounts) &#123;</span><br><span class="line">            System.out.println(account + <span class="string">"  "</span> + account.getUser());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account&#123;id=<span class="number">1</span>, uid=<span class="number">41</span>, money=<span class="number">1000.0</span>&#125;  User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">Account&#123;id=<span class="number">2</span>, uid=<span class="number">45</span>, money=<span class="number">1000.0</span>&#125;  User&#123;id=<span class="number">45</span>, username=<span class="string">'传智播客'</span>, address=<span class="string">'北京金燕龙'</span>, sex=<span class="string">'男'</span>, birthday=Sun Mar <span class="number">04</span> <span class="number">12</span>:<span class="number">04</span>:<span class="number">06</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">Account&#123;id=<span class="number">3</span>, uid=<span class="number">41</span>, money=<span class="number">2000.0</span>&#125;  User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="MyBatis-多表查询之一对多"><a href="#MyBatis-多表查询之一对多" class="headerlink" title="MyBatis 多表查询之一对多"></a>MyBatis 多表查询之一对多</h2><ul><li>查询所有用户信息及用户关联的账户信息。</li></ul><h3 id="编写-SQL-语句-1"><a href="#编写-SQL-语句-1" class="headerlink" title="编写 SQL 语句"></a>编写 SQL 语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">account</span> a</span><br><span class="line"><span class="keyword">on</span> u.id = a.uid</span><br></pre></td></tr></table></figure><ul><li>数据库查询结果：</li></ul><p><img src="/2020/06/11/mybatis-2/查询所有用户的账户信息结果.png" alt></p><h3 id="User-类中加入-List-lt-Account-gt"><a href="#User-类中加入-List-lt-Account-gt" class="headerlink" title="User 类中加入 List&lt;Account&gt;"></a><code>User</code> 类中加入 <code>List&lt;Account&gt;</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改映射配置文件"><a href="#修改映射配置文件" class="headerlink" title="修改映射配置文件"></a>修改映射配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置user对象中accounts集合的映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"Account"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"aid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">property</span>=<span class="string">"uid"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"money"</span> <span class="attr">property</span>=<span class="string">"money"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userAccountMap"</span>&gt;</span></span><br><span class="line">        select * from user u left outer join account a on u.id = a.uid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>collection</code> 表示关联查询结果集</strong>。<ul><li><code>property</code>：指定关联查询结果集存储在哪个属性中。</li><li><code>ofType</code>：指定关联查询结果集中的对象类型。可以使用别名，也可以使用全限定名。</li></ul></li></ul><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            System.out.println(user.getAccounts());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[Account&#123;id=<span class="keyword">null</span>, uid=<span class="number">41</span>, money=<span class="number">1000.0</span>&#125;, Account&#123;id=<span class="keyword">null</span>, uid=<span class="number">41</span>, money=<span class="number">2000.0</span>&#125;]</span><br><span class="line">User&#123;id=<span class="number">45</span>, username=<span class="string">'传智播客'</span>, address=<span class="string">'北京金燕龙'</span>, sex=<span class="string">'男'</span>, birthday=Sun Mar <span class="number">04</span> <span class="number">12</span>:<span class="number">04</span>:<span class="number">06</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[Account&#123;id=<span class="keyword">null</span>, uid=<span class="number">45</span>, money=<span class="number">1000.0</span>&#125;]</span><br><span class="line">User&#123;id=<span class="number">42</span>, username=<span class="string">'小二王'</span>, address=<span class="string">'北京金燕龙'</span>, sex=<span class="string">'女'</span>, birthday=Fri Mar <span class="number">02</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br><span class="line">User&#123;id=<span class="number">43</span>, username=<span class="string">'小二王'</span>, address=<span class="string">'北京金燕龙'</span>, sex=<span class="string">'女'</span>, birthday=Sun Mar <span class="number">04</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">34</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br><span class="line">User&#123;id=<span class="number">46</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Wed Mar <span class="number">07</span> <span class="number">17</span>:<span class="number">37</span>:<span class="number">26</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br><span class="line">User&#123;id=<span class="number">48</span>, username=<span class="string">'小马宝莉'</span>, address=<span class="string">'北京修正'</span>, sex=<span class="string">'女'</span>, birthday=Thu Mar <span class="number">08</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">00</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h2 id="MyBatis-多表查询之多对多"><a href="#MyBatis-多表查询之多对多" class="headerlink" title="MyBatis 多表查询之多对多"></a>MyBatis 多表查询之多对多</h2><ul><li>上面使用 MyBatis 实现了一对多关系的维护。</li><li><strong>多对多关系其实就是双向的一对多关系</strong>。</li></ul><h3 id="业务要求及-SQL"><a href="#业务要求及-SQL" class="headerlink" title="业务要求及 SQL"></a>业务要求及 SQL</h3><ul><li>使用用户与角色的关系模型进行实现。</li><li>查询所有角色并且加载它所分配的用户信息。</li><li>查询角色我们需要用到 <code>Role</code> 表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中间表（<code>USER_ROLE</code> 表）才能关联到用户信息。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> r.id <span class="keyword">as</span> rid, role_name, role_desc, u.* <span class="keyword">from</span> <span class="keyword">role</span> r</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> user_role ur <span class="keyword">on</span> r.id = ur.rid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> ur.uid = u.id</span><br></pre></td></tr></table></figure><ul><li>数据库查询结果：</li></ul><p><img src="/2020/06/11/mybatis-2/查询角色及用户信息.png" alt></p><h3 id="编写角色实体类-Role"><a href="#编写角色实体类-Role" class="headerlink" title="编写角色实体类 Role"></a>编写角色实体类 <code>Role</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String roleDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多对多的关系映射：一个角色可以赋予多个用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-Role-的持久层接口"><a href="#编写-Role-的持久层接口" class="headerlink" title="编写 Role 的持久层接口"></a>编写 <code>Role</code> 的持久层接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有角色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Role&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写映射配置文件"><a href="#编写映射配置文件" class="headerlink" title="编写映射配置文件"></a>编写映射配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"roles"</span> <span class="attr">ofType</span>=<span class="string">"Role"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"rid"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleDesc"</span> <span class="attr">column</span>=<span class="string">"role_desc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userAccountMap"</span>&gt;</span></span><br><span class="line">        select u.*, r.id as rid, role_name, role_desc from user u</span><br><span class="line">        left outer join user_role ur on u.id = ur.uid</span><br><span class="line">        left outer join role r on ur.rid = r.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Role&gt; roles = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            System.out.println(role);</span><br><span class="line">            System.out.println(role.getUsers());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=<span class="number">41</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[Role&#123;id=<span class="number">1</span>, roleName=<span class="string">'院长'</span>, roleDesc=<span class="string">'管理整个学院'</span>&#125;, Role&#123;id=<span class="number">2</span>, roleName=<span class="string">'总裁'</span>, roleDesc=<span class="string">'管理整个公司'</span>&#125;]</span><br><span class="line">User&#123;id=<span class="number">45</span>, username=<span class="string">'传智播客'</span>, address=<span class="string">'北京金燕龙'</span>, sex=<span class="string">'男'</span>, birthday=Sun Mar <span class="number">04</span> <span class="number">12</span>:<span class="number">04</span>:<span class="number">06</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[Role&#123;id=<span class="number">1</span>, roleName=<span class="string">'院长'</span>, roleDesc=<span class="string">'管理整个学院'</span>&#125;]</span><br><span class="line">User&#123;id=<span class="number">42</span>, username=<span class="string">'小二王'</span>, address=<span class="string">'北京金燕龙'</span>, sex=<span class="string">'女'</span>, birthday=Fri Mar <span class="number">02</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br><span class="line">User&#123;id=<span class="number">43</span>, username=<span class="string">'小二王'</span>, address=<span class="string">'北京金燕龙'</span>, sex=<span class="string">'女'</span>, birthday=Sun Mar <span class="number">04</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">34</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br><span class="line">User&#123;id=<span class="number">46</span>, username=<span class="string">'老王'</span>, address=<span class="string">'北京'</span>, sex=<span class="string">'男'</span>, birthday=Wed Mar <span class="number">07</span> <span class="number">17</span>:<span class="number">37</span>:<span class="number">26</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br><span class="line">User&#123;id=<span class="number">48</span>, username=<span class="string">'小马宝莉'</span>, address=<span class="string">'北京修正'</span>, sex=<span class="string">'女'</span>, birthday=Thu Mar <span class="number">08</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">00</span> CST <span class="number">2018</span>&#125;</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h1 id="MyBatis-延迟加载策略"><a href="#MyBatis-延迟加载策略" class="headerlink" title="MyBatis 延迟加载策略"></a>MyBatis 延迟加载策略</h1><ul><li>通过前面的学习，我们已经掌握了 MyBatis 中一对一、一对多、多对多关系的配置及实现，可以实现对象的关联查询。</li><li>实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载。</li></ul><h2 id="何为延迟加载"><a href="#何为延迟加载" class="headerlink" title="何为延迟加载"></a>何为延迟加载</h2><ul><li>问题：在一对多中，有一个用户，它有 100 个账户。<ul><li>在查询用户时，要不要把关联的账户查询出来？</li><li>在查询账户时，要不要把关联的用户查询出来？</li></ul></li><li>解决：<ul><li>在查询用户时，用户下的账户信息应该是，什么时候用，什么时候查询。</li><li>在查询账户时，账户的所属用户信息应该，随着账户查询一起查询出来。</li></ul></li><li><strong>延迟加载：</strong><ul><li><strong>在需要用到数据时才进行加载，不需要用到数据时就不加载数据</strong>。</li><li>延迟加载也称按需加载、懒加载。</li></ul></li><li>立即加载：<ul><li>不管需不需要使用数据，只要一调用方法就马上发起查询。</li></ul></li><li>使用时机：<ul><li>一对多和多对多关系中，通常采用延迟加载。</li><li>多对一和一对一关系中，通常采用立即加载。</li></ul></li></ul><h2 id="实现延迟加载"><a href="#实现延迟加载" class="headerlink" title="实现延迟加载"></a>实现延迟加载</h2><ul><li>我们使用了 <code>resultMap</code> 来实现一对一，一对多，多对多关系的操作。主要是通过 <code>association</code>、<code>collection</code> 实现一对一及一对多映射。<code>association</code>、<code>collection</code> 具备延迟加载功能。</li></ul><h3 id="使用-association-实现延迟加载"><a href="#使用-association-实现延迟加载" class="headerlink" title="使用 association 实现延迟加载"></a>使用 <code>association</code> 实现延迟加载</h3><ul><li>在多对一关系配置的 <code>&lt;association&gt;</code> 结点中配置延迟加载策略。</li></ul><h4 id="账户的持久层接口"><a href="#账户的持久层接口" class="headerlink" title="账户的持久层接口"></a>账户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户，同时包含用户姓名和地址信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="账户的持久层映射配置"><a href="#账户的持久层映射配置" class="headerlink" title="账户的持久层映射配置"></a>账户的持久层映射配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.AccountDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountMap"</span> <span class="attr">type</span>=<span class="string">"Account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一对一的关系映射：配置封装user的内容，</span></span><br><span class="line"><span class="comment">             select属性指定的内容：查询用户的唯一标识，</span></span><br><span class="line"><span class="comment">             column属性指定的内容：用户根据id查询时，所需要的参数的值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">select</span>=<span class="string">"dao.UserDao.findById"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"accountMap"</span>&gt;</span></span><br><span class="line">        select * from account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>select</code>：填写要调用的 <code>select</code> 映射的 <code>id</code></strong>。</li><li><strong><code>column</code>：填写要传递给 <code>select</code> 映射的参数</strong>。</li></ul><h4 id="用户的持久层接口"><a href="#用户的持久层接口" class="headerlink" title="用户的持久层接口"></a>用户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户的持久层映射配置"><a href="#用户的持久层映射配置" class="headerlink" title="用户的持久层映射配置"></a>用户的持久层映射配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启-MyBatis-的延迟加载"><a href="#开启-MyBatis-的延迟加载" class="headerlink" title="开启 MyBatis 的延迟加载"></a>开启 MyBatis 的延迟加载</h4><ul><li>进入 MyBatis 的官方文档，找到 settings 的说明信息：</li></ul><p><img src="/2020/06/11/mybatis-2/如何开启mybatis延迟加载.png" alt></p><ul><li>需要在 MyBatis 的配置文件 <code>SqlMapConfig.xml</code> 中添加延迟加载的配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启MyBatis的延迟加载开关 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将积极加载改为消极加载即按需加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写测试只查询账户信息不查用户信息"><a href="#编写测试只查询账户信息不查用户信息" class="headerlink" title="编写测试只查询账户信息不查用户信息"></a>编写测试只查询账户信息不查用户信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = mapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><p><img src="/2020/06/11/mybatis-2/只查询账户信息.png" alt></p><ul><li>因为本次只是将 <code>Account</code> 对象查询出来放入 <code>List</code> 集合中，并没有涉及到 <code>User</code> 对象，所以就没有发出 SQL 语句查询账户所关联的 <code>User</code> 对象。</li></ul><h3 id="使用-collection-实现延迟加载"><a href="#使用-collection-实现延迟加载" class="headerlink" title="使用 collection 实现延迟加载"></a>使用 <code>collection</code> 实现延迟加载</h3><ul><li>可以在一对多关系配置的 <code>&lt;collection&gt;</code> 结点中配置延迟加载策略。</li><li><code>&lt;collection&gt;</code> 结点中也有 <code>select</code> 属性和 <code>column</code> 属性。</li></ul><h4 id="用户的持久层接口-1"><a href="#用户的持久层接口-1" class="headerlink" title="用户的持久层接口"></a>用户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户的持久层映射配置-1"><a href="#用户的持久层映射配置-1" class="headerlink" title="用户的持久层映射配置"></a>用户的持久层映射配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collection 是用于建立一对多中集合属性的对应关系</span></span><br><span class="line"><span class="comment">             ofType 用于指定集合元素的数据类型</span></span><br><span class="line"><span class="comment">             select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称）</span></span><br><span class="line"><span class="comment">             column 是用于指定使用哪个字段的值作为条件查询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"Account"</span> <span class="attr">select</span>=<span class="string">"dao.AccountDao.findByUid"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;collection&gt;</code> 标签：主要用于加载关联的集合对象。</li><li><strong><code>select</code> 属性</strong>：用于指定查询 <code>account</code> 列表的 SQL 语句，所以填写的是该 <strong>SQL 映射的 <code>id</code></strong>。</li><li><strong><code>column</code> 属性</strong>：用于指定 <code>select</code> 属性的 <strong>SQL 语句的参数来源</strong>，上面的参数来自于 <code>user</code> 的 <code>id</code> 列，所以就写成 <code>id</code> 这一个字段名了。</li></ul><h4 id="账户的持久层接口-1"><a href="#账户的持久层接口-1" class="headerlink" title="账户的持久层接口"></a>账户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户id查询账户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findByUid</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="账户的持久层映射配置-1"><a href="#账户的持久层映射配置-1" class="headerlink" title="账户的持久层映射配置"></a>账户的持久层映射配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.AccountDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByUid"</span> <span class="attr">resultType</span>=<span class="string">"Account"</span>&gt;</span></span><br><span class="line">        select * from account where uid = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试只加载用户信息"><a href="#测试只加载用户信息" class="headerlink" title="测试只加载用户信息"></a>测试只加载用户信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = mapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><p><img src="/2020/06/11/mybatis-2/只查询用户信息.png" alt></p><ul><li>没有加载 <code>Account</code> 账户信息。</li></ul><h1 id="MyBatis-缓存"><a href="#MyBatis-缓存" class="headerlink" title="MyBatis 缓存"></a>MyBatis 缓存</h1><h2 id="简单认识缓存"><a href="#简单认识缓存" class="headerlink" title="简单认识缓存"></a>简单认识缓存</h2><ul><li>什么是缓存？<ul><li>存在于内存中的临时数据。</li></ul></li><li>为什么使用缓存？<ul><li>减少和数据库的交互次数，提高执行效率。</li></ul></li><li>适用场景：<ul><li>经常查询并且不经常改变。</li><li>数据的正确与否对最终结果影响不大。</li><li>比如：商品的库存、银行的汇率、股市的牌价。</li></ul></li></ul><h2 id="MyBatis-中的一级缓存"><a href="#MyBatis-中的一级缓存" class="headerlink" title="MyBatis 中的一级缓存"></a>MyBatis 中的一级缓存</h2><ul><li>MyBatis 中缓存分为一级缓存、二级缓存。</li></ul><p><img src="/2020/06/11/mybatis-2/mybatis缓存结构.png" alt></p><ul><li><strong>MyBatis 的一级缓存是指 <code>SqlSession</code> 级别的缓存，只要 <code>SqlSession</code> 没有 <code>flush</code> 或 <code>close</code>，缓存就存在</strong>。</li><li>当执行查询之后，查询的结果会存入到 <code>SqlSession</code> 提供的一块区域中，<strong>该区域的结构是一个 <code>Map</code></strong>。</li><li>当再次查询同样的数据，MyBatis 会先去 <code>SqlSession</code> 中查询是否有结果数据，有的话直接取出使用。</li><li>当 <code>SqlSession</code> 对象消失时，MyBatis 的一级缓存也就消失了。</li></ul><h3 id="证明一级缓存的存在"><a href="#证明一级缓存的存在" class="headerlink" title="证明一级缓存的存在"></a>证明一级缓存的存在</h3><ul><li>编写用户的持久层接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写用户的持久层映射配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写测试方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFirstLevelCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user1 = mapper.findById(<span class="number">41</span>);</span><br><span class="line">        <span class="comment">// session.clearCache();</span></span><br><span class="line">        User user2 = mapper.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user1 == user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果 <code>true</code>：</li></ul><p><img src="/2020/06/11/mybatis-2/证明一级缓存的存在.png" alt></p><ul><li>虽然在上面的代码中查询了两次，但最后只执行了一次数据库操作，这就是 MyBatis 提供的一级缓存在起作用了。</li><li>因为一级缓存的存在，导致第二次查询 <code>id</code> 为 41 的记录时，并没有发出 SQL 语句从数据库中查询数据，而是从一级缓存中查询。</li></ul><h3 id="触发一级缓存的清空"><a href="#触发一级缓存的清空" class="headerlink" title="触发一级缓存的清空"></a>触发一级缓存的清空</h3><ul><li>一级缓存是 <code>SqlSession</code> 范围的缓存，<strong>当调用 <code>SqlSession</code> 的修改、添加、删除、<code>commit()</code>、<code>close()</code> 等方法时，就会清空一级缓存</strong>。</li></ul><p><img src="/2020/06/11/mybatis-2/一级缓存的清空.png" alt></p><ul><li><code>SqlSession</code> 执行 CUD 操作后，清空 <code>SqlSession</code> 中的一级缓存，这样做的目的是<strong>让缓存中存储的是最新的信息，避免脏读</strong>。</li><li>下面测试清空一级缓存的触发。在 <code>UserDao</code> 中加入更新方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>UserDao.xml</code> 中添加更新方法的映射：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        update user set username = #&#123;username&#125;, address = #&#123;address&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加测试方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClearCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user1 = mapper.findById(<span class="number">57</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line">        user1.setUsername(<span class="string">"update user clear cache"</span>);</span><br><span class="line">        user1.setAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">        mapper.updateUser(user1);</span><br><span class="line"></span><br><span class="line">        User user2 = mapper.findById(<span class="number">57</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        System.out.println(user1 == user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果 <code>false</code>：</li></ul><p><img src="/2020/06/11/mybatis-2/测试更新导致清空一级缓存.png" alt></p><ul><li>当执行 <code>mapper.updateUser()</code> 后，再次查询 <code>id = 57</code> 的 <code>User</code> 对象时，又重新执行了 SQL 语句，从数据库进行了查询操作。</li></ul><h2 id="MyBatis-的二级缓存"><a href="#MyBatis-的二级缓存" class="headerlink" title="MyBatis 的二级缓存"></a>MyBatis 的二级缓存</h2><ul><li><strong>二级缓存是 <code>Mapper</code> 映射级别的缓存</strong>，多个 <code>SqlSession</code> 去操作同一个 <code>Mapper</code> 映射的 SQL 语句，多个 <code>SqlSession</code> 可以共用二级缓存，<strong>二级缓存是跨 <code>SqlSession</code> 的</strong>。</li></ul><h3 id="二级缓存结构图"><a href="#二级缓存结构图" class="headerlink" title="二级缓存结构图"></a>二级缓存结构图</h3><p><img src="/2020/06/11/mybatis-2/二级缓存结构.png" alt></p><ul><li>首先开启 MyBatis 的二级缓存。</li><li><code>sqlSession1</code> 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。</li><li>如果 <code>sqlSession3</code> 去执行相同 <code>mapper</code> 映射下的 SQL，执行 <code>commit</code> 提交，将会清空该 <code>mapper</code> 映射下的二级缓存区域的数据。</li><li><code>sqlSession2</code> 去查询与 <code>sqlSession1</code> 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</li></ul><h3 id="二级缓存的开启"><a href="#二级缓存的开启" class="headerlink" title="二级缓存的开启"></a>二级缓存的开启</h3><h4 id="在-SQLMapConfig-xml-文件中开启二级缓存"><a href="#在-SQLMapConfig-xml-文件中开启二级缓存" class="headerlink" title="在 SQLMapConfig.xml 文件中开启二级缓存"></a>在 <code>SQLMapConfig.xml</code> 文件中开启二级缓存</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启二级缓存的支持 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>因为 <code>cacheEnabled</code> 的取值默认就为 <code>true</code>，所以这一步可以省略不配置。</li></ul><h4 id="配置相关的-Mapper-映射文件"><a href="#配置相关的-Mapper-映射文件" class="headerlink" title="配置相关的 Mapper 映射文件"></a>配置相关的 <code>Mapper</code> 映射文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启二级缓存的支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>&lt;cache&gt;</code> 标签表示当前这个 <code>Mapper</code> 映射将使用二级缓存，区分的标准就看 <code>Mapper</code> 的 <code>namespace</code> 值</strong>。</li></ul><h4 id="配置-statement-上的-useCache-属性"><a href="#配置-statement-上的-useCache-属性" class="headerlink" title="配置 statement 上的 useCache 属性"></a>配置 statement 上的 <code>useCache</code> 属性</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"User"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="二级缓存测试"><a href="#二级缓存测试" class="headerlink" title="二级缓存测试"></a>二级缓存测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondLevelCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream config;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        config = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        config.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSecondLevelCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession();</span><br><span class="line">        UserDao mapper1 = sqlSession1.getMapper(UserDao.class);</span><br><span class="line">        User user1 = mapper1.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">        sqlSession1.close(); <span class="comment">// 一级缓存消失</span></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession2 = factory.openSession();</span><br><span class="line">        UserDao mapper2 = sqlSession2.getMapper(UserDao.class);</span><br><span class="line">        User user2 = mapper2.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">        sqlSession2.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(user1 == user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果 <code>false</code>：</li></ul><p><img src="/2020/06/11/mybatis-2/测试二级缓存.png" alt></p><ul><li>经过上面的测试，发现执行了两次查询，并且在执行第一次查询后，关闭了一级缓存，再去执行第二次查询时，发现并没有对数据库发出 SQL 语句，所以此时的数据就只能是来自于二级缓存。</li><li>但是两次获得的 User 对象不是同一个，说明<strong>二级缓存中存放的是数据，而不是对象</strong>。</li></ul><h3 id="二级缓存注意事项"><a href="#二级缓存注意事项" class="headerlink" title="二级缓存注意事项"></a>二级缓存注意事项</h3><ul><li><strong>当使用二级缓存时，所缓存的类一定要实现 <code>java.io.Serializable</code> 接口，这样就可以使用序列化方式来保存对象的数据，同时可以使用数据反序列化对象</strong>。</li></ul><h1 id="MyBatis-注解开发"><a href="#MyBatis-注解开发" class="headerlink" title="MyBatis 注解开发"></a>MyBatis 注解开发</h1><ul><li>MyBatis 也可以使用注解开发方式，这样就可以减少编写 <code>Mapper</code> 映射文件。</li></ul><h2 id="MyBatis-的常见注解说明"><a href="#MyBatis-的常见注解说明" class="headerlink" title="MyBatis 的常见注解说明"></a>MyBatis 的常见注解说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>: 实现新增</span><br><span class="line"><span class="meta">@Update</span>: 实现更新</span><br><span class="line"><span class="meta">@Delete</span>: 实现删除</span><br><span class="line"><span class="meta">@Select</span>: 实现查询</span><br><span class="line"><span class="meta">@Result</span>: 实现结果集封装</span><br><span class="line"><span class="meta">@Results</span>: 可以与<span class="meta">@Result</span>一起使用，封装多个结果集</span><br><span class="line"><span class="meta">@ResultMap</span>: 实现引用<span class="meta">@Results</span>定义的封装</span><br><span class="line"><span class="meta">@One</span>: 实现一对一结果集封装</span><br><span class="line"><span class="meta">@Many</span>: 实现一对多结果集封装</span><br><span class="line"><span class="meta">@SelectProvider</span>: 实现动态SQL映射</span><br><span class="line"><span class="meta">@CacheNamespace</span>: 实现注解二级缓存的使用</span><br></pre></td></tr></table></figure><h2 id="使用-MyBatis-注解实现基本-CRUD"><a href="#使用-MyBatis-注解实现基本-CRUD" class="headerlink" title="使用 MyBatis 注解实现基本 CRUD"></a>使用 MyBatis 注解实现基本 CRUD</h2><h3 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Date userBirthday;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String userAddress;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用注解方式开发持久层接口"><a href="#使用注解方式开发持久层接口" class="headerlink" title="使用注解方式开发持久层接口"></a>使用注解方式开发持久层接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id = <span class="string">"userMap"</span>,</span><br><span class="line">            value = &#123;</span><br><span class="line">                    <span class="meta">@Result</span>(id = <span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"userId"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"username"</span>, property = <span class="string">"userName"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"sex"</span>, property = <span class="string">"userSex"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"address"</span>, property = <span class="string">"userAddress"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"birthday"</span>, property = <span class="string">"userBirthday"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user values(null,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)"</span>)</span><br><span class="line">    <span class="meta">@SelectKey</span>(keyColumn = <span class="string">"id"</span>, keyProperty = <span class="string">"id"</span>, resultType = Integer.class,</span><br><span class="line">            before = <span class="keyword">false</span>, statement = &#123;<span class="string">"select last_insert_id()"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id删除用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from user where id = #&#123;uid&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;uid&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResultMap</span>(value = &#123;<span class="string">"userMap"</span>&#125;)</span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称模糊查询用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where username like #&#123;username&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResultMap</span>(<span class="string">"userMap"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询总用户数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select count(*) from user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTotal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-SqlMapConfig-xml-配置文件"><a href="#编写-SqlMapConfig-xml-配置文件" class="headerlink" title="编写 SqlMapConfig.xml 配置文件"></a>编写 <code>SqlMapConfig.xml</code> 配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入外部配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbcConfig.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"domain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定带有注解的dao接口所在位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写测试方式"><a href="#编写测试方式" class="headerlink" title="编写测试方式"></a>编写测试方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream config;</span><br><span class="line">    <span class="keyword">private</span> SqlSession session;</span><br><span class="line">    <span class="keyword">private</span> UserDao mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        config = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        session = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(config).openSession();</span><br><span class="line">        mapper = session.getMapper(UserDao.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">        config.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"mybatis annotation"</span>);</span><br><span class="line">        user.setUserSex(<span class="string">"男"</span>);</span><br><span class="line">        user.setUserAddress(<span class="string">"北京市顺义区"</span>);</span><br><span class="line">        user.setUserBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        mapper.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserId(<span class="number">64</span>);</span><br><span class="line">        user.setUserName(<span class="string">"mybatis annotation"</span>);</span><br><span class="line">        user.setUserAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">        user.setUserSex(<span class="string">"女"</span>);</span><br><span class="line">        user.setUserBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        mapper.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mapper.deleteUser(<span class="number">62</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = mapper.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = mapper.findByName(<span class="string">"%王%"</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = mapper.findTotal();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用注解实现复杂关系映射开发"><a href="#使用注解实现复杂关系映射开发" class="headerlink" title="使用注解实现复杂关系映射开发"></a>使用注解实现复杂关系映射开发</h2><h3 id="复杂关系映射的注解说明"><a href="#复杂关系映射的注解说明" class="headerlink" title="复杂关系映射的注解说明"></a>复杂关系映射的注解说明</h3><ul><li><strong><code>@Results</code> 注解</strong>：代替的是标签 <code>&lt;resultMap&gt;</code>。<ul><li>该注解中可以使用单个 <code>@Result</code> 注解，也可以使用 <code>@Result</code> 集合。</li><li><code>@Results({@Result(), @Result()})</code> 或 <code>@Results(@Result())</code>。</li></ul></li><li><strong><code>@Result</code> 注解</strong>：代替了 <code>&lt;id&gt;</code> 标签和 <code>&lt;result&gt;</code> 标签。<ul><li><code>@Result</code> 中属性介绍：<ul><li><code>id</code>：是否是主键字段。</li><li><code>column</code>：数据库的列名。</li><li><code>property</code>：需要装配的属性名。</li><li><code>one</code>：需要使用的 <code>@One</code> 注解（<code>@Result(one=@One())</code>）。</li><li><code>many</code>：需要使用的 <code>@Many</code> 注解（<code>@Result(many=@Many())</code>）。</li></ul></li></ul></li><li><strong><code>@One</code> 注解</strong>（一对一）：代替了 <code>&lt;assocation&gt;</code> 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。<ul><li><code>@One</code> 注解属性介绍：<ul><li><code>select</code>：指定用来多表查询的 <code>sqlmapper</code>。</li><li><code>fetchType</code>：代表会覆盖全局的配置参数 <code>lazyLoadingEnabled</code>。</li></ul></li><li>使用格式：<ul><li><code>@Result(column=&quot;&quot;,property=&quot;&quot;,one=@One(select=&quot;&quot;))</code>。</li></ul></li></ul></li><li><strong><code>@Many</code> 注解</strong>（多对一）：代替了 <code>&lt;Collection&gt;</code> 标签，是多表查询的关键，在注解中用来指定子查询返回对象集合。<ul><li>注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 <code>javaType</code>（一般为 <code>ArrayList</code>）但是注解中可以不定义。</li><li>使用格式：<code>@Result(property=&quot;&quot;,column=&quot;&quot;,many=@Many(select=&quot;&quot;))</code>。</li></ul></li></ul><h3 id="使用注解实现一对一的复杂关系映射及延迟加载"><a href="#使用注解实现一对一的复杂关系映射及延迟加载" class="headerlink" title="使用注解实现一对一的复杂关系映射及延迟加载"></a>使用注解实现一对一的复杂关系映射及延迟加载</h3><h4 id="添加-User-及-Account-实体类"><a href="#添加-User-及-Account-实体类" class="headerlink" title="添加 User 及 Account 实体类"></a>添加 <code>User</code> 及 <code>Account</code> 实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Date userBirthday;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String userAddress;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写账户的持久层接口"><a href="#编写账户的持久层接口" class="headerlink" title="编写账户的持久层接口"></a>编写账户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id = <span class="string">"accountMap"</span>,</span><br><span class="line">            value = &#123;</span><br><span class="line">                    <span class="meta">@Result</span>(id = <span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"id"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"uid"</span>, property = <span class="string">"uid"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"money"</span>, property = <span class="string">"money"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"uid"</span>, property = <span class="string">"user"</span>,</span><br><span class="line">                            one = <span class="meta">@One</span>(select = <span class="string">"dao.UserDao.findById"</span>, fetchType = FetchType.EAGER))</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写用户的持久层接口"><a href="#编写用户的持久层接口" class="headerlink" title="编写用户的持久层接口"></a>编写用户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;uid&#125;"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id = <span class="string">"userMap"</span>,</span><br><span class="line">            value = &#123;</span><br><span class="line">                    <span class="meta">@Result</span>(id = <span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"userId"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"username"</span>, property = <span class="string">"userName"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"sex"</span>, property = <span class="string">"userSex"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"address"</span>, property = <span class="string">"userAddress"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"birthday"</span>, property = <span class="string">"userBirthday"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试一对一关联及延迟加载"><a href="#测试一对一关联及延迟加载" class="headerlink" title="测试一对一关联及延迟加载"></a>测试一对一关联及延迟加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = mapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用注解实现一对多复杂关系映射"><a href="#使用注解实现一对多复杂关系映射" class="headerlink" title="使用注解实现一对多复杂关系映射"></a>使用注解实现一对多复杂关系映射</h3><h4 id="User-实体类加入-List-lt-Account-gt"><a href="#User-实体类加入-List-lt-Account-gt" class="headerlink" title="User 实体类加入 List&lt;Account&gt;"></a><code>User</code> 实体类加入 <code>List&lt;Account&gt;</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Date userBirthday;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String userAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加用户的持久层接口"><a href="#添加用户的持久层接口" class="headerlink" title="添加用户的持久层接口"></a>添加用户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id = <span class="string">"userMap"</span>,</span><br><span class="line">            value = &#123;</span><br><span class="line">                    <span class="meta">@Result</span>(id = <span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"userId"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"username"</span>, property = <span class="string">"userName"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"sex"</span>, property = <span class="string">"userSex"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"address"</span>, property = <span class="string">"userAddress"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"birthday"</span>, property = <span class="string">"userBirthday"</span>),</span><br><span class="line">                    <span class="meta">@Result</span>(column = <span class="string">"id"</span>, property = <span class="string">"accounts"</span>,</span><br><span class="line">                            many = <span class="meta">@Many</span>(select = <span class="string">"dao.AccountDao.findByUid"</span>, fetchType = FetchType.LAZY))</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加账户的持久层接口"><a href="#添加账户的持久层接口" class="headerlink" title="添加账户的持久层接口"></a>添加账户的持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户Id查询账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from account where uid = #&#123;uid&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findByUid</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加测试类"><a href="#添加测试类" class="headerlink" title="添加测试类"></a>添加测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyBatis-基于注解的二级缓存"><a href="#MyBatis-基于注解的二级缓存" class="headerlink" title="MyBatis 基于注解的二级缓存"></a>MyBatis 基于注解的二级缓存</h2><h3 id="在-SqlMapConfig-xml-中开启二级缓存支持"><a href="#在-SqlMapConfig-xml-中开启二级缓存支持" class="headerlink" title="在 SqlMapConfig.xml 中开启二级缓存支持"></a>在 <code>SqlMapConfig.xml</code> 中开启二级缓存支持</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启二级缓存的支持 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在持久层接口中使用注解配置二级缓存"><a href="#在持久层接口中使用注解配置二级缓存" class="headerlink" title="在持久层接口中使用注解配置二级缓存"></a>在持久层接口中使用注解配置二级缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mybatis基于注解方式实现配置二级缓存</span></span><br><span class="line"><span class="meta">@CacheNamespace</span>(blocking=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis框架（1）</title>
      <link href="/2020/06/07/mybatis-1.html"/>
      <url>/2020/06/07/mybatis-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h1><h2 id="什么是框架？"><a href="#什么是框架？" class="headerlink" title="什么是框架？"></a>什么是框架？</h2><ul><li>框架（Framework）是软件开发中的一套解决方案，不同的框架解决不同的问题。</li><li>使用框架的好处：<ul><li>框架封装了很多细节，使开发者可以使用极简的方式实现功能，大大提高开发效率。</li></ul></li></ul><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><ul><li><strong>表现层：</strong>用于展示数据</li><li><strong>业务层：</strong>处理业务需求</li><li><strong>持久层：</strong>与数据库交互</li></ul><h2 id="分层开发下的常见框架"><a href="#分层开发下的常见框架" class="headerlink" title="分层开发下的常见框架"></a>分层开发下的常见框架</h2><ol><li>解决数据的持久化问题的框架：MyBatis</li><li>解决 WEB 层问题的 MVC 框架：SpringMVC</li><li>解决技术整合问题的框架：Spring</li></ol><h2 id="MyBatis-框架概述"><a href="#MyBatis-框架概述" class="headerlink" title="MyBatis 框架概述"></a>MyBatis 框架概述</h2><ul><li>MyBatis 是一个优秀的基于 Java 的<strong>持久层框架</strong>，它内部封装了 JDBC 操作的很多细节，使开发者只需要关注 SQL 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</li><li>MyBatis 通过 <strong>XML 或注解</strong>的方式将要执行的各种 statement 配置起来，并通过 Java 对象和 statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射为 Java 对象并返回。</li><li>采用 <strong>ORM 思想</strong>（Object Relational Mapping，对象关系映射）解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC API 底层访问细节，使我们不用与 JDBC API 打交道，就可以完成对数据库的持久化操作。简单地说，就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。</li></ul><h1 id="MyBatis-的环境搭建"><a href="#MyBatis-的环境搭建" class="headerlink" title="MyBatis 的环境搭建"></a>MyBatis 的环境搭建</h1><h2 id="创建-Maven-工程"><a href="#创建-Maven-工程" class="headerlink" title="创建 Maven 工程"></a>创建 Maven 工程</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="导入-MyBatis-的坐标"><a href="#导入-MyBatis-的坐标" class="headerlink" title="导入 MyBatis 的坐标"></a>导入 MyBatis 的坐标</h2><ul><li>在 <code>pom.xml</code> 中添加相应坐标：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写-User-实体类"><a href="#编写-User-实体类" class="headerlink" title="编写 User 实体类"></a>编写 <code>User</code> 实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写持久层接口-UserDao"><a href="#编写持久层接口-UserDao" class="headerlink" title="编写持久层接口 UserDao"></a>编写持久层接口 <code>UserDao</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写持久层接口的映射文件-UserDao-xml"><a href="#编写持久层接口的映射文件-UserDao-xml" class="headerlink" title="编写持久层接口的映射文件 UserDao.xml"></a>编写持久层接口的映射文件 <code>UserDao.xml</code></h2><ul><li>要求：<ul><li>创建位置：必须和持久层接口在相同的目录结构中。</li><li>名称：必须以持久层接口名称命名文件名，扩展名是 <code>.xml</code>。</li></ul></li></ul><p><img src="/2020/06/07/mybatis-1/mybatis框架目录结构.png" alt="mybatis框架目录结构"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写-SqlMapConfig-xml-配置文件"><a href="#编写-SqlMapConfig-xml-配置文件" class="headerlink" title="编写 SqlMapConfig.xml 配置文件"></a>编写 <code>SqlMapConfig.xml</code> 配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis的主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置mysql的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置事务的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源（连接池） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置连接数据库的4个基本信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatisdb"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"dao/UserDao.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis的入门案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 创建SqlSessionFactory工厂</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line">        <span class="comment">// 使用工厂生产SqlSession对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">// 使用SqlSession对象创建Dao接口的代理对象</span></span><br><span class="line">        UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">        <span class="comment">// 使用代理对象执行方法</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在 MyBatis 中把持久层的操作接口名称和映射文件也叫做 <code>Mapper</code>，所以 <code>Dao</code> 和 <code>Mapper</code> 是一样的。</li><li>包在创建时，<code>com.example.dao</code> 是三级目录结构，而目录在创建时，<code>com.example.dao</code> 是一级目录。</li><li>MyBatis 的映射配置文件位置必须和 <code>Dao</code> 接口的包结构相同。</li><li>映射配置文件的 <code>mapper</code> 标签 <code>namespace</code> 属性的取值必须是 <code>Dao</code> 接口的全限定类名。</li><li>映射配置文件的操作配置（如 select、update），<code>id</code> 属性的取值必须是 <code>Dao</code> 接口的方法名。</li><li>当遵从第 3、4、5 点之后，开发中就无须再写 <code>Dao</code> 的实现类。</li><li>不要忘记在映射配置文件中告知 MyBatis 要将数据封装到哪个实体类中。</li></ol><h2 id="补充：基于注解的-MyBatis-的使用"><a href="#补充：基于注解的-MyBatis-的使用" class="headerlink" title="补充：基于注解的 MyBatis 的使用"></a>补充：基于注解的 MyBatis 的使用</h2><h3 id="在持久层接口中添加注解"><a href="#在持久层接口中添加注解" class="headerlink" title="在持久层接口中添加注解"></a>在持久层接口中添加注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-SqlMapConfig-xml"><a href="#修改-SqlMapConfig-xml" class="headerlink" title="修改 SqlMapConfig.xml"></a>修改 <code>SqlMapConfig.xml</code></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件</span></span><br><span class="line"><span class="comment">     如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"dao.UserDao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在使用基于注解的 MyBatis 配置时，请移除 XML 的映射配置（如 <code>UserDao.xml</code>）。</li></ul><h1 id="自定义-MyBatis-框架"><a href="#自定义-MyBatis-框架" class="headerlink" title="自定义 MyBatis 框架"></a>自定义 MyBatis 框架</h1><h2 id="自定义-MyBatis-框架的分析"><a href="#自定义-MyBatis-框架的分析" class="headerlink" title="自定义 MyBatis 框架的分析"></a>自定义 MyBatis 框架的分析</h2><h3 id="涉及知识点介绍"><a href="#涉及知识点介绍" class="headerlink" title="涉及知识点介绍"></a>涉及知识点介绍</h3><ul><li>使用前面所学的基础知识来构建一个属于自己的持久层框架，将会涉及到的一些知识点：<strong>工厂模式（<code>Factory</code> 模式）、构造者模式（<code>Builder</code> 模式）、代理模式</strong>，反射，自定义注解，注解的反射，xml 解析，数据库元数据，元数据的反射等。</li></ul><p><img src="/2020/06/07/mybatis-1/入门案例的分析.png" alt="涉及知识点介绍"></p><h3 id="分析实现流程"><a href="#分析实现流程" class="headerlink" title="分析实现流程"></a>分析实现流程</h3><p><img src="/2020/06/07/mybatis-1/自定义Mybatis分析.png" alt="自定义Mybatis分析"></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="创建-Maven-工程-1"><a href="#创建-Maven-工程-1" class="headerlink" title="创建 Maven 工程"></a>创建 Maven 工程</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis_customized<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="引入相关坐标"><a href="#引入相关坐标" class="headerlink" title="引入相关坐标"></a>引入相关坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 解析 xml 的 dom4j --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- dom4j 的依赖包 jaxen --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="引入工具类到项目中"><a href="#引入工具类到项目中" class="headerlink" title="引入工具类到项目中"></a>引入工具类到项目中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于解析配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hustffx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方</span></span><br><span class="line"><span class="comment">     * 使用的技术：dom4j+xpath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Configuration <span class="title">loadConfiguration</span><span class="params">(InputStream config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//定义封装连接信息的配置对象（mybatis的配置对象）</span></span><br><span class="line">            Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">            <span class="comment">//1.获取SAXReader对象</span></span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            <span class="comment">//2.根据字节输入流获取Document对象</span></span><br><span class="line">            Document document = reader.read(config);</span><br><span class="line">            <span class="comment">//3.获取根节点</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            <span class="comment">//4.使用xpath中选择指定节点的方式，获取所有property节点</span></span><br><span class="line">            List&lt;Element&gt; propertyElements = root.selectNodes(<span class="string">"//property"</span>);</span><br><span class="line">            <span class="comment">//5.遍历节点</span></span><br><span class="line">            <span class="keyword">for</span> (Element propertyElement : propertyElements) &#123;</span><br><span class="line">                <span class="comment">//判断节点是连接数据库的哪部分信息</span></span><br><span class="line">                <span class="comment">//取出name属性的值</span></span><br><span class="line">                String name = propertyElement.attributeValue(<span class="string">"name"</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"driver"</span>.equals(name)) &#123;</span><br><span class="line">                    <span class="comment">//表示驱动</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String driver = propertyElement.attributeValue(<span class="string">"value"</span>);</span><br><span class="line">                    cfg.setDriver(driver);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"url"</span>.equals(name)) &#123;</span><br><span class="line">                    <span class="comment">//表示连接字符串</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String url = propertyElement.attributeValue(<span class="string">"value"</span>);</span><br><span class="line">                    cfg.setUrl(url);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"username"</span>.equals(name)) &#123;</span><br><span class="line">                    <span class="comment">//表示用户名</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String username = propertyElement.attributeValue(<span class="string">"value"</span>);</span><br><span class="line">                    cfg.setUsername(username);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"password"</span>.equals(name)) &#123;</span><br><span class="line">                    <span class="comment">//表示密码</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String password = propertyElement.attributeValue(<span class="string">"value"</span>);</span><br><span class="line">                    cfg.setPassword(password);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出mappers中的所有mapper标签，判断他们使用了resource还是class属性</span></span><br><span class="line">            List&lt;Element&gt; mapperElements = root.selectNodes(<span class="string">"//mappers/mapper"</span>);</span><br><span class="line">            <span class="comment">//遍历集合</span></span><br><span class="line">            <span class="keyword">for</span> (Element mapperElement : mapperElements) &#123;</span><br><span class="line">                <span class="comment">//判断mapperElement使用的是哪个属性</span></span><br><span class="line">                Attribute attribute = mapperElement.attribute(<span class="string">"resource"</span>);</span><br><span class="line">                <span class="keyword">if</span> (attribute != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"使用的是XML"</span>);</span><br><span class="line">                    <span class="comment">//表示有resource属性，用的是XML</span></span><br><span class="line">                    <span class="comment">//取出属性的值"dao/IUserDao.xml"</span></span><br><span class="line">                    String mapperPath = attribute.getValue();</span><br><span class="line">                    <span class="comment">//把映射配置文件的内容获取出来，封装成一个map</span></span><br><span class="line">                    Map&lt;String, Mapper&gt; mappers = loadMapperConfiguration(mapperPath);</span><br><span class="line">                    <span class="comment">//给configuration中的mappers赋值</span></span><br><span class="line">                    cfg.setMappers(mappers);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"使用的是注解"</span>);</span><br><span class="line">                    <span class="comment">//表示没有resource属性，用的是注解</span></span><br><span class="line">                    <span class="comment">//获取class属性的值</span></span><br><span class="line">                    String daoClassPath = mapperElement.attributeValue(<span class="string">"class"</span>);</span><br><span class="line">                    <span class="comment">//根据daoClassPath获取封装的必要信息</span></span><br><span class="line">                    Map&lt;String, Mapper&gt; mappers = loadMapperAnnotation(daoClassPath);</span><br><span class="line">                    <span class="comment">//给configuration中的mappers赋值</span></span><br><span class="line">                    cfg.setMappers(mappers);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回Configuration</span></span><br><span class="line">            <span class="keyword">return</span> cfg;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                config.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的参数，解析XML，并且封装到Map中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapperPath 映射配置文件的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成）</span></span><br><span class="line"><span class="comment">     * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Mapper&gt; <span class="title">loadMapperConfiguration</span><span class="params">(String mapperPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//定义返回值对象</span></span><br><span class="line">            Map&lt;String, Mapper&gt; mappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">//1.根据路径获取字节输入流</span></span><br><span class="line">            in = Resources.getResourceAsStream(mapperPath);</span><br><span class="line">            <span class="comment">//2.根据字节输入流获取Document对象</span></span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = reader.read(in);</span><br><span class="line">            <span class="comment">//3.获取根节点</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            <span class="comment">//4.获取根节点的namespace属性取值     是组成map中key的部分</span></span><br><span class="line">            String namespace = root.attributeValue(<span class="string">"namespace"</span>);</span><br><span class="line">            <span class="comment">//5.获取所有的select节点</span></span><br><span class="line">            List&lt;Element&gt; selectElements = root.selectNodes(<span class="string">"//select"</span>);</span><br><span class="line">            <span class="comment">//6.遍历select节点集合</span></span><br><span class="line">            <span class="keyword">for</span> (Element selectElement : selectElements) &#123;</span><br><span class="line">                <span class="comment">//取出id属性的值      组成map中key的部分</span></span><br><span class="line">                String id = selectElement.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">                <span class="comment">//取出resultType属性的值  组成map中value的部分</span></span><br><span class="line">                String resultType = selectElement.attributeValue(<span class="string">"resultType"</span>);</span><br><span class="line">                <span class="comment">//取出文本内容            组成map中value的部分</span></span><br><span class="line">                String queryString = selectElement.getText();</span><br><span class="line">                <span class="comment">//创建Key</span></span><br><span class="line">                String key = namespace + <span class="string">"."</span> + id;</span><br><span class="line">                <span class="comment">//创建Value</span></span><br><span class="line">                Mapper mapper = <span class="keyword">new</span> Mapper();</span><br><span class="line">                mapper.setQueryString(queryString);</span><br><span class="line">                mapper.setResultType(resultType);</span><br><span class="line">                <span class="comment">//把key和value存入mappers中</span></span><br><span class="line">                mappers.put(key, mapper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mappers;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的参数，得到dao中所有被select注解标注的方法。</span></span><br><span class="line"><span class="comment">     * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> daoClassPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Mapper&gt; <span class="title">loadMapperAnnotation</span><span class="params">(String daoClassPath)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//定义返回值对象</span></span><br><span class="line">        Map&lt;String, Mapper&gt; mappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.得到dao接口的字节码对象</span></span><br><span class="line">        Class daoClass = Class.forName(daoClassPath);</span><br><span class="line">        <span class="comment">//2.得到dao接口中的方法数组</span></span><br><span class="line">        Method[] methods = daoClass.getMethods();</span><br><span class="line">        <span class="comment">//3.遍历Method数组</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//取出每一个方法，判断是否有select注解</span></span><br><span class="line">            <span class="keyword">boolean</span> isAnnotated = method.isAnnotationPresent(Select.class);</span><br><span class="line">            <span class="keyword">if</span> (isAnnotated) &#123;</span><br><span class="line">                <span class="comment">//创建Mapper对象</span></span><br><span class="line">                Mapper mapper = <span class="keyword">new</span> Mapper();</span><br><span class="line">                <span class="comment">//取出注解的value属性值</span></span><br><span class="line">                Select selectAnno = method.getAnnotation(Select.class);</span><br><span class="line">                String queryString = selectAnno.value();</span><br><span class="line">                mapper.setQueryString(queryString);</span><br><span class="line">                <span class="comment">//获取当前方法的返回值，还要求必须带有泛型信息</span></span><br><span class="line">                <span class="comment">//List&lt;User&gt;</span></span><br><span class="line">                Type type = method.getGenericReturnType();</span><br><span class="line">                <span class="comment">//判断type是不是参数化的类型</span></span><br><span class="line">                <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                    <span class="comment">//强转</span></span><br><span class="line">                    ParameterizedType ptype = (ParameterizedType) type;</span><br><span class="line">                    <span class="comment">//得到参数化类型中的实际类型参数</span></span><br><span class="line">                    Type[] types = ptype.getActualTypeArguments();</span><br><span class="line">                    <span class="comment">//取出第一个</span></span><br><span class="line">                    Class domainClass = (Class) types[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取domainClass的类名</span></span><br><span class="line">                    String resultType = domainClass.getName();</span><br><span class="line">                    <span class="comment">//给Mapper赋值</span></span><br><span class="line">                    mapper.setResultType(resultType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//组装key的信息</span></span><br><span class="line">                <span class="comment">//获取方法的名称</span></span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                String className = method.getDeclaringClass().getName();</span><br><span class="line">                String key = className + <span class="string">"."</span> + methodName;</span><br><span class="line">                <span class="comment">//给map赋值</span></span><br><span class="line">                mappers.put(key, mapper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mappers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责执行SQL语句，并且封装结果集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hustffx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(Mapper mapper, Connection conn)</span> </span>&#123;</span><br><span class="line">        PreparedStatement pstm = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.取出mapper中的数据</span></span><br><span class="line">            <span class="comment">//select * from user</span></span><br><span class="line">            String queryString = mapper.getQueryString();</span><br><span class="line">            <span class="comment">//domain.User</span></span><br><span class="line">            String resultType = mapper.getResultType();</span><br><span class="line">            Class domainClass = Class.forName(resultType);</span><br><span class="line">            <span class="comment">//2.获取PreparedStatement对象</span></span><br><span class="line">            pstm = conn.prepareStatement(queryString);</span><br><span class="line">            <span class="comment">//3.执行SQL语句，获取结果集</span></span><br><span class="line">            rs = pstm.executeQuery();</span><br><span class="line">            <span class="comment">//4.封装结果集</span></span><br><span class="line">            <span class="comment">//定义返回值</span></span><br><span class="line">            List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;E&gt;();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//实例化要封装的实体类对象</span></span><br><span class="line">                E obj = (E) domainClass.newInstance();</span><br><span class="line">                <span class="comment">//取出结果集的元信息：ResultSetMetaData</span></span><br><span class="line">                ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">                <span class="comment">//取出总列数</span></span><br><span class="line">                <span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">                <span class="comment">//遍历总列数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">                    <span class="comment">//获取每列的名称，列名的序号是从1开始的</span></span><br><span class="line">                    String columnName = rsmd.getColumnName(i);</span><br><span class="line">                    <span class="comment">//根据得到列名，获取每列的值</span></span><br><span class="line">                    Object columnValue = rs.getObject(columnName);</span><br><span class="line">                    <span class="comment">//给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装）</span></span><br><span class="line">                    <span class="comment">//要求：实体类的属性和数据库表的列名保持一种</span></span><br><span class="line">                    PropertyDescriptor pd = <span class="keyword">new</span> PropertyDescriptor(columnName, domainClass);</span><br><span class="line">                    <span class="comment">//获取它的写入方法</span></span><br><span class="line">                    Method writeMethod = pd.getWriteMethod();</span><br><span class="line">                    <span class="comment">//把获取的列的值，给对象赋值</span></span><br><span class="line">                    writeMethod.invoke(obj, columnValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把赋好值的对象加入到集合中</span></span><br><span class="line">                list.add(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            release(pstm, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(PreparedStatement pstm, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pstm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstm.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建数据源的工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/5 11:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于获取一个连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cfg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(Configuration cfg)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(cfg.getDriver());</span><br><span class="line">            conn = DriverManager.getConnection(cfg.getUrl(), cfg.getUsername(), cfg.getPassword());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-SqlMapConfig-xml"><a href="#编写-SqlMapConfig-xml" class="headerlink" title="编写 SqlMapConfig.xml"></a>编写 <code>SqlMapConfig.xml</code></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatisdb"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"dao/UserDao.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写读取配置文件类"><a href="#编写读取配置文件类" class="headerlink" title="编写读取配置文件类"></a>编写读取配置文件类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用类加载器读取配置文件的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/4 22:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Resources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的参数，获取一个字节输入流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 资源路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字节输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Resources.class.getClassLoader().getResourceAsStream(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-Mapper-类"><a href="#编写-Mapper-类" class="headerlink" title="编写 Mapper 类"></a>编写 <code>Mapper</code> 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于封装执行SQL语句和结果类型的全限定类名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/5 0:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SQL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String queryString;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实体类的全限定类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String resultType;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-Configuration-配置类"><a href="#编写-Configuration-配置类" class="headerlink" title="编写 Configuration 配置类"></a>编写 <code>Configuration</code> 配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MyBatis的配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/5 0:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Mapper&gt; mappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMappers</span><span class="params">(Map&lt;String, Mapper&gt; mappers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处需要使用追加的方式</span></span><br><span class="line">        <span class="keyword">this</span>.mappers.putAll(mappers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-User-实体类-1"><a href="#编写-User-实体类-1" class="headerlink" title="编写 User 实体类"></a>编写 <code>User</code> 实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于-XML-的自定义-MyBatis-框架"><a href="#基于-XML-的自定义-MyBatis-框架" class="headerlink" title="基于 XML 的自定义 MyBatis 框架"></a>基于 XML 的自定义 MyBatis 框架</h2><h3 id="编写持久层接口和-UserDao-xml"><a href="#编写持久层接口和-UserDao-xml" class="headerlink" title="编写持久层接口和 UserDao.xml"></a>编写持久层接口和 <code>UserDao.xml</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的持久层接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/3 19:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写构建者类"><a href="#编写构建者类" class="headerlink" title="编写构建者类"></a>编写构建者类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建一个SqlSessionFactory对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/4 22:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据字节输入流来构建一个SqlSessionFactory工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream config)</span> </span>&#123;</span><br><span class="line">        Configuration cfg = XMLConfigBuilder.loadConfiguration(config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-SqlSessionFactory-接口和实现类"><a href="#编写-SqlSessionFactory-接口和实现类" class="headerlink" title="编写 SqlSessionFactory 接口和实现类"></a>编写 <code>SqlSessionFactory</code> 接口和实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于打开一个新的SqlSession对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SqlSessionFactory接口的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/5 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration cfg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration cfg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cfg = cfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个新的操作数据库对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-SqlSession-接口和实现类"><a href="#编写-SqlSession-接口和实现类" class="headerlink" title="编写 SqlSession 接口和实现类"></a>编写 <code>SqlSession</code> 接口和实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyBatis中与数据库交互的核心类</span></span><br><span class="line"><span class="comment"> * 它里面可以创建dao接口的代理对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/4 22:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据参数创建一个代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> daoInterfaceClass dao的接口字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; daoInterfaceClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SqlSession接口的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/5 11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration cfg;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration cfg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cfg = cfg;</span><br><span class="line">        conn = DataSourceUtil.getConnection(cfg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> daoInterfaceClass dao的接口字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; daoInterfaceClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;daoInterfaceClass&#125;, <span class="keyword">new</span> MapperProxy(cfg.getMappers(), conn));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写用于创建代理对象的类"><a href="#编写用于创建代理对象的类" class="headerlink" title="编写用于创建代理对象的类"></a>编写用于创建代理对象的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map的key是全限定类名+方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Mapper&gt; mappers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(Map&lt;String, Mapper&gt; mappers, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mappers = mappers;</span><br><span class="line">        <span class="keyword">this</span>.conn = conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于对方法进行增强</span></span><br><span class="line"><span class="comment">     * 其实就是调用selectList方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 获取方法名</span></span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="comment">// 获取方法所在类的名称</span></span><br><span class="line">        String className = method.getDeclaringClass().getName();</span><br><span class="line">        <span class="comment">// 组合key</span></span><br><span class="line">        String key = className + <span class="string">"."</span> + methodName;</span><br><span class="line">        <span class="comment">// 获取mappers中的Mapper对象</span></span><br><span class="line">        Mapper mapper = mappers.get(key);</span><br><span class="line">        <span class="comment">// 判断是否有mapper</span></span><br><span class="line">        <span class="keyword">if</span> (mapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"传入的参数有误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用工具类执行查询所有操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Executor().selectList(mapper, conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行测试类"><a href="#运行测试类" class="headerlink" title="运行测试类"></a>运行测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 创建SqlSessionFactory工厂</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line">        <span class="comment">// 使用工厂生产SqlSession对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">// 使用SqlSession对象创建Dao接口的代理对象</span></span><br><span class="line">        UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">        <span class="comment">// 使用代理对象执行方法</span></span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于注解方式定义-MyBatis-框架"><a href="#基于注解方式定义-MyBatis-框架" class="headerlink" title="基于注解方式定义 MyBatis 框架"></a>基于注解方式定义 MyBatis 框架</h2><h3 id="自定义-Select-注解"><a href="#自定义-Select-注解" class="headerlink" title="自定义 @Select 注解"></a>自定义 <code>@Select</code> 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询的注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/5 11:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Select &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置SQL语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改持久层接口"><a href="#修改持久层接口" class="headerlink" title="修改持久层接口"></a>修改持久层接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的持久层接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/3 19:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-SqlMapConfig-xml-1"><a href="#修改-SqlMapConfig-xml-1" class="headerlink" title="修改 SqlMapConfig.xml"></a>修改 <code>SqlMapConfig.xml</code></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatisdb"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"dao.UserDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义-MyBatis-框架再分析"><a href="#自定义-MyBatis-框架再分析" class="headerlink" title="自定义 MyBatis 框架再分析"></a>自定义 MyBatis 框架再分析</h2><p><img src="/2020/06/07/mybatis-1/自定义mybatis开发流程图.png" alt="自定义mybatis开发流程图"></p><h1 id="MyBatis-代理-Dao-实现-CRUD"><a href="#MyBatis-代理-Dao-实现-CRUD" class="headerlink" title="MyBatis 代理 Dao 实现 CRUD"></a>MyBatis 代理 Dao 实现 CRUD</h1><ul><li>使用要求：<ol><li>持久层接口和持久层接口的映射配置文件必须在相同的包下；</li><li>持久层映射配置中 <code>mapper</code> 标签的 <code>namespace</code> 属性取值必须是持久层接口的全限定类名；</li><li>SQL 语句的配置标签 <code>&lt;select&gt;</code>，<code>&lt;insert&gt;</code>，<code>&lt;delete&gt;</code>，<code>&lt;update&gt;</code> 的 <code>id</code> 属性必须和持久层接口的方法名相同。</li></ol></li></ul><h2 id="根据-id-查询"><a href="#根据-id-查询" class="headerlink" title="根据 id 查询"></a>根据 id 查询</h2><h3 id="在持久层接口中添加-findById-方法："><a href="#在持久层接口中添加-findById-方法：" class="headerlink" title="在持久层接口中添加 findById 方法："></a>在持久层接口中添加 <code>findById</code> 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在映射配置文件中配置"><a href="#在映射配置文件中配置" class="headerlink" title="在映射配置文件中配置"></a>在映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据id查询用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>细节：<ul><li><code>resultType</code> 属性：<ul><li>用于指定结果集的类型。</li></ul></li><li><code>parameterType</code> 属性：<ul><li>用于指定传入参数的类型。</li></ul></li><li>SQL 语句中使用 <strong><code>#{}</code> 字符</strong>：<ul><li>代表<strong>占位符</strong>，相当于 JDBC 中的 <code>?</code>，都是用于执行语句时替换实际的数据。</li><li>具体的数据是由 <code>#{}</code> 中的内容决定的，该符号接受输入参数，在大括号中编写参数名称来接受对应参数。</li><li><strong>输入参数的类型可以是简单类型、普通 JavaBean 或者 <code>HashMap</code></strong>：<ul><li>基本类型：参数名可以随意写</li><li>自定义类型：参数名与属性名对应</li><li><code>Map</code> 类型：参数名与 key 对应</li></ul></li></ul></li></ul></li></ul><h3 id="在测试类中添加测试"><a href="#在测试类中添加测试" class="headerlink" title="在测试类中添加测试"></a>在测试类中添加测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream config;</span><br><span class="line">    <span class="keyword">private</span> SqlSession session;</span><br><span class="line">    <span class="keyword">private</span> UserDao mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        config = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(config);</span><br><span class="line">        session = factory.openSession();</span><br><span class="line">        mapper = session.getMapper(UserDao.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在关闭资源之前，提交事务</span></span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        config.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = mapper.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存操作"><a href="#保存操作" class="headerlink" title="保存操作"></a>保存操作</h2><h3 id="在持久层接口中添加-save-方法"><a href="#在持久层接口中添加-save-方法" class="headerlink" title="在持久层接口中添加 save 方法"></a>在持久层接口中添加 <code>save</code> 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在映射配置文件中配置-1"><a href="#在映射配置文件中配置-1" class="headerlink" title="在映射配置文件中配置"></a>在映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 保存用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveUser"</span> <span class="attr">parameterType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        insert into user(username, address, sex, birthday)</span><br><span class="line">        values(#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>细节：<ul><li><code>#{}</code> 中内容的写法：<ul><li>由于保存方法的参数是 一个 <code>User</code> 对象，此处要写 <code>User</code> 对象中的属性名称。</li><li>它用的是 ognl 表达式。</li></ul></li><li><strong>ognl 表达式：</strong><ul><li>是 apache 提供的一种表达式语言，全称是 Object Graphic Navigation Language（对象图导航语言）。</li><li>它是按照一定的语法格式来获取数据的。语法格式就是使用 <strong><code>#{对象.对象}</code></strong> 的方式。</li><li><strong>通过对象的取值方法来获取数据，在写法上把 <code>get</code> 方法省略了</strong>。</li><li>比如，<code>#{user.username}</code> 它会先去找 <code>user</code> 对象，然后在 <code>user</code> 对象中找到 <code>username</code> 属性，并调用 <code>getUsername()</code> 方法把值取出来。但是我们在 <code>parameterType</code> 属性上指定了实体类名称，所以可以省略 <code>user.</code> 而直接写 <code>username</code>。</li></ul></li></ul></li></ul><h3 id="在测试类中添加测试-1"><a href="#在测试类中添加测试-1" class="headerlink" title="在测试类中添加测试"></a>在测试类中添加测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"mybatis save user last insert id"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"湖北省武汉市"</span>);</span><br><span class="line">        user.setSex(<span class="string">"男"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"保存操作之前："</span> + user);</span><br><span class="line">        mapper.saveUser(user);</span><br><span class="line">        System.out.println(<span class="string">"保存操作之后："</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题扩展：返回新增-id-值"><a href="#问题扩展：返回新增-id-值" class="headerlink" title="问题扩展：返回新增 id 值"></a>问题扩展：返回新增 id 值</h3><ul><li>新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于要在新增后将自动增长 <code>auto_increment</code> 的值返回。</li><li>在数据库操作中，可以通过在 <code>insert</code> 语句之后，紧接着<strong>执行 <code>select last_insert_id()</code> 来获取新增的 id 值</strong>。</li><li>在映射配置文件中添加 <code>&lt;selectKey&gt;</code> 标签配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 保存用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveUser"</span> <span class="attr">parameterType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">            select last_insert_id();</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert into user(username, address, sex, birthday)</span><br><span class="line">        values(#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><h3 id="在持久层接口中添加-update-方法："><a href="#在持久层接口中添加-update-方法：" class="headerlink" title="在持久层接口中添加 update 方法："></a>在持久层接口中添加 <code>update</code> 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在映射配置文件中配置-2"><a href="#在映射配置文件中配置-2" class="headerlink" title="在映射配置文件中配置"></a>在映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 更新用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        update user</span><br><span class="line">        set username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125;</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在测试类中添加测试-2"><a href="#在测试类中添加测试-2" class="headerlink" title="在测试类中添加测试"></a>在测试类中添加测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">55</span>);</span><br><span class="line">        user.setUsername(<span class="string">"mybatis update user"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">        user.setSex(<span class="string">"女"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        mapper.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><h3 id="在持久层接口中添加-delete-方法："><a href="#在持久层接口中添加-delete-方法：" class="headerlink" title="在持久层接口中添加 delete 方法："></a>在持久层接口中添加 <code>delete</code> 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id删除用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在映射配置文件中配置-3"><a href="#在映射配置文件中配置-3" class="headerlink" title="在映射配置文件中配置"></a>在映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 删除用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from user where id = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在测试类中添加测试-3"><a href="#在测试类中添加测试-3" class="headerlink" title="在测试类中添加测试"></a>在测试类中添加测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mapper.deleteUser(<span class="number">55</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><h3 id="在持久层接口中添加-findByName-方法："><a href="#在持久层接口中添加-findByName-方法：" class="headerlink" title="在持久层接口中添加 findByName 方法："></a>在持久层接口中添加 <code>findByName</code> 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称模糊查询用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在映射配置文件中配置-4"><a href="#在映射配置文件中配置-4" class="headerlink" title="在映射配置文件中配置"></a>在映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据名称模糊查询用户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- select * from user where username like #&#123;name&#125; --&gt;</span></span><br><span class="line">        select * from user where username like '%$&#123;value&#125;%'</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>细节：<ul><li>在模糊查询中：<ul><li>如果使用 <code>#{}</code> 占位符，SQL 会在预编译阶段替换为 <code>?</code> 占位符，所以需要在传参的时候就给定模糊查询的标识 <code>%</code>。</li><li>如果使用 <code>${}</code> 拼接符，编译的时候直接将参数字符串拼接到 SQL 中，所以直接在 SQL 中写上 <code>%</code>，同时 <code>${value}</code> 的写法是固定的。</li></ul></li></ul></li></ul><h3 id="在测试类中添加测试-4"><a href="#在测试类中添加测试-4" class="headerlink" title="在测试类中添加测试"></a>在测试类中添加测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// List&lt;User&gt; users = mapper.findByName("%王%");</span></span><br><span class="line">        List&lt;User&gt; users = mapper.findByName(<span class="string">"王"</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：-与-的区别"><a href="#补充：-与-的区别" class="headerlink" title="补充：#{} 与 ${} 的区别"></a>补充：<code>#{}</code> 与 <code>${}</code> 的区别</h3><ul><li><code>#{}</code>：<ul><li>表示一个占位符号。</li><li>通过 <code>#{}</code> 可以实现 <code>preparedStatement</code> 向占位符中设置值，自动进行 Java 类型和 JDBC 类型转换。</li><li><code>#{}</code> 可以有效防止 SQL 注入。</li><li><code>#{}</code> 可以接收简单类型值或 pojo 属性值。</li><li>如果 <code>parameterType</code> 传输单个简单类型值，<code>#{}</code> 括号中可以是 <code>value</code> 或其它名称。</li></ul></li><li><code>${}</code>：<ul><li>表示拼接 SQL 串。</li><li>通过 <code>${}</code>可以将 <code>parameterType</code> 传入的内容拼接在 SQL 中且不进行 JDBC 类型转换。</li><li><code>${}</code> 可以接收简单类型值或 pojo 属性值。</li><li>如果 <code>parameterType</code> 传输单个简单类型值，<code>${}</code> 括号中只能是 <code>value</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextSqlNode</span> <span class="keyword">implements</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingTokenParser</span> <span class="keyword">implements</span> <span class="title">TokenHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">            Object parameter = <span class="keyword">this</span>.context.getBindings().get(<span class="string">"_parameter"</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.context.getBindings().put(<span class="string">"value"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SimpleTypeRegistry.isSimpleType(parameter.getClass())) &#123;</span><br><span class="line">                <span class="keyword">this</span>.context.getBindings().put(<span class="string">"value"</span>, parameter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object value = OgnlCache.getValue(content, <span class="keyword">this</span>.context.getBindings());</span><br><span class="line">            String srtValue = value == <span class="keyword">null</span> ? <span class="string">""</span> : String.valueOf(value);</span><br><span class="line">            <span class="keyword">this</span>.checkInjection(srtValue);</span><br><span class="line">            <span class="keyword">return</span> srtValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据上面的 <code>${value}</code> 的部分源码可以看到，指定了读取的 key 的名字就是 <code>&quot;value&quot;</code>，所以在绑定参数时就只能叫 <code>value</code> 的名字。</li></ul><h2 id="使用聚合函数查询"><a href="#使用聚合函数查询" class="headerlink" title="使用聚合函数查询"></a>使用聚合函数查询</h2><h3 id="在持久层接口中添加-findTotal-方法："><a href="#在持久层接口中添加-findTotal-方法：" class="headerlink" title="在持久层接口中添加 findTotal 方法："></a>在持久层接口中添加 <code>findTotal</code> 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询总用户数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTotal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在映射配置文件中配置-5"><a href="#在映射配置文件中配置-5" class="headerlink" title="在映射配置文件中配置"></a>在映射配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获取用户的总记录条数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findTotal"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select count(*) from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在测试类中添加测试-5"><a href="#在测试类中添加测试-5" class="headerlink" title="在测试类中添加测试"></a>在测试类中添加测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = mapper.findTotal();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyBatis-与-JDBC-编程的比较"><a href="#MyBatis-与-JDBC-编程的比较" class="headerlink" title="MyBatis 与 JDBC 编程的比较"></a>MyBatis 与 JDBC 编程的比较</h2><ol><li>数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。<ul><li>在 <code>SqlMapConfig.xml</code> 中配置数据连接池，使用连接池管理数据库连接。</li></ul></li><li>SQL 语句写在代码中造成代码不易维护，实际应用 SQL 变化的可能较大，SQL 变动需要改变 Java 代码。<ul><li>将 SQL 语句配置在 <code>XXXXmapper.xml</code> 文件中与 Java 代码分离。</li></ul></li><li>向 SQL 语句传参数麻烦，因为 SQL 语句的 <code>where</code> 条件不一定，可能多也可能少，占位符需要和参数对应。<ul><li>MyBatis 自动将 Java 对象映射至 SQL 语句，通过 <code>parameterType</code> 定义输入参数的类型。</li></ul></li><li>对结果集解析麻烦，SQL 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。<ul><li>MyBatis 自动将 SQL 执行结果映射至 Java 对象，通过 <code>resultType</code> 定义输出结果的类型。</li></ul></li></ol><h1 id="MyBatis-参数深入"><a href="#MyBatis-参数深入" class="headerlink" title="MyBatis 参数深入"></a>MyBatis 参数深入</h1><h2 id="MyBatis-的参数输入"><a href="#MyBatis-的参数输入" class="headerlink" title="MyBatis 的参数输入"></a>MyBatis 的参数输入</h2><h3 id="parameterType-使用说明"><a href="#parameterType-使用说明" class="headerlink" title="parameterType 使用说明"></a><code>parameterType</code> 使用说明</h3><ul><li>前面已经介绍过 SQL 语句传参，使用标签的 <code>parameterType</code> 属性来设定。<ul><li>该属性的<strong>取值可以是基本类型、引用类型，还可以是实体类类型（POJO 类），同时也可以是实体类的包装类</strong>。</li></ul></li><li>注意事项：<ul><li><strong>基本类型和 <code>String</code> 可以直接写类型名称，也可以使用 <code>包名.类名</code> 的方式</strong>，如 ：<code>java.lang.String</code>。</li><li><strong>实体类类型，只能使用全限定类名</strong>。究其原因，是 MyBatis 在加载时已经把常用的数据类型注册了别名，从而在使用时可以不写包名，而实体类并没有注册别名，所以必须写全限定类名。</li></ul></li></ul><h3 id="传递-POJO-对象"><a href="#传递-POJO-对象" class="headerlink" title="传递 POJO 对象"></a>传递 POJO 对象</h3><ul><li>MyBatis 使用 <strong>ognl 表达式</strong>解析对象字段的值，<code>#{}</code> 或 <code>${}</code> 括号中的值为 pojo 属性名称。</li></ul><h3 id="传递-POJO-包装对象"><a href="#传递-POJO-包装对象" class="headerlink" title="传递 POJO 包装对象"></a>传递 POJO 包装对象</h3><ul><li>开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件，还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</li><li>POJO 类中包含 pojo。</li></ul><h4 id="编写-QueryVo"><a href="#编写-QueryVo" class="headerlink" title="编写 QueryVo"></a>编写 <code>QueryVo</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询条件对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/6 16:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写持久层接口"><a href="#编写持久层接口" class="headerlink" title="编写持久层接口"></a>编写持久层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的持久层接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hustffx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/6/5 17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据queryVo中的条件查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByVo</span><span class="params">(QueryVo vo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持久层接口的映射文件"><a href="#持久层接口的映射文件" class="headerlink" title="持久层接口的映射文件"></a>持久层接口的映射文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据queryVo的条件查询用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByVo"</span> <span class="attr">parameterType</span>=<span class="string">"domain.QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        select * from user where username like #&#123;user.username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试包装类作为参数"><a href="#测试包装类作为参数" class="headerlink" title="测试包装类作为参数"></a>测试包装类作为参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByVo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryVo vo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"%王%"</span>);</span><br><span class="line">        vo.setUser(user);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = mapper.findByVo(vo);</span><br><span class="line">        <span class="keyword">for</span> (User u : users) &#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyBatis-的结果封装"><a href="#MyBatis-的结果封装" class="headerlink" title="MyBatis 的结果封装"></a>MyBatis 的结果封装</h2><h3 id="resultType-输出类型"><a href="#resultType-输出类型" class="headerlink" title="resultType 输出类型"></a><code>resultType</code> 输出类型</h3><ul><li><strong><code>resultType</code> 属性可以指定结果集的类型，支持基本类型和实体类类型</strong>。在前面的 CRUD 案例中已经对此属性进行过应用了。</li><li>需要注意的是，它和 <code>parameterType</code> 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名，例如实体类必须是全限定类名。同时，当是实体类名称时，还有一个要求，<strong>实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装</strong>。</li></ul><h3 id="特殊情况示例（属性名与列名不一致）"><a href="#特殊情况示例（属性名与列名不一致）" class="headerlink" title="特殊情况示例（属性名与列名不一致）"></a>特殊情况示例（属性名与列名不一致）</h3><h4 id="新建实体类-User2"><a href="#新建实体类-User2" class="headerlink" title="新建实体类 User2"></a>新建实体类 <code>User2</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Date userBirthday;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String userAddress;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写-User2Dao-接口"><a href="#编写-User2Dao-接口" class="headerlink" title="编写 User2Dao 接口"></a>编写 <code>User2Dao</code> 接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface User2Dao &#123;</span><br><span class="line">    List&lt;User2&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="映射配置-User2Dao-xml"><a href="#映射配置-User2Dao-xml" class="headerlink" title="映射配置 User2Dao.xml"></a>映射配置 <code>User2Dao.xml</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.User2Dao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"domain.User2"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试查询结果"><a href="#测试查询结果" class="headerlink" title="测试查询结果"></a>测试查询结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream config;</span><br><span class="line">    <span class="keyword">private</span> SqlSession session;</span><br><span class="line">    <span class="keyword">private</span> User2Dao mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        config = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(config);</span><br><span class="line">        session = factory.openSession();</span><br><span class="line">        mapper = session.getMapper(User2Dao.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在关闭资源之前，提交事务</span></span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        config.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User2&gt; users = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User2 user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User2&#123;userId=<span class="keyword">null</span>, userName=<span class="string">'老王'</span>, userBirthday=<span class="keyword">null</span>, userSex=<span class="string">'null'</span>, userAddress=<span class="string">'null'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="keyword">null</span>, userName=<span class="string">'小二王'</span>, userBirthday=<span class="keyword">null</span>, userSex=<span class="string">'null'</span>, userAddress=<span class="string">'null'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="keyword">null</span>, userName=<span class="string">'小二王'</span>, userBirthday=<span class="keyword">null</span>, userSex=<span class="string">'null'</span>, userAddress=<span class="string">'null'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="keyword">null</span>, userName=<span class="string">'传智播客'</span>, userBirthday=<span class="keyword">null</span>, userSex=<span class="string">'null'</span>, userAddress=<span class="string">'null'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="keyword">null</span>, userName=<span class="string">'老王'</span>, userBirthday=<span class="keyword">null</span>, userSex=<span class="string">'null'</span>, userAddress=<span class="string">'null'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="keyword">null</span>, userName=<span class="string">'小马宝莉'</span>, userBirthday=<span class="keyword">null</span>, userSex=<span class="string">'null'</span>, userAddress=<span class="string">'null'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到只有 <code>userName</code> 有值。</li><li>因为 MySQL 在 Windows 下不区分大小写，表中的 <code>username</code> 列认为与 <code>userName</code> 属性匹配上了。</li></ul><h4 id="修改映射配置"><a href="#修改映射配置" class="headerlink" title="修改映射配置"></a>修改映射配置</h4><ul><li>使用别名可以解决属性名与列名不一致导致的问题。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.User2Dao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"domain.User2"</span>&gt;</span></span><br><span class="line">        select id as userId,username as userName,birthday as userBirthday,</span><br><span class="line">        sex as userSex,address as userAddress from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>再次运行测试类，输出结果如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User2&#123;userId=<span class="number">41</span>, userName=<span class="string">'老王'</span>, userBirthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>, userSex=<span class="string">'男'</span>, userAddress=<span class="string">'北京'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="number">42</span>, userName=<span class="string">'小二王'</span>, userBirthday=Fri Mar <span class="number">02</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37</span> CST <span class="number">2018</span>, userSex=<span class="string">'女'</span>, userAddress=<span class="string">'北京金燕龙'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="number">43</span>, userName=<span class="string">'小二王'</span>, userBirthday=Sun Mar <span class="number">04</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">34</span> CST <span class="number">2018</span>, userSex=<span class="string">'女'</span>, userAddress=<span class="string">'北京金燕龙'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="number">45</span>, userName=<span class="string">'传智播客'</span>, userBirthday=Sun Mar <span class="number">04</span> <span class="number">12</span>:<span class="number">04</span>:<span class="number">06</span> CST <span class="number">2018</span>, userSex=<span class="string">'男'</span>, userAddress=<span class="string">'北京金燕龙'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="number">46</span>, userName=<span class="string">'老王'</span>, userBirthday=Wed Mar <span class="number">07</span> <span class="number">17</span>:<span class="number">37</span>:<span class="number">26</span> CST <span class="number">2018</span>, userSex=<span class="string">'男'</span>, userAddress=<span class="string">'北京'</span>&#125;</span><br><span class="line">User2&#123;userId=<span class="number">48</span>, userName=<span class="string">'小马宝莉'</span>, userBirthday=Thu Mar <span class="number">08</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">00</span> CST <span class="number">2018</span>, userSex=<span class="string">'女'</span>, userAddress=<span class="string">'北京修正'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点：如果查询很多，都使用别名写起来会很麻烦。</li></ul><h3 id="resultMap-结果类型"><a href="#resultMap-结果类型" class="headerlink" title="resultMap 结果类型"></a><code>resultMap</code> 结果类型</h3><ul><li><strong><code>resultMap</code> 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装</strong>。</li><li>在 <code>select</code> 标签中使用 <code>resultMap</code> 属性指定引用即可。同时 <code>resultMap</code> 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。</li></ul><h4 id="定义-resultMap-并进行映射配置"><a href="#定义-resultMap-并进行映射配置" class="headerlink" title="定义 resultMap 并进行映射配置"></a>定义 <code>resultMap</code> 并进行映射配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"dao.User2Dao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询结果的列名与实体类的属性名之间的对应关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"domain.User2"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主键字段的对应 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"userId"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 非主键字段的对应 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userBirthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userAddress"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User2Dao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User2 <span class="title">findById</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCRUDTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User2 user = mapper.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User2&#123;userId=<span class="number">41</span>, userName=<span class="string">'老王'</span>, userBirthday=Tue Feb <span class="number">27</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">08</span> CST <span class="number">2018</span>, userSex=<span class="string">'男'</span>, userAddress=<span class="string">'北京'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="MyBatis-传统-Dao-层开发"><a href="#MyBatis-传统-Dao-层开发" class="headerlink" title="MyBatis 传统 Dao 层开发"></a>MyBatis 传统 Dao 层开发</h1><h2 id="持久层-Dao-的实现类"><a href="#持久层-Dao-的实现类" class="headerlink" title="持久层 Dao 的实现类"></a>持久层 Dao 的实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">(SqlSessionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        List&lt;User&gt; users = session.selectList(<span class="string">"dao.UserDao.findAll"</span>);</span><br><span class="line">        session.close();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="keyword">int</span> id = session.insert(<span class="string">"dao.UserDao.saveUser"</span>, user);</span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        session.update(<span class="string">"dao.UserDao.updateUser"</span>, user);</span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        session.delete(<span class="string">"dao.UserDao.deleteUser"</span>, userId);</span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        User user = session.selectOne(<span class="string">"dao.UserDao.findById"</span>, userId);</span><br><span class="line">        session.close();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findByName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        List&lt;User&gt; users = session.selectList(<span class="string">"dao.UserDao.findByName"</span>, username);</span><br><span class="line">        session.close();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="keyword">int</span> count = session.selectOne(<span class="string">"dao.UserDao.findTotal"</span>);</span><br><span class="line">        session.close();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream config;</span><br><span class="line">    <span class="keyword">private</span> UserDao mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        config = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(config);</span><br><span class="line">        mapper = <span class="keyword">new</span> UserDaoImpl(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        config.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"mybatis save user last insert id"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"湖北省武汉市"</span>);</span><br><span class="line">        user.setSex(<span class="string">"男"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"保存操作之前："</span> + user);</span><br><span class="line">        mapper.saveUser(user);</span><br><span class="line">        System.out.println(<span class="string">"保存操作之后："</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">55</span>);</span><br><span class="line">        user.setUsername(<span class="string">"mybatis update user"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"北京市海淀区"</span>);</span><br><span class="line">        user.setSex(<span class="string">"女"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        mapper.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mapper.deleteUser(<span class="number">55</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = mapper.findById(<span class="number">41</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = mapper.findByName(<span class="string">"王"</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = mapper.findTotal();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SqlMapConfig-xml-配置文件"><a href="#SqlMapConfig-xml-配置文件" class="headerlink" title="SqlMapConfig.xml 配置文件"></a><code>SqlMapConfig.xml</code> 配置文件</h1><h2 id="配置内容与顺序"><a href="#配置内容与顺序" class="headerlink" title="配置内容与顺序"></a>配置内容与顺序</h2><ul><li><code>properties</code>（属性）<ul><li><code>property</code></li></ul></li><li><code>settings</code>（全局配置参数）<ul><li><code>setting</code></li></ul></li><li><code>typeAliases</code>（类型别名）<ul><li><code>typeAlias</code></li><li><code>package</code></li></ul></li><li><code>typeHandlers</code>（类型处理器）</li><li><code>objectFactory</code>（对象工厂）</li><li><code>plugins</code>（插件）</li><li><code>environments</code>（环境集合属性对象）<ul><li><code>environment</code>（环境子属性对象）<ul><li><code>transactionManager</code>（事务管理）</li><li><code>dataSource</code>（数据源）</li></ul></li></ul></li><li><code>mappers</code>（映射器）<ul><li><code>mapper</code></li><li><code>package</code></li></ul></li></ul><h2 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties 属性"></a><code>properties</code> 属性</h2><ul><li>在使用 <code>properties</code> 标签配置时，我们可以采用两种方式指定属性配置。</li></ul><h3 id="使用-property-标签配置"><a href="#使用-property-标签配置" class="headerlink" title="使用 property 标签配置"></a>使用 <code>property</code> 标签配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatisdb"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-properties-文件配置"><a href="#使用-properties-文件配置" class="headerlink" title="使用 properties 文件配置"></a>使用 <code>properties</code> 文件配置</h3><ul><li>在 <strong>classpath</strong> 下定义 <code>jdbcConfig.properties</code> 文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/mybatisdb</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><ul><li>对 <code>properties</code> 标签进行配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbcConfig.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">url</span>=<span class="string">"file:///G:/SSM/MyBatis/day02/MyBatis_CRUD/src/main/resources/jdbcConfig.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>dataSource</code> 标签引用上面的配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases 类型别名"></a><code>typeAliases</code> 类型别名</h2><ul><li>在前面讲的 MyBatis 支持默认别名，也可以采用自定义别名方式来开发。</li><li><code>typeAlias</code> 标签用于配置别名。<ul><li><code>type</code> 属性指定的是实体类全限定类名。</li><li><code>alias</code> 属性指定别名，当指定了别名就再区分大小写。</li></ul></li><li><code>package</code> 标签用于指定要配置别名的包。<ul><li>当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"domain.User"</span> <span class="attr">alias</span>=<span class="string">"User"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mappers-映射器"><a href="#mappers-映射器" class="headerlink" title="mappers 映射器"></a><code>mappers</code> 映射器</h2><ul><li><code>mappers</code> 标签用于指定映射配置。<ul><li><code>mapper</code> 标签指定映射配置文件的位置。<ul><li><code>resource</code> 属性使用相对于类路径的 XML 资源定位。</li><li><code>class</code> 属性使用 mapper 接口的全限定类名，要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</li></ul></li><li><code>package</code> 标签注册指定包下的所有 mapper 接口。<ul><li>要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"dao/UserDao.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"dao.UserDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE总结（JVM篇）</title>
      <link href="/2020/06/04/javase-sumary-jvm.html"/>
      <url>/2020/06/04/javase-sumary-jvm.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存区域（运行时数据区）"><a href="#Java-内存区域（运行时数据区）" class="headerlink" title="Java 内存区域（运行时数据区）"></a>Java 内存区域（运行时数据区）</h1><ul><li>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同。</li><li>JDK 1.8 之前：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/JVM运行时数据区域1.8之前.png" alt="JVM运行时数据区域1.8之前"></p><ul><li>JDK 1.8 之后：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/Java运行时数据区域1.8之后.png" alt="Java运行时数据区域JDK1.8"></p><ul><li><strong>线程私有的：</strong><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li><strong>线程共享的：</strong><ul><li>堆</li><li>方法区</li><li>直接内存（非运行时数据区的一部分）</li></ul></li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul><li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</li><li>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li><li>从上面的介绍中我们知道<strong>程序计数器主要有两个作用：</strong><ol><li><strong>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</strong></li><li><strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</strong></li></ol></li><li>注意：<strong>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li></ul><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><ul><li>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</li><li>Java 内存可以粗糙地区分为堆内存（Heap）和栈内存（Stack），其中栈就是现在说的虚拟机栈，确切地说是虚拟机栈中局部变量表部分。 实际上，<strong>Java 虚拟机栈是由一个个栈帧（Stack Frame）组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态连接、方法出口</strong>。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机中入栈和出栈的过程。Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。<ul><li><strong>局部变量表</strong>：<ul><li>用于<strong>存放方法参数和方法内部定义的局部变量</strong>。</li><li>主要存放了编译器可知的各种数据类型（<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>）、对象引用（<code>reference</code> 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li></ul></li><li><strong>操作数栈</strong>：<ul><li>是 Java 虚拟机<strong>用来数值计算的内存区域</strong>。</li><li>方法的执行操作在操作数栈中完成，每一个字节码指令往操作数栈进行写入和提取的过程，就是入栈和出栈的过程。</li><li>一次完整的计算之后，栈中的数据会已经出栈，所以操作数栈的空间在一个方法内部可以反复使用。</li><li>当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，通过一些字节码指令从局部变量表或者对象实例字段中复制常量或者变量值到操作数栈中，也提供一些指令向操作数栈中写入和提取值，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。</li></ul></li><li><strong>动态连接</strong>：<ul><li>每个栈帧都包含一个<strong>指向运行时常量池中该栈帧所有属性方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态连接。</li><li>虚拟机在执行方法时有两种形式被用来确定执行指令对应的方法：<ol><li>静态解析：在类加载的时候，直接确定要执行的方法（静态方法、私有方法和 <code>final</code> 方法等）。</li><li>动态连接：<strong>在真正运行的时候，根据对象的真实引用判断当前要执行的方法</strong>。</li></ol></li><li>字节码文件中都有一个常量池，在常量池中保存有大量的符号引用（是每一个方法的间接引用），字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用（静态解析），另外一部分将在每一次的运行期期间转化为直接引用（动态连接）。</li></ul></li><li><strong>方法出口</strong>：<ul><li>当一个方法开始执行后，只有两种方式可以退出这个方法：<ol><li>第一种方式是执行引擎遇到任意一个方法返回的字节码指令（如 <code>return</code>、<code>areturn</code>、<code>ireturn</code>），这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>正常完成出口</strong>。</li><li>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用 <code>athrow</code> 字节码指令产生的异常，只要在本方法的异常处理器表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<strong>异常完成出口</strong>。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</li></ol></li><li>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的<strong>程序计数器</strong>的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过<strong>异常处理器表</strong>来确定的，栈帧中一般不会保存这部分信息。</li><li>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整程序计数器的值以指向方法调用指令后面的一条指令等。</li></ul></li></ul></li><li>Java 虚拟机栈会出现两种异常：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。<ul><li><code>StackOverFlowError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 异常。</li><li><code>OutOfMemoryError</code>：若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 <code>OutOfMemoryError</code> 异常。</li></ul></li><li>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul><li>和虚拟机栈所发挥的作用非常相似，它们之间的区别是<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <code>native</code> 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li><li>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种异常。</li><li>线程开始调用本地方法时，会进入一个不再受 JVM 约束的世界。本地方法可以通过 JNI（Java Native Interface）来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和 JVM 相同的能力和权限。 当大量本地方法出现时，势必会削弱 JVM 对系统的控制力，因为它的出错信息都比较黑盒。对内存不足的情况，本地方法栈还是会抛出 <code>nativeheapOutOfMemory</code>。</li><li>JNI 类本地方法最著名的应该是 <code>System.currentTimeMillis()</code> ，JNI 使 Java 深度使用操作系统的特性功能，复用非 Java 代码。 但是在项目过程中， 如果大量使用其他语言来实现 JNI , 就会丧失跨平台特性。</li></ul><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><ul><li>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></li><li>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。<strong>从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存</strong>。</li><li>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：<code>Eden</code> 空间、<code>From Survivor</code>、<code>To Survivor</code> 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存</strong>。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/堆结构.png" alt="堆结构"></p><ul><li>上图所示的 <code>eden</code> 区、<code>s0</code> 区、<code>s1</code> 区都属于新生代，<code>tentired</code> 区属于老年代。大部分情况，对象都会首先在 <code>eden</code> 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 <code>s0</code> 或者 <code>s1</code>，并且对象的年龄还会加 1（<code>Eden</code> 区 → <code>Survivor</code> 区后对象的初始年龄变为 1），当它的年龄增加到一定程度，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。Hotspot 遍历所有对象时，按照年龄从小到大进行累积，当累积的某个年龄的大小超过了 <code>survivor</code> 区容量的一半时，取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值。</li><li>经过这次 GC 后，<code>Eden</code> 区和 <code>From</code> 区已经被清空。这个时候，<code>From</code> 和 <code>To</code> 会交换他们的角色，也就是新的 <code>To</code> 就是上次 GC 前的 <code>From</code>，新的 <code>From</code> 就是上次 GC 前的 <code>To</code>。不管怎样，都会保证名为 <code>To</code> 的 <code>Survivor</code> 区域是空的。Minor GC 会一直重复这样的过程，直到 <code>To</code> 区被填满，<code>To</code> 区被填满之后，会将所有对象移动到老年代中。</li><li>从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的<strong>分配缓冲区（Thread Local Allocation Buffer，TLAB</strong>）。</li><li>Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 <code>OutOfMemoryError</code> 异常。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。</li><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 <strong><code>Non-Heap</code>（非堆）</strong>，目的应该是与 Java 堆区分开来。</li><li>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。<strong>垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。</strong>当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</li></ul><h3 id="方法区与永久代的关系"><a href="#方法区与永久代的关系" class="headerlink" title="方法区与永久代的关系"></a>方法区与永久代的关系</h3><ul><li>《Java虚拟机规范》只是规定了有方法区这个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。</li><li><strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> </li><li>在 HotSpot JVM 中，永久代中用于存放类和方法的元数据以及常量池，比如 <code>Class</code> 和 <code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</li><li>也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，其他的虚拟机实现并没有永久代这一说法。</li></ul><h3 id="为什么要使用元空间取代永久代的实现？"><a href="#为什么要使用元空间取代永久代的实现？" class="headerlink" title="为什么要使用元空间取代永久代的实现？"></a>为什么要使用元空间取代永久代的实现？</h3><ul><li><strong>JDK 1.8 之前，HotSpot 中方法区的实现是永久代（PermGen），JDK 8 开始使用元空间（MetaSpace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配</strong>。</li><li>为什么要将永久代替换为元空间呢？<ol><li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，内存经常会溢出，引发<code>OutOfMemoryError</code>，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。<ul><li>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 <code>unlimited</code>，这意味着它只受系统内存的限制。</li><li><code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</li></ul></li><li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li><li>在 JDK 1.8 移除永久代可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li></ol></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li><code>Class</code> 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/常量池包含的内容.jpg" alt="常量池包含的内容"></p><ul><li>一般来说，除了保存 <code>Class</code> 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li><li>运行时常量池相对于 <code>Class</code> 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 <code>Class</code> 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 <code>String</code> 类的 <code>intern()</code> 方法。</li><li>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li><li>JDK 1.7 及之后版本的修改：<ol><li><strong>JDK 1.7 之前运行时常量池逻辑包含字符串常量池</strong>，存放在方法区，此时 hotspot 虚拟机对方法区的实现为永久代。</li><li><strong>JDK 1.7 字符串常量池被从方法区拿到了堆中</strong>，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，<strong>运行时常量池剩下的东西还在方法区，也就是 hotspot 中的永久代</strong>。</li><li><strong>JDK 1.8</strong> hotspot 移除了永久代用元空间（Metaspace）取而代之，这时候<strong>字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间</strong>。</li></ol></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul><li><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></li><li>JDK 1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</li><li>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/Java内存区域.png" alt="Java内存区域"></p><h1 id="Java-内存模型（JVM-工作方式）"><a href="#Java-内存模型（JVM-工作方式）" class="headerlink" title="Java 内存模型（JVM 工作方式）"></a>Java 内存模型（JVM 工作方式）</h1><ul><li>Java 内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。而内存模型（Java Memory Model，简称 JMM）是定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存（RAM）中的工作方式，如果我们要想深入了解 Java 并发编程，就要先理解好 Java 内存模型。</li><li><strong>Java 内存模型是共享内存的并发模型</strong>，线程之间主要通过读写共享变量（堆内存中的实例域、静态域和数组元素）来完成隐式通信。</li><li>Java 内存模型（JMM）控制 Java 线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。</li></ul><h2 id="计算机高速缓存与缓存一致性"><a href="#计算机高速缓存与缓存一致性" class="headerlink" title="计算机高速缓存与缓存一致性"></a>计算机高速缓存与缓存一致性</h2><ul><li>计算机在高速的 CPU 和相对低速的存储设备之间使用高速缓存，作为内存和处理器之间的缓冲。将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中。</li><li>在多处理器的系统中（或者单处理器多核的系统），每个处理器内核都有自己的高速缓存，它们有共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/计算机高速缓存示意图.png" alt="计算机高速缓存示意图"></p><h2 id="JVM-主内存与工作内存"><a href="#JVM-主内存与工作内存" class="headerlink" title="JVM 主内存与工作内存"></a>JVM 主内存与工作内存</h2><ul><li>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量（线程共享的变量）存储到内存和从内存中取出变量这样底层细节。</li><li>Java 内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</li><li>这里的工作内存是 JMM 的一个抽象概念，也叫本地内存，其存储了该线程以读 / 写共享变量的副本。</li><li><strong>就像每个处理器内核拥有私有的高速缓存，JMM 中每个线程拥有私有的本地内存</strong>。</li><li>不同线程之间无法直接访问对方工作内存中的变量，线程间的通信一般有两种方式进行，一是通过消息传递，二是共享内存。Java 线程间的通信采用的是共享内存方式，线程、主内存和工作内存的交互关系如下图所示：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/线程、主内存和工作内存的交互关系.png" alt="线程、主内存和工作内存的交互关系"></p><ul><li>这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</li></ul><h2 id="重排序与-happens-before-规则"><a href="#重排序与-happens-before-规则" class="headerlink" title="重排序与 happens-before 规则"></a>重排序与 happens-before 规则</h2><ul><li>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：<ol><li><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><strong>内存系统的重排序</strong>。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol></li><li>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/指令重排序.png" alt="指令重排序"></p><ul><li>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</li><li>Java 编译器禁止处理器重排序是通过在生成指令序列的适当位置会<strong>插入内存屏障（重排序时不能把后面的指令重排序到内存屏障之前的位置）指令</strong>来实现的。</li><li>从 JDK 5 开始，Java 内存模型提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。</li><li>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</li><li><strong>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong></li><li>如果 A happens-before B，那么 Java 内存模型将向程序员保证 A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。</li><li>重要的 <strong>happens-before 规则</strong>如下：<ol><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li><li><strong><code>volatile</code> 变量规则</strong>：对一个 <code>volatile</code> 域的写，happens-before 于任意后续对这个 <code>volatile</code> 域的读。</li><li><strong>传递性</strong>：如果 A happens- before B，且 B happens-before C，那么 A happens-before C。</li></ol></li><li>下图是 happens-before 与 JMM 的关系：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/happens-before与JMM的关系.png" alt="happens-before与JMM的关系"></p><h2 id="valotile-关键字"><a href="#valotile-关键字" class="headerlink" title="valotile 关键字"></a><code>valotile</code> 关键字</h2><ul><li><code>volatile</code> 可以说是 JVM 提供的最轻量级的同步机制，当一个变量定义为 <code>volatile</code> 之后，它将具备两种特性：<ol><li><strong>保证此变量对所有线程的可见性。</strong>而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。<ul><li>注意，<code>volatile</code> 虽然保证了可见性，但是 Java 里面的运算并非原子操作，导致 <code>volatile</code> 变量的运算在并发下一样是不安全的。</li><li>而 <code>synchronized</code> 关键字则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得线程安全的。</li></ul></li><li><strong>禁止指令重排序优化。</strong>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</li></ol></li></ul><h1 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h1><h2 id="Java-对象的创建过程"><a href="#Java-对象的创建过程" class="headerlink" title="Java 对象的创建过程"></a>Java 对象的创建过程</h2><ul><li>下图便是 Java 对象的创建过程：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/Java对象的创建过程.png" alt="Java对象的创建过程"></p><ol><li><strong>类加载检查：</strong>虚拟机遇到一条 <code>new</code> 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li><li><strong>分配内存：</strong>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有<strong>“指针碰撞”</strong>和<strong>“空闲列表”</strong>两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</li><li><strong>初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头：</strong>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 <code>init</code> 方法：</strong>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 <code>new</code> 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ol><h2 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a>内存分配的两种方式</h2><ul><li>内存分配有两种方式：<ol><li>指针碰撞：<ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>GC 收集器：Serial、ParNew。</li></ul></li><li>空闲列表：<ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录。</li><li>GC 收集器：CMS。</li></ul></li></ol></li></ul><p><img src="/2020/06/04/javase-sumary-jvm/内存分配的两种方式.png" alt="内存分配的两种方式"></p><ul><li>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</li></ul><h2 id="内存分配的并发问题"><a href="#内存分配的并发问题" class="headerlink" title="内存分配的并发问题"></a>内存分配的并发问题</h2><ul><li>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：<ol><li><strong>CAS + 失败重试：</strong>CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong>为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li></ol></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ul><li>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。<ol><li><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</li><li><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</li><li><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ol></li></ul><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><ul><li>建立对象就是为了使用对象，Java 程序通过栈上的 <code>reference</code> 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</li><li><strong>使用句柄</strong>：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，<code>reference</code> 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/通过句柄访问对象.png" alt="通过句柄访问对象"></p><ul><li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 <code>reference</code> 中存储的直接就是对象的地址。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/通过直接指针访问对象.png" alt="通过直接指针访问对象"></p><ul><li>这两种对象访问方式各有优势：<ul><li>使用句柄来访问的最大好处是 <code>reference</code> 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 <code>reference</code> 本身不需要修改。</li><li>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</li></ul></li></ul><h1 id="揭开-JVM-内存分配与回收的神秘面纱"><a href="#揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="揭开 JVM 内存分配与回收的神秘面纱"></a>揭开 JVM 内存分配与回收的神秘面纱</h1><ul><li>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。</li><li>同时，Java 自动内存管理最核心的功能是<strong>堆</strong>内存中对象的分配与回收。</li></ul><h2 id="堆内存中对象分配的基本策略"><a href="#堆内存中对象分配的基本策略" class="headerlink" title="堆内存中对象分配的基本策略"></a>堆内存中对象分配的基本策略</h2><ul><li>堆空间的基本结构：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/堆结构.png" alt="堆空间的基本结构"></p><ul><li>上图所示的 <code>eden</code> 区、<code>s0</code> 区、<code>s1</code> 区都属于新生代，<code>tentired</code> 区属于老年代。大部分情况，对象都会首先在 <code>eden</code> 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 <code>s0</code> 或者 <code>s1</code>，并且对象的年龄还会加 1（<code>Eden</code> 区 → <code>Survivor</code> 区后对象的初始年龄变为 1），当它的年龄增加到一定程度，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。Hotspot 遍历所有对象时，按照年龄从小到大进行累积，当累积的某个年龄的大小超过了 <code>survivor</code> 区容量的一半时，取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值。</li><li>经过这次 GC 后，<code>Eden</code> 区和 <code>From</code> 区已经被清空。这个时候，<code>From</code> 和 <code>To</code> 会交换他们的角色，也就是新的 <code>To</code> 就是上次 GC 前的 <code>From</code>，新的 <code>From</code> 就是上次 GC 前的 <code>To</code>。不管怎样，都会保证名为 <code>To</code> 的 <code>Survivor</code> 区域是空的。Minor GC 会一直重复这样的过程，直到 <code>To</code> 区被填满，<code>To</code> 区被填满之后，会将所有对象移动到老年代中。</li><li>另外，大对象和长期存活的对象会直接进入老年代。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/堆内存常见的分配策略.jpg" alt="堆内存常见的分配策略"></p><h2 id="对象优先在-eden-区分配"><a href="#对象优先在-eden-区分配" class="headerlink" title="对象优先在 eden 区分配"></a>对象优先在 eden 区分配</h2><ul><li>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li><li>大多数情况下，对象在新生代中 <code>eden</code> 区分配。当 <code>eden</code> 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</li><li>当 Minor GC 期间发现 <code>eden</code> 区的对象无法存入 <code>survival</code> 空间，只好通过<strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去。如果老年代上的空间足够存放该对象，则不会出现 Full GC。</li><li>执行 Minor GC 后，后面分配的对象如果能够存在 <code>eden</code> 区的话，还是会在 <code>eden</code> 区分配内存。</li><li><strong>Minor GC 和 Full GC 有什么不同呢？</strong><ul><li><strong>新生代 GC（Minor GC）</strong>：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢10倍以上。</li></ul></li></ul><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><ul><li>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</li><li>为什么要这样呢？为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</li></ul><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><ul><li>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</li><li>如果对象在 <code>Eden</code> 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 <code>Survivor</code> 容纳的话，将被移动到 <code>Survivor</code> 空间中，并将对象年龄设为 1。对象在 <code>Survivor</code> 中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</li></ul><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><ul><li>Hotspot 遍历所有对象时，按照年龄从小到大进行累积，当累积的某个年龄的大小超过了 <code>survivor</code> 区容量的一半时，取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值。</li></ul><h1 id="对象的死亡"><a href="#对象的死亡" class="headerlink" title="对象的死亡"></a>对象的死亡</h1><h2 id="判断对象死亡的两种方法"><a href="#判断对象死亡的两种方法" class="headerlink" title="判断对象死亡的两种方法"></a>判断对象死亡的两种方法</h2><ul><li>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</li><li><strong>引用计数法</strong>：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</li><li><strong>可达性分析算法</strong>：这个算法的基本思想就是通过一系列的称为<strong>“GC Roots”</strong>的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/可达性分析算法.jpg" alt="可达性分析算法"></p><h2 id="强引用、软引用、弱引用与虚引用介绍"><a href="#强引用、软引用、弱引用与虚引用介绍" class="headerlink" title="强引用、软引用、弱引用与虚引用介绍"></a>强引用、软引用、弱引用与虚引用介绍</h2><ul><li>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</li><li>JDK 1.2 之前，Java 中引用的定义很传统：如果 <code>reference</code> 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</li><li>JDK 1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）。</li></ul><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><ul><li>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</li></ul><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><ul><li>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</li><li>软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。</li></ul><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><ul><li>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：<strong>只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。</li><li>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li><li>弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li></ul><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><ul><li>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</li><li><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</li><li><strong>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（<code>ReferenceQueue</code>）联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li><li>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（<code>OutOfMemory</code>）等问题的产生</strong>。</li></ul><h2 id="不可达对象并非非死不可"><a href="#不可达对象并非非死不可" class="headerlink" title="不可达对象并非非死不可"></a>不可达对象并非非死不可</h2><ul><li>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程。</li><li>可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</li><li>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</li></ul><h2 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h2><ul><li><strong>运行时常量池主要回收的是废弃的常量</strong>。那么，我们如何判断一个常量是废弃常量呢？</li><li>假如在常量池中存在字符串 “abc”，如果当前没有任何 <code>String</code> 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</li></ul><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><ul><li><strong>该算法分为“标记”和“清除”阶段：首先比较出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</strong></li><li>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：<ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol></li></ul><p><img src="/2020/06/04/javase-sumary-jvm/标记-清除算法.jpg" alt="标记-清除算法"></p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ul><li>为了解决效率问题，“复制”收集算法出现了。</li><li><strong>它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</strong></li><li>这样就使每次的内存回收都是对内存区间的一半进行回收。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/复制算法.jpg" alt="复制算法"></p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><ul><li>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是<strong>让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</strong>。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/标记-整理算法.jpg" alt="标记-整理算法"></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul><li><strong>当前虚拟机的垃圾收集都采用分代收集算法</strong>，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块</strong>。</li><li>一般将 Java 堆分为新生代和老年代，这样我们就可以<strong>根据各个年代的特点选择合适的垃圾收集算法</strong>。</li><li>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</li><li>而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li><li><strong>延伸面试问题：</strong>HotSpot 为什么要分为新生代和老年代？主要是为了提升 GC 效率。上面提到的分代收集算法已经很好的解释了这个问题。</li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><ul><li><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></li><li>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</li></ul><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><ul><li>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</li><li><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li></ul><p><img src="/2020/06/04/javase-sumary-jvm/Serial收集器.jpg" alt="Serial收集器"></p><ul><li>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</li><li>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</li></ul><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><ul><li>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</li><li>新生代采用复制算法，老年代采用标记-整理算法。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/ParNew收集器.jpg" alt="ParNew收集器"></p><ul><li>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</li><li><strong>并行和并发概念补充：</strong><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul></li></ul><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><ul><li>Parallel Scavenge 收集器<strong>也是使用复制算法的多线程收集器</strong>，它看上去几乎和 ParNew 都一样。 那么它有什么特别之处呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure><ul><li><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> </li><li>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</li><li><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li></ul><p><img src="/2020/06/04/javase-sumary-jvm/ParallelScavenge收集器.jpg" alt="Parallel Scavenge收集器"></p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><ul><li><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。</li><li>它主要有两大用途：一种用途是在 JDK 1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</li></ul><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><ul><li><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。</li><li>在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</li></ul><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><ul><li><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用</strong>。</li><li><strong>CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。</li><li>从名字中的 <strong>Mark Sweep</strong> 这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：<ul><li><strong>初始标记：</strong>暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong>同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong>重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong>开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul></li></ul><p><img src="/2020/06/04/javase-sumary-jvm/CMS收集器.jpg" alt="CMS 收集器"></p><ul><li>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：<ul><li><strong>对 CPU 资源敏感</strong>；</li><li><strong>无法处理浮动垃圾</strong>；</li><li><strong>它使用的“标记-清除”算法会导致收集结束时会有大量空间碎片产生</strong>。</li></ul></li></ul><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><ul><li><strong>G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多个处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</strong>。</li><li>被视为 JDK 1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：<ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul></li><li>G1 收集器的运作大致分为以下几个步骤：<ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul></li><li><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（这也就是它的名字 Garbage-First 的由来）</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内具有尽可能高的收集效率（把内存化整为零）。</li></ul><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><ul><li>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成 <code>.class</code> 文件最终运行在 Java 虚拟机之上。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/不同语言编译class情况.png" alt="不同语言编译class情况"></p><ul><li><strong>可以说 <code>.class</code> 文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</strong></li><li>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">// Class 文件的标志</span></span><br><span class="line">    u2             minor_version; <span class="comment">// Class 的小版本号</span></span><br><span class="line">    u2             major_version; <span class="comment">// Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count; <span class="comment">// 常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">// 常量池</span></span><br><span class="line">    u2             access_flags; <span class="comment">// Class 的访问标记</span></span><br><span class="line">    u2             this_class; <span class="comment">// 当前类</span></span><br><span class="line">    u2             super_class; <span class="comment">// 父类</span></span><br><span class="line">    u2             interfaces_count; <span class="comment">// 接口</span></span><br><span class="line">    u2             interfaces[interfaces_count]; <span class="comment">// 一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count; <span class="comment">// Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count]; <span class="comment">// 一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count; <span class="comment">// Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count]; <span class="comment">// 一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count; <span class="comment">// 此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="comment">// 属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Class</code> 文件字节码结构组织示意图</strong>：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/Class文件字节码结构组织示意图.png" alt="Class文件字节码结构组织示意图"></p><ul><li>下面会按照上图结构按顺序详细介绍一下 <code>Class</code> 文件结构涉及到的一些组件。<ol><li><strong>魔数:</strong> 确定这个文件是否为一个能被虚拟机接收的 <code>Class</code> 文件。</li><li><strong>Class 文件版本</strong>：<code>Class</code> 文件的版本号，保证编译正常执行。</li><li><strong>常量池</strong>：常量池主要存放两大常量：字面量和符号引用。</li><li><strong>访问标志</strong>：标志用于识别一些类或者接口层次的访问信息，包括：这个 <code>Class</code> 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</li><li><strong>当前类索引、父类索引</strong>：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</li><li><strong>接口索引集合</strong>：接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按 <code>implents</code>（如果这个类本身是接口的话则是 <code>extends</code>）后的接口顺序从左到右排列在接口索引集合中。</li><li><strong>字段表集合</strong>：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li><strong>方法表集合</strong>：类中的方法。</li><li><strong>属性表集合</strong>： 在 <code>Class</code> 文件，字段表，方法表中都可以携带自己的属性表集合。</li></ol></li></ul><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><ul><li>一个类的完整生命周期如下：</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/类的生命周期.png" alt="类的生命周期"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ul><li><code>Class</code> 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 <code>Class</code> 文件呢？</li><li>系统加载 <code>Class</code> 类型的文件主要三步：<strong>加载 → 连接 → 初始化</strong>。连接过程又可分为三步：<strong>验证 → 准备 → 解析</strong>。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/类加载过程.png" alt="类加载过程"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>类加载过程的第一步，主要完成下面 3 件事情：<ol><li>通过全类名获取定义此类的二进制字节流；</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构；</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ol></li><li>虚拟机规范对上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的 JAR、EAR、WAR 格式的基础）、其他文件生成（典型应用就是 JSP）等等。</li><li><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></li><li>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/2020/06/04/javase-sumary-jvm/类加载过程的验证阶段.png" alt="类加载过程的验证阶段"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<ol><li>这时候进行内存分配的仅包括类变量（<code>static</code>），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等），比如我们定义了 <code>public static int value = 111</code>，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 <code>fianl</code> 关键字 <code>public static final int value = 111</code>，那么准备阶段 value 的值就被赋值为 111。</li></ol></li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul><li><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</li><li>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</li><li>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码（字节码），<strong>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程</strong>。</li><li>对于 <code>&lt;clinit&gt;()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为  <code>&lt;clinit&gt;()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</li><li>对于初始化阶段，虚拟机严格规范了有且只有 6 种情况下，必须对类进行初始化（只有主动去使用类才会初始化类）：<ol><li><strong>当遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条直接码指令时</strong>，比如 <code>new</code> 一个类，读取一个静态字段（未被 <code>final</code> 修饰）、或调用一个类的静态方法时。<ul><li>当 JVM 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 JVM 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）。</li><li>当 JVM 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 JVM 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li><strong>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时</strong>，如 <code>Class.forname(&quot;...&quot;)</code>、<code>newInstance()</code> 等等，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果<strong>其父类还未初始化</strong>，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要<strong>定义一个要执行的主类</strong>（包含 main 方法的那个类），虚拟机会先初始化这个类。</li><li><strong><code>MethodHandle</code> 和 <code>VarHandle</code></strong> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li><li><strong>当一个接口中定义了 JDK 8 新加入的默认方法</strong>（被 <code>default</code> 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>JVM 中内置了三个重要的 <code>ClassLoader</code>，除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自 <code>java.lang.ClassLoader</code>：<ol><li><strong><code>BootstrapClassLoader</code>（启动类加载器）</strong>：最顶层的加载类，由 C++ 实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类，或被 <code>-Xbootclasspath</code> 参数指定的路径中的所有类。</li><li><strong><code>ExtensionClassLoader</code>（扩展类加载器）</strong>：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong><code>AppClassLoader</code>（应用程序类加载器）</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol></li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h3><ul><li>每一个类都有一个对应它的类加载器。系统中的 <code>ClassLoder</code> 在协同工作的时候会默认使用<strong>双亲委派模型</strong>。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。</li><li><strong>加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理</strong>，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。<strong>当父类加载器无法处理时，才由自己来处理</strong>。当父类加载器为 <code>null</code> 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</li></ul><p><img src="/2020/06/04/javase-sumary-jvm/双亲委派模型.png" alt="双亲委派模型"></p><ul><li>每个类加载都有一个父类加载器，我们通过下面的程序来验证：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLodarDemo's ClassLoader is "</span> </span><br><span class="line">                + ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"The Parent of ClassLodarDemo's ClassLoader is "</span></span><br><span class="line">                + ClassLoaderDemo.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span></span><br><span class="line">                + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo<span class="string">'s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="string">The Parent of ClassLodarDemo'</span>s ClassLoader is sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo<span class="string">'s ClassLoader is null</span></span><br></pre></td></tr></table></figure><ul><li><code>AppClassLoader</code> 的父类加载器为 <code>ExtClassLoader</code>，<code>ExtClassLoader</code> 的父类加载器为 <code>null</code>，<strong><code>null</code> 并不代表 <code>ExtClassLoader</code> 没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</li><li>这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。</li></ul><h3 id="双亲委派模型实现的源码分析"><a href="#双亲委派模型实现的源码分析" class="headerlink" title="双亲委派模型实现的源码分析"></a>双亲委派模型实现的源码分析</h3><ul><li>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line">    <span class="comment">// must be added *after* it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                    <span class="comment">// 抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">// 自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><ul><li>双亲委派模型<strong>保证了 Java 程序的稳定运行</strong>，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也<strong>保证了 Java 的核心 API 不被篡改</strong>。</li><li>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</li></ul><h3 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h3><ul><li>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</li><li><strong>如何自定义类加载器？</strong>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</li></ul><h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><ul><li>卸载类即该类的 <code>Class</code> 对象被 GC。</li><li>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</li><li>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：<ol><li>该类所有的实例都已经被回收，也就是 Java 堆中<strong>不存在该类的任何实例</strong>。</li><li><strong>加载该类的 <code>ClassLoader</code> 已经被回收</strong>。</li><li>该类对应的 <strong><code>Class</code> 对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ol></li><li>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</li><li>在 JVM 生命周期内，由 JVM 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</li><li>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>、<code>PlatformClassLoader</code>、<code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们（类加载器的实例）肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> JavaSE面试总结 </category>
          
          <category> JVM篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> JavaSE面试总结 </tag>
            
            <tag> JVM篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE总结（多线程）</title>
      <link href="/2020/05/28/javase-sumary-multithreading.html"/>
      <url>/2020/05/28/javase-sumary-multithreading.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h2><ul><li>进程：<ul><li>进程<strong>是程序的一次执行过程，是系统运行程序的基本单位</strong>，因此进程是动态的。</li><li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</li></ul></li><li>线程：<ul><li>与进程相似，但线程<strong>是一个比进程更小的执行单位</strong>。</li><li>一个进程在其执行的过程中可以产生多个线程。</li><li>与进程不同的是，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>（JDK 8 之后称作元空间）资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。也正因为如此，线程也被称为轻量级进程。</li></ul></li><li>Java 程序天生就是多线程程序，可以通过 JMX 来看一个普通的 Java 程序有哪些线程，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] main <span class="comment">// main 线程,程序入口</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">// 清除 reference 线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">// 调用对象 finalize 方法的线程</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理给 JVM 信号的线程</span></span><br><span class="line">[<span class="number">5</span>] Attach Listener <span class="comment">// 添加事件</span></span><br><span class="line">[<span class="number">11</span>] Common-Cleaner</span><br><span class="line">[<span class="number">12</span>] Monitor Ctrl-Break</span><br></pre></td></tr></table></figure><ul><li>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 <code>main</code> 线程和多个其他线程同时运行</strong>。</li></ul><h2 id="线程与进程的关系、区别及优缺点"><a href="#线程与进程的关系、区别及优缺点" class="headerlink" title="线程与进程的关系、区别及优缺点"></a>线程与进程的关系、区别及优缺点</h2><ul><li>下图是 Java 内存区域，通过下图从 JVM 的角度来说一下线程和进程之间的关系。</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/JVM运行时数据区域.png" alt></p><ul><li>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区（JDK 1.8 之后的元空间）</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</li><li>总结：<ul><li>线程是进程划分成的更小的运行单位。</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但不利于资源的管理和保护，而进程正相反。</li><li>进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li></ul></li></ul><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li></ul><h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><ul><li>总体来说：<ul><li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong>现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul></li><li>深入到计算机底层来探讨：<ul><li><strong>单核时代：</strong>在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li><li><strong>多核时代：</strong>多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会有一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li></ul></li></ul><h2 id="使用多线程可能带来什么问题？"><a href="#使用多线程可能带来什么问题？" class="headerlink" title="使用多线程可能带来什么问题？"></a>使用多线程可能带来什么问题？</h2><ul><li>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</li></ul><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><ul><li>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/Java线程的状态.png" alt="Java线程的状态"></p><ul><li>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/Java线程状态变迁.png" alt="Java线程状态变迁"></p><ul><li>Java 线程将操作系统中的 <code>Ready</code>（就绪）和 <code>Running</code>（运行中）两种状态隐藏，统称为 <code>Runnable</code>（可运行）状态。</li><li>线程创建之后它将处于 <code>New</code>（新建）状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <code>Ready</code>（可运行）状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <code>Running</code>（运行）状态。</li><li>当线程执行 <code>wait()</code> 方法之后，线程进入 <code>Waiting</code>（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li>而 <code>Timed_Waiting</code>（超时等待）状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep(long millis)</code> 方法或 <code>wait(long millis)</code> 方法可以将 Java 线程置于 <code>Timed_Waiting</code> 状态。当超时时间到达后 Java 线程将会返回到 <code>Runnable</code> 状态。</li><li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <code>Blocked</code>（阻塞） 状态。</li><li>线程在退出 <code>run()</code> 方法之后将会进入到 <code>Terminated</code>（终止）状态。</li></ul><h2 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h2><ul><li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是<strong>为每个线程分配时间片并轮转</strong>的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，等到该线程获取到新的时间片再切换到运行状态，这个过程就属于一次上下文切换。</li><li>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</li><li>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</li><li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li></ul><h2 id="线程死锁的概念及避免方式"><a href="#线程死锁的概念及避免方式" class="headerlink" title="线程死锁的概念及避免方式"></a>线程死锁的概念及避免方式</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><ul><li>线程死锁描述的是这样一种情况：<strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止</strong>。</li><li>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/死锁1.png" alt="线程死锁"></p><ul><li>下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object(); <span class="comment">// 资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object(); <span class="comment">// 资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程A,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]waiting get resource1</span><br><span class="line">Thread[线程A,<span class="number">5</span>,main]waiting get resource2</span><br></pre></td></tr></table></figure><ul><li>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过 <code>Thread.sleep(1000);</code> 让线程 A 休眠 1s，为的是让线程 B 得到执行然后获取到 <code>resource2</code> 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</li><li>学过操作系统的朋友都知道<strong>产生死锁必须具备以下四个条件</strong>：<ol><li><strong>互斥条件：</strong>该资源任意一个时刻只由一个线程占用。</li><li><strong>请求与保持条件：</strong>一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件：</strong>线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol></li></ul><h3 id="如何避免线程死锁？"><a href="#如何避免线程死锁？" class="headerlink" title="如何避免线程死锁？"></a>如何避免线程死锁？</h3><ul><li>为了避免死锁，只要破坏产生死锁的四个条件中的其中一个就可以了。现在挨个分析一下：<ol><li><strong>破坏互斥条件</strong>：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li><li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol></li><li>对线程 B 的代码修改成下面这样就不会产生死锁了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"线程B"</span>).start();</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程A,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程A,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程A,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程B,<span class="number">5</span>,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>分析一下上面的代码为什么避免了死锁的发生？线程 A 首先获得到 <code>resource1</code> 的监视器锁，这时候线程 B 就获取不到了。然后线程 A 再去获取 <code>resource2</code> 的监视器锁，可以获取到。然后线程 A 释放了对 <code>resource1</code>、<code>resource2</code> 的监视器锁的占用，线程 B 获取到就可以执行了。这样就破坏了循环等待条件，因此避免了死锁。</li></ul><h2 id="sleep-与-wait-方法的区别和共同点"><a href="#sleep-与-wait-方法的区别和共同点" class="headerlink" title="sleep() 与 wait() 方法的区别和共同点"></a><code>sleep()</code> 与 <code>wait()</code> 方法的区别和共同点</h2><ul><li>两者最主要的区别在于：<strong><code>sleep</code> 方法没有释放锁，而 <code>wait</code> 方法释放了锁</strong>。</li><li>两者都可以暂停线程的执行。</li><li><strong><code>wait</code> 通常被用于线程间交互/通信，<code>sleep</code> 通常被用于暂停执行</strong>。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。<code>sleep()</code> 方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul><h2 id="为什么调用-start-方法时会调用-run-方法？为什么不能直接调用-run-方法？"><a href="#为什么调用-start-方法时会调用-run-方法？为什么不能直接调用-run-方法？" class="headerlink" title="为什么调用 start() 方法时会调用 run() 方法？为什么不能直接调用 run() 方法？"></a>为什么调用 <code>start()</code> 方法时会调用 <code>run()</code> 方法？为什么不能直接调用 <code>run()</code> 方法？</h2><ul><li><code>new</code> 一个 <code>Thread</code>，线程进入了新建状态，调用 <code>start()</code> 方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。</li><li>而直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li><li><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，而 <code>run()</code> 方法只是 <code>Thread</code> 的一个普通方法调用，还是在主线程里执行</strong>。</li></ul><h1 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><code>synchronized</code> 关键字</h1><h2 id="认识-synchronized-关键字"><a href="#认识-synchronized-关键字" class="headerlink" title="认识 synchronized 关键字"></a>认识 <code>synchronized</code> 关键字</h2><ul><li><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code> 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</li><li>另外，在 Java 早期版本中，<code>synchronized</code> 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 <code>synchronized</code> 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对<code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。<strong>JDK 1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销</strong>。</li></ul><h2 id="synchronized-关键字最主要的-3-种使用方式"><a href="#synchronized-关键字最主要的-3-种使用方式" class="headerlink" title="synchronized 关键字最主要的 3 种使用方式"></a><code>synchronized</code> 关键字最主要的 3 种使用方式</h2><ul><li><strong>修饰实例方法：</strong>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法：</strong>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（<code>static</code> 表明这是该类的一个静态资源，不管 <code>new</code>了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为<strong>访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块：</strong>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li><li>总结：<code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 <code>Class</code> 类上锁。<code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。<strong>尽量不要使用 <code>synchronized(String str)</code>，因为 JVM 中，字符串常量池具有缓存功能</strong>。</li></ul><h2 id="双重检验锁实现单例模式（线程安全）"><a href="#双重检验锁实现单例模式（线程安全）" class="headerlink" title="双重检验锁实现单例模式（线程安全）"></a>双重检验锁实现单例模式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile关键字确保，当uniqueInstance变量被初始化成Singleton实例时，</span></span><br><span class="line"><span class="comment">     * 多个线程正确地处理uniqueInstance变量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 进入同步区块后再次检查，仍是null才会创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另外，需要注意 <code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要。</li><li><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：<ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol></li><li>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行顺序有可能变成 1 → 3 → 2。</li><li>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</li><li><strong>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。</li></ul><h2 id="synchronized-关键字的底层实现原理"><a href="#synchronized-关键字的底层实现原理" class="headerlink" title="synchronized 关键字的底层实现原理"></a><code>synchronized</code> 关键字的底层实现原理</h2><ul><li><code>synchronized</code> 关键字的底层原理属于 JVM 层面。</li></ul><h3 id="同步语句块"><a href="#同步语句块" class="headerlink" title="同步语句块"></a>同步语句块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"synchronized代码块"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 JDK 自带的 <code>javap -c -s -v -l</code> 命令查看 <code>SynchronizedDemo1</code> 类的相关字节码信息：</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/synchronized关键字原理.png" alt="synchronized关键字原理"></p><ul><li>可以看出：<strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置</strong>。</li><li>当执行 <code>monitorenter</code> 指令时，线程试图获取锁，也就是获取 <code>monitor</code> 的持有权，当锁计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。</li><li><code>monitor</code> 对象存在于每个 Java 对象的对象头中，<code>synchronized</code> 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因。</li><li>相应的在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。</li><li>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li></ul><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/28/javase-sumary-multithreading/synchronized关键字原理2.png" alt="synchronized关键字原理2"></p><ul><li><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</li><li><strong>JVM 通过 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</strong>。</li></ul><h2 id="JDK-1-6-之后的-synchronized-关键字底层做了哪些优化？"><a href="#JDK-1-6-之后的-synchronized-关键字底层做了哪些优化？" class="headerlink" title="JDK 1.6 之后的 synchronized 关键字底层做了哪些优化？"></a>JDK 1.6 之后的 <code>synchronized</code> 关键字底层做了哪些优化？</h2><ul><li>JDK 1.6 对锁的实现引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术</strong>来减少锁操作的开销。</li><li><strong>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul><li>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了<strong>没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而<strong>偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</li><li>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！</li><li>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul><li>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段（1.6 之后加入的）。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为<strong>使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了 CAS 操作</strong>。</li><li>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。<strong>如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生 CAS 操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！</strong>如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁。</li></ul><h3 id="自旋锁与适应性自旋锁"><a href="#自旋锁与适应性自旋锁" class="headerlink" title="自旋锁与适应性自旋锁"></a>自旋锁与适应性自旋锁</h3><ul><li>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</li><li>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</li><li><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</li><li>自旋锁在 JDK 1.6 之前其实就已经引入了，不过是默认关闭的，需要通过 <code>--XX:+UseSpinning</code> 参数来开启。JDK 1.6 及 1.6 之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是 10 次，用户可以修改 <code>--XX:PreBlockSpin</code> 来更改</strong>。</li><li>另外，<strong>在 JDK 1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul><li>锁消除理解起来很简单，它指的就是虚拟机<strong>即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除</strong>。锁消除可以节省毫无意义的请求锁的时间。</li></ul><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul><li>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，—直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</li><li>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</li></ul><h2 id="Synchronized-和-ReenTrantLock-的对比"><a href="#Synchronized-和-ReenTrantLock-的对比" class="headerlink" title="Synchronized 和 ReenTrantLock 的对比"></a><code>Synchronized</code> 和 <code>ReenTrantLock</code> 的对比</h2><ol><li><strong>两者都是可重入锁：</strong><ul><li>“可重入锁”概念是：自己可以再次获取自己的内部锁。</li><li>比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</li></ul></li><li><strong><code>synchronized</code> 依赖于 JVM 而 <code>ReentrantLock</code> 依赖于 API：</strong><ul><li><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK 1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</li><li><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li></ul></li><li><strong><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：</strong><ol><li><strong>等待可中断：</strong><ul><li><code>ReentrantLock</code> 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。</li><li>也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li></ul></li><li><strong>可实现公平锁：</strong><ul><li><code>ReentrantLock</code> 可以指定是公平锁还是非公平锁。而 <code>synchronized</code> 只能是非公平锁。</li><li>所谓的公平锁就是先等待的线程先获得锁。</li><li><code>ReentrantLock</code> 默认是非公平的，可以通过 <code>ReentrantLock</code> 类的 <code>ReentrantLock(boolean fair)</code> 构造方法来指定是否公平。</li></ul></li><li><strong>可实现选择性通知（锁可以绑定多个条件）：</strong><ul><li><code>synchronized</code> 关键字与 <code>wait()</code> 和 <code>notify()/notifyAll()</code> 方法相结合可以实现等待/通知机制，<code>ReentrantLock</code> 类当然也可以实现，但是需要借助于 <code>Condition</code> 接口与 <code>newCondition()</code> 方法。</li><li><code>Condition</code> 是 JDK 1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能，也就是在一个 <code>Lock</code> 对象中可以创建多个 <code>Condition</code> 实例（即对象监视器），线程对象可以注册在指定的 <code>Condition</code> 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 </li><li>在使用 <code>notify()/notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 选择的，用 <code>ReentrantLock</code> 类结合 <code>Condition</code> 实例可以实现“选择性通知” ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。</li><li>而 <code>synchronized</code> 关键字就相当于整个 <code>Lock</code> 对象中只有一个 <code>Condition</code> 实例，所有的线程都注册在它一个身上。如果执行 <code>notifyAll()</code> 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 <code>Condition</code> 实例的 <code>signalAll()</code> 方法只会唤醒注册在该 <code>Condition</code> 实例中的所有等待线程。</li></ul></li></ol></li><li>性能已不是选择标准。</li></ol><h1 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h1><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><ul><li>在 JDK 1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。</li><li>而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。</li><li>这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/数据不一致.png" alt></p><ul><li>要解决这个问题，就需要把变量声明为 <strong><code>volatile</code></strong>，这就指示 JVM，<strong>这个变量是不稳定的，每次使用它都到主存中进行读取</strong>。</li><li>说白了， <strong><code>volatile</code></strong> 关键字的主要作用就是<strong>保证变量的可见性</strong>，然后还有一个作用是<strong>防止指令重排序</strong>。</li></ul><h2 id="并发编程的-3-个重要特性"><a href="#并发编程的-3-个重要特性" class="headerlink" title="并发编程的 3 个重要特性"></a>并发编程的 3 个重要特性</h2><ol><li><strong>原子性：</strong>一个操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性：</strong>当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性：</strong>代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h2 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a><code>synchronized</code> 和 <code>volatile</code> 的区别</h2><ul><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code> 性能肯定比 <code>synchronized</code> 要好</strong>。（<code>synchronized</code> 关键字在 Java SE 1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 <code>synchronized</code> 关键字的场景还是更多一些</strong>。）</li><li><strong><code>volatile</code> 关键字只能用于变量，而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong>。</li><li><strong>多线程访问 <code>volatile</code> 关键字不会发生阻塞，而 <code>synchronized</code> 关键字可能会发生阻塞</strong>。</li><li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证</strong>。</li><li><strong><code>volatile</code> 关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性</strong>。</li></ul><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h1><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a><code>ThreadLocal</code> 简介</h2><ul><li>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的 <code>ThreadLocal</code> 类正是为了解决这样的问题。</li><li><code>ThreadLocal</code> 类主要解决的就是让每个线程绑定自己的值，可以将 <code>ThreadLocal</code> 类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</li><li>如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 <code>ThreadLocal</code> 变量名的由来。</li><li>可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</li></ul><h2 id="ThreadLocal-示例"><a href="#ThreadLocal-示例" class="headerlink" title="ThreadLocal 示例"></a><code>ThreadLocal</code> 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name = "</span> + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">" default Formatter = "</span> + formatter.get().toPattern());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name = "</span> + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">" formatter = "</span> + formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample example = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(example, i + <span class="string">""</span>);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread Name = <span class="number">0</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">0</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">1</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">2</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">1</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">2</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">3</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">3</span> formatter = y/M/d ah:mm</span><br><span class="line">Thread Name = <span class="number">4</span> <span class="keyword">default</span> Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name = <span class="number">4</span> formatter = y/M/d ah:mm</span><br></pre></td></tr></table></figure><ul><li>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</li><li>创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java 8 的知识，使用一个新的方法 <code>withInitial()</code>，将 <code>Supplier</code> 功能接口作为参数。</li></ul><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a><code>ThreadLocal</code> 原理</h2><ul><li>从 <code>Thread</code> 类源代码入手：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与此线程有关的ThreadLocal值。该map由ThreadLocal类维护。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与此线程有关的InheritableThreadLocal值。该map由InheritableThreadLocal类维护。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从上面 <code>Thread</code> 类源码可以看出 <code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量，可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。</li><li>默认情况下这两个变量都是 <code>null</code>，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code> 或 <code>get</code> 方法时才创建它们，实际上调用这两个方法的时候，我们调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code>、<code>set()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面这些内容，我们足以得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code> 的封装，传递了变量值</strong>。</li><li><code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code> 可以访问到该线程的 <code>ThreadLocalMap</code> 对象。</li><li><strong>每个 <code>Thread</code> 中都具备一个 <code>ThreadLocalMap</code>，而 <code>ThreadLocalMap</code> 可以存储以 <code>ThreadLocal</code> 为 key ，<code>Object</code> 对象为 value 的键值对</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>比如，在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code> 内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code> 的 key 就是 <code>ThreadLocal</code> 对象，value 就是 <code>ThreadLocal</code> 对象调用 <code>set</code> 方法设置的值。</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/ThreadLocal数据结构.jpg" alt="ThreadLocal数据结构"></p><ul><li><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类。</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/ThreadLocal内部类.png" alt="ThreadLocal内部类"></p><h2 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a><code>ThreadLocal</code> 内存泄露问题</h2><ul><li><strong><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用</strong>。</li><li>所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 <code>null</code> 的 <code>Entry</code>。</li><li>假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</li><li><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 <code>null</code> 的记录。使用完 <code>ThreadLocal</code> 方法后，最好手动调用 <code>remove()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>弱引用介绍：<ul><li>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</li><li>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li><li>弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li></ul></li></ul><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><ul><li><strong>池化技术</strong>相比大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</li><li><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</li><li><strong>使用线程池的好处：</strong><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul></li></ul><h2 id="实现-Runnable-和-Callable-接口的区别"><a href="#实现-Runnable-和-Callable-接口的区别" class="headerlink" title="实现 Runnable 和 Callable 接口的区别"></a>实现 <code>Runnable</code> 和 <code>Callable</code> 接口的区别</h2><ul><li><code>Runnable</code> 自 Java 1.0 以来一直存在，但 <code>Callable</code> 仅在 Java 1.5 中引入，目的就是为了来处理 <code>Runnable</code> 不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</li><li><strong>工具类 <code>Executors</code></strong> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。使用 <code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被线程执行，没有返回值，也无法抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行-execute-和-submit-方法的区别"><a href="#执行-execute-和-submit-方法的区别" class="headerlink" title="执行 execute() 和 submit() 方法的区别"></a>执行 <code>execute()</code> 和 <code>submit()</code> 方法的区别</h2><ol><li><strong><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</strong>；</li><li><strong><code>submit()</code> 方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout, TimeUnit unit)</code> 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h2><ol><li><strong>通过 <code>ThreadPoolExecutor</code> 构造方法实现：</strong><ul><li>在 <code>ThreadPoolExecutor</code> 类中提供了四个构造方法：<img src="/2020/05/28/javase-sumary-multithreading/ThreadPoolExecutor构造方法.png" alt="ThreadPoolExecutor构造方法"></li><li>解释下一下构造器中各个参数的含义:<ul><li><strong><code>corePoolSize</code>：核心池的大小</strong>。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 <code>prestartAllCoreThreads()</code> 或者 <code>prestartCoreThread()</code> 方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 <code>corePoolSize</code> 个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 <code>corePoolSize</code> 后，就会把到达的任务放到缓存队列当中。</li><li><strong><code>maximumPoolSize</code>：线程池最大线程数</strong>，表示在线程池中最多能创建多少个线程。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>keepAliveTime</code>：表示线程没有任务执行时最多保持多久时间会终止</strong>。默认情况下，只有当线程池中的线程数大于 <code>corePoolSize</code> 时，<code>keepAliveTime</code> 才会起作用，直到线程池中的线程数不大于 <code>corePoolSize</code>，即当线程池中的线程数大于 <code>corePoolSize</code> 时，如果一个线程空闲的时间达到 <code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过 <code>corePoolSize</code>。但是如果调用了 <code>allowCoreThreadTimeOut(boolean)</code> 方法，在线程池中的线程数不大于 <code>corePoolSize</code> 时，<code>keepAliveTime</code> 参数也会起作用，直到线程池中的线程数为 0。</li><li><strong><code>unit</code>：参数 <code>keepAliveTime</code> 的时间单位</strong>，有 7 种取值，在 <code>TimeUnit</code> 类中有 7 种静态属性：<code>DAYS</code>、<code>HOURS</code>、<code>MINUTES</code>、<code>SECONDS</code>、<code>MILLISECONDS</code>、<code>MICROSECONDS</code>、<code>NANOSECONDS</code>。</li><li><strong><code>workQueue</code>：一个阻塞队列，用来存储等待执行的任务</strong>。一般来说，这里的阻塞队列有以下 4 种选择：<code>ArrayBlockingQueue</code>、<code>PriorityBlockingQueue</code> 、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code>。<code>ArrayBlockingQueue</code> 和 <code>PriorityBlockingQueue</code> 使用较少，一般使用 <code>LinkedBlockingQueue</code> 和 <code>SynchronousQueue</code>。线程池的排队策略与 <code>BlockingQueue</code> 有关。</li><li><strong><code>threadFactory</code>：线程工厂</strong>，主要用来创建新的线程。</li><li><strong><code>handler</code>：表示饱和策略（当线程池达到饱和拒绝处理任务时的策略）</strong>，有以下 4 种取值：<ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出 <code>RejectedExecutionException</code> 异常；</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：直接丢弃任务，但是不抛出异常；</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务（最早未处理的任务），然后重新尝试执行任务（重复此过程）；</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。当最大池被填满时，此策略提供可伸缩队列，会降低对于新任务提交速度，影响程序的整体性能。</li></ul></li></ul></li></ul></li><li><strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现：</strong> <ul><li>可以创建 4 种类型的 <code>ThreadPoolExecutor</code>。<img src="/2020/05/28/javase-sumary-multithreading/Executors创建线程池的几个方法.png" alt="Executors创建线程池的几个方法"></li><li><strong><code>FixedThreadPool</code>：</strong>该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong>方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong>该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong><code>ScheduledThreadPool</code>：</strong>方法返回一个调度型线程池，支持定时及周期性任务执行。</li><li>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<code>Executors</code> 返回线程池对象的弊端如下：<ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ：允许请求的队列长度为 <code>Integer.MAX_VALUE</code>，可能堆积大量的请求，从而导致 OOM（OutOfMemory）。</li><li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ：允许创建的线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li></ul></li></ul></li></ol><h2 id="一个简单的线程池-Demo"><a href="#一个简单的线程池-Demo" class="headerlink" title="一个简单的线程池 Demo"></a>一个简单的线程池 Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">// 通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建Runnable对象</span></span><br><span class="line">            Runnable task = <span class="keyword">new</span> Task();</span><br><span class="line">            <span class="comment">// 执行Runnable</span></span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">09</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">14</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Thu May <span class="number">28</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">19</span> CST <span class="number">2020</span></span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h2 id="线程池的实现原理剖析"><a href="#线程池的实现原理剖析" class="headerlink" title="线程池的实现原理剖析"></a>线程池的实现原理剖析</h2><ul><li>为了搞懂线程池的原理，首先分析一下 <code>execute</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面会涉及到 3 步 操作</span></span><br><span class="line">        <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">        <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">        <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="comment">// 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过下图可以更好的对上面这 3 步做一个展示：</li></ul><p><img src="/2020/05/28/javase-sumary-multithreading/图解线程池实现原理.png" alt="图解线程池实现原理"></p><h1 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a><code>Atomic</code> 原子类</h1><h2 id="认识-Atomic-原子类"><a href="#认识-Atomic-原子类" class="headerlink" title="认识 Atomic 原子类"></a>认识 <code>Atomic</code> 原子类</h2><ul><li>这里 <code>Atomic</code> 是指一个操作是不可中断的。即在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</li><li>所以，所谓原子类，就是具有原子/原子操作特征的类。</li><li>并发包 <code>java.util.concurrent</code> 的原子类都存放在 <code>java.util.concurrent.atomic</code> 下。<img src="/2020/05/28/javase-sumary-multithreading/JUC原子类概览.png" alt="JUC原子类概览"></li><li>JUC 包中的原子类有 4 类：<ol><li>基本类型：使用原子的方式更新基本类型<ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul></li><li>数组类型：使用原子的方式更新数组里的某个元素<ul><li><code>AtomicIntegerArray</code>：整形数组原子类</li><li><code>AtomicLongArray</code>：长整形数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul></li><li>引用类型：<ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li></ul></li><li>对象的属性修改类型：<ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li></ul></li></ol></li></ul><h2 id="AtomicInteger-的使用"><a href="#AtomicInteger-的使用" class="headerlink" title="AtomicInteger 的使用"></a><code>AtomicInteger</code> 的使用</h2><ul><li><code>AtomicInteger</code> 类常用方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">// 获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> <span class="comment">// 获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">// 获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">// 如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> <span class="comment">// 最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><ul><li><code>AtomicInteger</code> 类的使用示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>AtomicInteger</code> 之后，不用对 <code>increment()</code> 方法加锁也可以保证线程安全。</li></ul><h2 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="AtomicInteger 类的原理"></a><code>AtomicInteger</code> 类的原理</h2><ul><li><code>AtomicInteger</code> 线程安全原理简单分析，部分源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>AtomicInteger</code> 类主要利用 CAS + <code>volatile</code> 和 <code>native</code> 方法来保证原子操作，从而避免 synchronized 的高开销</strong>，执行效率大为提升。</li><li>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。<code>UnSafe</code> 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 <code>volatile</code> 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h2><ul><li>AQS 的全称为 <strong><code>AbstractQueuedSynchronizer</code>（抽象队列式同步器）</strong>，这个类在 <code>java.util.concurrent.locks</code> 包下面。</li><li>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</li></ul><h2 id="AQS-原理分析"><a href="#AQS-原理分析" class="headerlink" title="AQS 原理分析"></a>AQS 原理分析</h2><h3 id="AQS-原理概况"><a href="#AQS-原理概况" class="headerlink" title="AQS 原理概况"></a>AQS 原理概况</h3><ul><li>AQS 核心思想是，<strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中</strong>。</li><li><strong>CLH</strong>（Craig, Landin, and Hagersten）队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</li><li>看个 AQS 的原理图：<img src="/2020/05/28/javase-sumary-multithreading/AQS原理图.png" alt="AQS原理图"></li><li>AQS 使用一个 <code>int</code> 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。<strong>AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><ul><li>状态信息通过 <code>protected</code> 类型的 <code>getState</code>，<code>setState</code>，<code>compareAndSetState</code> 进行操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><ul><li><strong>AQS 定义两种资源共享方式：</strong><ul><li><strong>Exclusive（独占）：</strong>只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁。</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。</li></ul></li><li><strong>Share（共享）：</strong>多个线程可同时执行，如 <code>Semaphore</code> / <code>CountDownLatch</code>。</li></ul></li><li><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</li><li>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</li></ul><h3 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h3><ul><li>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：<ol><li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol></li><li>这和以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。<ul><li>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。</li><li>举个很简单的例子假如我们要去一个地方的步骤是：购票 <code>buyTicket()</code> → 安检 <code>securityCheck()</code> → 乘坐某某工具回家 <code>ride()</code> → 到达目的地 <code>arrive()</code>。</li><li>我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了 <code>ride()</code> 方法，其他方法的实现几乎相同。</li><li>我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改  <code>ride()</code> 方法。</li></ul></li><li><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively() <span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>) <span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>) <span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>) <span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>) <span class="comment">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 <code>final</code>，所以无法被其他类使用，只有这几个方法可以被其他类使用。</li><li>以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state + 1</code>。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state = 0</code>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</li><li>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 <code>N</code>（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 <code>countDown()</code> 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即 <code>state = 0</code>），会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</li><li>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 <code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 <code>ReentrantReadWriteLock</code>。</li></ul><h2 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h2><ul><li><strong><code>Semaphore</code>（信号量）- 允许多个线程同时访问：</strong><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>（信号量）可以指定多个线程同时访问某个资源。</li><li><strong><code>CountDownLatch</code>（倒计时器）：</strong><code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常<strong>用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行</strong>。</li><li><strong><code>CyclicBarrier</code>（循环栅栏）：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活</strong>。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> JavaSE面试总结 </category>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> JavaSE面试总结 </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE总结（集合篇）</title>
      <link href="/2020/05/27/javase-sumary-collections.html"/>
      <url>/2020/05/27/javase-sumary-collections.html</url>
      
        <content type="html"><![CDATA[<h1 id="List、Set、Map-的区别"><a href="#List、Set、Map-的区别" class="headerlink" title="List、Set、Map 的区别"></a><code>List</code>、<code>Set</code>、<code>Map</code> 的区别</h1><ul><li><strong><code>List</code>（对付顺序的好帮手）</strong>：<code>List</code> 接口存储一组不唯一（可以有多个元素引用相同的对象）且有序的对象。</li><li><strong><code>Set</code>（注重独一无二的性质）</strong>：不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong><code>Map</code>（用Key来搜索的专家）</strong>：使用键值对存储。<code>Map</code> 会维护与 Key 有关联的 Value。两个 Key 可以引用相同的对象，但 Key 不能重复。Key 和 Value 可以是任何类型。</li></ul><h1 id="ArrayList-与-LinkedList-的区别"><a href="#ArrayList-与-LinkedList-的区别" class="headerlink" title="ArrayList 与 LinkedList 的区别"></a><code>ArrayList</code> 与 <code>LinkedList</code> 的区别</h1><ol><li><strong>底层数据结构</strong>：<ul><li><code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>。</li><li><code>LinkedList</code> 底层使用的是<strong>双向链表</strong>数据结构（JDK 1.6 之前为双向循环链表，JDK 1.7 去掉了循环）。</li></ul></li><li><strong>插入和删除是否受元素位置的影响</strong>：<ul><li><code>ArrayList</code> ：<ul><li>采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</li><li>执行 <code>add(E e)</code> 方法的时候，<code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 <code>O(1)</code>​。</li><li>但是如果要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 <code>O(n-i)</code>。因为在进行上述操作的时候集合中第 <code>i</code> 和第 <code>i</code> 个元素之后的 <code>n-i</code> 个元素都要执行向后/向前移一位的操作。</li></ul></li><li><code>LinkedList</code>：<ul><li>采用链表存储，所以对于 <code>add(E e)</code> 方法的插入和删除元素，时间复杂度不受元素位置的影响，近似 <code>O(1)</code>。</li><li>如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>） 时间复杂度近似为 <code>o(n)</code>，因为需要先移动指针到指定位置再插入。</li></ul></li></ul></li><li><strong>是否支持快速随机访问</strong>：<ul><li><code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。</li><li>快速随机访问就是通过元素的序号快速获取元素对象（对应于<code>get(int index)</code>方法）。</li></ul></li><li><strong>内存空间占用</strong>：<ul><li><code>ArrayList</code> 的空间浪费主要体现在在 <code>List</code> 列表的结尾会预留一定的容量空间。</li><li><code>LinkedList</code> 的空间花费体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul></li><li><strong>是否保证线程安全</strong>：<ul><li><code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全。</li></ul></li></ol><h2 id="补充：RandomAccess-接口"><a href="#补充：RandomAccess-接口" class="headerlink" title="补充：RandomAccess 接口"></a>补充：<code>RandomAccess</code> 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看源码发现，实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，<code>RandomAccess</code> 接口就是一个<strong>标记型接口</strong>，标识<strong>实现这个接口的类具有随机访问功能</strong>。</li><li>在 <code>binarySearch()</code> 方法中，它要判断传入的 <code>list</code> 是否 <code>RamdomAccess</code> 的实例，如果是，调用 <code>indexedBinarySearch()</code> 方法，如果不是，那么调用 <code>iteratorBinarySearch()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？还是和底层数据结构有关！<ul><li><code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 <code>O(1)</code>，所以称为快速随机访问。</li><li>链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 <code>O(n)</code>，所以不支持快速随机访问。</li></ul></li><li><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。<code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</li></ul><h2 id="List-的遍历方式选择"><a href="#List-的遍历方式选择" class="headerlink" title="List 的遍历方式选择"></a><code>List</code> 的遍历方式选择</h2><ul><li>实现了 <code>RandomAccess</code> 接口的 <code>list</code>，优先选择普通 <code>for</code> 循环 ，其次 <code>foreach</code>。</li><li>未实现 <code>RandomAccess</code> 接口的 <code>list</code>，优先选择 <code>iterator</code> 遍历（<code>foreach</code> 遍历底层也是通过 <code>iterator</code> 实现的），大 size 的数据，千万不要使用普通 <code>for</code> 循环。</li></ul><h1 id="ArrayList-取代-Vector-的原因"><a href="#ArrayList-取代-Vector-的原因" class="headerlink" title="ArrayList 取代 Vector 的原因"></a><code>ArrayList</code> 取代 <code>Vector</code> 的原因</h1><ul><li><code>Vector</code> 类的所有方法都是同步的。可以由两个线程安全地访问同一个 <code>Vector</code> 对象，但是仅有一个线程访问 <code>Vector</code> 的话代码要在同步操作上耗费大量的时间。</li><li><code>ArrayList</code> 不是同步的，所以在不需要保证线程安全时建议使用 <code>ArrayList</code>。</li></ul><h1 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a><code>ArrayList</code> 的扩容机制</h1><ul><li><code>ArrayList</code> 有三种方式来初始化，<strong>构造方法</strong>源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享的空数组实例，用于默认大小的空实例。</span></span><br><span class="line"><span class="comment"> * 我们将其与EMPTY_ELEMENTDATA区别开来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储ArrayList元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。</span></span><br><span class="line"><span class="comment"> * 添加第一个元素时，任何 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的ArrayList都将扩容为DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的大小（它包含的元素数）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照指定集合迭代器返回的顺序,构造一个包含该集合所有元素的列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// defend against c.toArray (incorrectly) not returning Object[]</span></span><br><span class="line">        <span class="comment">// (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过源码可以发现：<ul><li>以无参构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。</li><li>当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</li></ul></li><li>再来看看 <strong><code>add</code> 和 <code>addAll</code> 方法</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此辅助方法从add(E)中分离出来，以使方法字节码大小保持在35以下，</span></span><br><span class="line"><span class="comment"> * 在C1编译循环中调用add(E)时会有所帮助。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素插入此列表中的指定位置。</span></span><br><span class="line"><span class="comment"> * 将当前在该位置的元素（如果有的话）和任何后续元素向右移动（将它们的索引添加一个）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合中的所有元素，以集合Iterator返回的顺序，追加到此列表的末尾。</span></span><br><span class="line"><span class="comment"> * 如果在操作过程中修改了指定的集合，则该操作的行为是不确定的。 </span></span><br><span class="line"><span class="comment"> * 这意味着如果指定的集合是此列表，并且此列表是非空的，则此调用的行为是未定义的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定位置开始，将指定集合中的所有元素插入此列表。</span></span><br><span class="line"><span class="comment"> * 将当前位于该位置的元素（如果有）和任何后续元素右移（增加它们的索引）。</span></span><br><span class="line"><span class="comment"> * 新元素将按指定集合的迭代器返回的顺序加入列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = s - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index,</span><br><span class="line">                         elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再来看看 <strong><code>grow</code> 方法</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小（除非必要）。</span></span><br><span class="line"><span class="comment"> * 尝试分配更大的阵列可能会导致OutOfMemoryError：请求的数组大小超出VM限制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量以确保列表至少可以容纳minCapacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再来看看 <strong><code>newCapacity</code> 方法</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回至少等于给定最小容量的容量。 </span></span><br><span class="line"><span class="comment"> * 如果足够，则返回当前容量增加50％的结果。 </span></span><br><span class="line"><span class="comment"> * 除非给定的最小容量大于MAX_ARRAY_SIZE，否则不会返回大于MAX_ARRAY_SIZE的容量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>newCapacity</code> 方法的源码可以看到，<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，所以 <strong><code>ArrayList</code> 扩容之后容量都变为原来的 1.5 倍</strong>。</li><li>再看看 <strong><code>hugeCapacity</code> 方法</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>newCapacity</code> 方法的源码可知：如果新容量大于 <code>MAX_ARRAY_SIZE</code>，执行 <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为 <code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</li><li>从源码中可以发现，<code>ArrayList</code> 中大量调用了 <strong><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code></strong> 这两个方法。看看这两个方法的源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">            ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>/<span class="keyword">short</span>/<span class="keyword">int</span>/<span class="keyword">long</span>/<span class="keyword">char</span>/<span class="keyword">float</span>/<span class="keyword">double</span>/<span class="keyword">boolean</span>[] copyOf(</span><br><span class="line">            <span class="keyword">byte</span>/<span class="keyword">short</span>/<span class="keyword">int</span>/<span class="keyword">long</span>/<span class="keyword">char</span>/<span class="keyword">float</span>/<span class="keyword">double</span>/<span class="keyword">boolean</span>[]original,</span><br><span class="line">            <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">byte</span>/<span class="keyword">short</span>/<span class="keyword">int</span>/<span class="keyword">long</span>/<span class="keyword">char</span>/<span class="keyword">float</span>/<span class="keyword">double</span>/<span class="keyword">boolean</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code> 方法的联系与区别：<ul><li>联系：<code>Arrays.copyOf()</code> 内部实际调用了 <code>System.arraycopy()</code> 方法。</li><li>区别：<code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置。而<code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</li></ul></li><li><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如有必要，增加此ArrayList实例的容量，</span></span><br><span class="line"><span class="comment"> * 以确保它至少可以容纳minCapacity参数指定的元素数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">            &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">                 &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>最好在 <code>add</code> 大量元素之前用 <code>ensureCapacity</code> 方法，以减少容量重新分配的次数。</li></ul><h1 id="HashMap-与-Hashtable-的区别"><a href="#HashMap-与-Hashtable-的区别" class="headerlink" title="HashMap 与 Hashtable 的区别"></a><code>HashMap</code> 与 <code>Hashtable</code> 的区别</h1><ol><li><strong>线程安全</strong>：<ul><li><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的。</li><li><code>HashTable</code> 内部的方法基本都经过 <code>synchronized</code> 修饰。</li><li>如果要保证线程安全的话就使用 <code>ConcurrentHashMap</code>。</li></ul></li><li><strong>效率</strong>：<ul><li>因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。</li><li>另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它。</li></ul></li><li><strong>对 Null key 和 Null value 的支持</strong>：<ul><li><code>HashMap</code> 中，<code>null</code> 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 <code>null</code>。</li><li>但是在 <code>Hashtable</code> 中 <code>put</code> 的键和值只要有一个 <code>null</code>，直接抛出 <code>NullPointerException</code>。</li></ul></li><li><strong>初始容量大小和每次扩充容量大小的不同</strong>：<ol><li>创建时如果不指定容量初始值：<ul><li><code>Hashtable</code> 默认的初始大小为 <code>11</code>，之后每次扩充，容量变为原来的 <code>2n+1</code>。</li><li><code>HashMap</code> 默认的初始化大小为 <code>16</code>。之后每次扩充，容量变为原来的 <code>2倍</code>。</li></ul></li><li>创建时如果给定了容量初始值：<ul><li><code>Hashtable</code> 会直接使用 <code>给定</code> 大小。</li><li><code>HashMap</code> 会将其扩充为 <code>2 的幂次方</code> 大小（例如给定 7，创建容量将换算成 8）。</li></ul></li></ol></li><li><strong>底层数据结构：</strong><ul><li>JDK 1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</strong>。</li><li><code>Hashtable</code> 没有这样的机制。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap-和-HashSet-的区别"><a href="#HashMap-和-HashSet-的区别" class="headerlink" title="HashMap 和 HashSet 的区别"></a><code>HashMap</code> 和 <code>HashSet</code> 的区别</h1><ul><li><strong><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</strong></li><li><code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code> 是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">哈希表类型</th><th style="text-align:left"><code>HashMap</code></th><th><code>HashSet</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>实现接口</strong></td><td style="text-align:left">实现了 <code>Map</code> 接口</td><td>实现 <code>Set</code> 接口</td></tr><tr><td style="text-align:left"><strong>存储内容</strong></td><td style="text-align:left">存储键值对</td><td>仅存储对象</td></tr><tr><td style="text-align:left"><strong>添加元素方式</strong></td><td style="text-align:left">调用 <code>put()</code> 向 <code>Map</code> 中添加元素</td><td>调用 <code>add()</code> 方法向 <code>Set</code> 中添加元素</td></tr><tr><td style="text-align:left"><strong>检查重复方式</strong></td><td style="text-align:left">使用<strong>键对象</strong>来计算 hashcode</td><td>使用<strong>成员对象</strong>来计算 hashcode</td></tr><tr><td style="text-align:left"><strong>性能</strong></td><td style="text-align:left">比较快，因为是使用唯一的键来获取对象</td><td>较 <code>HashMap</code> 来说比较慢</td></tr></tbody></table></div><h1 id="HashSet-如何检查重复元素"><a href="#HashSet-如何检查重复元素" class="headerlink" title="HashSet 如何检查重复元素"></a><code>HashSet</code> 如何检查重复元素</h1><ul><li>把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较。</li><li>如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。</li><li>但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashcode</code> 相等的对象是否真的相同。</li><li>如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</li></ul><h1 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a><code>HashMap</code> 的底层实现</h1><ul><li>JDK 1.8 之前，<code>HashMap</code> 底层是 <strong><code>数组 + 链表</code></strong> 结合在一起使用，也就是<strong>链表散列</strong>。</li><li><code>HashMap</code> 通过 key 的 hashcode 经过扰动函数处理过后得到 hash 值，然后<strong>通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置</strong>（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就<strong>通过拉链法解决冲突</strong>。</li><li>所谓扰动函数指的就是 <code>HashMap</code> 的 <code>hash</code> 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</li><li>JDK 1.8 的 <code>hash</code> 方法 相比于 JDK 1.7 <code>hash</code> 方法更加简化，但是原理不变。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li><li>JDK 1.8 之后，<code>HashMap</code> 在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>，以减少搜索时间（即 JDK 1.8 之后 HashMap 底层采用 <strong><code>数组 + 链表 + 红黑树</code></strong> 实现。</li></ul><p><img src="/2020/05/27/javase-sumary-collections/JDK1.8之后的HashMap底层数据结构.jpg" alt="jdk1.8之后的内部结构-HashMap">)</p><h1 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a><code>HashMap</code> 的长度为什么是 2 的幂次方？</h1><ul><li>为了能让 <code>HashMap</code> 存取高效，尽量较少碰撞，就要尽量把数据分配均匀。</li><li>Hash 值的范围值 -2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</li><li>但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。</li><li>我们首先可能会想到采用 <code>%</code> 取余的操作来实现。但是，<strong>取余（<code>%</code>）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（<code>&amp;</code>）操作，也就是说 <code>hash % length == hash &amp; ( length - 1)</code> 的前提是 length 是 2 的 n 次方。</strong> 并且<strong>采用二进制位操作 <code>&amp;</code>，相对于 <code>%</code> 能够提高运算效率</strong>。</li><li>因此这个算法设计的数组下标计算方法是 <code>(n - 1) &amp; hash</code>（n 代表数组长度）。这也就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方。</li></ul><h1 id="HashMap-多线程操作导致死循环的问题"><a href="#HashMap-多线程操作导致死循环的问题" class="headerlink" title="HashMap 多线程操作导致死循环的问题"></a><code>HashMap</code> 多线程操作导致死循环的问题</h1><ul><li>主要原因在于并发下的 <code>Rehash</code> 会造成元素之间会形成一个循环链表。不过，JDK 1.8 后解决了这个问题。</li><li>但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在其他问题比如数据丢失。并发环境下推荐使用 <code>ConcurrentHashMap</code> 。</li><li>JDK 1.8 之前 <code>HashMap</code> 多线程操作导致死循环的具体分析见 <a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">Java HashMap的死循环</a>。</li></ul><h1 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别</h1><ul><li><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在<strong>实现线程安全的方式上的不同</strong>。<ul><li><strong>底层数据结构</strong>：<ul><li><code>ConcurrentHashMap</code>：<ul><li>JDK 1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong><code>分段的数组 + 链表</code></strong> 实现。</li><li>JDK 1.8 采用的数据结构跟 <code>HashMap</code> 1.8 的结构一样，<strong><code>数组 + 链表 / 红黑二叉树</code></strong>。</li></ul></li><li><code>Hashtable</code>：<ul><li><code>Hashtable</code> 和 JDK 1.8 之前的 <code>HashMap</code> 的底层数据结构类似，都是采用 <strong><code>数组 + 链表</code></strong> 的形式。</li><li>数组是主体，链表则是主要为了解决哈希冲突而存在的。</li></ul></li></ul></li><li><strong>实现线程安全的方式</strong>：<ul><li><code>ConcurrentHashMap</code>：<ul><li><strong>在 JDK 1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段（<code>Segment</code>），每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li><strong>到了 JDK 1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node[]数组 + 链表 + 红黑树</code> 的数据结构来实现，并发控制使用 <code>synchronized</code> 和 <code>CAS</code> 来操作</strong>。</li><li><code>CAS</code>（Compare And Swap）是一种乐观锁的实现，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li><li><code>ConcurrentHashMap</code> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK 1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。</li></ul></li><li><strong><code>Hashtable</code>（同一把锁）</strong>：<ul><li><strong>使用 <code>synchronized</code> 来保证线程安全</strong>，效率非常低下。</li><li>当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态。</li><li>如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。</li></ul></li></ul></li></ul></li><li><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的对比图：<ul><li><code>Hashtable</code>：<img src="/2020/05/27/javase-sumary-collections/HashTable全表锁.png" alt></li><li>JDK 1.7 的 <code>ConcurrentHashMap</code>：<img src="/2020/05/27/javase-sumary-collections/ConcurrentHashMap分段锁.jpg" alt></li><li>JDK 1.8 的 <code>ConcurrentHashMap</code>（TreeBin 表示红黑二叉树节点，Node 表示链表节点）：<img src="/2020/05/27/javase-sumary-collections/JDK1.8-ConcurrentHashMap-Structure.jpg" alt></li></ul></li></ul><h1 id="ConcurrentHashMap-线程安全的具体实现方式"><a href="#ConcurrentHashMap-线程安全的具体实现方式" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式"></a><code>ConcurrentHashMap</code> 线程安全的具体实现方式</h1><h2 id="JDK-1-7-阶段的-ConcurrentHashMap"><a href="#JDK-1-7-阶段的-ConcurrentHashMap" class="headerlink" title="JDK 1.7 阶段的 ConcurrentHashMap"></a>JDK 1.7 阶段的 <code>ConcurrentHashMap</code></h2><ul><li>JDK 1.7 中的 <code>ConcurrentHashMap</code> 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li><li><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</li><li><code>Segment</code> 实现了 <code>ReentrantLock</code>，所以 <code>Segment</code> 是一种<strong>可重入锁</strong>，扮演锁的角色，<code>HashEntry</code> 用于存储键值对数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，<strong>每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁</strong>。</li></ul><h2 id="JDK-1-8-阶段的-ConcurrentHashMap"><a href="#JDK-1-8-阶段的-ConcurrentHashMap" class="headerlink" title="JDK 1.8 阶段的 ConcurrentHashMap"></a>JDK 1.8 阶段的 <code>ConcurrentHashMap</code></h2><ul><li>JDK 1.8 中的 <code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <strong><code>CAS</code> 和 <code>synchronized</code></strong> 来保证并发安全。</li><li>数据结构跟 <code>HashMap</code> 1.8 的结构类似，<code>数组 + 链表 / 红黑二叉树</code>。<strong>Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 <code>O(N)</code>）转换为红黑树（寻址时间复杂度为 <code>O(log(N))</code>）</strong>。</li><li><strong><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍</strong>。</li></ul><h1 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a><code>Comparable</code> 和 <code>Comparator</code> 的区别</h1><ul><li><code>Comparable</code> 接口出自 <code>java.lang</code> 包，它<strong>只有</strong>一个 <code>compareTo(T o)</code> 方法用来排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Comparator</code> 接口出自 <code>java.util</code> 包，它<strong>包含</strong>一个 <code>compare(T o1, T o2)</code> 方法用来排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一般需要对一个集合使用自定义排序时，就要重写 <code>compareTo()</code> 方法或 <code>compare()</code> 方法。</li><li>当需要对某一个集合实现两种排序方式，可以重写 <code>compareTo()</code> 方法和使用自制的 <code>Comparator</code> 的方法，或者以两个 <code>Comparator</code> 来实现两种排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>。</li></ul><h2 id="Comparator-比较器定制排序"><a href="#Comparator-比较器定制排序" class="headerlink" title="Comparator 比较器定制排序"></a><code>Comparator</code> 比较器定制排序</h2><ul><li><code>Comparator</code> ：相当于找一个第三方的裁判，比较两个对象。</li><li><code>Comparator</code> 强行对某个对象进行整体排序。可以将 <code>Comparator</code> 传递给 <code>sort()</code> 方法（如 <code>Collections.sort()</code> 和 <code>Arrays.sort()</code>），从而允许在排序顺序上实现精确控制。</li><li>还可以使用 <code>Comparator</code> 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(-<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(-<span class="number">5</span>);</span><br><span class="line">        arrayList.add(<span class="number">7</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(-<span class="number">9</span>);</span><br><span class="line">        arrayList.add(-<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">        Collections.sort(arrayList);</span><br><span class="line">        System.out.println(<span class="string">"Collections.sort(arrayList):"</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定制排序的用法</span></span><br><span class="line">        Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"定制排序后："</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[-<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">9</span>, -<span class="number">7</span>]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-<span class="number">9</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">定制排序后：</span><br><span class="line">[<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h2 id="要排序的类型实现-Comparable-接口"><a href="#要排序的类型实现-Comparable-接口" class="headerlink" title="要排序的类型实现 Comparable 接口"></a>要排序的类型实现 <code>Comparable</code> 接口</h2><ul><li><code>Comparable</code> ：自己（this）和别人（参数）比较，自己需要实现 <code>Comparable</code> 接口，重写比较的规则 <code>compareTo()</code> 方法.</li><li><code>Comparable</code> 强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 <code>compareTo()</code> 方法被称为它的自然比较方法。只能在类中实现 <code>compareTo()</code> 一次，不能经常修改类的代码实现自己想要的排序。</li><li>实现此接口的对象列表（和数组）可以通过 <code>Collections.sort()</code> 和 <code>Arrays.sort()</code> 进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge() - o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>), <span class="string">"zhangsan"</span>);</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>), <span class="string">"lisi"</span>);</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">10</span>), <span class="string">"wangwu"</span>);</span><br><span class="line">        pdata.put(<span class="keyword">new</span> Person(<span class="string">"小红"</span>, <span class="number">5</span>), <span class="string">"xiaohong"</span>);</span><br><span class="line">        <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">        Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">            System.out.println(key.getAge() + <span class="string">"-"</span> + key.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>-小红</span><br><span class="line"><span class="number">10</span>-王五</span><br><span class="line"><span class="number">20</span>-李四</span><br><span class="line"><span class="number">30</span>-张三</span><br></pre></td></tr></table></figure><h1 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a><code>Collection</code></h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><ul><li><strong><code>ArrayList</code></strong>： <code>Object</code> 数组</li><li><strong><code>Vector</code></strong>：<code>Object</code> 数组</li><li><strong><code>LinkedList</code></strong>：双向链表（JDK 1.6 之前为循环链表，JDK 1.7 取消了循环）</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><ul><li><strong><code>HashSet</code>（无序，唯一）</strong>：基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><strong><code>LinkedHashSet</code></strong>：<code>LinkedHashSet</code> 继承于 <code>HashSet</code>，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的。</li><li><strong><code>TreeSet</code>（有序，唯一）</strong>：红黑树（自平衡的排序二叉树）</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><ul><li><strong><code>HashMap</code></strong>：JDK 1.8之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK 1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</li><li><strong><code>LinkedHashMap</code></strong>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><strong><code>Hashtable</code></strong>：数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong><code>TreeMap</code></strong>：红黑树（自平衡的排序二叉树）</li></ul><h1 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h1><ul><li>主要根据集合的特点来选用，然后再根据实现这些接口的集合的特点来选用。<ul><li>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>，不需要排序时就选择 <code>HashMap</code>，需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li><li>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合，比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的，比如 <code>ArrayList</code> 或 <code>LinkedList</code>。</li></ul></li></ul><h1 id="Arrays-asList-的使用"><a href="#Arrays-asList-的使用" class="headerlink" title="Arrays.asList() 的使用"></a><code>Arrays.asList()</code> 的使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>Arrays.asList()</code> ：将一个数组转换为一个 <code>List</code> 集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回由指定数组支持的固定大小的列表。</span></span><br><span class="line"><span class="comment">     * 此方法与Collection.toArray结合使用，充当基于数组和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     * 返回的列表是可序列化的，并且实现了RandomAccess。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">        ArrayList(E[] array) &#123;</span><br><span class="line">            a = Objects.requireNonNull(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Arrays.asList()</code> 将数组转换为集合后，<strong>底层其实还是数组</strong>。</li></ul><h2 id="《阿里巴巴-Java-开发手册》对其的描述"><a href="#《阿里巴巴-Java-开发手册》对其的描述" class="headerlink" title="《阿里巴巴 Java 开发手册》对其的描述"></a>《阿里巴巴 Java 开发手册》对其的描述</h2><ul><li>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，<strong>不能使用其修改集合相关的方法</strong>，它的 add / remove / clear 方法会抛出 <code>UnsupportedOperationException</code> 异常。</li><li><code>Arrays.asList()</code> 的<strong>返回对象是一个 <code>Arrays</code> 内部类</strong>，并没有实现集合的修改方法。<code>Arrays.asList()</code> 体现的是<strong>适配器模式</strong>，只是转换接口，后台的数据仍是数组。</li></ul><h2 id="使用时的注意事项"><a href="#使用时的注意事项" class="headerlink" title="使用时的注意事项"></a>使用时的注意事项</h2><h3 id="传递的数组必须是对象数组，而不是基本类型"><a href="#传递的数组必须是对象数组，而不是基本类型" class="headerlink" title="传递的数组必须是对象数组，而不是基本类型"></a>传递的数组必须是对象数组，而不是基本类型</h3><ul><li><code>Arrays.asList()</code> 是<strong>泛型方法</strong>，传入的对象必须是对象数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list1 = Arrays.asList(arr1);</span><br><span class="line">        System.out.println(list1); <span class="comment">// [[I@58ceff1]</span></span><br><span class="line"></span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br><span class="line">        System.out.println(list2); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当传入一个基本数据类型数组时，<code>Arrays.asList()</code> 真正得到的参数就不是数组中的元素，而是数组对象本身！此时 <code>List</code> 的唯一元素就是这个数组，这也就解释了上面的代码。</li><li>使用包装类型数组就可以解决这个问题。</li></ul><h3 id="使用集合的修改方法-add-、remove-、clear-会抛出异常"><a href="#使用集合的修改方法-add-、remove-、clear-会抛出异常" class="headerlink" title="使用集合的修改方法 add()、remove()、clear() 会抛出异常"></a>使用集合的修改方法 <code>add()</code>、<code>remove()</code>、<code>clear()</code> 会抛出异常</h3><ul><li><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code>，而是 <code>java.util.Arrays</code> 的一个内部类，这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</li><li>看一下这个内部类的源码中实现了哪些方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再看一下 <code>java.util.AbstractList</code> 的 <code>add()</code>、<code>remove()</code>、<code>clear()</code> 方法，为什么会抛出 <code>UnsupportedOperationException</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(size(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        removeRange(<span class="number">0</span>, size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何正确地将数组转换为-ArrayList？"><a href="#如何正确地将数组转换为-ArrayList？" class="headerlink" title="如何正确地将数组转换为 ArrayList？"></a>如何正确地将数组转换为 <code>ArrayList</code>？</h2><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最简便的方法"><a href="#最简便的方法" class="headerlink" title="最简便的方法"></a>最简便的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure><h3 id="使用-Java-8-的-Stream"><a href="#使用-Java-8-的-Stream" class="headerlink" title="使用 Java 8 的 Stream"></a>使用 Java 8 的 <code>Stream</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List myList1 = Arrays.stream(myArray1).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span>[] myArray2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List myList2 = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="使用-Guava"><a href="#使用-Guava" class="headerlink" title="使用 Guava"></a>使用 Guava</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于不可变集合，可以使用ImmutableList类及其of()与copyOf()工厂方法</span></span><br><span class="line">List&lt;String&gt; il1 = ImmutableList.of(<span class="string">"string"</span>, <span class="string">"elements"</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il2 = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于可变集合，你可以使用Lists类及其newArrayList()工厂方法</span></span><br><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">"or"</span>, <span class="string">"string"</span>, <span class="string">"elements"</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure><h3 id="使用-Apache-Commons-Collections"><a href="#使用-Apache-Commons-Collections" class="headerlink" title="使用 Apache Commons Collections"></a>使用 Apache Commons Collections</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure><h1 id="如何反转数组：Collection-toArray-的使用"><a href="#如何反转数组：Collection-toArray-的使用" class="headerlink" title="如何反转数组：Collection.toArray() 的使用"></a>如何反转数组：<code>Collection.toArray()</code> 的使用</h1><ul><li>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 。</li><li>如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code> 类型数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> String[]&#123;<span class="string">"dog"</span>, <span class="string">"lazy"</span>, <span class="string">"brown"</span>, <span class="string">"quick"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s = list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]); <span class="comment">// 没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure><ul><li>由于 JVM 优化，<code>new String[0]</code> 作为 <code>Collection.toArray()</code> 方法的参数现在使用更好，<code>new String[0]</code> 就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。</li></ul><h1 id="不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove / add 操作"></a>不要在 foreach 循环里进行元素的 <code>remove</code> / <code>add</code> 操作</h1><ul><li><strong>不要在 foreach 循环里进行元素的 <code>remove</code> / <code>add</code> 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁</strong>。</li><li>如果要进行 <code>remove</code> 操作，可以调用迭代器的 <code>remove</code> 方法而不是集合类的 <code>remove</code> 方法。</li><li>因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身的 <code>remove</code> / <code>add</code> 方法，迭代器都将抛出一个 <code>ConcurrentModificationException</code>，这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</li><li><strong>fail-fast 机制</strong>：多个线程对 fail-fast 集合进行修改时，可能会抛出 <code>ConcurrentModificationException</code>，单线程下也会出现这种情况。</li><li><code>java.util</code> 包下面的所有的集合类都是 fail-fast 的，而 <code>java.util.concurrent</code> 包下面的所有的类都是 fail-safe 的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String s = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(s)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> JavaSE面试总结 </category>
          
          <category> Java集合篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> JavaSE面试总结 </tag>
            
            <tag> Java集合篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE总结（基础篇）</title>
      <link href="/2020/05/22/javase-sumary-fundamentals.html"/>
      <url>/2020/05/22/javase-sumary-fundamentals.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-基本功"><a href="#Java-基本功" class="headerlink" title="Java 基本功"></a>Java 基本功</h1><h2 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h2><h3 id="Java-语言的特点"><a href="#Java-语言的特点" class="headerlink" title="Java 语言的特点"></a>Java 语言的特点</h3><ol><li>简单易学，有丰富的类库；</li><li>面向对象（封装、继承、多态，让程序低耦合、高内聚）；</li><li>平台无关性（JVM 是实现跨平台的根本）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程；</li><li>支持网络编程并且很方便（Java 语言诞生就是为简化网络编程设计的）；</li><li>编译与解释并存。</li></ol><h3 id="JVM、JDK-与-JRE-的概念"><a href="#JVM、JDK-与-JRE-的概念" class="headerlink" title="JVM、JDK 与 JRE 的概念"></a>JVM、JDK 与 JRE 的概念</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li><strong>JVM</strong>（Java Virtual Machine，Java 虚拟机）：<ul><li>JVM 是运行 Java 字节码的虚拟机器。</li><li>JVM 有针对不同系统的特定实现（Windows、Linux、macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li></ul></li><li><strong>什么是字节码？采用字节码的好处是什么？</strong><ul><li>JVM 可以理解的代码就叫做 <code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</li><li>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行（<strong>一次编译，随处可以运行</strong>）。</li></ul></li><li>Java 程序从源代码到运行的过程如下：<ul><li><img src="/2020/05/22/javase-sumary-fundamentals/Java程序运行过程.png" alt="Java程序运行过程"></li><li>在字节码转换为机器码的过程中，JVM 类加载器首先加载字节码文件，然后通过解释器（Interpreter）逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码，Hot Spot Code），所以后面引进了 JIT 编译器（Just-In-Time Compiler，即时编译器）， JIT 属于运行时编译。</li></ul></li><li><strong>JIT 编译器</strong>：<ul><li>当 JVM 发现某个方法或代码块运行特别频繁时，就会把这些代码认定为<strong>热点代码</strong>，然后 JVM 会把这些代码交给 JIT 编译器编译成与本地平台相关的机器码，并进行各种层次的优化。当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。而机器码的运行效率肯定是高于 Java 解释器的。这也解释了为什么经常会说 Java 是编译与解释共存的语言。</li><li>HotSpot 采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT（Ahead of Time Compilation），它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</li></ul></li></ul><h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><ul><li><strong>JDK</strong>：是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</li><li><strong>JRE</strong>：是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</li></ul><h3 id="Java-和-C-的比较"><a href="#Java-和-C-的比较" class="headerlink" title="Java 和 C++ 的比较"></a>Java 和 C++ 的比较</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态。</li><li>Java 不提供指针来直接访问内存，程序内存更加安全。</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存。</li><li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong></li></ul><h3 id="import-java-和-javax-的区别"><a href="#import-java-和-javax-的区别" class="headerlink" title="import java 和 javax 的区别"></a>import java 和 javax 的区别</h3><ul><li>刚开始的时候 Java API 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。</li><li>但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 <strong>javax 包将成为标准 API 的一部分</strong>。</li><li>所以，实际上 java 和 javax 没有区别。这都是一个名字。</li></ul><h3 id="为什么说-Java-语言解释与编译共存"><a href="#为什么说-Java-语言解释与编译共存" class="headerlink" title="为什么说 Java 语言解释与编译共存"></a>为什么说 Java 语言解释与编译共存</h3><ul><li>高级编程语言按照程序的执行方式分为编译型和解释型两种。</li><li>简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</li><li>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，<strong>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行</strong>。因此，我们可以认为 Java 语言编译与解释并存。</li></ul><h2 id="Java-语法"><a href="#Java-语法" class="headerlink" title="Java 语法"></a>Java 语法</h2><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><ol><li><strong>形式上</strong>：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符。</li><li><strong>含义上</strong>：字符常量相当于一个整型值（ASCII 值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）。</li><li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节 （<strong>注意： <code>char</code> 在 Java 中占 2 个字节</strong>）</li></ol><h3 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h3><ul><li>Java 中的注释有三种：<ol><li>单行注释</li><li>多行注释</li><li>文档注释</li></ol></li><li>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。</li><li>注释并不会执行，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</li><li>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</li></ul><h3 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h3><ul><li>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符。简单来说，<strong>标识符就是一个名字</strong>。</li><li>但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，<strong>关键字是被赋予特殊含义的标识符</strong>。</li></ul><h3 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h3><ul><li><strong>标识符</strong>：是指在程序中，我们自己定义的内容，比如类的名字、方法的名字和变量的名字等等。</li><li><strong>命名规则：<code>硬性要求</code></strong><ul><li>标识符可以包含 <code>英文字母26个（区分大小写）</code> 、 <code>0-9数字</code> 、 <code>$（美元符号）</code> 和 <code>_（下划线）</code></li><li>标识符不能以数字开头</li><li>标识符不能是关键字</li></ul></li><li><strong>命名规范：<code>软性建议</code></strong><ul><li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</li><li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</li><li>变量名规范：同方法名。</li></ul></li></ul><h3 id="连等类赋值运算符的特殊使用"><a href="#连等类赋值运算符的特殊使用" class="headerlink" title="连等类赋值运算符的特殊使用"></a>连等类赋值运算符的特殊使用</h3><ul><li><code>byte</code> / <code>short</code> / <code>char</code> 这三种类型都可以发生数学运算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b = a + b; // 编译错误，无法自动将 int 类型的数值转换为 byte 类型</span></span><br><span class="line">b += a; <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><ul><li>在运算的时候，<code>byte</code> / <code>short</code> / <code>char</code> 都会被<strong>首先提升成为 <code>int</code> 类型</strong>，然后再计算。</li><li>计算完之后，结果类型就是 <code>int</code> 类型，不会自动转换为之前的数据类型。因此使用普通赋值运算符会报错。</li><li>而<strong>连等类赋值运算会将右边表达式的运算结果强制转换匹配左边的数据类型</strong>。</li></ul><h3 id="Java-中常见的关键字"><a href="#Java-中常见的关键字" class="headerlink" title="Java 中常见的关键字"></a>Java 中常见的关键字</h3><div class="table-container"><table><thead><tr><th>功能</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td><code>private</code></td><td><code>protected</code></td><td><code>public</code></td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td><code>abstract</code></td><td><code>class</code></td><td><code>extends</code></td><td><code>final</code></td><td><code>implements</code></td><td><code>interface</code></td><td><code>native</code></td></tr><tr><td></td><td><code>new</code></td><td><code>static</code></td><td><code>strictfp</code></td><td><code>synchronized</code></td><td><code>transient</code></td><td><code>volatile</code></td><td></td></tr><tr><td>程序控制</td><td><code>break</code></td><td><code>continue</code></td><td><code>return</code></td><td><code>do</code></td><td><code>while</code></td><td><code>if</code></td><td><code>else</code></td></tr><tr><td></td><td><code>for</code></td><td><code>instanceof</code></td><td><code>switch</code></td><td><code>case</code></td><td><code>default</code></td><td></td><td></td></tr><tr><td>错误处理</td><td><code>try</code></td><td><code>catch</code></td><td><code>throw</code></td><td><code>throws</code></td><td><code>finally</code></td><td></td><td></td></tr><tr><td>包相关</td><td><code>import</code></td><td><code>package</code></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td><code>boolean</code></td><td><code>byte</code></td><td><code>char</code></td><td><code>double</code></td><td><code>float</code></td><td><code>int</code></td><td><code>long</code></td></tr><tr><td></td><td><code>short</code></td><td><code>null</code></td><td><code>true</code></td><td><code>false</code></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td><code>super</code></td><td><code>this</code></td><td><code>void</code></td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td><code>goto</code></td><td><code>const</code></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h3 id="continue、break、和-return-的区别是什么？"><a href="#continue、break、和-return-的区别是什么？" class="headerlink" title="continue、break、和 return 的区别是什么？"></a><code>continue</code>、<code>break</code>、和 <code>return</code> 的区别是什么？</h3><ul><li>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：<ol><li><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li></ol></li><li><code>return</code> 用于跳出所在方法，结束该方法的运行。<code>return</code> 一般有两种用法：<ol><li><code>return;</code> ：直接使用 <code>return</code> 结束方法执行，用于没有返回值函数的方法。</li><li><code>return value;</code> ：<code>return</code> 一个特定值，用于有返回值函数的方法。</li></ol></li></ul><h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><ul><li>什么是<strong>泛型</strong>？<ul><li>泛型是 Java SE 5 之后的特性。顾名思义，泛指的类型。</li><li>泛型保证可以在类或方法中预支地使用未知的类型。</li><li><strong>泛型意味着编写的代码可以被不同类型的对象所重用。</strong></li><li>泛型提供了<strong>编译时类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。</li><li>泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</li></ul></li><li>泛型的使用：<ul><li>泛型提供了泛指的概念，<strong>具体执行的时候使用具体的规则来约束</strong>。</li><li>泛型<strong>将数据类型作为参数进行传递</strong>。</li><li>含有泛型的<strong>类</strong>：在创建对象时确定泛型。</li><li>含有泛型的<strong>方法</strong>：在调用方法时确定泛型。</li><li>含有泛型的<strong>接口</strong>：<ol><li>在实现类时确定泛型。</li><li>始终不确定泛型直到创建实现类对象时确定泛型。</li></ol></li><li><strong>泛型方法的使用</strong>：在调用泛型方法时，可以指定泛型，也可以不指定泛型。<ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到<code>Object</code>。</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类。</li><li>注意：在泛型方法中使用的 <code>T</code> 是自己在方法中定义的 <code>T</code>，而不是泛型类中的 <code>T</code>。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是一个简单的泛型方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不指定泛型的时候</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 这两个参数都是Integer，所以T为Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> i = Test.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number</span></span><br><span class="line">        Number f = Test.add(<span class="number">1</span>, <span class="number">1.2</span>);</span><br><span class="line">        <span class="comment">// 这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span></span><br><span class="line">        Object o = Test.add(<span class="number">1</span>, <span class="string">"asd"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指定泛型的时候</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 指定了Integer，所以只能为Integer类型或者其子类</span></span><br><span class="line">        <span class="keyword">int</span> a = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 编译错误，指定了Integer，不能为Float</span></span><br><span class="line">        <span class="comment">// int b = Test.&lt;Integer&gt;add(1, 2.2);</span></span><br><span class="line">        <span class="comment">// 指定为Number，所以可以为Integer和Float</span></span><br><span class="line">        Number c = Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用泛型的好处：<ul><li>不必因为添加元素类型的不同而定义不同类型的集合。</li><li>可以通过规则控制存储的数据类型，避免了类型转换的麻烦。</li><li>把运行期异常提升到了编译期。</li></ul></li></ul><h4 id="泛型的实现方式：类型擦除"><a href="#泛型的实现方式：类型擦除" class="headerlink" title="泛型的实现方式：类型擦除"></a>泛型的实现方式：类型擦除</h4><ul><li><strong>类型擦除</strong>：<ul><li>Java 的泛型是伪泛型，这是因为 <strong>Java 在编译期间，所有的泛型信息都会被擦掉</strong>，这也就是通常所说类型擦除 。</li><li>Java 的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程称为类型擦除。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">"abc"</span>);</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接调用add方法只能存储整形，因为泛型类型的实例为 Integer</span></span><br><span class="line">        list.add(<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用反射调用add方法的时候，可以存储字符串</span></span><br><span class="line">        list.getClass().getMethod(<span class="string">"add"</span>, Object.class).invoke(list, <span class="string">"asd"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型擦除后保留的<strong>原始类型</strong>：<ul><li>原始类型就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。</li><li>无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用 <code>Object</code>）替换。</li><li>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。例如，<code>class Test&lt;T extends Comparable&gt; {}</code> 的原始类型就是 <code>Comparable</code>。</li><li>要区分原始类型和泛型变量的类型。</li></ul></li></ul><h4 id="类型擦除引起的问题及解决方法"><a href="#类型擦除引起的问题及解决方法" class="headerlink" title="类型擦除引起的问题及解决方法"></a>类型擦除引起的问题及解决方法</h4><h5 id="编译期进行类型检查"><a href="#编译期进行类型检查" class="headerlink" title="编译期进行类型检查"></a>编译期进行类型检查</h5><ul><li>Java 编译器是通过先检查代码中泛型的类型，然后进行类型擦除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="number">123</span>); <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是在编译之后检查，类型擦除后，原始类型为 <code>Object</code>，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</li><li>那么，这个类型检查是针对谁的呢？我们先看看<strong>参数化类型和原始类型的兼容</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以ArrayList举例子，以前的写法:</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在的写法：</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList(); <span class="comment">// 第一种情况</span></span><br><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 第二种情况</span></span><br></pre></td></tr></table></figure><ul><li>在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</li><li>因为类型检查就是编译时完成的，<code>new ArrayList()</code> 只是在内存中开辟了一个存储空间，可以存储任何类型对象，而<strong>真正涉及类型检查的是它的引用</strong>，因为我们是使用它引用 <code>list1</code> 来调用它的方法，所以 <code>list1</code> 引用能完成泛型类型的检查。而引用 <code>list2</code> 没有使用泛型，所以不行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list1.add(<span class="string">"1"</span>); <span class="comment">// 编译通过</span></span><br><span class="line">        list1.add(<span class="number">1</span>); <span class="comment">// 编译错误</span></span><br><span class="line">        String str1 = list1.get(<span class="number">0</span>); <span class="comment">// 返回类型就是String</span></span><br><span class="line"></span><br><span class="line">        ArrayList list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list2.add(<span class="string">"1"</span>); <span class="comment">// 编译通过</span></span><br><span class="line">        list2.add(<span class="number">1</span>); <span class="comment">// 编译通过</span></span><br><span class="line">        Object object = list2.get(<span class="number">0</span>); <span class="comment">// 返回类型就是Object</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="string">"11"</span>); <span class="comment">// 编译通过</span></span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</li></ul><h5 id="不允许包含继承关系的引用传递"><a href="#不允许包含继承关系的引用传递" class="headerlink" title="不允许包含继承关系的引用传递"></a>不允许包含继承关系的引用传递</h5><ul><li>在 Java 中，像下面形式的引用传递是不允许的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); <span class="comment">// 编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><ul><li>我们先看第一种情况，将第一种情况拓展成下面的形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="keyword">new</span> Object());</span><br><span class="line">list1.add(<span class="keyword">new</span> Object());</span><br><span class="line">ArrayList&lt;String&gt; list2 = list1; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><ul><li>我们先假设它编译没错。那么当我们使用 <code>list2</code> 引用用 <code>get()</code> 方法取值的时候，返回的都是 <code>String</code> 类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了 <code>Object</code> 类型的对象，这样就会有 <code>ClassCastException</code> 了。</li><li>所以为了避免这种极易出现的错误，Java 不允许进行这样的引用传递。（<strong>泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷</strong>）。</li><li>再看第二种情况，将第二种情况拓展成下面的形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> String());  </span><br><span class="line">list1.add(<span class="keyword">new</span> String());</span><br><span class="line">ArrayList&lt;Object&gt; list2 = list1; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><ul><li>看上去没问题，用 <code>list2</code> 取值的时候不会出现 <code>ClassCastException</code>，因为是从 <code>String</code> 转换为 <code>Object</code> 。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们<strong>使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷</strong>。</li><li>如果又用 <code>list2</code> 往里面 <code>add()</code> 新的对象，那么到时候取的时候，怎么知道取出来的到底是 <code>String</code> 类型的，还是 <code>Object</code> 类型的呢？所以 Java 不允许这么干。</li><li><strong>所以，要格外注意，泛型中的引用传递的问题。</strong></li></ul><h5 id="取出元素时进行自动类型转换"><a href="#取出元素时进行自动类型转换" class="headerlink" title="取出元素时进行自动类型转换"></a>取出元素时进行自动类型转换</h5><ul><li>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。</li><li>既然都被替换为原始类型，那么为什么在获取的时候，不需要进行强制类型转换呢？看下 <code>ArrayList.get()</code>方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到，在 <code>return</code> 的时候是返回原始类型的值。再看看调用 <code>get</code> 方法的字节码文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        Integer elem = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        Integer elem = (Integer)list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以发现，在编译后的字节码文件中，<code>get</code> 方法返回值被强制转换为指定的泛型类型。</li><li>所以我们不用自己进行强转，当取出一个泛型类型的元素或属性时，会自动插入强制类型转换。</li></ul><h5 id="类型擦除与多态的冲突"><a href="#类型擦除与多态的冲突" class="headerlink" title="类型擦除与多态的冲突"></a>类型擦除与多态的冲突</h5><ul><li>假设有这样一个泛型类，用一个子类继承它。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个子类中，我们设定父类的泛型类型为 <code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法。</li><li>我们的原意是这样的：将父类的泛型类型限定为 <code>Date</code>，那么父类里面的两个方法的参数都为 <code>Date</code> 类型。所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的 <code>@Override</code> 标签中也可以看到，一点问题也没有。</li><li><strong>分析</strong>：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型 <code>Object</code>。看看 <code>setValue</code> 方法，父类的类型是 <code>Object</code>，而子类的类型是 <code>Date</code>，参数类型不一样。如果是在普通的继承关系中，根本就不会是重写，而是重载。</li><li>测试一下这个方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateInter dateInter = <span class="keyword">new</span> DateInter();</span><br><span class="line">dateInter.setValue(<span class="keyword">new</span> Date());</span><br><span class="line">dateInter.setValue(<span class="keyword">new</span> Object()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><ul><li>如果是重载，那么子类中两个 <code>setValue</code> 方法，一个参数是 <code>Object</code> 类型，一个参数是 <code>Date</code> 类型。可是我们发现，根本就没有这样的一个子类继承自父类的 <code>Object</code> 类型参数的方法。所以说，<strong>确实是重写，而不是重载</strong>。</li><li>为什么会这样呢？</li><li>原因是这样的，我们传入父类的泛型类型是 <code>Date</code>，我们的本意是将泛型类中存在泛型的地方都替换为 <code>Date</code>，然后在子类中重写参数类型为 <code>Date</code> 的那两个方法，实现继承中的多态。</li><li>可是由于种种原因，JVM 并不能将泛型类型变为 <code>Date</code>，只能将类型擦除掉，变为原始类型 <code>Object</code>。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。</li><li>JVM 知道你的本意吗？知道！！！可是它能直接实现吗？不能！！！如果真的不能的话，那我们怎么去重写我们想要的 <code>Date</code> 类型参数的方法啊。</li><li>于是 JVM 采用了一个特殊的方法，来完成这项功能，那就是<strong>桥方法</strong>。</li><li>反编译 <code>DateInter</code> 类的字节码，结果如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fundamental</span>.<span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">fundamental</span>.<span class="title">Pair</span>&lt;<span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">  fundamental.DateInter();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method fundamental/Pair."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.util.Date)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: invokespecial #2                  // Method fundamental/Pair.setValue:(Ljava/lang/Object;)V</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #3                  // Method fundamental/Pair.getValue:()Ljava/lang/Object;</span><br><span class="line">       4: checkcast     #4                  // class java/util/Date</span><br><span class="line">       <span class="number">7</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: checkcast     #4                  // class java/util/Date</span><br><span class="line">       5: invokevirtual #5                  // Method setValue:(Ljava/util/Date;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokevirtual #6                  // Method getValue:()Ljava/util/Date;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从反编译的结果来看，我们本意重写 <code>setValue</code> 和 <code>getValue</code> 方法的子类中有 4 个方法，最后的两个方法就是编译器自己生成的<strong>桥方法</strong>。</li><li>可以看到桥方法的参数类型都是 <code>Object</code>，也就是说，<strong>子类中真正覆盖父类两个方法的就是这两个看不到的桥方法</strong>。</li><li>而标注在我们自己定义的 <code>setvalue</code> 和 <code>getValue</code> 方法上面的 <code>@Oveerride</code> 只不过是假象。而<strong>桥方法的内部实现，就只是去调用我们自己重写的那两个方法</strong>。</li><li>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</li></ul><h5 id="instanceof-中不能指定泛型"><a href="#instanceof-中不能指定泛型" class="headerlink" title="instanceof 中不能指定泛型"></a><code>instanceof</code> 中不能指定泛型</h5><ul><li>因为类型擦除之后，泛型类中只剩下原始类型，泛型信息（指定的具体类型）不存在了。那么，编译时进行类型查询指定泛型就是非法的。</li></ul><h5 id="泛型在静态方法和静态类中的问题"><a href="#泛型在静态方法和静态类中的问题" class="headerlink" title="泛型在静态方法和静态类中的问题"></a>泛型在静态方法和静态类中的问题</h5><ul><li><strong>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one; <span class="comment">// 编译错误  </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title">show</span><span class="params">(T one)</span></span>&#123; <span class="comment">// 编译错误    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为泛型类中的<strong>泛型参数的实例化是在定义对象的时候指定的</strong>，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</li><li>但是要注意区分下面的一种情况：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt;<span class="function">T <span class="title">show</span><span class="params">(T one)</span></span>&#123; <span class="comment">// 这是正确的    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为这是一个泛型方法，<strong>在泛型方法中使用的 <code>T</code> 是自己在方法中定义的 <code>T</code>，而不是泛型类中的 <code>T</code></strong>。</li></ul><h3 id="与-equals-的区别："><a href="#与-equals-的区别：" class="headerlink" title="== 与 equals 的区别："></a><code>==</code> 与 <code>equals</code> 的区别：</h3><ul><li><code>==</code> ：<ul><li>基本类型：比较两个值是否相等。如 <code>10</code>、<code>10L</code>、<code>10.0</code> 都是相等的，都指向值为 <code>10</code> 的堆。</li><li>引用类型：比较两个对象的<strong>内存地址</strong>是否相同，即判断两个对象引用是不是指向同一个对象。</li></ul></li><li><code>equals</code> ：<ul><li>判断两个对象是否相等，不能用于比较基本数据类型的变量。该方法继承自 <code>Object</code> 类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>equals()</code> 方法存在两种使用情况：<ol><li>类没有覆盖 <code>equals()</code> 方法。则通过 <code>equals()</code> 比较该类的两个对象时，实际上是通过 <code>==</code> 比较这两个对象。</li><li>类覆盖了 <code>equals()</code> 方法。一般都覆盖 <code>equals()</code> 方法来比较两个对象的<strong>内容</strong>是否相等，若它们的内容相等，则返回 <code>true</code> （即认为这两个对象相等）。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123; <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ol><li><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 类的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 类的 <code>equals</code> 方法比较的是对象的值。</li><li>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用，如果没有就在常量池中重新创建一个 <code>String</code> 对象。</li></ol></li></ul><h3 id="hashCode-与-equals-的使用"><a href="#hashCode-与-equals-的使用" class="headerlink" title="hashCode 与 equals 的使用"></a><code>hashCode</code> 与 <code>equals</code> 的使用</h3><h4 id="hashCode-的作用"><a href="#hashCode-的作用" class="headerlink" title="hashCode() 的作用"></a><code>hashCode()</code> 的作用</h4><ul><li><code>hashCode()</code> 的作用是<strong>获取哈希码</strong>（散列码），实际上是返回一个 <code>int</code> 整数。</li><li>这个哈希码的作用是确定该对象在哈希表中的索引位置。</li><li><code>hashCode()</code> 定义在 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。（需要注意的是， <code>Object</code> 的 <code>hashcode</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是 <strong><code>hashCode()</code> 在哈希表结构中才有用，在其它情况下没用</strong>。</li><li><strong>以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode()</code>：</strong> <ul><li>当把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较。</li><li>如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。</li><li>但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</li><li>这样就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</li></ul></li></ul><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法？"></a>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</h4><ul><li>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 <code>equals</code> 方法都返回 <code>true</code>。两个对象有相同的 hashcode 值，它们也不一定是相等的。</li><li><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该类的两个对象无论如何都不会相等（即使这两个对象具有相同的数据）。<strong>因此，<code>equals</code> 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></li></ul><h4 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h4><ul><li>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>）。</li><li>我们刚刚也提到了 <code>HashSet</code>，如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="8-种基本数据类型及其包装类"><a href="#8-种基本数据类型及其包装类" class="headerlink" title="8 种基本数据类型及其包装类"></a>8 种基本数据类型及其包装类</h3><div class="table-container"><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">关键字</th><th style="text-align:left">内存占用</th><th>默认值</th><th>封装类</th></tr></thead><tbody><tr><td style="text-align:left">字节型</td><td style="text-align:left"><code>byte</code></td><td style="text-align:left">1 个字节</td><td><code>(byte)0</code></td><td><code>Byte</code></td></tr><tr><td style="text-align:left">短整型</td><td style="text-align:left"><code>short</code></td><td style="text-align:left">2 个字节</td><td><code>(short)0</code></td><td><code>Short</code></td></tr><tr><td style="text-align:left">整型</td><td style="text-align:left"><code>int</code>（默认）</td><td style="text-align:left">4 个字节</td><td><code>0</code></td><td><code>Integer</code></td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:left"><code>long</code></td><td style="text-align:left">8 个字节</td><td><code>0L</code></td><td><code>Long</code></td></tr><tr><td style="text-align:left">单精度浮点型</td><td style="text-align:left"><code>float</code></td><td style="text-align:left">4 个字节</td><td><code>0.0F</code></td><td><code>Float</code></td></tr><tr><td style="text-align:left">双精度浮点型</td><td style="text-align:left"><code>double</code>（默认）</td><td style="text-align:left">8 个字节</td><td><code>0.0</code></td><td><code>Double</code></td></tr><tr><td style="text-align:left">字符型</td><td style="text-align:left"><code>char</code></td><td style="text-align:left">2 个字节</td><td><code>\u0000</code></td><td><code>Character</code></td></tr><tr><td style="text-align:left">布尔型</td><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">-</td><td><code>false</code></td><td><code>Boolean</code></td></tr></tbody></table></div><ol><li>列举的数据类型是基本类型，后面的封装类是引用类型，<strong>所有引用类型的默认值都是 <code>null</code></strong> 。在引用使用前，必须为其指定一个对象，否则会抛出空指针异常。</li><li>基本数据类型在声明时，系统会自动给它分配空间；而<strong>引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。</strong></li><li>虽然定义了 <code>boolean</code> 这种数据类型，但是 Java 只对它提供了有限的支持。在 JVM 中没有任何供 <code>boolean</code> 值专用的字节码指令，Java 语言表达式所操作的 <code>boolean</code> 值，在编译之后都使用 JVM 中的 <code>int</code> 数据类型来代替，而 <code>boolean</code> 数组将会被编码成 JVM 的 <code>byte</code> 数组，数组中的每个 <code>boolean</code> 元素占 8 位。这样我们可以得出 <strong><code>boolean</code> 类型单独使用是占用 4 个字节，在数组中又是 1 个字节</strong>。使用 <code>int</code> 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这里不是指的是 32 / 64 位系统，而是指 CPU 硬件层面），具有高效存取的特点。</li></ol><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><h4 id="什么是装箱和拆箱"><a href="#什么是装箱和拆箱" class="headerlink" title="什么是装箱和拆箱"></a>什么是装箱和拆箱</h4><ul><li>从 Java SE 5 开始就提供了自动装箱和拆箱的特性：<ul><li><strong>装箱</strong>：将基本数据类型转换为它们对应的包装类型。</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型。</li></ul></li></ul><h4 id="装箱和拆箱是如何实现的"><a href="#装箱和拆箱是如何实现的" class="headerlink" title="装箱和拆箱是如何实现的"></a>装箱和拆箱是如何实现的</h4><ul><li>以 <code>Integer</code> 类为例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反编译 class 文件之后得到如下字节码内容：</li></ul><p><img src="/2020/05/22/javase-sumary-fundamentals/装箱和拆箱示例字节码.png" alt="装箱和拆箱示例字节码"></p><ul><li>可以看出：<ul><li>装箱的时候会自动调用 <code>Integer</code> 类的静态方法 <code>valueOf(int)</code> ；</li><li>拆箱的时候会自动调用 <code>Integer</code> 类的成员方法 <code>intValue()</code> 。</li></ul></li><li>因此可以用一句话总结<strong>装箱和拆箱的实现过程</strong>：<ul><li>装箱过程是通过调用包装器的 <code>valueOf()</code> 方法实现的，而拆箱过程是通过调用包装器的 <code>xxxValue()</code> 方法实现的（<code>xxx</code> 代表对应的基本数据类型）。</li></ul></li></ul><h3 id="8-种包装类与常量池"><a href="#8-种包装类与常量池" class="headerlink" title="8 种包装类与常量池"></a>8 种包装类与常量池</h3><ul><li>Java 基本类型的包装类大部分都实现了常量池技术。</li><li>即 <code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Character</code>、<code>Boolean</code>。</li><li><strong>如果超出对应数据范围，仍然会去创建新的对象。</strong></li></ul><h4 id="Byte、Short、Integer、Long-的缓存范围"><a href="#Byte、Short、Integer、Long-的缓存范围" class="headerlink" title="Byte、Short、Integer、Long 的缓存范围"></a><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 的缓存范围</h4><ul><li><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 这 4 种包装类默认创建了数值 <strong><code>[-128，127]</code></strong> 的相应类型的缓存数据。</li><li>下面以 <code>Integer</code> 的源码为例进行解析。<code>Integer</code> 的 <code>valueOf()</code> 方法的具体实现为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而其中的 <code>IntegerCache</code> 类是 <code>Integer</code> 的静态内部类，其实现为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出，<strong>在通过 <code>valueOf</code> 方法创建 <code>Integer</code> 对象的时候，如果数值在 [-128, 127] 之间，便返回指向 <code>IntegerCache.cache</code> 中已经存在的对象的引用；否则创建一个新的 <code>Integer</code> 对象。</strong></li></ul><h4 id="Character-的缓存范围"><a href="#Character-的缓存范围" class="headerlink" title="Character 的缓存范围"></a><code>Character</code> 的缓存范围</h4><ul><li><code>Character</code> 创建了数值在 <strong><code>[0,127]</code></strong> 范围的缓存数据。</li><li><code>Character</code> 的 <code>valueOf()</code> 方法实现为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而 <code>CharacterCache</code> 为 <code>Character</code> 的静态内部类，源码为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出，<strong>在通过 <code>valueOf</code> 方法创建 <code>Character</code> 对象的时候，如果数值在 [0, 127] 之间，便返回指向 <code>CharacterCache.cache</code> 中已经存在的对象的引用；否则创建一个新的 <code>Character</code> 对象。</strong></li></ul><h4 id="Boolean-的缓存数据"><a href="#Boolean-的缓存数据" class="headerlink" title="Boolean 的缓存数据"></a><code>Boolean</code> 的缓存数据</h4><ul><li><p><code>Boolean</code> 直接返回 <code>True</code> 或 <code>False</code>。</p></li><li><p><code>Boolean</code> 的 <code>valueOf</code> 方法的具体实现：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBoolean(s) ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而其中的 <code>TRUE</code> 和 <code>FALSE</code> 又是什么呢？在 <code>Boolean</code> 中定义了 2 个<strong>静态成员属性 <code>TRUE</code> 和 <code>FALSE</code></strong> ：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">     * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么浮点数类型的包装类-Float-与-Double-没有实现常量池技术？"><a href="#为什么浮点数类型的包装类-Float-与-Double-没有实现常量池技术？" class="headerlink" title="为什么浮点数类型的包装类 Float 与 Double 没有实现常量池技术？"></a>为什么浮点数类型的包装类 <code>Float</code> 与 <code>Double</code> 没有实现常量池技术？</h4><ul><li><code>Double</code> 的 <code>valueOf</code> 的实现为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么 <code>Double</code> 类的 <code>valueOf</code> 方法会采用与 <code>Integer</code> 类的 <code>valueOf</code> 方法不同的实现？<ul><li>很简单，<strong>在某个范围内的整型数值的个数是有限的，而浮点数却不是</strong>。</li></ul></li><li>注意：<ul><li><code>Integer</code>、<code>Short</code>、<code>Byte</code>、<code>Character</code>、<code>Long</code> 这几个类的 <code>valueOf</code> 方法的实现是类似的。</li><li><code>Double</code>、<code>Float</code> 的 <code>valueOf</code> 方法的实现是类似的。</li></ul></li></ul><h4 id="面试中的相关问题"><a href="#面试中的相关问题" class="headerlink" title="面试中的相关问题"></a>面试中的相关问题</h4><h5 id="面试题-1：Integer"><a href="#面试题-1：Integer" class="headerlink" title="面试题 1：Integer"></a>面试题 1：<code>Integer</code></h5><ul><li>下面这段代码的输出结果是什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果表明 i1和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象。</li><li>代码中 i1 和 i2 的数值为 100，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。</li></ul><h5 id="面试题-2：Double"><a href="#面试题-2：Double" class="headerlink" title="面试题 2：Double"></a>面试题 2：<code>Double</code></h5><ul><li>下面这段代码的输出结果是什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double i1 = <span class="number">100.0</span>;</span><br><span class="line">        Double i2 = <span class="number">100.0</span>;</span><br><span class="line">        Double i3 = <span class="number">200.0</span>;</span><br><span class="line">        Double i4 = <span class="number">200.0</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也许有的朋友会认为跟上面一道题目的输出结果相同，但是事实上却不是。</li><li>因为 <code>Double</code> 类没有缓存的数据。</li></ul><h5 id="面试题-3：Boolean"><a href="#面试题-3：Boolean" class="headerlink" title="面试题 3：Boolean"></a>面试题 3：<code>Boolean</code></h5><ul><li>下面这段代码的输出结果是什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="面试题-4：-与-equals"><a href="#面试题-4：-与-equals" class="headerlink" title="面试题 4：== 与 equals"></a>面试题 4：<code>==</code> 与 <code>equals</code></h5><ul><li>下面程序的输出结果是什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(c == d); <span class="comment">// true</span></span><br><span class="line">        System.out.println(e == f); <span class="comment">// false</span></span><br><span class="line">        System.out.println(c == (a + b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c.equals(a + b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g == (a + b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g.equals(a + b)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(g.equals(a + h)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意 2 点：<ol><li>当 <code>==</code> 运算符的两个操作数都是包装器类型的引用时，是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即<strong>包含算术运算</strong>），则比较的是数值（即会<strong>触发自动拆箱过程</strong>）。</li><li><strong>对于包装器类型，<code>equals</code> 方法并不会进行类型转换</strong>。</li></ol></li><li>第一个和第二个输出结果没有什么疑问。第三句由于 <code>a+b</code> 包含了算术运算，因此会触发自动拆箱过程（会调用 <code>intValue</code> 方法），因此它们比较的是数值是否相等。而对于 <code>c.equals(a+b)</code> 会先触发自动拆箱过程，再触发自动装箱过程，也就是说 <code>a+b</code>，会先各自调用 <code>intValue</code> 方法，得到了加法运算后的数值之后，便调用 <code>Integer.valueOf</code> 方法，再进行 <code>equals</code> 比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是 <code>int</code> 类型的，装箱过程调用的是<code>Integer.valueOf</code>；如果是 <code>long</code> 类型的，装箱调用的 <code>Long.valueOf</code> 方法）。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法返回值的作用"><a href="#方法返回值的作用" class="headerlink" title="方法返回值的作用"></a>方法返回值的作用</h3><ul><li>返回值：指获取到的某个方法体中的代码执行后产生的结果（前提是该方法可能产生结果）。</li><li>作用：接收方法执行的结果，使得它可以用于其他的操作。</li></ul><h3 id="Java-中的值传递"><a href="#Java-中的值传递" class="headerlink" title="Java 中的值传递"></a>Java 中的值传递</h3><ul><li>各种程序设计语言中方法参数的传递方式：<ul><li>按值调用（call by value）：表示方法接收的是调用者提供的值。</li><li>按引用调用（call by reference）：表示方法接收的是调用者提供的变量地址。</li><li><strong>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值</strong>。</li></ul></li><li><strong>Java 程序设计语言总是采用按值调用</strong>。<ul><li>方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</li></ul></li></ul><h4 id="方法不能修改基本数据类型的参数变量"><a href="#方法不能修改基本数据类型的参数变量" class="headerlink" title="方法不能修改基本数据类型的参数变量"></a>方法不能修改基本数据类型的参数变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        swap(num1, num2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">        System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>swap</code> 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</li></ul><h4 id="方法可以改变对象参数的状态"><a href="#方法可以改变对象参数的状态" class="headerlink" title="方法可以改变对象参数的状态"></a>方法可以改变对象参数的状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>array 被初始化 arr 的拷贝（一个对象的引用），也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</li></ul><h4 id="方法不能让对象参数引用一个新的对象"><a href="#方法不能让对象参数引用一个新的对象" class="headerlink" title="方法不能让对象参数引用一个新的对象"></a>方法不能让对象参数引用一个新的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><ul><li>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</li></ul><h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h3><ul><li><strong>重写（Override）</strong>：<ul><li>在子类中对父类允许访问的方法的实现过程进行重新编写。</li><li><strong>方法名、参数列表完全相同</strong>（声明不变，重新实现）。</li><li>返回值范围<strong>小于等于</strong>父类。</li><li>抛出的异常范围<strong>小于等于</strong>父类（不能抛出新的异常或者比重写方法声明更加宽泛的异常）。</li><li>访问权限修饰符范围<strong>大于等于</strong>父类。</li><li><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong>。</li></ul></li><li><strong>重载（Overload）</strong>：<ul><li>在同一个类中，同名的方法具有不同的参数列表。</li><li><strong>参数类型、顺序、个数不同。</strong></li><li>返回值类型和访问修饰符可以不同。</li><li>无法以返回值类型作为重载函数的区分标准。</li><li><strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</strong>。</li></ul></li></ul><div class="table-container"><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类中</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table></div><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><p><img src="/2020/05/22/javase-sumary-fundamentals/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p><h2 id="获取键盘输入的两种方式"><a href="#获取键盘输入的两种方式" class="headerlink" title="获取键盘输入的两种方式"></a>获取键盘输入的两种方式</h2><ul><li>通过 <code>Scanner</code> ：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br></pre></td></tr></table></figure><ul><li>通过 <code>BufferedReader</code> ：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure><h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul><li>面向对象与面向过程的区别：<ul><li>面向对象<strong>强调的是通过调用对象的行为来实现功能</strong>。</li><li>面向过程<strong>强调自己一步一步的去操作实现</strong>。</li></ul></li><li>面向对象与面向过程的优缺点：<ul><li><strong>面向过程性能比面向对象高。</strong><ul><li>因为类调用时需要实例化，开销比较大，比较消耗资源。</li><li>编程语言的性能主要与运行机制有关。直接编译成 CPU 可执行的机器码的语言性能肯定比解释执行的语言在过程复杂度上性能要高得多。</li></ul></li><li><strong>面向对象易维护、易复用、易扩展。</strong><ul><li>因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li></ul></li></ul></li></ul><h3 id="构造方法的使用"><a href="#构造方法的使用" class="headerlink" title="构造方法的使用"></a>构造方法的使用</h3><h4 id="构造方法的作用及特性"><a href="#构造方法的作用及特性" class="headerlink" title="构造方法的作用及特性"></a>构造方法的作用及特性</h4><ul><li>构造方法的作用：<ul><li>完成对类对象的初始化工作，给对象的成员变量赋初始值。</li></ul></li><li>构造方法的特性：<ol><li>名字与类名相同。</li><li>没有返回值类型，不能用 <code>void</code> 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol></li></ul><h4 id="一个类没有声明构造方法，该程序能正确执行吗"><a href="#一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="一个类没有声明构造方法，该程序能正确执行吗?"></a>一个类没有声明构造方法，该程序能正确执行吗?</h4><ul><li>可以执行。</li><li>一个类没有声明构造方法时，编译器会默认提供一个<strong>无参构造方法</strong>。</li><li><strong>一旦自定义构造方法，编译器不再提供默认的无参构造方法！</strong></li></ul><h4 id="构造方法是否可以被子类继承或重写？"><a href="#构造方法是否可以被子类继承或重写？" class="headerlink" title="构造方法是否可以被子类继承或重写？"></a>构造方法是否可以被子类继承或重写？</h4><ul><li>构造方法是与类名一致的，所以子类无法继承父类的构造方法，更不能重写。</li><li>但是构造方法<strong>可以重载</strong>，所以可以看到一个类中有多个构造函数的情况。</li></ul><h4 id="为什么调用子类构造方法前会先调用父类构造方法？"><a href="#为什么调用子类构造方法前会先调用父类构造方法？" class="headerlink" title="为什么调用子类构造方法前会先调用父类构造方法？"></a>为什么调用子类构造方法前会先调用父类构造方法？</h4><ul><li>帮助子类做初始化工作。</li><li>子类无法继承父类的构造方法，而构造方法是用来初始化成员变量的，所以在子类的初始化过程中，必须先执行父类的初始化动作。</li><li>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于<strong>子类对象中包含了其对应的父类空间</strong>，便可以包含其父类的成员。</li><li>Java 程序在执行子类的构造方法之前，如果没有用 <code>super(...)</code> 来调用父类特定的构造方法，则会隐式调用父类中没有参数的构造方法，即有一个默认隐含的 <code>super()</code> 调用。</li></ul><h4 id="定义不做事的无参构造方法的作用"><a href="#定义不做事的无参构造方法的作用" class="headerlink" title="定义不做事的无参构造方法的作用"></a>定义不做事的无参构造方法的作用</h4><ul><li>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code> 来调用父类特定的构造方法，则会调用父类中的无参构造方法。</li><li>而一旦自定义构造方法，无论是有参还是无参的，编译器不再提供默认的无参构造方法。</li><li><strong>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super(...)</code> 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到无参构造方法可供执行</strong>。</li><li>解决办法是在父类里加上一个不做事且没有参数的构造方法。</li></ul><h3 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h3><ol><li>从语法形式上看：<ul><li>成员变量定义在类中方法外，是属于类的，而<strong>局部变量是在方法中定义的变量或是方法的参数</strong>。</li><li>成员变量可以被 <code>public</code> / <code>protected</code> / <code>private</code> / <code>static</code> 等修饰符所修饰，而<strong>局部变量不能被访问控制修饰符及 <code>static</code> 所修饰</strong>。</li><li>但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li></ul></li><li>从变量在内存中的存储方式来看：<ul><li>如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。</li><li>而对象存在于<strong>堆内存</strong>，局部变量则存在于<strong>栈内存</strong>。</li></ul></li><li>从变量在内存中的生存时间上看：<ul><li>成员变量是对象的一部分，它随着<strong>对象</strong>的创建而存在，随着对象的消失而消失。</li><li>局部变量则是随着<strong>方法的调用</strong>而存在，随着方法调用完毕而消失。</li></ul></li><li>从变量的初始化值来看：<ul><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外：<strong>被 <code>final</code> 修饰的成员变量也必须显式地赋值</strong>）。</li><li><strong>局部变量不会自动赋值，必须显式赋值</strong>。</li></ul></li></ol><h3 id="显式创建对象的几种方式"><a href="#显式创建对象的几种方式" class="headerlink" title="显式创建对象的几种方式"></a>显式创建对象的几种方式</h3><ol><li>使用 <strong><code>new</code> 运算符</strong>在堆内存中创建对象实例。</li><li>通过<strong>反射机制</strong>调用 <code>Constructor</code> 类的 <code>newInstance()</code> 方法创建实例。</li><li>采用 <strong>clone 机制</strong>调用实现了 <code>Cloneable</code> 接口的类对象的 <code>clone()</code> 方法复制对象。</li><li>借助<strong>反序列化机制</strong>调用 <code>ObjectInputStream</code> 对象的 <code>readObject()</code> 方法重建实现了 <code>Serializable</code> 接口的类对象。</li></ol><h3 id="对象实例与对象引用的区别"><a href="#对象实例与对象引用的区别" class="headerlink" title="对象实例与对象引用的区别"></a>对象实例与对象引用的区别</h3><ol><li>对象实例在堆内存中，对象引用存放在栈内存中，对象引用指向对象实例。</li><li>一个对象引用可以指向 0 个或 1 个对象，一个对象可以有 n 个引用指向它。</li></ol><h2 id="面向对象的三大特性：封装、继承、多态"><a href="#面向对象的三大特性：封装、继承、多态" class="headerlink" title="面向对象的三大特性：封装、继承、多态"></a>面向对象的三大特性：封装、继承、多态</h2><ul><li><strong>封装：</strong><ul><li>把一个对象的<strong>属性私有化</strong>，同时在必要的时候提供一些可以供外界访问属性的方法。</li></ul></li><li><strong>继承：</strong><ul><li>使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li><li>通过使用继承我们能够非常方便地复用以前的代码。</li><li>注意 3 点：<ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行<strong>扩展</strong>。</li><li>子类可以用自己的方式实现父类的方法，即<strong>重写</strong>父类方法。</li></ol></li></ul></li><li><strong>多态：</strong><ul><li><strong>同一行为具有多种不同的表现形式。</strong></li><li>具体表现为<strong>父类的引用指向子类的实例</strong>。</li><li>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li><li>在 Java 中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同一方法的重写）和<strong>实现</strong>（实现接口并覆盖接口中同一方法）。</li><li>注意：<ul><li>对象类型不可变，引用类型可变。</li><li>方法具有多态性，属性不具有多态性。</li><li>多态不能调用只在子类存在但在父类不存在的方法。</li></ul></li></ul></li></ul><h2 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h2><h3 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a><code>instanceof</code> 关键字</h3><ul><li><code>instanceof</code> 严格来说是 Java 中的一个双目运算符，<strong>给引用变量做类型校验</strong>，用来判断一个父类型的对象是否为一个类的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><ul><li><code>Class</code> 表示一个类或一个接口，当 <code>obj</code> 为 <code>Class</code> 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果都返回 <code>true</code>，否则返回 <code>false</code>。</li><li>在 Java SE 规范中对 <code>instanceof</code> 运算符的规定就是：如果 <code>obj</code> 为 <code>null</code>，那么将返回 <code>false</code>。</li><li>注意：在编译器会检查 <code>obj</code>  是否能转换为右边的 <code>Class</code> 类型，如果不能转换将会直接抛出 <code>ClassCastException</code>，如果不能确定类型，则通过编译，具体看运行时。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 编译不通过，i必须是引用类型，不能是基本类型</span></span><br><span class="line"><span class="comment">// System.out.println(i instanceof Integer);</span></span><br><span class="line"></span><br><span class="line">Integer integer = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);</span><br></pre></td></tr></table></figure><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a><code>final</code> 关键字</h3><ul><li><code>final</code> ：代表最终，不可改变，可用于修饰 <code>类</code> 、<code>方法</code> 和 <code>变量</code>。<ol><li>类：被修饰的类，<strong>不能被继承</strong>。<ul><li><code>final</code> 类不能有任何的子类。</li><li><code>final</code> 类中的所有成员方法都会被隐式地指定为 <code>final</code> 方法。</li></ul></li><li>方法：被修饰的方法，<strong>不能被重写</strong>。<ul><li>把方法锁定，以防任何继承类修改它的含义。</li><li>类中所有的 <code>private</code> 方法都隐式地指定为 <code>final</code>。</li></ul></li><li>变量：被修饰的变量，<strong>不能被重新赋值</strong>。<ul><li>基本数据类型的变量，其数值一旦在初始化之后便不能更改。</li><li>引用类型的变量，在对其初始化之后便不能再让其指向另一个对象，<strong>但是不影响对其指向的对象内部的修改</strong>。</li></ul></li></ol></li><li><strong>注意</strong>：对类、方法来说，<code>abstract</code> 关键字和 <code>final</code> 关键字不能同时使用，因为二者的含义矛盾。</li></ul><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a><code>this</code> 关键字</h3><ul><li><code>this</code> ：代表对所在类的当前对象的引用，即对象自己的引用，用来访问本类内容。<ol><li>在本类的成员方法中，访问本类的成员变量。</li><li>在本类的成员方法中，访问本类的另一个成员方法。</li><li>在本类的构造方法中，访问本类的另一个构造方法。</li></ol></li></ul><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a><code>super</code> 关键字</h3><ul><li><code>super</code> ：代表对父类对象的引用，用来访问父类内容。<ol><li>在子类的成员方法中，访问父类的成员变量。</li><li>在子类的成员方法中，访问父类的成员方法。</li><li>在子类的构造方法中，访问父类的构造方法。</li></ol></li><li><strong>使用 <code>this</code> 和 <code>super</code> 要注意的问题：</strong><ul><li>在构造器中使用 <code>super</code> 或 <code>this</code> 调用其他的构造方法时，该语句必须处于构造器的首行，否则编译器会报错，因而两者不能同时存在。如果当前构造函数使用了 <code>this()</code> ，则当前构造函数中不再在隐含添加 <code>super()</code>，由其调用的其他构造函数来实现对父类空间的初始化。</li><li><code>this</code> 和 <code>super</code> 不能用在 <code>static</code> 方法中使用。被 <code>static</code> 修饰的成员属于类，不属于某个对象，被类中所有对象共享。而 <code>this</code> 代表对本类对象的引用，指向本类对象；<code>super</code> 代表对父类对象的引用，指向父类对象；所以，<code>this</code> 和 <code>super</code> 是属于对象范畴的东西，而静态方法是属于类范畴的东西，与对象无关。</li></ul></li></ul><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a><code>static</code> 关键字</h3><ul><li><code>static</code> ：被修饰的内容是静态的，<strong>属于类的，与对象无关</strong>。</li></ul><h4 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h4><ul><li>被 <code>static</code> 修饰的成员属于类，不属于某个对象，被类中所有对象共享，可以<strong>通过类名调用</strong>。</li><li>被 <code>static</code> 声明的成员变量属于静态成员变量，<strong>静态变量存放在 Java 内存区域的方法区</strong>。</li><li>调用格式：<code>类名.静态变量名</code>、<code>类名.静态方法名()</code>。</li><li>静态方法和成员方法的区别：<ol><li>在外部调用静态方法时，可以使用 <code>类名.方法名()</code> 的方式，也可以使用 <code>对象名.方法名()</code> 的方式，而成员方法只有后面这种方式（调用静态方法无需创建对象）。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问成员变量和成员方法，成员方法则无此限制。</li></ol></li><li>在静态方法内调用非静态成员为什么是非法的？<ul><li><strong>静态内容属于类所有，随着类的加载进入方法区的静态区中</strong>。非静态内容属于类的对象，只有在实例化之后才会分配内存，然后通过对象来访问。</li><li>静态方法要访问非静态内容，如果类的对象不存在，非静态内容也就不存在，访问自然是非法的。如果类的对象已经创建，因为非静态内容属于对象独有，静态方法自身与对象无关，无法确定访问哪个对象的非静态内容，这样也是非法的。</li></ul></li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li>静态代码块定义在类中方法外，它在非静态代码块之前执行（<strong>静态代码块 → 非静态代码块 → 构造方法</strong>）。 </li><li>不管创建多少对象，<strong>静态代码块只在类加载的时候执行一次</strong>。而非静态代码块在每 <code>new</code> 一次就执行一次。</li><li>一个类中的静态代码块可以有多个，位置可以随便放，JVM 加载类时会执行这些静态代码块，JVM 将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</li><li>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。</li></ul><h5 id="静态代码块与非静态代码块的比较"><a href="#静态代码块与非静态代码块的比较" class="headerlink" title="静态代码块与非静态代码块的比较"></a>静态代码块与非静态代码块的比较</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"默认构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"非静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法中的内容"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法中的代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态方法中的代码块"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Test.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行结果如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">非静态代码块</span><br><span class="line">默认构造方法</span><br><span class="line">静态方法中的内容</span><br><span class="line">静态方法中的代码块</span><br></pre></td></tr></table></figure><ul><li><strong>相同点</strong>：<ul><li>在 JVM 加载类时且在构造方法执行之前执行。</li><li>在类中都可以定义多个，定义多个时按定义的顺序执行。</li><li>一般在代码块中对一些 <code>static</code> 变量进行赋值。</li></ul></li><li><strong>不同点</strong>： <ul><li>静态代码块在非静态代码块之前执行。</li><li>静态代码块只在类加载的时候执行唯一一次，之后不再执行，而非静态代码块在每 <code>new</code> 一次就执行一次。 </li><li>非静态代码块可在普通方法中定义（不过作用不大）；而静态代码块不行。</li></ul></li></ul><h5 id="非静态代码块与构造函数的区别"><a href="#非静态代码块与构造函数的区别" class="headerlink" title="非静态代码块与构造函数的区别"></a>非静态代码块与构造函数的区别</h5><ul><li>非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。</li><li>因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象。但无论建立哪个对象，都会先执行相同的非静态代码块。</li><li>也就是说，非静态代码块中定义的是不同对象共性的初始化内容。</li></ul><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul><li><code>static</code> 修饰类的话只能修饰内部类。</li><li>静态内部类与非静态内部类之间存在一个最大的区别是：<ul><li>非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类。</li><li>但是静态内部类却没有。没有这个引用就意味着：<ol><li>它的创建是不需要依赖外部类的创建。</li><li>它不能使用外部类的任何非 <code>static</code> 成员变量和方法。</li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明为 private 避免调用默认构造方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 <code>Singleton</code> 类加载时，静态内部类 <code>SingletonHolder</code> 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 <code>SingletonHolder</code> 才会被加载，此时初始化 <code>INSTANCE</code> 实例，并且 JVM 能确保 <code>INSTANCE</code> 只被实例化一次。这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</li></ul><h4 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h4><ul><li><code>static</code> 可以用来导入类中的静态资源，是 JDK 1.5 之后的新特性，格式为：<code>import static ...</code> 。</li><li>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ul><h3 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a><code>transient</code> 关键字</h3><ul><li><code>transient</code> ：<ul><li><code>transient</code> 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化</strong>。</li><li>当对象被反序列化时，<strong>被 <code>transient</code> 修饰的变量值不会被持久化和恢复</strong>。</li><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li></ul></li><li><strong>不能被序列化和反序列化的变量</strong>：<ul><li>被 <code>static</code> 修饰的成员变量属于类，不能被序列化，序列化的都是对象。</li><li>被 <code>transient</code> 修饰的成员变量，不能被序列化。</li></ul></li></ul><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ol><li><strong>Java 8 以前，接口中的方法只能是 <code>抽象方法</code> ，Java 8 开始接口中可以包含 <code>默认方法</code> 和 <code>静态方法</code> ，Java 9 开始接口中允许定义 <code>私有方法</code> 和 <code>私有静态方法</code></strong> ，而抽象类可以有各种方法。</li><li>接口中除了<strong>默认声明为 <code>public static final</code> 的变量</strong>，不能有其他变量，而抽象类中则不一定。</li><li><strong>一个类可以实现多个接口，但只能实现一个抽象类</strong>。接口自己本身可以通过 <code>extends</code> 关键字扩展多个接口。</li><li><strong>接口方法默认修饰符是 <code>public</code></strong>，抽象方法可以有 <code>public</code>、<code>protected</code> 和 <code>default</code> 这些修饰符（<strong>抽象方法就是为了被重写所以不能使用 <code>private</code> 关键字修饰</strong>）。</li><li>从设计层面来说，抽象是<strong>对类的抽象</strong>，是一种模板设计，而接口是<strong>对行为的抽象</strong>，是一种行为的规范。</li></ol><h1 id="Java-核心技术"><a href="#Java-核心技术" class="headerlink" title="Java 核心技术"></a>Java 核心技术</h1><h2 id="String、StringBuffer-和-StringBuilder-的区别"><a href="#String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别"></a><code>String</code>、<code>StringBuffer</code> 和 <code>StringBuilder</code> 的区别</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><ul><li><code>String</code> ：<ul><li>从底层源码来看，<code>String</code> 类中<strong>使用 <code>final</code> 关键字修饰字符数组</strong>来保存字符串，所以 String 对象是不可变的。</li><li>字符串一定定义无法再修改，每次对字符串的操作都会生成新的 <code>String</code> 对象。</li><li><strong>对 <code>String</code> 对象每次执行 <code>+</code> 操作，都隐式在堆上创建了一个 <code>StringBuilder</code> 对象，再调用 <code>append</code> 方法进行字符串的拼接。</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]; <span class="comment">// jdk8以前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value; <span class="comment">// jdk9之后</span></span><br></pre></td></tr></table></figure><ul><li><code>StringBuffer</code> 和 <code>StringBuilder</code> ：<ul><li>都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 类中也是<strong>使用字符数组保存字符串，但是没有使用 <code>final</code> 关键字修饰</strong>，所以这两种类型的对象都是可变的。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value; <span class="comment">// jdk8之前</span></span><br><span class="line">    <span class="keyword">byte</span>[] value; <span class="comment">// jdk9之后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><ul><li><code>String</code> 中的对象是不可变的，也就可以理解为常量，<strong>线程安全</strong>。</li><li><code>StringBuffer</code> 和 <code>StringBuilder</code> 的公共父类 <code>AbstractStringBuilder</code> 中定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。<ul><li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。</li><li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</li></ul></li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul><li>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</li><li><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>操作少量的数据：适用 <code>String</code>；</li><li>单线程操作字符串缓冲区下操作大量数据：适用 <code>StringBuilder</code>；</li><li>多线程操作字符串缓冲区下操作大量数据：适用 <code>StringBuffer</code>。</li></ol><h2 id="Collections-与-Arrays-工具类"><a href="#Collections-与-Arrays-工具类" class="headerlink" title="Collections 与 Arrays 工具类"></a><code>Collections</code> 与 <code>Arrays</code> 工具类</h2><ul><li><code>Collections</code> 工具类的常用方法：<ol><li>排序：<ul><li><code>void reverse(List list)</code> ：反转</li><li><code>void shuffle(List list)</code> ：随机排序</li><li><code>void sort(List list)</code> ：按自然排序的升序排序</li><li><code>void sort(List list, Comparator c)</code> ：定制排序，由 <code>Comparator</code> 控制排序逻辑</li><li><code>void swap(List list, int i , int j)</code> ：交换两个索引位置的元素</li><li><code>void rotate(List list, int distance)</code> ：旋转。当 <code>distance</code> 为正数时，将 <code>list</code> 后 <code>distance</code> 个元素整体移到前面。当 <code>distance</code> 为负数时，将 <code>list</code> 的前 <code>distance</code> 个元素整体移到后面。</li></ul></li><li>查找和替换：<ul><li><code>int binarySearch(List list, Object key)</code> ：对 <code>List</code> 进行二分查找，返回索引，注意 <code>List</code> 必须是有序的</li><li><code>int max(Collection coll)</code> ：根据元素的自然顺序，返回最大的元素。 类比 <code>int min(Collection coll)</code>。</li><li><code>int max(Collection coll, Comparator c)</code> ：根据定制排序，返回最大元素，排序规则由 <code>Comparator</code> 类控制。类比 <code>int min(Collection coll, Comparator c)</code>。</li><li><code>void fill(List list, Object obj)</code> ：用指定的元素代替指定 <code>list</code> 中的所有元素。</li><li><code>int frequency(Collection c, Object o)</code> ：统计元素出现次数。</li><li><code>int indexOfSubList(List list, List target)</code> ：统计 <code>target</code> 在 <code>list</code> 中第一次出现的索引，找不到则返回 -1，类比 <code>int lastIndexOfSubList(List source, list target)</code>。</li><li><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code> ：用新元素替换旧元素。</li></ul></li><li>同步控制：可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。<ul><li><code>synchronizedCollection(Collection&lt;T&gt;  c)</code>  ：返回指定 <code>collection</code> 支持的同步（线程安全的）<code>collection</code>。</li><li><code>synchronizedList(List&lt;T&gt; list)</code> ：返回指定列表支持的同步 <code>List</code>。</li><li><code>synchronizedMap(Map&lt;K,V&gt; m)</code>  ：返回由指定映射支持的同步 <code>Map</code>。</li><li><code>synchronizedSet(Set&lt;T&gt; s)</code>  ：返回指定 set 支持的同步 <code>set</code>。</li><li>注意：最好不要用上面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包 （<code>java.util.concurrent</code>）下的并发集合。</li></ul></li><li>支持不可变集合：<ul><li><code>emptyXxx()</code>：返回一个空的、不可变的集合对象，此处的集合既可以是 <code>List</code>，也可以是 <code>Set</code>，还可以是 <code>Map</code>。</li><li><code>singletonXxx()</code>：返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是<code>List</code>，<code>Set</code>，<code>Map</code>。</li><li><code>unmodifiableXxx()</code>：返回指定集合对象的不可变视图，此处的集合可以是<code>List</code>，<code>Set</code>，<code>Map</code>。</li><li>注意：上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。</li></ul></li></ol></li><li><code>Arrays</code> 工具类的常用方法：<ol><li>排序 : <code>sort()</code></li><li>查找 : <code>binarySearch()</code></li><li>比较: <code>equals()</code></li><li>填充 : <code>fill()</code></li><li>转列表: <code>asList()</code></li><li>转字符串 : <code>toString()</code></li><li>复制: <code>copyOf()</code></li></ol></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li><strong><code>java.lang.Throwable</code> 类</strong>：是 Java 语言中<strong>所有错误或异常的超类</strong>。<ul><li><strong><code>Error</code>：</strong><ul><li><strong>是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。</li><li>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM 出现的问题。</li></ul></li><li><code>Exception</code>：<ul><li><strong>是程序本身可以处理的异常</strong>。</li><li>有一个重要的子类 <strong><code>RuntimeException</code></strong> ：运行时异常，Java 程序运行过程中出现的问题。<code>RuntimeException</code> 异常由  JVM 抛出。</li><li>其他的 <code>Exception</code> 类都是编译期异常，编译器会检查。</li></ul></li><li><img src="/2020/05/22/javase-sumary-fundamentals/exceptions-java.png" alt="Java异常类层次结构"></li><li>注意：<strong>异常和错误的区别是，异常能被程序本身处理，错误是无法处理。</strong></li></ul></li><li><strong><code>Throwable</code> 类的常用方法：</strong><ul><li><code>public void printStackTrace()</code>：在控制台上打印 <code>Throwable</code> 对象封装的异常信息（包含异常的类型、原因、出现的位置）。</li><li><code>public string getMessage()</code>：返回异常发生时的简要描述。</li><li><code>public string toString()</code>：返回异常发生时的详细信息。</li><li><code>public string getLocalizedMessage()</code>：返回异常对象的本地化信息。<ul><li>使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。</li><li>如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code> 返回的结果相同。</li></ul></li></ul></li><li><strong>异常处理总结</strong>：<ol><li><strong>抛出异常 <code>throw</code></strong> ：在方法内部抛出指定的异常对象。<ul><li><code>RuntimeException</code> 或者是 <code>RuntimeException</code> 的子类对象是<strong>运行时异常，可以不处理，默认交给 <code>JVM</code> 处理</strong>（打印异常对象，中断程序）。</li><li><code>Exception</code> 或者是 <code>Exception</code> 的子类对象是<strong>编译期异常</strong>，必须处理这个异常，<strong>要么 <code>throws</code>，要么 <code>try...catch</code></strong>。</li></ul></li><li><strong>声明异常 <code>throws</code></strong> ：在方法声明中把异常对象声明抛出给方法的调用者处理。<ul><li>调用了一个声明抛出异常的方法，就必须的处理声明的异常。<ul><li>要么继续使用 <code>throws</code> 声明抛出，交给方法的调用者处理，最终交给 JVM；</li><li>要么 <code>try...catch</code> 自己处理异常。</li></ul></li></ul></li><li><strong>捕获异常 <code>try...catch...finally</code></strong> ：对出现的异常进行指定方式的处理。<ul><li><strong><code>try</code> 块</strong>：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><strong><code>catch</code> 块</strong>：用于处理 try 捕获到的异常。<ul><li><code>catch</code> 里边定义的异常变量，如果有子父类关系，那么<strong>子类的异常变量必须写在上边</strong>，否则就会报错。</li></ul></li><li><strong><code>finally</code> 块</strong>：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。<ul><li>当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li><li>只有在下面四种情况下 <code>finally</code> 语句块才不会执行：<ol><li>在 <code>try</code> 或者 <code>catch</code> 中的异常语句之前调用退出 JVM 的相关方法，如 <code>System.exit(int)</code>。若该语句在异常语句之后，<code>finally</code> 还是会执行。</li><li>在 <code>finally</code> 语句块第一行发生了异常。因为在其他行，finally 块还是会得到执行。</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol></li></ul></li></ul></li></ol></li><li>使用 <code>try-with-resources</code> 来代替 <code>try-catch-finally</code>：<ul><li>Java 中类似于 <code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code> 等的资源都需要我们调用 <code>close()</code> 方法来手动关闭，一般情况下我们都是通过 <code>try-catch-finally</code> 语句来实现这个需求。</li><li>使用 Java 7 之后的 <code>try-with-resources</code> 语句产生的代码更简短，更清晰，更容易编写必须要关闭的资源的代码，若采用 <code>try-finally</code> 则几乎做不到这点。</li><li>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用 <code>try-catch-finally</code> 可能会带来很多问题。通过使用分号分隔，可以在 <code>try-with-resources</code> 块中声明多个资源。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="什么是程序、进程、线程？"><a href="#什么是程序、进程、线程？" class="headerlink" title="什么是程序、进程、线程？"></a>什么是程序、进程、线程？</h3><ul><li><strong>程序</strong>：<ul><li>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中。</li><li>也就是说，程序<strong>是静态的代码</strong>。</li></ul></li><li><strong>进程</strong>：<ul><li>进程<strong>是程序的一次执行过程，是系统运行程序的基本单位</strong>，因此进程是动态的。</li><li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</li></ul></li><li><strong>线程</strong>：<ul><li>与进程相似，但线程<strong>是一个比进程更小的执行单位</strong>。</li><li>一个进程在其执行的过程中可以产生多个线程。</li><li>与进程不同的是，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>（JDK 8 之后称作元空间）资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。也正因为如此，线程也被称为轻量级进程。</li></ul></li></ul><h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><ul><li>线程是进程划分成的更小的运行单位。</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但不利于资源的管理和保护，而进程正相反。</li><li>进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul><li>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">线程状态</th><th style="text-align:left">导致状态发生的条件</th></tr></thead><tbody><tr><td style="text-align:left"><code>NEW</code>（新建）</td><td style="text-align:left">线程刚被创建，但是并未启动。还没调用 <code>start()</code> 方法。</td></tr><tr><td style="text-align:left"><code>RUNNABLE</code>（可运行）</td><td style="text-align:left">线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td></tr><tr><td style="text-align:left"><code>BLOCKED</code>（阻塞）</td><td style="text-align:left">线程阻塞于锁。当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则进入 <code>Blocked</code> 状态；当该线程持有锁时，将变成 <code>Runnable</code> 状态。</td></tr><tr><td style="text-align:left"><code>WAITING</code>（无限等待）</td><td style="text-align:left">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 <code>Waiting</code> 状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用 <code>notify()</code> 或者 <code>notifyAll()</code> 方法才能够唤醒。</td></tr><tr><td style="text-align:left"><code>TIMED_WAITING</code>（超时等待）</td><td style="text-align:left">不同于 <code>Waiting</code> 状态，可以在指定时间自行返回。有几个方法有超时参数，调用它们将进入 <code>Timed Waiting</code> 状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 <code>Thread.sleep(...)</code> 、<code>Object.wait(...)</code>。</td></tr><tr><td style="text-align:left"><code>TERMINATED</code>（终止）</td><td style="text-align:left">线程执行完毕。线程因为 <code>run()</code> 方法正常退出而死亡，或者因为没有捕获的异常终止了 <code>run()</code> 方法而死亡。</td></tr></tbody></table></div><ul><li>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</li></ul><p><img src="/2020/05/22/javase-sumary-fundamentals/Java线程状态变迁.png" alt="Java 线程状态变迁"></p><ul><li>Java 线程将操作系统中的 <code>Ready</code>（就绪）和 <code>Running</code>（运行中）两种状态隐藏，统称为 <code>Runnable</code>（可运行）状态。</li><li>线程创建之后它将处于 <code>New</code>（新建）状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <code>Ready</code>（可运行）状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <code>Running</code>（运行）状态。</li><li>当线程执行 <code>wait()</code> 方法之后，线程进入 <code>Waiting</code>（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li><li>而 <code>Timed_Waiting</code>（超时等待）状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep(long millis)</code> 方法或 <code>wait(long millis)</code> 方法可以将 Java 线程置于 <code>Timed_Waiting</code> 状态。当超时时间到达后 Java 线程将会返回到 <code>Runnable</code> 状态。</li><li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <code>Blocked</code>（阻塞） 状态。</li><li>线程在退出 <code>run()</code> 方法之后将会进入到 <code>Terminated</code>（终止）状态。</li></ul><h2 id="文件与-IO-流"><a href="#文件与-IO-流" class="headerlink" title="文件与 IO 流"></a>文件与 IO 流</h2><ul><li>Java 中 IO 流分为几种?<ul><li>按照流的流向分，可以划分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分，可以划分为节点流和处理流。</li></ul></li><li>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的：<ul><li><code>InputStream</code> / <code>Reader</code>：所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code> / <code>Writer</code>：所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul></li><li>按操作方式分类结构图：<img src="/2020/05/22/javase-sumary-fundamentals/IO-操作方式分类.png" alt></li><li>按操作对象分类结构图：<img src="/2020/05/22/javase-sumary-fundamentals/IO-操作对象分类.png" alt></li><li><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong><ul><li>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个<strong>转换过程算是非常耗时</strong>，并且，如果我们不知道编码类型就<strong>很容易出现乱码问题</strong>。</li><li>所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</li><li>如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</li></ul></li><li>BIO、NIO、AIO 有什么区别?<ul><li><strong>BIO (Blocking I/O)</strong>：同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。<ul><li>在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。</li><li>但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li></ul></li><li><strong>NIO (Non-blocking/New I/O)</strong>：NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。<ul><li>NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。</li><li>NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</li><li>阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</li><li>对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li></ul></li><li><strong>AIO (Asynchronous I/O)</strong>：AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的 IO 模型。<ul><li>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li><li>AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。</li><li>对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul></li></ul></li></ul><h2 id="反射机制的原理与作用"><a href="#反射机制的原理与作用" class="headerlink" title="反射机制的原理与作用"></a>反射机制的原理与作用</h2><ul><li>什么是反射？<ul><li>反射机制是在运行时，对任意一个类都能够知道这个类的所有属性和方法，对任意一个对象都能够调用它的任意方法。</li><li>在 Java 中，只要给定类的名字，就可以反射机制来获得这个类的所有信息。</li><li>这种<strong>动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制</strong>。</li></ul></li><li>反射机制的原理：<ul><li>实现上，反射机制将类的各个组成部分（属性、方法等）封装为对象，可以在程序运行过程中，操作这些对象。</li><li><img src="/2020/05/22/javase-sumary-fundamentals/Java代码的三个阶段.png" alt="Java代码的三个阶段"></li></ul></li><li>反射的实现方式：<ol><li>获取 <code>Class</code> 对象：<ul><li><code>Class.forName(&quot;全类名&quot;)</code>：将字节码文件加载进内存，返回 <code>Class</code> 对象。<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</li></ul></li><li><code>类名.class</code> ：通过类名的属性 <code>class</code> 获取。<ul><li>多用于参数的传递。</li></ul></li><li><code>对象.getClass()</code>：<code>getClass()</code> 方法在 <code>Object</code> 类中定义着。<ul><li>多用于对象的获取字节码的方式。</li></ul></li><li>注意：同一个字节码文件 <code>*.class</code> 在一次程序运行过程中，<strong>只会被加载一次</strong>，不论通过哪一种方式获取的 <code>Class</code> 对象都是同一个。</li></ul></li><li>获取 <code>Field</code> 对象：<ul><li><code>Field[] getFields()</code> ：获取所有 <strong><code>public</code> 修饰</strong>的成员变量。</li><li><code>Field getField(String name)</code> ：获取指定名称的 <code>public</code> 修饰的成员变量。</li><li><code>Field[] getDeclaredFields()</code> ：获取所有的成员变量，<strong>不考虑修饰符</strong>。</li><li><code>Field getDeclaredField(String name)</code> ：获取指定名称的成员变量，不考虑修饰符。</li><li><code>get(Object obj)</code> ：获取值。</li><li><code>void set(Object obj, Object value)</code> ：设置值。</li><li><code>void setAccessible(boolean flag)</code> ：将此对象的 <code>accessible</code> 标志设置为指示的布尔值。<ul><li><code>flag</code> 为 <code>true</code> ：忽略访问权限修饰符的安全检查（暴力反射）。</li><li><code>flag</code> 为 <code>false</code> ：反射的对象将实施 Java 语言访问检查。</li></ul></li></ul></li><li>获取 <code>Constructor</code> 对象：<ul><li><code>Constructor[] getConstructors()</code> ：返回一个包含某些 <code>Constructor</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类的所有公共构造方法。</li><li><code>Constructor getConstructor(Class... parameterTypes)</code> ：返回一个 <code>Constructor</code> 对象，它反映此 <code>Class</code> 对象所表示的类的指定公共构造方法。</li><li><code>Constructor[] getDeclaredConstructors()</code> ：返回 <code>Constructor</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象表示的类声明的所有构造方法。</li><li><code>Constructor getDeclaredConstructor(Class... parameterTypes)</code> ：返回一个 <code>Constructor</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定构造方法。</li><li><code>T newInstance(Object... initargs)</code> ：使用此 <code>Constructor</code> 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。<ul><li>如果获取的是空参构造方法来创建对象，可以使用 <code>Class</code> 对象的 <code>newInstance</code> 方法简化操作。</li></ul></li><li><code>void setAccessible(boolean flag)</code> ：将此对象的 <code>accessible</code> 标志设置为指示的布尔值。<ul><li><code>flag</code> 为 <code>true</code> ：忽略访问权限修饰符的安全检查（暴力反射）。</li><li><code>flag</code> 为 <code>false</code> ：反射的对象将实施 Java 语言访问检查。</li></ul></li></ul></li><li>获取 <code>Method</code> 对象：<ul><li><code>Method[] getMethods()</code> ：返回一个包含某些 <code>Method</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类或接口（<strong>包括</strong>那些由该类或接口声明的以及从超类和超接口<strong>继承的</strong>那些的类或接口）的公共 member 方法。</li><li><code>Method getMethod(String name, Class... parameterTypes)</code> ：返回一个 <code>Method</code> 对象，它反映此 <code>Class</code> 对象所表示的类或接口的指定公共成员方法。</li><li><code>Method[] getDeclaredMethods()</code> ：返回 <code>Method</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但<strong>不包括继承的方法</strong>。</li><li><code>Method getDeclaredMethod(String name, Class... parameterTypes)</code> ：返回一个 <code>Method</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定已声明方法。</li><li><code>Object invoke(Object obj, Object... args)</code> ：执行方法。</li><li><code>String getName()</code> ：获取方法名。</li></ul></li></ol></li><li>反射机制的优缺点：<ul><li>优点：<ul><li>能够运行时动态地获取类的实例，提高灵活性。</li><li>与动态编译结合。框架设计的灵魂就是反射。</li></ul></li><li>缺点：<ul><li>使用反射性能低，需要解析字节码，将内存中的对象进行解析。解决方案：<ol><li>通过 <code>setAccessible(true)</code> 关闭 JDK 的安全检查来提升反射速度。</li><li>多次创建一个类的实例时，有缓存会快很多。</li><li>ReflectASM 工具类，通过字节码生成的方式加快反射速度。</li></ol></li><li>相对不安全，破坏了封装性（因为反射可以获得私有方法和属性）。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> JavaSE面试总结 </category>
          
          <category> Java基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> JavaSE面试总结 </tag>
            
            <tag> Java基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC入门</title>
      <link href="/2020/04/17/basic-jdbc-mysql.html"/>
      <url>/2020/04/17/basic-jdbc-mysql.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-JDBC-？"><a href="#什么是-JDBC-？" class="headerlink" title="什么是 JDBC ？"></a>什么是 JDBC ？</h1><ul><li>JDBC 概念：<ul><li>Java DataBase Connectivity（Java 数据库连接）</li><li>是 Java 访问关系型数据库的标准规范。</li></ul></li><li>JDBC 本质：<ul><li>是官方（sun公司）定义的一套操作所有关系型数据库的规则，即<strong>接口</strong>。</li><li>各个数据库厂商去实现这套接口，提供数据库驱动 jar 包。</li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动 jar 包中的实现类。</li></ul></li></ul><h1 id="JDBC-核心-API"><a href="#JDBC-核心-API" class="headerlink" title="JDBC 核心 API"></a>JDBC 核心 API</h1><p>入门代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 导入驱动jar包</span></span><br><span class="line">        <span class="comment">// 2.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">// 3.获取数据库连接对象</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/dbdemo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        <span class="comment">// 4.定义sql语句</span></span><br><span class="line">        String sql = <span class="string">"update account set balance = 500 where id = 1"</span>;</span><br><span class="line">        <span class="comment">// 5.获取执行sql的对象 Statement</span></span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">// 6.执行sql</span></span><br><span class="line">        <span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line">        <span class="comment">// 7.处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">// 8.释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DriverManager-类"><a href="#DriverManager-类" class="headerlink" title="DriverManager 类"></a><code>DriverManager</code> 类</h2><ul><li><code>DriverManager</code> 管理驱动对象的作用：<ol><li>管理和注册数据库驱动；</li><li>得到数据库连接对象。</li></ol></li></ul><h3 id="注册驱动"><a href="#注册驱动" class="headerlink" title="注册驱动"></a>注册驱动</h3><ul><li>注册驱动：告诉程序该使用哪个 jar 包。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver, DriverAction da)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>写代码可直接使用下面的语句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(数据库驱动实现类);</span><br><span class="line">Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure><ul><li>为什么加载类进内存就可以注册驱动呢？<ul><li>通过查看源码发现，在 <code>com.mysql.jdbc.Driver</code> 类中存在静态代码块。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：mysql 5 之后的驱动 jar 包可以省略注册驱动的步骤。</li></ul><h3 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, String user, String password)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, Properties info)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><code>url</code> ：指定连接的路径<ul><li>语法：<code>协议名:子协议://ip地址:端口号/数据库名称?参数=参数值</code> 。</li><li>如：<code>jdbc:mysql://localhost:3306/dbdemo</code> 。</li><li>细节：如果连接是本机 MySQL 服务器，并且 MySQL 默认端口是 3306，则 <code>url</code> 可以简写为 <code>jdbc:mysql:///数据库名称</code> 。</li><li>乱码的处理：指定参数为 <code>?characterEncoding=utf8</code>，表示让数据库以 UTF-8 编码来处理数据。</li></ul></li></ul></li></ul><h2 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a><code>Connection</code> 接口</h2><ul><li><code>Connection</code> 数据库连接对象的作用：<ol><li>获取执行 SQL 的对象；</li><li>管理事务。</li></ol></li></ul><h3 id="获取执行-SQL-的对象"><a href="#获取执行-SQL-的对象" class="headerlink" title="获取执行 SQL 的对象"></a>获取执行 SQL 的对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String var1)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>; <span class="comment">// 调用该方法设置参数为 false，关闭自动提交即开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Statement-接口"><a href="#Statement-接口" class="headerlink" title="Statement 接口"></a><code>Statement</code> 接口</h2><ul><li><code>Statement</code> 对象的作用：<ul><li>用于执行静态 SQL 语句并返回它所生成的结果。 </li></ul></li></ul><h3 id="执行-DML-语句（insert-update-delete）、DDL-语句："><a href="#执行-DML-语句（insert-update-delete）、DDL-语句：" class="headerlink" title="执行 DML 语句（insert / update / delete）、DDL 语句："></a>执行 DML 语句（insert / update / delete）、DDL 语句：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String var1)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回值：<ul><li>影响的行数，可以通过这个影响的行数判断 DML 语句是否执行成功。</li><li>返回值 &gt; 0 的则执行成功，反之，则失败。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///dbdemo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"insert into account values(null, 'tianqi', 3000)"</span>;</span><br><span class="line">            <span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"添加成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"添加失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行-DQL-语句（select）"><a href="#执行-DQL-语句（select）" class="headerlink" title="执行 DQL 语句（select）:"></a>执行 DQL 语句（select）:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String var1)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回值：查询的结果集。</li></ul><h2 id="ResultSet-接口"><a href="#ResultSet-接口" class="headerlink" title="ResultSet 接口"></a><code>ResultSet</code> 接口</h2><ul><li><code>ResultSet</code> 结果集对象的作用：<ul><li>封装数据库查询的结果集，对结果集进行遍历，取出每一条记录。</li></ul></li></ul><h3 id="移动游标"><a href="#移动游标" class="headerlink" title="移动游标"></a>移动游标</h3><ul><li>游标：指向记录。一开始指向第一条记录的前面。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>方法的作用：<ol><li>游标向下移动一行；</li><li>判断当前指向的记录是否是最后一行。<ul><li>返回 true 表示还有数据记录，否则返回 false。</li></ul></li></ol></li></ul><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 getXxx(参数);</span><br></pre></td></tr></table></figure><ul><li><code>Xxx</code>：代表数据类型</li><li>参数：<ol><li><code>int</code> ：代表列的编号，从 1 开始。</li><li><code>String</code> ：代表列的名称。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///dbdemo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"select * from account"</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                <span class="keyword">double</span> balance = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">                System.out.println(id + <span class="string">" "</span> + name + <span class="string">" "</span> + balance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项：<ul><li>如果光标在<strong>第一行之前</strong>，使用 <code>rs.getXX()</code> 获取列值，报错：<code>Before start of result set</code> ；</li><li>如果光标在<strong>最后一行之后</strong>，使用 <code>rs.getXX()</code> 获取列值，报错：<code>After end of result set</code> ；</li><li>使用完毕以后要关闭结果集 <code>ResultSet</code>，再关闭 <code>Statement</code>，再关闭 <code>Connection</code> 。</li></ul></li></ul><h3 id="练习：查询数据将其封装为对象装载进集合中"><a href="#练习：查询数据将其封装为对象装载进集合中" class="headerlink" title="练习：查询数据将其封装为对象装载进集合中"></a>练习：查询数据将其封装为对象装载进集合中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个方法，查询 account 表的数据将其封装为对象，然后装载集合，返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; list = <span class="keyword">new</span> JdbcDemo4().findAll();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有 Account 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///dbdemo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">            String sql = <span class="string">"select * from account"</span>;</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            Account account;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                <span class="keyword">double</span> balance = rs.getDouble(<span class="string">"balance"</span>);</span><br><span class="line"></span><br><span class="line">                account = <span class="keyword">new</span> Account(id, name, balance);</span><br><span class="line">                list.add(account);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", balance="</span> + balance +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽取-JdbcUtils-工具类"><a href="#抽取-JdbcUtils-工具类" class="headerlink" title="抽取 JdbcUtils 工具类"></a>抽取 JdbcUtils 工具类</h2><ul><li>目的：简化书写，便于代码复用</li><li>分析：<ol><li>注册驱动要抽取</li><li>抽取一个方法获取连接对象<ul><li>需求：不想传递参数，还得保证工具类的通用性</li><li>解决：配置文件（利用反射技术）</li></ul></li><li>抽取一个方法释放资源</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 加载配置文件</span></span><br><span class="line">            ClassLoader classLoader = JdbcUtils.class.getClassLoader();</span><br><span class="line">            URL resource = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            prop.load(<span class="keyword">new</span> FileReader(resource.getPath()));</span><br><span class="line"></span><br><span class="line">            driver = prop.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            url = prop.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = prop.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = prop.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdbc.properties</span></span><br><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">///dbdemo</span></span><br><span class="line">user=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><h2 id="PreparedStatement-接口"><a href="#PreparedStatement-接口" class="headerlink" title="PreparedStatement 接口"></a><code>PreparedStatement</code> 接口</h2><h3 id="SQL-注入问题"><a href="#SQL-注入问题" class="headerlink" title="SQL 注入问题"></a>SQL 注入问题</h3><ul><li>SQL 注入问题：<ul><li>在拼接 SQL 时，有一些 SQL 的特殊关键字参与字符串的拼接，改变了原有 SQL 的真正意义。</li><li>会造成安全性问题。</li><li>如：在登录问题中，如果密码输入 <code>a&#39; or &#39;1&#39;=&#39;1</code> ，最终拼接成的 SQL 将变成 <code>select * from user where name=&#39;newboy&#39; and password=&#39;a&#39; or &#39;1&#39;=&#39;1&#39;</code> ，错误的密码却登录成功。</li></ul></li><li>解决办法：<ul><li>使用 <code>PreparedStatement</code> 对象来解决。</li></ul></li></ul><h3 id="预编译的-SQL"><a href="#预编译的-SQL" class="headerlink" title="预编译的 SQL"></a>预编译的 SQL</h3><ul><li><code>PreparedStatement</code> 是 <code>Statement</code> 接口的子接口，继承于父接口中所有的方法。</li><li>它是一个预编译的 SQL 语句：<ul><li>SQL 的参数使用占位符 <code>?</code> 。</li><li>给 <code>?</code> 赋值使用 <code>setXxx(参数1, 参数2)</code> 方法：<ul><li>参数 1 ：<code>?</code> 的位置编号。从 1 开始。</li><li>参数 2 ：<code>?</code> 的值。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 键盘录入用户名和密码</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">        String username = sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">        String password = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用登录方法</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">new</span> JdbcDemo2().login(username, password);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"用户名或密码不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="keyword">null</span> || password == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接数据库判断是否登录成功</span></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line">            <span class="comment">// 定义 sql</span></span><br><span class="line">            String sql = <span class="string">"select * from user where username = ? and password = ?"</span>;</span><br><span class="line">            <span class="comment">// 获取执行 sql 的对象</span></span><br><span class="line">            pstmt = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">// 给 ? 赋值</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, username);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, password);</span><br><span class="line">            <span class="comment">// 执行 sql，不需要传递 sql</span></span><br><span class="line">            rs = pstmt.executeQuery();</span><br><span class="line">            <span class="keyword">return</span> rs.next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(rs, pstmt, conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PreparedStatement-的执行原理"><a href="#PreparedStatement-的执行原理" class="headerlink" title="PreparedStatement 的执行原理"></a><code>PreparedStatement</code> 的执行原理</h3><ul><li><code>Statement</code> 对象：<ul><li>每执行一条 SQL 语句，都会先将 SQL 语句发送到数据库，数据库先编译 SQL，再运行。</li><li>如果有多条类似的 SQL 语句，数据库需要重复编译多次，再执行多次，效率低。</li></ul></li><li><code>PreparedStatement</code> 对象：<ul><li>先将 SQL 语句发送给数据库预编译，然后引用预编译后的结果，可以多次传入不同的参数给对象并执行。</li><li>如果有多条类似的 SQL 语句，数据库只需要预编译 1 次，然后传入多次不同参数并执行，减少了 SQL 语句的编译次数，提高了执行效率。</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>后期都会使用 <code>PreparedStatement</code> 来完成增删改查的所有操作。<ol><li>防止 SQL 注入，安全性更高。</li><li>有预编译的功能，执行效率更高。</li><li>提高了程序的可读性。</li></ol></li></ul><h2 id="JDBC-管理事务"><a href="#JDBC-管理事务" class="headerlink" title="JDBC 管理事务"></a>JDBC 管理事务</h2><ul><li>事务：<ul><li>一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</li></ul></li><li>操作：<ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li>使用 <code>Connection</code> 对象来管理事务：<ol><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> ，调用该方法设置参数为 false，即开启事务。</li><li>提交事务：<code>commit()</code> ，当所有 SQL 都执行完提交事务。</li><li>回滚事务：<code>rollback()</code> ，在 <code>catch</code> 语句块中回滚事务。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取连接</span></span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 定义SQL语句</span></span><br><span class="line">            String sql1 = <span class="string">"update account set balance = balance - ? where id = ?"</span>;</span><br><span class="line">            String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line">            <span class="comment">// 获取执行SQL的对象</span></span><br><span class="line">            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">            <span class="comment">// 设置SQL参数</span></span><br><span class="line">            pstmt1.setDouble(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">            pstmt1.setInt(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">            pstmt2.setDouble(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">            pstmt2.setInt(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 执行SQL</span></span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            <span class="comment">// 手动制造异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            <span class="comment">// 所有SQL执行完毕，提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 捕捉到异常，SQL未执行完毕，回滚事务</span></span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(pstmt2, <span class="keyword">null</span>);</span><br><span class="line">            JdbcUtils.close(pstmt1, conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><ul><li>数据库连接池：<ul><li>概念：<ul><li>其实就是一个存放数据库连接的容器（集合）。</li></ul></li><li>好处：<ol><li>节约资源；</li><li>用户访问高效。</li></ol></li><li>实现：<ol><li>标准接口 <code>javax.sql.DataSource</code> 。<ul><li>获取连接：<code>getConnection()</code> </li><li>归还连接：<code>Connection.close()</code> ，如果连接对象 <code>Connection</code> 是从连接池中获取的，那么调用<code>Connection.close()</code> 方法，则不会再关闭连接了，而是归还连接。</li></ul></li><li>一般不去实现它，由数据库厂商来实现。<ul><li>C3P0</li><li>Druid（阿里巴巴提供的数据库连接池实现技术）</li></ul></li></ol></li></ul></li></ul><h2 id="Druid-连接池"><a href="#Druid-连接池" class="headerlink" title="Druid 连接池"></a>Druid 连接池</h2><ul><li>使用步骤<ol><li>导入 jar 包</li><li>定义配置文件：<ul><li>是 properties 形式的</li><li>可以叫任意名称，可以放在任意目录下</li></ul></li><li>加载配置文件：<code>Properties</code></li><li>获取数据库连接池对象：通过工厂类 <code>DruidDataSourceFactory</code> 来获取</li><li>获取连接：<code>getConnection</code> </li></ol></li></ul><h2 id="简单的连接池使用案例"><a href="#简单的连接池使用案例" class="headerlink" title="简单的连接池使用案例"></a>简单的连接池使用案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">        prop.load(is);</span><br><span class="line">        <span class="comment">// 获取数据库连接池</span></span><br><span class="line">        DataSource ds = DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">        <span class="comment">// 获取数据库连接</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽取-JdbcUtils-工具类-1"><a href="#抽取-JdbcUtils-工具类-1" class="headerlink" title="抽取 JdbcUtils 工具类"></a>抽取 JdbcUtils 工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用静态代码块给ds赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">            prop.load(JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        close(<span class="keyword">null</span>, stmt, conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 归还连接</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDemo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成添加操作，给account表增加一条记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line">            String sql = <span class="string">"insert into account values(null, ?, ?)"</span>;</span><br><span class="line">            pstmt = conn.prepareStatement(sql);</span><br><span class="line">            pstmt.setString(<span class="number">1</span>, <span class="string">"fangba"</span>);</span><br><span class="line">            pstmt.setDouble(<span class="number">2</span>, <span class="number">8000</span>);</span><br><span class="line">            <span class="keyword">int</span> count = pstmt.executeUpdate();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(pstmt, conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><ul><li>Spring 框架对 JDBC 进行了简单封装，提供了一个 <code>JdbcTemplate</code> 对象简化 JDBC 的开发。<ul><li>创建 <code>JdbcTemplate</code> 对象依赖于数据源 <code>DataSource</code>。</li><li>调用 <code>JdbcTemplate</code> 的方法来完成 CRUD 操作：<ul><li><code>update()</code> ：执行 DML语句（增删改）</li><li><code>queryForMap()</code> ：查询结果将结果集封装为 Map 集合<ul><li>将列名作为 key，将值作为 value，将这条记录封装为一个 Map 集合</li><li>注意：这个方法查询的结果集长度只能是 1</li></ul></li><li><code>queryForList()</code> ：查询结果将结果集封装为 List 集合<ul><li>注意：将每一条记录封装为一个 Map 集合，再将 Map 集合装载到 List 集合中</li></ul></li><li><code>query()</code> ：查询结果，将结果封装为 JavaBean 对象<ul><li>参数是 <code>RowMapper</code> ，一般我们使用 <code>BeanPropertyRowMapper</code> 实现类，可以完成数据到 JavaBean 的自动封装。</li><li><code>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</code> </li></ul></li><li><code>queryForObject</code> ：查询结果，将结果封装为对象<ul><li>一般用于聚合函数的查询</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建JdbcTemplate对象</span></span><br><span class="line">        JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JdbcUtils.getDataSource());</span><br><span class="line">        <span class="comment">// 调用方法，只关心如何定义SQL、如何执行以及如何处理结果</span></span><br><span class="line">        String sql = <span class="string">"update account set balance = 0 where id = ?"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql, <span class="number">3</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JdbcUtils.getDataSource());</span><br><span class="line">        String sql = <span class="string">"select * from account where id = ?"</span>;</span><br><span class="line">        <span class="comment">// 将列名作为 key，将值作为 value，将这条记录封装为一个 Map 集合</span></span><br><span class="line">        <span class="comment">// 注意：这个方法查询的结果集长度只能是 1</span></span><br><span class="line">        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JdbcUtils.getDataSource());</span><br><span class="line">        String sql = <span class="string">"select * from account"</span>;</span><br><span class="line">        <span class="comment">/*List&lt;Account&gt; list = template.query(sql, new RowMapper&lt;Account&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123;</span></span><br><span class="line"><span class="comment">                Account account = new Account();</span></span><br><span class="line"><span class="comment">                account.setId(resultSet.getInt("id"));</span></span><br><span class="line"><span class="comment">                account.setName(resultSet.getString("name"));</span></span><br><span class="line"><span class="comment">                account.setBalance(resultSet.getDouble("balance"));</span></span><br><span class="line"><span class="comment">                return account;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">        <span class="comment">// 不需要上述复杂操作</span></span><br><span class="line">        List&lt;Account&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Account.class));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JdbcUtils.getDataSource());</span><br><span class="line">        String sql = <span class="string">"select count(*) from account"</span>;</span><br><span class="line">        Long count = template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
          <category> JDBC入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> JDBC入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础</title>
      <link href="/2020/03/27/database-sql.html"/>
      <url>/2020/03/27/database-sql.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><ol><li>数据库的英文单词：<ul><li>DataBase（简称 DB）。</li></ul></li><li>什么是数据库？<ul><li>用于存储和管理数据的仓库。</li></ul></li><li>数据库的特点：<ol><li>持久化存储数据。其实数据库就是一个文件系统。</li><li>方便存储和管理数据。</li><li>使用了统一的方式操作数据库（SQL）。</li></ol></li><li>常见的数据库软件：<ol><li>Oarcle</li><li>MySQL</li><li>Microsoft SQL Server</li></ol></li><li>几个概念：<ol><li>数据库：相当于文件夹</li><li>表：相当于文件</li><li>数据记录：文件中存储的数据</li></ol></li></ol><h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h2 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h2><ol><li>什么是 SQL？<ul><li>Structured Query Language，结构化查询语言。</li><li>定义了操作所有关系型数据库的规则。</li><li>不同的数据库软件操作数据库的方式存在不一样的地方，类似“方言”。</li></ul></li><li>SQL 通用语法：<ol><li>SQL 语句可以单行或多行书写，以分号结尾。</li><li>可使用空格和缩进来增强语句的可读性。</li><li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li><li>3 种注释：<ul><li>单行注释:：<code>-- 注释内容</code> 或 <code># 注释内容</code>（MySQL 特有）</li><li>多行注释：<code>/* 注释 */</code> </li></ul></li></ol></li><li>SQL 分类：<ol><li>DDL（Data Definition Language）数据定义语言<ul><li>用来定义数据库对象：数据库，表，列等。</li><li>关键字：<code>create</code>，<code>drop</code>，<code>alter</code> 等。</li></ul></li><li>DML（Data Manipulation Language）数据操作语言<ul><li>用来对数据库中表的数据进行增删改。</li><li>关键字：<code>insert</code>，<code>delete</code>，<code>update</code> 等。</li></ul></li><li>DQL（Data Query Language）数据查询语言<ul><li>用来查询数据库中表的记录。</li><li>关键字：<code>select</code>，<code>where</code> 等。</li></ul></li><li>DCL（Data Control Language）数据控制语言<ul><li>用来定义数据库的访问权限和安全级别及创建用户。</li><li>关键字：<code>grant</code>，<code>revoke</code> 等。</li></ul></li></ol></li></ol><h2 id="DDL：操作数据库、表"><a href="#DDL：操作数据库、表" class="headerlink" title="DDL：操作数据库、表"></a>DDL：操作数据库、表</h2><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><ol><li>Create（创建）：<ul><li>创建数据库：<code>create database 数据库名称;</code> </li><li>当数据库不存在时创建数据库：<code>create database if not exists 数据库名称;</code> </li><li>创建数据库并指定字符集：<code>create database 数据库名称 character set 字符集名称;</code> </li></ul></li><li>Retrieve（查询）：<ul><li>查询所有数据库名称：<code>show databases;</code> </li><li>查询某个数据库的创建语句（可看到该数据库的字符集）：<code>show create database 数据库名称;</code> </li></ul></li><li>Update（修改）：<ul><li>修改数据库的字符集：<code>alter database 数据库名称 character set 字符集名称;</code> </li></ul></li><li>Delete（删除）：<ul><li>删除数据库：<code>drop database 数据库名称;</code> </li><li>判断数据库是否存在再删除：<code>drop database if exists 数据库名称;</code> </li></ul></li><li>使用数据库：<ul><li>查询正在使用的数据库名称：<code>select database();</code> </li><li>使用数据库：<code>use 数据库名称;</code> </li></ul></li></ol><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><ol><li>Create（创建）：<ul><li>语法：<code>create table 表名(列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n);</code> </li><li>复制表：<code>create table 表名 like 被复制的表名;</code> </li><li>SQL 中的数据类型：<ol><li><code>int</code> ：整数类型。</li><li><code>double</code> ：小数类型，格式：<code>double(m, d)</code> ，表示该小数最多含有 m 位数字，小数点后保留 d 位。</li><li><code>date</code> ：日期，只包含年月日，格式：<code>yyyy-MM-dd</code>。</li><li><code>datetime</code> ：日期，包含年月日时分秒，格式：<code>yyyy-MM-dd HH:mm:ss</code>。</li><li><code>timestamp</code> ：时间戳类型，包含年月日时分秒，格式：<code>yyyy-MM-dd HH:mm:ss</code>。<ul><li>如果将来不给这个字段赋值，或赋值为 <code>null</code>，则默认使用当前的系统时间来自动赋值。</li></ul></li><li><code>varchar</code> ：字符串，格式：<code>varchar(m)</code> ，表示最多存储 m 个字符。</li></ol></li></ul></li><li>Retrieve（查询）：<ul><li>查询某个数据库中的所有表名称：<code>show tables;</code> </li><li>查询表结构：<code>desc 表名;</code> </li></ul></li><li>Update（修改）： <ul><li>修改表名：<code>alter table 表名 rename to 新的表名;</code> </li><li>修改表的字符集：<code>alter table 表名 character set 字符集名称;</code> </li><li>添加列：<code>alter table 表名 add 列名 数据类型;</code> </li><li>修改列名：<code>alter table 表名 change 列名 新列名 新数据类型;</code> </li><li>修改列的数据类型：<code>alter table 表名 modify 列名 新数据类型;</code> </li><li>删除列：<code>alter table 表名 drop 列名;</code> </li></ul></li><li>Delete（删除）： <ul><li>删除表：<code>drop table 表名;</code> </li><li>判断表是否存在再删除：<code>drop table if exists 表名;</code> </li></ul></li></ol><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><ul><li>语法：<ul><li><code>insert into 表名(列名1, 列名2, ... 列名n) values (值1, 值2, ... 值n);</code> </li></ul></li><li>注意：<ol><li>列名和值要一一对应。</li><li>如果表名后，不定义列名，则默认给所有列添加值。<ul><li><code>insert into 表名 values(值1, 值2, ... 值n);</code> </li></ul></li><li>除了数字类型，其他类型需要使用引号（单双引号都可以）引起来。</li></ol></li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li>语法：<ul><li><code>delete from 表名 [where 条件];</code> </li></ul></li><li>注意：<ol><li>如果不加条件，则删除表中所有记录。</li><li>如果要删除所有记录：<ol><li><code>delete from 表名;</code> 不推荐使用。有多少条记录就会执行多少次删除操作。</li><li><code>truncate [table] 表名;</code> 推荐使用，效率更高。先删除表，然后再创建一张一样的表。</li></ol></li></ol></li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul><li>语法：<ul><li><code>update 表名 set 列名1 = 值1, 列名2 = 值2, ... [where 条件];</code> </li></ul></li><li>注意：<ul><li>如果不加任何条件，则会将表中所有记录全部修改。</li></ul></li></ul><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> 表名列表</span><br><span class="line"><span class="keyword">where</span> 条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组字段</span><br><span class="line"><span class="keyword">having</span> 分组之后的条件</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序字段 排序方式</span><br><span class="line"><span class="keyword">limit</span> 分页限定</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ol><li>多个字段的查询<ul><li><code>select 字段名1, 字段名2, ... from 表名;</code> </li><li>注意：如果查询所有字段，则可以使用 <code>*</code> 来代替所有字段。</li></ul></li><li>去除重复的结果集<ul><li>使用 <code>distinct</code> 关键字修饰字段列表。</li></ul></li><li>计算列<ul><li>一般可以使用四则运算计算一些列的值（一般只会进行数值型的计算）。</li><li>注意：<code>null</code> 参与的运算，结果都为 <code>null</code>。</li><li><code>ifnull(表达式1, 表达式2)</code> ：<ul><li><code>表达式1</code> ：哪个字段需要判断是否为 <code>null</code>；</li><li><code>表达式2</code> ：如果该字段为 <code>null</code> 后的替代值。</li></ul></li></ul></li><li>起别名<ul><li><code>as</code> 关键字（可以省略，字段名和别名之间加空格）。</li></ul></li></ol><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ol><li>为什么要条件查询？<ul><li>指定查询条件，对查询结果进行过滤。</li></ul></li><li>条件查询的语法：<ul><li><code>where</code> 子句后面写查询条件。</li><li><code>select 字段 from 表名 where 条件</code> </li></ul></li><li>比较运算符和逻辑运算符：<ol><li><code>&gt;</code> 、<code>&lt;</code> 、<code>&lt;=</code> 、<code>&gt;=</code> 、<code>=</code> 、<code>&lt;&gt;</code> </li><li><code>between...and</code> </li><li><code>in(集合)</code> </li><li><code>like</code>：模糊查询<ul><li>占位符：<ul><li><code>_</code> ：单个任意字符</li><li><code>%</code> ：多个任意字符</li></ul></li></ul></li><li><code>is (not) null</code> ：查询某一列（不）为 <code>null</code> 的值<ul><li>注意：null 值不能使用 <code>=</code> 或 <code>&lt;&gt;</code> 判断</li></ul></li><li><code>and</code> 或 <code>&amp;&amp;</code> </li><li><code>or</code> 或 <code>||</code> </li><li><code>not</code> 或 <code>!</code> </li></ol></li></ol><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul><li>排序：<ul><li><code>order by</code> 子句用于排序。</li><li>排序只是显示方式，不会影响数据库中数据的顺序。</li></ul></li><li>语法：<ul><li><code>order by 排序字段1 排序方式1, 排序字段2 排序方式2, ...;</code> </li></ul></li><li>排序方式：<ul><li><code>ASC</code> ：升序（默认）。</li><li><code>DESC</code>：降序。</li></ul></li><li>注意：<ul><li>如果有多个排序条件，则当前面的条件值一样时，才会判断第二个条件。</li></ul></li></ul><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li>聚合函数：将一列数据作为一个整体，进行纵向的计算。<ol><li><code>count</code> ：计算个数。<ol><li>一般选择非空的列，如主键；</li><li><code>count(*)</code> ：计算表中的记录个数。</li></ol></li><li><code>max</code> ：计算最大值</li><li><code>min</code> ：计算最小值。</li><li><code>sum</code> ：计算和。</li><li><code>avg</code> ：计算平均值。</li></ol></li><li>注意事项：聚合函数的计算，排除 <code>null</code> 值。<ul><li>解决办法：<ol><li>选择不包含非空的列进行计算；</li><li>使用 <code>ifnull</code> 函数指定 <code>null</code> 值的替代值。</li></ol></li></ul></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li>分组：<ul><li><code>group by</code> 子句用于分组。</li><li>将分组字段结果中相同内容作为一组，并且返回每组的第一条数据。</li></ul></li><li>语法：<ul><li><code>group by 分组字段 [having 分组之后的条件]</code> </li></ul></li><li>注意：<ol><li>单独分组没有什么用处，分组是为了统计。</li><li>分组之后查询的字段：分组字段、聚合函数。</li><li><code>where</code> 子句和 <code>having</code> 子句的区别？<ol><li>过滤时间不同：<ul><li><code>where</code> 子句在分组之前进行限定，如果不满足条件，则不参与分组。</li><li><code>having</code> 子句在分组之后进行限定，如果不满足结果，则不会被查询出来。</li></ul></li><li>使用聚合函数：<ul><li><code>where</code> 子句后面不可以使用聚合函数。</li><li><code>having</code> 子句后面可以进行聚合函数的判断。</li></ul></li></ol></li></ol></li></ul><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>分页：<ul><li><code>limit</code> 子句用于分页。</li><li>限制查询记录的条数。</li></ul></li><li>语法：<ul><li><code>limit offset(开始的索引), length(每页查询的条数)</code> </li><li>公式：<code>offset = (page - 1) * length</code> </li></ul></li><li>注意：<ul><li><code>limit</code> 是一个 MySQL 方言。</li><li>如果 <code>offset</code> 是 0，可以省略不写。</li><li>如果查询结果不够 <code>length</code> 条，有多少显示多少。</li></ul></li></ul><h2 id="DCL：管理用户与授权"><a href="#DCL：管理用户与授权" class="headerlink" title="DCL：管理用户与授权"></a>DCL：管理用户与授权</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ul><li>查询用户：<ul><li><code>select * from user;</code> </li></ul></li><li>创建用户：<ul><li><code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</code> <ul><li>主机名：指定用户在哪个主机上可以登录，<code>localhost</code> 表示本地用户，<code>%</code> 表示任意主机。</li><li>密码：可以为空。</li></ul></li></ul></li><li>删除用户：<ul><li><code>ddrop user &#39;用户名&#39;@&#39;主机名&#39;</code> </li></ul></li><li>修改用户密码：<ul><li><code>update user set password = password(&#39;新密码&#39;) where user = &#39;用户名&#39;;</code> </li><li><code>set password for &#39;用户名&#39;@&#39;主机名&#39; = password(&#39;新密码&#39;);</code> </li></ul></li></ul><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><ul><li>权限列表：<ul><li><code>create</code> </li><li><code>alter</code> </li><li><code>select</code> </li><li><code>insert</code> </li><li><code>update</code> </li><li><code>all</code> </li></ul></li><li>查询权限：<ul><li><code>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code> </li></ul></li><li>授予权限：<ul><li><code>grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code> </li></ul></li><li>撤销权限：<ul><li><code>revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</code> </li></ul></li></ul><h1 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h1><h2 id="约束的概念和分类"><a href="#约束的概念和分类" class="headerlink" title="约束的概念和分类"></a>约束的概念和分类</h2><ul><li>概念： <ul><li>对表中的数据进行限定，保证数据的正确性、有效性和完整性。</li><li>一个表如果添加了约束，不正确的数据将无法插入到表中。</li></ul></li><li>分类：<ol><li>主键约束：<code>primary key</code> </li><li>非空约束：<code>not null</code> </li><li>唯一约束：<code>unique</code> </li><li>外键约束：<code>foreign key</code> </li></ol></li></ul><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>非空约束：<code>not null</code>，值不能为空。</p><h3 id="非空约束基本语法格式"><a href="#非空约束基本语法格式" class="headerlink" title="非空约束基本语法格式"></a>非空约束基本语法格式</h3><ul><li>创建表时添加约束：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="comment">-- name为非空</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>创建表完后，添加非空约束：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>删除非空约束：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul><li>数据库中所有字段初始都默认为 <code>null</code>。</li><li>如果某个字段经常性地出现某个特定值，可以在一开始就设置为默认值，方便使用。</li><li>默认值关键字：<code>default</code> </li><li>创建表时，添加默认值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    address <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">'广州'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>使用字段列表添加记录，不给具有默认值的字段赋值，自动添加默认值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">2</span>, <span class="string">'李白'</span>);</span><br></pre></td></tr></table></figure><ul><li>不使用字段列表添加记录，给具有默认值的字段赋值 <code>default</code> ：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'李四'</span>, <span class="keyword">default</span>);</span><br></pre></td></tr></table></figure><ul><li>修改默认值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">alter</span> <span class="keyword">column</span> 字段名 <span class="keyword">set</span> <span class="keyword">default</span> 默认值;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 字段名 <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure><ul><li>删除默认值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">alter</span> <span class="keyword">column</span> 字段名 <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 字段名 <span class="keyword">default</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><p>唯一约束：<code>unique</code>，值不能重复。</p><ul><li>创建表时，添加唯一约束：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    phone_number <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span> <span class="comment">-- 添加了唯一约束</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：MySQL 中，唯一约束限定的列的值可以有多个 <code>null</code>。</p></blockquote><ul><li>在创建表后，添加唯一约束：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">modify</span> phone_number <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>;</span><br></pre></td></tr></table></figure><ul><li>删除唯一约束：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误 alter table stu modify phone_number varchar(20)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">drop</span> <span class="keyword">index</span> phone_number;</span><br></pre></td></tr></table></figure><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>主键约束：<code>primary key</code>。</p><ol><li>含义：非空且唯一。</li><li>一张表只能有一个主键。</li><li>主键可以是单个字段，也可以是多个字段。</li><li>主键用来唯一标识数据库中的每一条记录。</li></ol><h3 id="主键基本语法格式"><a href="#主键基本语法格式" class="headerlink" title="主键基本语法格式"></a>主键基本语法格式</h3><ul><li>在创建表时，添加主键约束：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, <span class="comment">-- 给id添加主键约束</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>创建完表后，添加主键：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><ul><li>删除主键：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误 alter table stu modify id int ;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure><h3 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h3><ul><li>概念：如果某一列是数值类型的，使用 <code>auto_increment</code> 可以来完成值得自动增长。</li><li>注意：自动增长大部分情况下都是与主键相关联。</li></ul><h4 id="自增基本语法格式"><a href="#自增基本语法格式" class="headerlink" title="自增基本语法格式"></a>自增基本语法格式</h4><ul><li>在创建表时，添加主键约束，并且完成主键自增：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, <span class="comment">-- 给id添加主键约束</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>在创建表后添加自动增长：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span> auto_increment;</span><br></pre></td></tr></table></figure><ul><li>删除自动增长：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">modify</span> <span class="keyword">id</span> <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure><h4 id="自增起始值的设置"><a href="#自增起始值的设置" class="headerlink" title="自增起始值的设置"></a>自增起始值的设置</h4><ul><li><code>auto_increment</code> 的默认起始值是 1。</li><li>创建表时，指定自增起始值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, <span class="comment">-- 给id添加主键约束</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">) auto_increment = 起始值;</span><br></pre></td></tr></table></figure><ul><li>创建表后，修改起始值：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 auto_increment = 起始值;</span><br></pre></td></tr></table></figure><h4 id="删除数据对自增的影响"><a href="#删除数据对自增的影响" class="headerlink" title="删除数据对自增的影响"></a>删除数据对自增的影响</h4><ul><li><code>delete</code> ：删除所有的记录之后，自增没有影响。</li><li><code>truncate</code> ：删除表并重建以后，自增又重新开始。</li></ul><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ul><li>外键约束：<code>foreign key</code>，让表与表产生关系，从而保证数据的正确性。</li><li>外键：在从表中引用主表主键的字段。<ul><li>从表：引用别人的数据，被别人约束。</li><li>主表：被别人引用数据，约束别人。</li></ul></li></ul><h3 id="外键基本语法格式"><a href="#外键基本语法格式" class="headerlink" title="外键基本语法格式"></a>外键基本语法格式</h3><ul><li>在创建表时，添加外键：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    ....,</span><br><span class="line">    外键列,</span><br><span class="line">    [<span class="keyword">constraint</span> 外键约束名称] <span class="keyword">foreign</span> <span class="keyword">key</span> (外键字段名称) <span class="keyword">references</span> 主表名称(主表字段名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>在创建表之后，添加外键：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> [<span class="keyword">constraint</span> 外键约束名称] <span class="keyword">foreign</span> <span class="keyword">key</span> (外键字段名称) <span class="keyword">references</span> 主表名称(主表字段名称);</span><br></pre></td></tr></table></figure><ul><li>删除外键：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">constraint</span> 外键约束名称;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> 外键字段名称;</span><br></pre></td></tr></table></figure><h3 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h3><ul><li>级联操作：<ul><li>在修改和删除主表的主键时，同时更新或删除副表的外键值。</li></ul></li><li>添加级联操作：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> [<span class="keyword">constraint</span> 外键约束名称] <span class="keyword">foreign</span> <span class="keyword">key</span> (外键字段名称) <span class="keyword">references</span> 主表名称(主表字段名称) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span> <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure><ul><li>分类：<ol><li>级联更新：<code>on update cascade</code> ，更新主表中的主键，从表中的外键列也自动同步更新。</li><li>级联删除：<code>on delete cascade</code> ，删除主表中的某记录，从表中的引用该主表记录主键的外键列对应的记录也自动同步删除。</li></ol></li></ul><h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><h2 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h2><ol><li>分类：<ol><li>一对一：<ul><li>如：人和身份证；</li><li>分析：一个人只有一个身份证，一个身份证只能对应一个人。</li></ul></li><li>一对多（多对一）：<ul><li>如：部门和员工；</li><li>分析：一个部门有多个员工，一个员工只能对应一个部门。</li></ul></li><li>多对多：<ul><li>如：学生和课程；</li><li>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择。</li></ul></li></ol></li><li>实现关系：<ol><li>一对一：<ul><li>实现方式：可以在任意一方添加唯一外键指向另一方的主键。合并在一张表中更为直接。</li></ul></li><li>一对多：<ul><li>实现方式：在多的一方（从表）建立外键，指向一的一方（主表）的主键。</li></ul></li><li>多对多：<ul><li>实现方式：需要借助第三张中间表，中间表至少包含两个字段，这两个字段作为中间表的外键，分别指向两张表的主键。</li></ul></li></ol></li></ol><h2 id="数据库设计的范式"><a href="#数据库设计的范式" class="headerlink" title="数据库设计的范式"></a>数据库设计的范式</h2><h3 id="范式的概念"><a href="#范式的概念" class="headerlink" title="范式的概念"></a>范式的概念</h3><ul><li>设计数据库时，需要遵循一些规范，来优化数据的设计和存储，这些规则就叫<strong>范式</strong>。</li><li>各种范式呈递次规范，越高的范式数据库<strong>冗余</strong>越小。</li><li>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</li><li>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。</li></ul><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><ul><li><strong>第一范式（1NF）</strong>：<ul><li>数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。</li><li>即表中的某个列有多个值时，必须拆分为不同的列。</li><li>简而言之，第一范式每一列不可再拆分，称为原子性。</li></ul></li></ul><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th><th>课程名称</th><th>分数</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>高等数学</td><td>95</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>大学英语</td><td>87</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>计算机基础</td><td>65</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法理学</td><td>77</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>87</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>65</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>95</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法理学</td><td>97</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>99</td></tr></tbody></table></div><ul><li>存在的问题：<ol><li>存在非常严重的数据冗余（重复数据）：<ul><li>如：姓名、系名、系主任</li></ul></li><li>数据添加存在问题：<ul><li>添加新开设的系和系主任时，数据不合法</li></ul></li><li>数据删除存在问题：<ul><li>张无忌同学毕业了，删除数据，会将系的数据一起删除。</li></ul></li></ol></li></ul><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><ul><li><strong>第二范式（2NF）</strong>：<ul><li>在 1NF 的基础上，非码属性必须完全依赖于候选码。</li><li>即在 1NF 基础上消除非主属性对主码的部分函数依赖。</li></ul></li><li><strong>函数依赖</strong>：<ul><li>如果通过 A 属性（组）的值，可以确定唯一 B 属性的值，则称 B 依赖于 A，记为 A → B。</li><li>如：学号 → 姓名，（学号，课程名称）→ 分数。</li></ul></li><li>完全函数依赖：<ul><li>如果 A 是一个属性组，则 B 属性值的确定需要依赖于 A 属性组中所有的属性值。</li><li>如：（学号，课程名称）→ 分数。</li></ul></li><li>部分函数依赖：<ul><li>如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些属性值。</li><li>如：（学号，课程名称）→ 姓名。</li></ul></li><li>传递函数依赖：<ul><li>如果通过 A 属性（组）的值，可以确定唯一 B 属性（组）的值，再通过 B 属性（组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A。即 A → B → C。</li><li>如：学号 → 姓名 → 系主任。</li></ul></li><li>码：<ul><li>如果在一张表中，一个属性（组），被其他所有属性所完全依赖，则称这个属性（组）为该表的码。</li><li>如：（学号，课程名称）是上表的码。</li></ul></li><li>主属性：<ul><li>码属性组中的所有属性。</li></ul></li><li>非主属性：<ul><li>除码属性组外的属性。</li></ul></li></ul><div class="table-container"><table><thead><tr><th>学号</th><th>课程名称</th><th>分数</th></tr></thead><tbody><tr><td>10010</td><td>高等数学</td><td>95</td></tr><tr><td>10010</td><td>大学英语</td><td>87</td></tr><tr><td>10010</td><td>计算机基础</td><td>65</td></tr><tr><td>10011</td><td>法理学</td><td>77</td></tr><tr><td>10011</td><td>大学英语</td><td>87</td></tr><tr><td>10011</td><td>法律社会学</td><td>65</td></tr><tr><td>10012</td><td>法律社会学</td><td>95</td></tr><tr><td>10012</td><td>法理学</td><td>97</td></tr><tr><td>10012</td><td>大学英语</td><td>99</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td></tr></tbody></table></div><ul><li>存在的问题：<ol><li>数据添加存在问题：<ul><li>添加新开设的系和系主任时，数据不合法</li></ul></li><li>数据删除存在问题：<ul><li>张无忌同学毕业了，删除数据，会将系的数据一起删除。</li></ul></li></ol></li></ul><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><ul><li><strong>第三范式（3NF）</strong>：<ul><li>在 2NF 基础上，任何非主属性不依赖于其它非主属性。</li><li>即在 2NF 基础上消除传递函数依赖。</li></ul></li></ul><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>系名</th><th>系主任</th></tr></thead><tbody><tr><td>经济系</td><td>张三丰</td></tr><tr><td>法律系</td><td>任我行</td></tr><tr><td>计算机系</td><td>殷天正</td></tr></tbody></table></div><h3 id="三大范式小结"><a href="#三大范式小结" class="headerlink" title="三大范式小结"></a>三大范式小结</h3><ul><li><strong>1NF</strong>：原子性，表中每列不可再拆分。</li><li><strong>2NF</strong>：不产生局部依赖，一张表只描述一件事情。</li><li><strong>3NF</strong>：不产生传递依赖，表中每一列都直接依赖于主键，而不是通过其它列间接依赖于主键。</li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><ul><li>笛卡尔积：<ul><li>有两个集合 A，B，取这两个集合的所有组成情况。</li><li>要完成多表查询，需要消除无用的数据。</li></ul></li></ul><h2 id="表连接查询"><a href="#表连接查询" class="headerlink" title="表连接查询"></a>表连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><ul><li>内连接：<ul><li>用左边表的记录去匹配右边表的记录，如果符合条件的则显示。</li><li>如：<code>从表.外键 = 主表.主键</code> </li></ul></li><li>隐式内连接：<ul><li>看不到 <code>join</code> 关键字，条件使用 <code>where</code> 限定。</li><li><code>select 字段名 form 左表, 右表 where 条件;</code> </li></ul></li><li>显式内连接：<ul><li>使用 <code>inner join ... on ...</code> 语句。</li><li><code>select 字段名 from 左表 [inner] join 右表 on 条件;</code> </li></ul></li><li>内连接查询步骤：<ol><li>从哪些表查询；</li><li>条件是什么；</li><li>查询哪些字段。</li></ol></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul><li>外连接：<ul><li>用一张表的记录去匹配另一张表的记录，如果符合条件则显示，否则显示 <code>null</code>。</li><li>可以理解为：在内连接的基础上保证某个表的数据全部显示。</li></ul></li><li>左外连接：<ul><li>查询的是左表的所有数据以及两张表的交集部分。</li><li><code>select 字段名 from 左表 left [outer] join 右表 on 条件;</code> </li></ul></li><li>右外连接：<ul><li>查询的是右表的所有数据以及两张表的交集部分。</li><li><code>select 字段名 from 左表 right [outer] join 右表 on 条件;</code> </li></ul></li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul><li>子查询的概念：<ul><li>一个查询的结果作为另一个查询的条件。</li><li>有查询的嵌套，内部的查询称为子查询。</li><li>子查询要使用括号。</li></ul></li><li>子查询结果的三种情况：<ol><li>子查询结果是单行单列：<ul><li>子查询可以作为条件，父查询使用比较运算符做判断。</li></ul></li><li>子查询结果是多行单列：<ul><li>子查询可以作为条件，父查询使用运算符 <code>in</code> 来判断。</li></ul></li><li>子查询结果是多行多列：<ul><li>子查询可以作为一张虚拟表参与查询。</li><li>子查询作为表需要取别名，否则这张表没有名称无法访问表中的字段。</li></ul></li></ol></li></ul><h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h2><ul><li>什么是事务？<ul><li>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作<strong>要么同时成功，要么同时失败</strong>。</li><li>在实际的开发过程中，一个业务操作，往往是要多次访问数据库才能完成的。如果其中有一条 SQL 语句出现异常，这条 SQL 就可能执行失败。</li><li>事务执行是一个整体，所有的 SQL 语句都必须执行成功。如果其中有 1 条 SQL 语句出现异常，则所有的 SQL 语句都要回滚，整个业务执行失败。</li></ul></li></ul><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><ul><li>事务的操作：<ol><li><strong>开启事务</strong>：<code>start transaction</code> </li><li><strong>回滚事务</strong>：<code>rollback</code> </li><li><strong>提交事务</strong>：<code>commit</code> </li></ol></li><li>事务提交的两种方式：<ol><li>自动提交：<ul><li>每一条 DML 语句都会自动开启一个事务，语句执行完毕自动提交事务。</li><li>MySQL 数据库中的事务默认自动提交。</li></ul></li><li>手动提交：<ul><li>需要先开启事务，再提交事务。</li><li>Oracle 数据库默认手动提交事务。</li></ul></li></ol></li><li>事务的默认提交方式：<ul><li>查看事务的默认提交方式：<ul><li><code>select @@autocommit;</code> <ul><li><code>0</code> ：代表手动提交</li><li><code>1</code> ：代表自动提交</li></ul></li></ul></li><li>修改事务默认提交方式：<ul><li><code>set @@autocommit = 事务提交方式对应数值;</code> </li></ul></li></ul></li></ul><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><ul><li><strong>事务原理</strong>：<ul><li>事务开启之后, 所有的操作都会<strong>临时保存到事务日志</strong>中。</li><li>事务日志只有在得到 commit 命令才会同步到数据表中。</li><li>其他任何情况（如 rollback 或者断开连接）都会清空事务日志。</li></ul></li></ul><h2 id="回滚点"><a href="#回滚点" class="headerlink" title="回滚点"></a>回滚点</h2><ul><li>回滚点：<ul><li>在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。可以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为回滚点。</li></ul></li><li>回滚点的操作：<ul><li>设置回滚点：<code>savepoint 回滚点名字</code> </li><li>回到回滚点：<code>rollback to 回滚点名字</code> </li></ul></li><li>总结：<ul><li>设置回滚点可以让我们在失败的时候回到回滚点，而不是回到事务开启的时候。</li></ul></li></ul><h2 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h2><ol><li><strong>原子性</strong>（Atomicity）：<ul><li>每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功，要么都失败。</li></ul></li><li><strong>一致性</strong>（Consistency）：<ul><li>事务在执行前数据库的状态与执行后数据库的状态保持一致。事务操作前后，数据总量不变。</li></ul></li><li><strong>隔离性</strong>（Isolation）：<ul><li>事务与事务之间不应该相互影响，执行时保持隔离的状态。</li></ul></li><li><strong>持久性</strong>（Durability）：<ul><li>一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。</li></ul></li></ol><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="并发访问引起的问题"><a href="#并发访问引起的问题" class="headerlink" title="并发访问引起的问题"></a>并发访问引起的问题</h3><ul><li>事务在操作时的理想状态：多个事务之间是隔离的，相互独立，互不影响。</li><li>但是如果因为并发操作，多个事务操作同一批数据，则会引发一些并发访问的问题。</li><li>并发访问的问题：<ol><li><strong>脏读</strong>：<ul><li>一个事务读取到另一个事务尚未提交的数据。</li></ul></li><li><strong>不可重复读</strong>：<ul><li>一个事务中两次读取到的数据内容不一致。</li><li><code>update</code> 时引发的问题。</li></ul></li><li><strong>幻读</strong>：<ul><li>一个事务中两次读取到的数据数量不一致。</li><li><code>insert</code> 或 <code>delete</code> 时引发的问题。</li></ul></li></ol></li></ul><h3 id="事务的隔离级别-1"><a href="#事务的隔离级别-1" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><div class="table-container"><table><thead><tr><th>级别</th><th>名字</th><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>数据库默认隔离级别</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td></td><td>√</td><td>√</td><td>Oracle 和 SQL Server</td></tr><tr><td>3</td><td>可重复读</td><td>repeatable read</td><td></td><td></td><td>√</td><td>MySQL</td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li>串行化：<ul><li>将表锁定，当前事务结束后其他事务才能对表进行操作。</li></ul></li><li>注意：<ul><li>隔离级别从小到大，安全性越来越高，但是效率越来越低。</li></ul></li><li>数据库的隔离级别：<ul><li>查询全局事务隔离级别：<code>select @@tx_isolation</code> </li><li>修改全局事务隔离级别：<code>set global transaction isolation level 级别字符串</code> <ul><li>数据库重新登录才能看到隔离级别的变化。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据库基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 数据库基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级（6）JUnit、反射机制与注解</title>
      <link href="/2020/03/01/java-advanced-6.html"/>
      <url>/2020/03/01/java-advanced-6.html</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit-单元测试"><a href="#JUnit-单元测试" class="headerlink" title="JUnit 单元测试"></a>JUnit 单元测试</h1><p>测试分类：</p><ol><li><strong>黑盒测试</strong>：不需要写代码，给输入值，看程序是否能够输出期望的值。</li><li><strong>白盒测试</strong>：需要写代码的。关注程序具体的执行流程。</li></ol><p>JUnit（白盒测试）的使用步骤：</p><ol><li>定义一个测试类（测试用例）<ul><li>测试类名：被测试的类名 + Test</li><li>包名：xxx.xxx.xxx.test</li></ul></li><li>定义测试方法：可以独立运行<ul><li>方法名：test + 测试的方法名</li><li>返回值：void</li><li>参数列表：空参</li></ul></li><li>给方法加上 <code>@Test</code> 注解</li><li>导入 JUnit 依赖环境</li></ol><p>判定结果：</p><ul><li>红色：失败</li><li>绿色：成功</li><li>一般我们使用断言操作来处理结果<ul><li><code>Aseert.asertXXX(expected, actual)</code> </li></ul></li></ul><p>资源申请和释放：</p><ul><li><code>@Before</code> 注解：被修饰的方法会在测试方法之前自动被执行</li><li><code>@After</code> 注解：修饰的方法会在测试方法执行之后自动被执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaseadd.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加法运算：</span></span><br><span class="line"><span class="comment">     * 用于计算两个整数的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减法运算：</span></span><br><span class="line"><span class="comment">     * 用于计算两个整数的差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaseadd.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junitdemo.junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法：</span></span><br><span class="line"><span class="comment">     * 用于资源申请，所有测试方法之前都会先执行该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源释放方法：</span></span><br><span class="line"><span class="comment">     * 在所有方法执行完后，都会自动执行该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"close..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试add方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testAdd..."</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Calculator().add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试add方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testSub..."</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Calculator().sub(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">init...</span><br><span class="line">testAdd...</span><br><span class="line">close...</span><br><span class="line">init...</span><br><span class="line">testSub...</span><br><span class="line">close...</span><br></pre></td></tr></table></figure><h1 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h1><h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><ul><li>框架：半成品软件，可以在框架的基础上进行软件开发，简化代码。</li><li>反射：将类的各个组成部分封装为其他对象，这就是反射机制。<ol><li>可以在程序运行过程中，操作这些对象。</li><li>可以解耦，提高程序的可扩展性。</li></ol></li></ul><p><img src="/2020/03/01/java-advanced-6/Java代码的三个阶段.png" alt></p><p>预先定义 Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line">    <span class="keyword">protected</span> String b;</span><br><span class="line">    String c;</span><br><span class="line">    <span class="keyword">private</span> String d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", a='"</span> + a + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", b='"</span> + b + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", c='"</span> + c + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", d='"</span> + d + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat "</span> + food + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-Class-类对象"><a href="#获取-Class-类对象" class="headerlink" title="获取 Class 类对象"></a>获取 <code>Class</code> 类对象</h2><p>获取 <code>Class</code> 对象的方式：</p><ol><li><code>Class.forName(&quot;全类名&quot;)</code> ：将字节码文件加载进内存，返回 <code>Class</code> 对象。<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</li></ul></li><li><code>类名.class</code> ：通过类名的属性 <code>class</code> 获取。<ul><li>多用于参数的传递。</li></ul></li><li><code>对象.getClass()</code> ：<code>getClass()</code> 方法在 <code>Object</code> 类中定义着。<ul><li>多用于对象的获取字节码的方式。</li></ul></li></ol><p>注意：</p><ul><li>同一个字节码文件 <code>*.class</code> 在一次程序运行过程中，<strong>只会被加载一次</strong>，不论通过哪一种方式获取的 <code>Class</code> 对象都是同一个。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Class.forName("全类名")</span></span><br><span class="line">        Class&lt;?&gt; class1 = Class.forName(<span class="string">"javaseadd.domain.Person"</span>);</span><br><span class="line">        System.out.println(class1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类名.class</span></span><br><span class="line">        Class&lt;Person&gt; class2 = Person.class;</span><br><span class="line">        System.out.println(class2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象名.getClass()</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Class&lt;? extends Person&gt; class3 = p.getClass();</span><br><span class="line">        System.out.println(class3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较三个对象</span></span><br><span class="line">        System.out.println(class1 == class2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(class1 == class3); <span class="comment">// true</span></span><br><span class="line">        System.out.println(class2 == class3); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-Field-成员变量"><a href="#获取-Field-成员变量" class="headerlink" title="获取 Field 成员变量"></a>获取 <code>Field</code> 成员变量</h2><p>使用 <code>Class</code> 对象获取成员变量：</p><ul><li><code>Field[] getFields()</code> ：获取所有 <strong><code>public</code> 修饰</strong>的成员变量。</li><li><code>Field getField(String name)</code> ：获取指定名称的 <code>public</code> 修饰的成员变量。</li><li><code>Field[] getDeclaredFields()</code> ：获取所有的成员变量，<strong>不考虑修饰符</strong>。</li><li><code>Field getDeclaredField(String name)</code> ：获取指定名称的成员变量，不考虑修饰符。</li></ul><p><code>Field</code> 类的常用方法：</p><ul><li><code>get(Object obj)</code> ：获取值。</li><li><code>void set(Object obj, Object value)</code> ：设置值。</li><li><code>void setAccessible(boolean flag)</code> ：将此对象的 accessible 标志设置为指示的布尔值。<ul><li>flag 为 <code>true</code> ：忽略访问权限修饰符的安全检查（暴力反射）。</li><li>flag 为 <code>false</code> ：反射的对象将实施 Java 语言访问检查。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person类的Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        <span class="comment">// 创建一个Person类对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有公有成员变量</span></span><br><span class="line">        Field[] publicFields = personClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field publicField : publicFields) &#123;</span><br><span class="line">            System.out.println(publicField);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取公有成员变量a的值</span></span><br><span class="line">        Field a = personClass.getField(<span class="string">"a"</span>);</span><br><span class="line">        Object valueA = a.get(person);</span><br><span class="line">        System.out.println(valueA);</span><br><span class="line">        <span class="comment">// 设置公有成员变量a的值</span></span><br><span class="line">        a.set(person, <span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有成员变量</span></span><br><span class="line">        Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(declaredField);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取私有成员变量d</span></span><br><span class="line">        Field d = personClass.getDeclaredField(<span class="string">"d"</span>);</span><br><span class="line">        <span class="comment">// 设置accessible为true，忽略访问权限检查</span></span><br><span class="line">        d.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 获取私有成员变量d的值</span></span><br><span class="line">        Object valueD = d.get(person); <span class="comment">// 如果不忽略访问权限控制，会抛出IllegalAccessException</span></span><br><span class="line">        System.out.println(valueD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-Constructor-构造方法"><a href="#获取-Constructor-构造方法" class="headerlink" title="获取 Constructor 构造方法"></a>获取 <code>Constructor</code> 构造方法</h2><p>使用 <code>Class</code> 对象获取构造方法：</p><ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code> ：返回一个包含某些 <code>Constructor</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类的所有公共构造方法。</li><li><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code> ：返回一个 <code>Constructor</code> 对象，它反映此 <code>Class</code> 对象所表示的类的指定公共构造方法。</li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code> ：返回 <code>Constructor</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象表示的类声明的所有构造方法。</li><li><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code> ：返回一个 <code>Constructor</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定构造方法。</li></ul><p><code>Constructor</code> 类的常用方法：</p><ul><li><code>T newInstance(Object... initargs)</code> ：使用此 <code>Constructor</code> 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。<ul><li>如果获取的是空参构造方法来创建对象，可以使用 <code>Class</code> 对象的 <code>newInstance</code> 方法简化操作。</li></ul></li><li><code>void setAccessible(boolean flag)</code> ：将此对象的 accessible 标志设置为指示的布尔值。<ul><li>flag 为 <code>true</code> ：忽略访问权限修饰符的安全检查（暴力反射）。</li><li>flag 为 <code>false</code> ：反射的对象将实施 Java 语言访问检查。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有公有构造方法</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons = personClass.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; con : cons) &#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定的公有含参构造方法</span></span><br><span class="line">        Constructor&lt;Person&gt; constructor1 = personClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Person person1 = constructor1.newInstance(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取无参构造方法</span></span><br><span class="line">        Constructor&lt;Person&gt; constructor2 = personClass.getConstructor();</span><br><span class="line">        Person person2 = constructor2.newInstance();</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">        <span class="comment">// 使用Class类的newIinstance方法简化</span></span><br><span class="line">        Person person3 = personClass.newInstance();</span><br><span class="line">        System.out.println(person3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-Method-成员方法"><a href="#获取-Method-成员方法" class="headerlink" title="获取 Method 成员方法"></a>获取 <code>Method</code> 成员方法</h2><p>使用 <code>Class</code> 对象获取成员方法：</p><ul><li><code>Method[] getMethods()</code> ：返回一个包含某些 <code>Method</code> 对象的数组，这些对象反映此 <code>Class</code>  对象所表示的类或接口（<strong>包括</strong>那些由该类或接口声明的以及从超类和超接口<strong>继承的</strong>那些的类或接口）的公共 member 方法。</li><li><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> ：返回一个 <code>Method</code> 对象，它反映此 <code>Class</code> 对象所表示的类或接口的指定公共成员方法。</li><li><code>Method[] getDeclaredMethods()</code> ：返回 <code>Method</code> 对象的一个数组，这些对象反映此 <code>Class</code>  对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但<strong>不包括继承的方法</strong>。</li><li><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code> ：返回一个 <code>Method</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定已声明方法。</li></ul><p><code>Method</code> 类的常用方法：</p><ul><li><code>Object invoke(Object obj, Object... args)</code> ：执行方法。</li><li><code>String getName()</code> ：获取方法名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        Method eat1 = personClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line">        eat1.invoke(person);</span><br><span class="line"></span><br><span class="line">        Method eat2 = personClass.getMethod(<span class="string">"eat"</span>, String.class);</span><br><span class="line">        eat2.invoke(person,<span class="string">"diner"</span>);</span><br><span class="line"></span><br><span class="line">        Method[] methods = personClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射案例"><a href="#反射案例" class="headerlink" title="反射案例"></a>反射案例</h2><p>写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。</p><p>创建配置文件 prop.properties：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=javaseadd.domain.Person</span><br><span class="line">methodName=eat</span><br></pre></td></tr></table></figure><p>设计框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Properties集合</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        ClassLoader classLoader = ReflectTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">"prop.properties"</span>);</span><br><span class="line">        prop.load(is);</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="comment">// 获取配置文件中定义的数据</span></span><br><span class="line">        String className = prop.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = prop.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">        <span class="comment">// 加载类进入内存</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        Object obj = aClass.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class).newInstance(<span class="string">"王五"</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = aClass.getDeclaredMethod(methodName, String.class);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        method.invoke(obj, <span class="string">"food"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的概念和作用分类"><a href="#注解的概念和作用分类" class="headerlink" title="注解的概念和作用分类"></a>注解的概念和作用分类</h2><ul><li><strong>注解</strong>（Annotation），也叫元数据，一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释。</li><li><strong>作用分类</strong>：<ol><li><strong>编写文档</strong>：通过代码里标识的注解生成文档【生成文档 doc 文档】。</li><li><strong>代码分析</strong>：通过代码里标识的注解对代码进行分析【使用反射】。</li><li><strong>编译检查</strong>：通过代码里标识的注解让编译器能够实现基本的编译检查【例如 Override】。</li></ol></li></ul><h2 id="JDK-预定义的注解"><a href="#JDK-预定义的注解" class="headerlink" title="JDK 预定义的注解"></a>JDK 预定义的注解</h2><ul><li><code>@Override</code> ：检测被该注解标注的方法是否是继承自父类（接口）的。</li><li><code>@Deprecated</code> ：该注解标注的内容，表示已过时。</li><li><code>@SuppressWarnings</code> ：压制警告。一般传递参数 all： <code>@SuppressWarnings(&quot;all&quot;)</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AnnoDemo&#123;&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有缺陷</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 替代show1方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>注解定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123;</span><br><span class="line">    属性列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnoUse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnno</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>通过 <code>javap</code> 命令反编译 <code>class</code> 文件可以获得如下 <code>java</code> 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 注解名称 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>注解实质上就是一个<strong>接口</strong>，该接口默认<strong>继承 <code>Annotation</code> 接口</strong>。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>属性</strong>：就是接口中定义的<strong>抽象方法</strong>。</p><h4 id="属性的返回值类型"><a href="#属性的返回值类型" class="headerlink" title="属性的返回值类型"></a>属性的返回值类型</h4><p>属性的返回值类型有下列取值：</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Person &#123;</span><br><span class="line">    p1, p2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>; <span class="comment">// 基本数据类型</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "张三"</span>; <span class="comment">// 字符串String</span></span><br><span class="line">    <span class="function">Person <span class="title">per</span><span class="params">()</span> <span class="keyword">default</span> Person.p1</span>; <span class="comment">// 枚举</span></span><br><span class="line">    <span class="function">MyAnno <span class="title">anno</span><span class="params">()</span> <span class="keyword">default</span> @MyAnno</span>; <span class="comment">// 注解</span></span><br><span class="line">    String[] strs() <span class="keyword">default</span> &#123;<span class="string">"abc"</span>, <span class="string">"def"</span>&#125;; <span class="comment">// 以上类型的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h4><p>定义了属性，在使用时需要给属性赋值：</p><ol><li>如果定义属性时，使用 <code>default</code> 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是 <code>value</code>，则 <code>value</code> 可以省略，直接定义值即可。</li><li>数组赋值时，值使用 <code>{}</code> 包裹。如果数组中只有一个值，则 <code>{}</code> 可以省略。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnno</span>2(<span class="number">22</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnno</span>2(value = <span class="number">22</span>, per = Person.p2, strs = <span class="string">"hust"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><strong>元注解</strong>：用于描述注解的注解。</p><ol><li><code>@Target</code> ：描述注解能够作用的位置。<ul><li><code>ElementType</code> 是枚举类型，取值有以下几种：<ul><li><code>TYPE</code> ：可以作用于类上；</li><li><code>METHOD</code> ：可以作用于方法上；</li><li><code>FIELD</code> ：可以作用于成员变量上。</li></ul></li></ul></li><li><code>@Retention</code> ：描述注解被保留的阶段。<ul><li><code>RetentionPolicy</code> 是枚举类型，取值有以下几种：<ul><li><code>SOURCE</code> ：当前被描述的注解，保留到 Java 源程序阶段，class 字节码文件中不会保留。</li><li><code>CLASS</code> ：当前被描述的注解，会保留到 class 字节码文件中，但是不会被 JVM 读取到。</li><li><code>RUNTIME</code> ：当前被描述的注解，会保留到 class 字节码文件中，并被 JVM 读取到。</li></ul></li></ul></li><li><code>@Documented</code> ：描述注解是否被抽取到 API 文档中。</li><li><code>@Inherited</code> ：描述注解是否被子类继承。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno3 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnno</span>3</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnno</span>3</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"ffx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnno</span>3</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Worker 3 work!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p><strong>解析注解</strong>：在程序中获取注解中定义的属性值。</p><ol><li>获取注解定义的位置的对象（Class，Method，Field）；</li><li>获取指定的注解（<code>getAnnotation(class)</code>）；</li><li>调用注解中的抽象方法获取配置的属性值。</li></ol><p>定义一个 Prop 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述需要执行的类名和方法名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Prop &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解来改写之前的框架类反射案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 框架类：不改变类的任何代码，可以创建任意类的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Prop</span>(className = <span class="string">"annotation.selfdefined.Worker3"</span>, methodName = <span class="string">"work"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取框架类的字节码文件对象</span></span><br><span class="line">        Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上边的注解对象</span></span><br><span class="line">        Prop anno = reflectTestClass.getAnnotation(Prop.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getAnnotation方法实际上是在内存中生成了一个该注解接口的子类实现类对象</span></span><br><span class="line">        <span class="comment">/*public class ProImpl implements Prop &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String className() &#123;</span></span><br><span class="line"><span class="comment">                return "annotation.selfdefined.Worker3";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String methodName() &#123;</span></span><br><span class="line"><span class="comment">                return "work";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用注解对象中定义的抽象方法，获取返回值</span></span><br><span class="line">        String className = anno.className();</span><br><span class="line">        String methodName = anno.methodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载类进内存</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">        <span class="comment">// 创建类的实例对象</span></span><br><span class="line">        Object obj = aClass.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        aClass.getDeclaredMethod(methodName).invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例：简单的测试框架"><a href="#案例：简单的测试框架" class="headerlink" title="案例：简单的测试框架"></a>案例：简单的测试框架</h2><p>定义一个 Check 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要测试的类的方法加上 Check 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小明定义的计算器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(str.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"1 + 0 = "</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 - 0 = "</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乘法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 * 0 = "</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 / 0 = "</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"永无bug..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="comment">// 通过类对象来获取所有的方法</span></span><br><span class="line">        Class&lt;? extends Calculator&gt; cls = calculator.getClass();</span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 记录出现异常的次数</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"JavaSEaddition\\src\\annotation\\selfdefined\\checkprogram\\bug.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试需要测试的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 判断方法是否有Check注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Check.class)) &#123;</span><br><span class="line">                <span class="comment">// 有Check注解则执行</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    method.invoke(calculator);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 捕获异常后记录到文件中</span></span><br><span class="line">                    count++;</span><br><span class="line">                    bw.write(method.getName() + <span class="string">" method has exception"</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"Exception name: "</span> + e.getCause().getClass().getSimpleName());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"What cause: "</span> + e.getCause().getMessage());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"-------------------"</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.write(<span class="string">"Total "</span> + count + <span class="string">" exception in this test!"</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>以后大多数时候，我们会使用注解，而不是自定义注解。</li><li>注解给谁用？<ul><li>编译器；</li><li>给解析程序用。</li></ul></li><li>注解不是程序的一部分，可以理解为注解就是一个标签。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java语言高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java语言高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级（5）网络编程与JDK8新特性</title>
      <link href="/2020/02/23/java-advanced-5.html"/>
      <url>/2020/02/23/java-advanced-5.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络通信概述"><a href="#网络通信概述" class="headerlink" title="网络通信概述"></a>网络通信概述</h1><h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><ul><li><strong>C/S 结构</strong> ：全称为 Client / Server 结构，是指客户端和服务器结构。</li><li><strong>B/S 结构</strong> ：全称为 Browser / Server 结构，是指浏览器和服务器结构。</li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li><li><strong>TCP/IP 协议：</strong> 传输控制协议 / 因特网互联协议（Transmission Control Protocol / Internet Protocol），是 Internet 最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型（链路层、网络层、传输层、应用层），每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><h2 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p> <code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><strong>UDP</strong>：用户数据报协议（User Datagram Protocol）。<ul><li>UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li><li>由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输。例如视频会议都使用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</li><li>但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用 UDP 协议。</li><li>特点：数据被限制在 64kb 以内，超出这个范围就不能发送了。</li></ul></li><li><strong>TCP</strong>：传输控制协议（Transmission Control Protocol）。<ul><li>TCP 协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</li><li>在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</li><li>三次握手：TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</li><li>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP 协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</li></ul></li></ul><h2 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则。</li></ul><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称 IP。IP 地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><h4 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h4><ul><li>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成 <code>a.b.c.d</code> 的形式，最多可以表示 42 亿个。</li><li>IPv6：由于互联网的蓬勃发展，IP 地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。为了扩大地址空间，通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping IP地址</span><br></pre></td></tr></table></figure><h4 id="特殊的-IP-地址"><a href="#特殊的-IP-地址" class="headerlink" title="特殊的 IP 地址"></a>特殊的 IP 地址</h4><ul><li>本机 IP 地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说 <strong>IP 地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是 0 ~ 65535 </strong>。其中，0 ~ 1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p><img src="/2020/02/23/java-advanced-5/端口号.png" alt></p><p>利用 <code>协议</code> + <code>IP地址</code> + <code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h1 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h1><h2 id="TCP-通信概述"><a href="#TCP-通信概述" class="headerlink" title="TCP 通信概述"></a>TCP 通信概述</h2><p>TCP 通信能实现两台计算机之间的数据交互，通信的两端要严格区分为客户端（Client）与服务器端（Server）。</p><p>两端通信时步骤：</p><ol><li>服务器端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务器端不可以主动连接客户端。</li><li>客户端与服务器端建立逻辑连接后，连接中会包含一个 IO 字节流对象，客户端与服务器端可以使用这个 IO 对象进行通信。</li></ol><p>在 Java 中，提供了两个类用于实现 TCP 通信程序：</p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建 <code>Socket</code> 对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建 <code>ServerSocket</code> 对象，相当于开启一个服务，并等待客户端的连接。</li></ol><p>服务器端必须明确两件事：</p><ol><li>多个客户端同时与服务器端交互，服务器端必须明确在和哪个客户端交互。<ul><li>服务器端有一个方法 <code>accept</code> 可以获取到请求的客户端对象。</li></ul></li><li>多个客户端同时与服务器端交互，服务器端必须使用多个 IO 对象。<ul><li>服务器端是没有 IO 流的，服务器端可以获取到请求的客户端对象 <code>Socket</code>，使用每个客户端 <code>Socket</code> 中提供的 IO 流与客户端进行交互。</li></ul></li></ol><p><img src="/2020/02/23/java-advanced-5/TCP通信的概述.png" alt></p><h2 id="Socket-类"><a href="#Socket-类" class="headerlink" title="Socket 类"></a><code>Socket</code> 类</h2><p>TCP 通信的客户端，向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据。</p><p>表示客户端的类：<code>Socket</code> 类。此类实现客户端套接字，套接字指的是两台设备之间通讯的端点，套接字是包含了 IP 地址和端口号的网络单位。</p><p>构造方法：</p><ul><li><code>public Socket(String host, int port)</code> ：创建一个流套接字并将其连接到指定主机上的指定端口号。<ul><li>如果指定的 host 是 <code>null</code> ，则相当于指定地址为回送地址。  </li><li>回送地址（127.x.x.x）是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</li></ul></li></ul><p>成员方法：</p><ul><li><code>public InputStream getInputStream()</code> ：返回此套接字的输入流。<ul><li>如果此 <code>Scoket</code> 具有相关联的通道，则生成的 <code>InputStream</code> 的所有操作也关联该通道。</li><li>关闭生成的 <code>InputStream</code> 也将关闭相关的 <code>Socket</code>。</li></ul></li><li><code>public OutputStream getOutputStream()</code> ：返回此套接字的输出流。<ul><li>如果此 <code>Scoket</code> 具有相关联的通道，则生成的 <code>OutputStream</code> 的所有操作也关联该通道。</li><li>关闭生成的 <code>OutputStream</code> 也将关闭相关的 <code>Socket</code>。</li></ul></li><li><code>public void close()</code> ：关闭此套接字。<ul><li>一旦一个 <code>Socket</code> 被关闭，它不可再使用。</li><li>关闭此 <code>Socket</code> 也将关闭相关的 <code>InputStream</code> 和 <code>OutputStream</code> 。 </li></ul></li><li><code>public void shutdownOutput()</code> ：禁用此套接字的输出流。   <ul><li>对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。</li><li>如果在套接字上调用 <code>shutdownOutput()</code> 后写入套接字输出流，则该流将抛出 <code>IOException</code>。 </li></ul></li></ul><p>客户端的实现步骤：</p><ol><li>创建一个客户端对象 <code>Socket</code>，构造方法绑定服务器的 IP 地址和端口号；</li><li>使用 <code>Socket</code> 对象中的方法 <code>getOutputStream()</code> 获取网络字节输出流 <code>OutputStream</code> 对象；</li><li>使用网络字节输出流 <code>OutputStream</code> 对象中的方法 <code>write</code>，给服务器发送数据；</li><li>使用 <code>Socket</code> 对象中的方法 <code>getInputStream()</code> 获取网络字节输入流 <code>InputStream</code> 对象；</li><li>使用网络字节输入流 <code>InputStream</code> 对象中的方法 <code>read</code>，读取服务器回写的数据；</li><li>释放资源（<code>Socket</code>）。</li></ol><p>注意：</p><ol><li>客户端和服务器端进行交互，必须使用 <code>Socket</code> 中提供的网络流，不能使用自己创建的流对象。</li><li>当我们创建客户端对象 <code>Socket</code> 的时候，就会去请求服务器，和服务器经过三次握手建立连接通路。<ul><li>这时如果服务器没有启动，那么就会抛出异常 <code>ConnectException</code>。</li><li>如果服务器已经启动，那么就可以进行交互。</li></ul></li></ol><h2 id="ServerSocket-类"><a href="#ServerSocket-类" class="headerlink" title="ServerSocket 类"></a><code>ServerSocket</code> 类</h2><p>TCP 通信的服务器端，接收客户端的请求，读取客户端发送的数据，给客户端回写数据。</p><p>表示服务器的类：<code>ServerSocket</code> 类。此类实现了服务器套接字，该对象等待通过网络的请求。</p><p>构造方法：</p><ul><li><code>public ServerSocket(int port)</code> ：创建绑定到特定端口的服务器套接字。</li></ul><p>成员方法：</p><ul><li><code>public Socket accept()</code> ：侦听并接受到此套接字的连接。<ul><li>返回一个新的 <code>Socket</code> 对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul></li></ul><p>服务器的实现步骤：</p><ol><li>创建服务器 <code>ServerSocket</code> 对象向系统要指定的端口号；</li><li>使用 <code>ServerSocket</code> 对象中的方法 <code>accept</code>，获取到请求的客户端对象 <code>Socket</code>；</li><li>使用 <code>Socket</code> 对象中的方法 <code>getInputStream()</code> 获取网络字节输入流 <code>InputStream</code> 对象；</li><li>使用网络字节输入流 <code>InputStream</code> 对象中的方法 <code>read</code>，读取客户端发送的数据；</li><li>使用 <code>Socket</code> 对象中的方法 <code>getOutputStream()</code> 获取网络字节输出流 <code>OutputStream</code> 对象；</li><li>使用网络字节输出流 <code>OutputStream</code> 对象中的方法 <code>write</code>，给客户端回写数据；</li><li>释放资源（<code>Socket</code>，<code>ServerSocket</code>）。</li></ol><h2 id="简单的-TCP-通信程序"><a href="#简单的-TCP-通信程序" class="headerlink" title="简单的 TCP 通信程序"></a>简单的 TCP 通信程序</h2><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输出流OutputStream对象中的方法write,给服务器发送数据</span></span><br><span class="line">        os.write(<span class="string">"你好服务器"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输入流InputStream对象中的方法read,读取服务器回写的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源(Socket)</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器ServerSocket对象向系统要指定的端口号</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 使用ServerSocket对象中的方法accept,获取到请求的客户端对象Socket</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输入流InputStream对象中的方法read,读取客户端发送的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 使用网络字节输出流OutputStream对象中的方法write,给客户端回写数据</span></span><br><span class="line">        os.write(<span class="string">"收到谢谢"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 释放资源(Socket,ServerSocket)</span></span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络编程案例"><a href="#网络编程案例" class="headerlink" title="网络编程案例"></a>网络编程案例</h1><h2 id="案例：文件上传"><a href="#案例：文件上传" class="headerlink" title="案例：文件上传"></a>案例：文件上传</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p><img src="/2020/02/23/java-advanced-5/文件上传的原理.png" alt></p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件上传案例的客户端:读取本地文件,上传到服务器,读取服务器回写的数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源:c:\\1.jpg</span></span><br><span class="line"><span class="comment">        目的地:服务器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源</span></span><br><span class="line"><span class="comment">        2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号</span></span><br><span class="line"><span class="comment">        3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象</span></span><br><span class="line"><span class="comment">        4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件</span></span><br><span class="line"><span class="comment">        5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器</span></span><br><span class="line"><span class="comment">        6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象</span></span><br><span class="line"><span class="comment">        7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据</span></span><br><span class="line"><span class="comment">        8.释放资源(FileInputStream,Socket)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件上传案例服务器端:读取客户端上传的文件,保存到服务器的硬盘,给客户端回写"上传成功"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确:</span></span><br><span class="line"><span class="comment">        数据源:客户端上传的文件</span></span><br><span class="line"><span class="comment">        目的地:服务器的硬盘 d:\\upload\\1.jpg</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建一个服务器ServerSocket对象,和系统要指定的端口号</span></span><br><span class="line"><span class="comment">        2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象</span></span><br><span class="line"><span class="comment">        3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象</span></span><br><span class="line"><span class="comment">        4.判断d:\\upload文件夹是否存在,不存在则创建</span></span><br><span class="line"><span class="comment">        5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地</span></span><br><span class="line"><span class="comment">        6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件</span></span><br><span class="line"><span class="comment">        7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上</span></span><br><span class="line"><span class="comment">        8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象</span></span><br><span class="line"><span class="comment">        9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功"</span></span><br><span class="line"><span class="comment">        10.释放资源(FileOutputStream,Socket,ServerSocket)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        </span><br><span class="line">        File file =  <span class="keyword">new</span> File(<span class="string">"d:\\upload"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">"\\1.jpg"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.getOutputStream().write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        fos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="程序阻塞问题"><a href="#程序阻塞问题" class="headerlink" title="程序阻塞问题"></a>程序阻塞问题</h4><p>执行程序，客户端和服务器都不停止，进入阻塞状态，原因如下：</p><ul><li><code>InputStream</code> 类的 <strong><code>read</code> 方法：在输入数据可用、检测到文件末尾或者抛出异常前，此方法一直阻塞</strong>。</li><li><code>OutputStream</code> 对象的 <code>write</code> 方法在读取到结束标记后不会将文件结束标记写入，则服务器不会接收到文件结束标记，导致服务器端的网络字节输入流阻塞。</li><li>服务器端的网络字节输入流阻塞，就不会执行网络字节输出流给客户端回写数据，导致客户端的网络字节输入流接收不到数据而阻塞。</li></ul><p>解决方式：</p><ul><li>在上传完文件后，给服务器端写一个文件结束标记。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      解决:上传完文件,给服务器写一个结束标记</span></span><br><span class="line"><span class="comment">      void shutdownOutput() 禁用此套接字的输出流。</span></span><br><span class="line"><span class="comment">      对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">socket.shutdownOutput();</span><br></pre></td></tr></table></figure><p><img src="/2020/02/23/java-advanced-5/文件上传案例的阻塞问题.png" alt></p><h4 id="文件名称写死问题"><a href="#文件名称写死问题" class="headerlink" title="文件名称写死问题"></a>文件名称写死问题</h4><p>服务器端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      自定义一个文件的命名规则:防止同名的文件被覆盖</span></span><br><span class="line"><span class="comment">      规则:域名+毫秒值+随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String fileName = System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999</span>) + <span class="string">".jpg"</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">"\\"</span> + fileName);</span><br></pre></td></tr></table></figure><h4 id="循环接收问题"><a href="#循环接收问题" class="headerlink" title="循环接收问题"></a>循环接收问题</h4><p>服务器端，只保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      让服务器一直处于监听状态(死循环accept方法)</span></span><br><span class="line"><span class="comment">      有一个客户端上传文件,就保存一个文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h4><p>服务器端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用多线程技术,提高程序的效率</span></span><br><span class="line"><span class="comment">有一个客户端上传文件,就开启一个线程,完成文件的上传</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用匿名内部类和Lambda表达式优化</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 完成文件的上传</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为Runnable接口中run方法未声明异常，所以需要在方法体内try...catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h3 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h3><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        </span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//完成文件的上传</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       InputStream is = socket.getInputStream();</span><br><span class="line">                       </span><br><span class="line">                       File file =  <span class="keyword">new</span> File(<span class="string">"d:\\upload"</span>);</span><br><span class="line">                       <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">                           file.mkdirs();</span><br><span class="line">                       &#125;</span><br><span class="line">                       String fileName = System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999</span>) + <span class="string">".jpg"</span>;</span><br><span class="line">                       FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">"\\"</span> + fileName);</span><br><span class="line">                       </span><br><span class="line">                       <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                       <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                       <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                           fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                       socket.getOutputStream().write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                       </span><br><span class="line">                       fos.close();</span><br><span class="line">                       socket.close();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       System.out.println(e);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例：模拟-B-S-服务器"><a href="#案例：模拟-B-S-服务器" class="headerlink" title="案例：模拟 B/S 服务器"></a>案例：模拟 B/S 服务器</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务器端程序，查看网页效果。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p><img src="/2020/02/23/java-advanced-5/模拟BS服务器分析.png" alt></p><ol><li><p>准备页面数据，web 文件夹，复制到 Module 中。</p><p> <img src="/2020/02/23/java-advanced-5/复制.png" alt></p></li><li><p>模拟服务器端，<code>ServerSocket</code> 类监听端口，使用浏览器访问。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line">    socket.close();</span><br><span class="line">    server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息。</p><p> <img src="/2020/02/23/java-advanced-5/读取访问信息.jpg" alt></p><p>  <code>GET /web/index.html HTTP/1.1</code> 是浏览器的请求消息。<code>/web/index.html</code> 为浏览器想要请求的服务器端的资源，使用字符串切割方式获取到请求的资源。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">// 取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure></li></ol><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务器端实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     创建BS版本TCP服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个服务器ServerSocket,和系统要指定的端口号</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 使用accept方法获取到请求的客户端对象(浏览器)</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 把is网络字节输入流对象,转换为字符缓冲输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">// 把客户端请求信息的第一行读取出来 GET /11_Net/web/index.html HTTP/1.1</span></span><br><span class="line">        String line = br.readLine();</span><br><span class="line">        <span class="comment">// 把读取的信息进行切割,只要中间部分 /11_Net/web/index.html</span></span><br><span class="line">        String[] arr = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 把路径前边的/去掉,进行截取 11_Net/web/index.html</span></span><br><span class="line">        String htmlpath = arr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个本地字节输入流,构造方法中绑定要读取的html路径</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(htmlpath);</span><br><span class="line">        <span class="comment">// 使用Socket中的方法getOutputStream获取网络字节输出流OutputStream对象</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        os.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">        os.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一读一写复制文件,把服务读取的html文件回写到客户端</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><p><img src="/2020/02/23/java-advanced-5/效果图1.png" alt></p><p>发现浏览器中出现很多的叉子，说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问，因此在服务器端加入线程技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建BS版本TCP服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            浏览器解析服务器回写的html页面,页面中如果有图片,那么浏览器就会单独的开启一个线程,读取服务器的图片</span></span><br><span class="line"><span class="comment">            我们就的让服务器一直处于监听状态,客户端请求一次,服务器就回写一次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用accept方法获取到请求的客户端对象(浏览器)</span></span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        InputStream is = socket.getInputStream();</span><br><span class="line">                        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">                        </span><br><span class="line">                        String line = br.readLine();</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                        String[] arr = line.split(<span class="string">" "</span>);</span><br><span class="line">                        String htmlpath = arr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        FileInputStream fis = <span class="keyword">new</span> FileInputStream(htmlpath);</span><br><span class="line">                        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">                        os.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                        os.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">                        os.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        fis.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问效果：</p><p><img src="/2020/02/23/java-advanced-5/效果图2.png" alt></p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h2 id="函数式接口的定义"><a href="#函数式接口的定义" class="headerlink" title="函数式接口的定义"></a>函数式接口的定义</h2><p>函数式接口在 Java 中是指：<strong>有且仅有一个抽象方法的接口</strong>。 </p><p>函数式接口，即适用于函数式编程场景的接口。而 Java 中的函数式编程体现就是 Lambda，所以函数式接口就是可以适用于 Lambda 使用的接口。只有确保接口中有且仅有一个抽象方法，Java 中的 Lambda 才能顺利地进行推导。 </p><p>备注：“<strong>语法糖</strong>”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的 <code>for-each</code> 语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java 中的 Lambda 可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。 </p><p>函数式接口的定义格式：只要确保接口中有且仅有一个抽象方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值类型 方法名称(参数列表);</span><br><span class="line">    <span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FunctionalInterface-注解"><a href="#FunctionalInterface-注解" class="headerlink" title="@FunctionalInterface 注解"></a><code>@FunctionalInterface</code> 注解</h2><p>与 <code>@Override</code> 注解的作用类似，Java 8 中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code> 。该注解可用于一个接口的定义上，用来检测一个接口是否是一个函数式接口。</p><ul><li>是函数式接口：编译成功；</li><li>不是函数式接口：编译失败（接口中没有抽象方法，或抽象方法的个数多于 1 个）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义函数式接口并使用"><a href="#自定义函数式接口并使用" class="headerlink" title="自定义函数式接口并使用"></a>自定义函数式接口并使用</h2><p>函数式接口的使用：一般可以作为方法的参数和返回值类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFunctionalInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用普通实现类重写接口中的抽象方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,参数使用函数式接口MyFunctionalInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(MyFunctionalInterface myInter)</span></span>&#123;</span><br><span class="line">        myInter.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用show方法,方法的参数是一个接口,所以可以传递接口的实现类对象</span></span><br><span class="line">        show(<span class="keyword">new</span> MyFunctionalInterfaceImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用show方法,方法的参数是一个接口,所以我们可以传递接口的匿名内部类</span></span><br><span class="line">        show(<span class="keyword">new</span> MyFunctionalInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用匿名内部类重写接口中的抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用show方法,方法的参数是一个函数式接口,所以我们可以Lambda表达式</span></span><br><span class="line">        show(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化Lambda表达式</span></span><br><span class="line">        show(() -&gt; System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>在兼顾面向对象特性的基础上，Java 语言通过 Lambda 表达式与方法引用等，为开发者打开了函数式编程的大门。</p><h2 id="Lambda-的延迟执行"><a href="#Lambda-的延迟执行" class="headerlink" title="Lambda 的延迟执行"></a>Lambda 的延迟执行</h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而 Lambda 表达式是延迟执行的，这正好可以 作为解决方案，提升性能。 </p><h3 id="性能浪费的日志案例"><a href="#性能浪费的日志案例" class="headerlink" title="性能浪费的日志案例"></a>性能浪费的日志案例</h3><p>日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoLogger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个根据日志的级别,显示日志信息的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(<span class="keyword">int</span> level, String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对日志的等级进行判断,如果是1级别,那么输出日志信息</span></span><br><span class="line">        <span class="keyword">if</span>(level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义三个日志信息</span></span><br><span class="line">        String msg1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String msg2 = <span class="string">"World"</span>;</span><br><span class="line">        String msg3 = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用showLog方法,传递日志级别和日志信息</span></span><br><span class="line">        showLog(<span class="number">2</span>, msg1 + msg2 + msg3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码存在问题：无论级别是否满足要求，作为 <code>showLog</code> 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 </p><h3 id="Lambda-优化"><a href="#Lambda-优化" class="headerlink" title="Lambda 优化"></a>Lambda 优化</h3><p>使用 Lambda 需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个拼接消息的抽象方法,返回被拼接的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">buildMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 showLog 方法进行改造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Lambda</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个显示日志的方法,方法的参数传递日志的等级和MessageBuilder接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder mb)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对日志的等级进行判断,如果是1级,则调用MessageBuilder接口中的builderMessage方法</span></span><br><span class="line">        <span class="keyword">if</span>(level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(mb.buildMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义三个日志信息</span></span><br><span class="line">        String msg1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String msg2 = <span class="string">"World"</span>;</span><br><span class="line">        String msg3 = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用showLog方法,参数MessageBuilder是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        showLog(<span class="number">1</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"不满足条件不执行"</span>);</span><br><span class="line">            <span class="comment">// 返回一个拼接好的字符串</span></span><br><span class="line">            <span class="keyword">return</span> msg1 + msg2 + msg3;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Lambda 表达式作为参数传递，仅仅是把参数传递到 <code>showLog</code> 方法中。</p><ul><li>只有满足条件，日志的等级是 1 级，才会调用接口 <code>MessageBuilder</code> 中的方法 <code>builderMessage</code>，进行字符串的拼接；</li><li>如果条件不满足，日志的等级不是 1 级，那么 <code>MessageBuilder</code> 接口中的方法 <code>builderMessage</code> 也不会执行，所以拼接字符串的代码也不会执行，不会存在性能的浪费。</li></ul><h2 id="使用-Lambda-作为方法的参数和返回值"><a href="#使用-Lambda-作为方法的参数和返回值" class="headerlink" title="使用 Lambda 作为方法的参数和返回值"></a>使用 Lambda 作为方法的参数和返回值</h2><p>如果抛开实现原理不说，Java 中的 Lambda 表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用 Lambda 表达式进行替代。使用 Lambda 表达式作为方法参数，其实就是使用函数式接口作为方法参数。</p><p>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 <code>startThread</code> 方法使用该接口作为参数，那么就可以使用 Lambda 进行传参。这种情况其实和 <code>Thread</code> 类的构造方法参数为 <code>Runnable</code> 没有本质区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable run)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用startThread方法,方法的参数是一个接口,那么我们可以传递这个接口的匿名内部类</span></span><br><span class="line">        startThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"线程启动了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用startThread方法,方法的参数是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        startThread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"线程启动了"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        startThread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"线程启动了"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个 Lambda 表达式。当需要通过一个方法来获取一个 <code>java.util.Comparator</code> 接口类型的对象作为排序器时，就可以调该方法获取。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法的返回值类型是一个接口,那么我们可以返回这个接口的匿名内部类</span></span><br><span class="line">        <span class="comment">/*return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">                return o2.length() - o1.length();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法的返回值类型是一个函数式接口,所有我们可以返回一个Lambda表达式</span></span><br><span class="line">        <span class="comment">/*return (String o1, String o2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            return o2.length() - o1.length();</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续优化Lambda表达式</span></span><br><span class="line">        <span class="keyword">return</span> (o1, o2) -&gt; o2.length() - o1.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"aaa"</span>,<span class="string">"b"</span>,<span class="string">"cccccc"</span>,<span class="string">"dddddddddddd"</span>&#125;;</span><br><span class="line">        <span class="comment">// 输出排序前的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [aaa, b, cccccc, dddddddddddd]</span></span><br><span class="line">        <span class="comment">// 调用Arrays中的sort方法,对字符串数组进行排序</span></span><br><span class="line">        Arrays.sort(arr, getComparator());</span><br><span class="line">        <span class="comment">// 输出排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [dddddddddddd, cccccc, aaa, b]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h1><p>JDK 8 提供了大量常用的函数式接口以丰富 Lambda 的典型使用场景，它们主要在 <code>java.util.function</code> 包中被提供。</p><h2 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a><code>Supplier</code> 接口</h2><p> <code>java.util.function.Supplier&lt;T&gt;</code> 接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的 <code>get</code> 方法就会生产什么类型的数据。</p><h3 id="抽象方法-get"><a href="#抽象方法-get" class="headerlink" title="抽象方法 get"></a>抽象方法 <code>get</code></h3><p> <code>Supplier&lt;T&gt;</code> 接口仅包含一个无参的方法 <code>T get()</code>，用来获取一个泛型参数指定类型的对象数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSupplier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,方法的参数传递Supplier&lt;T&gt;接口,泛型执行String,get方法就会返回一个String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用getString方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        String s1 = getString(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 生产一个字符串,并返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"胡歌"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        String s2 = getString(() -&gt; <span class="string">"胡歌"</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习：求数组元素最大值"><a href="#练习：求数组元素最大值" class="headerlink" title="练习：求数组元素最大值"></a>练习：求数组元素最大值</h3><p>练习使用 <code>Supplier</code> 接口作为方法参数类型，通过 Lambda 表达式求出 int 数组中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 方法的参数传递Supplier接口,泛型使用Integer</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sup.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">880</span>,<span class="number">99</span>,<span class="number">33</span>,-<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">// 调用getMax方法,方法的参数Supplier是一个函数式接口,传递Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; max) &#123;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"数组中元素的最大值是:"</span> + maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a><code>Consumer</code> 接口</h2><p> <code>java.util.function.Consumer&lt;T&gt;</code> 接口则正好与 <code>Supplier</code> 接口相反，它不是生产一个数据，而是<strong>消费</strong>一个数据，其数据类型由泛型决定。</p><h3 id="抽象方法-accept"><a href="#抽象方法-accept" class="headerlink" title="抽象方法 accept"></a>抽象方法 <code>accept</code></h3><p> <code>Consumer</code> 接口中包含抽象方法 <code>void accept(T t)</code>，意为消费一个指定泛型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递一个字符串的姓名</span></span><br><span class="line"><span class="comment">        方法的参数传递Consumer接口,泛型使用String</span></span><br><span class="line"><span class="comment">        可以使用Consumer接口消费字符串的姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> </span>&#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递字符串姓名,方法的另一个参数是Consumer接口,是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        method(<span class="string">"赵丽颖"</span>, (String name) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 消费方式:把字符串进行反转输出</span></span><br><span class="line">            String reName = <span class="keyword">new</span> StringBuffer(name).reverse().toString();</span><br><span class="line">            System.out.println(reName);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认方法-andThen"><a href="#默认方法-andThen" class="headerlink" title="默认方法 andThen"></a>默认方法 <code>andThen</code></h3><p>如果一个方法的参数和返回值全都是 <code>Consumer</code> 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是 <code>Consumer</code> 接口中的 <code>default</code> 方法 <code>andThen</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想实现组合，需要两个或多个 Lambda 表达式，而 <code>andThen</code> 的语义正是“一步接一步”操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAndThen</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,方法的参数传递一个字符串和两个Consumer接口,Consumer接口的泛型使用字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// con1.accept(s);</span></span><br><span class="line">        <span class="comment">// con2.accept(s);</span></span><br><span class="line">        <span class="comment">// 使用andThen方法,把两个Consumer接口连接到一起,在消费数据</span></span><br><span class="line">        con1.andThen(con2).accept(s); <span class="comment">// con1连接con2,先执行con1消费数据,再执行con2消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递一个字符串,两个Lambda表达式</span></span><br><span class="line">        method(<span class="string">"Hello"</span>,</span><br><span class="line">               (t) -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 消费方式:把字符串转换为大写输出</span></span><br><span class="line">                   System.out.println(t.toUpperCase());</span><br><span class="line">               &#125;,</span><br><span class="line">               (t) -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 消费方式:把字符串转换为小写输出</span></span><br><span class="line">                   System.out.println(t.toLowerCase());</span><br><span class="line">               &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习：格式化打印信息"><a href="#练习：格式化打印信息" class="headerlink" title="练习：格式化打印信息"></a>练习：格式化打印信息</h3><p>字符串数组当中存有多条信息，请按照格式“ 姓名：XX。性别：XX。 ”的格式将信息打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,参数传递String类型的数组和两个Consumer接口,泛型使用String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (String message : arr) &#123;</span><br><span class="line">            <span class="comment">// 使用andThen方法连接两个Consumer接口,消费字符串</span></span><br><span class="line">            con1.andThen(con2).accept(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用printInfo方法,传递一个字符串数组,和两个Lambda表达式</span></span><br><span class="line">        printInfo(arr, (message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 消费方式:对message进行切割,获取姓名,按照指定的格式输出</span></span><br><span class="line">            String name = message.split(<span class="string">","</span>)[<span class="number">0</span>];</span><br><span class="line">            System.out.print(<span class="string">"姓名: "</span> + name + <span class="string">"。"</span>);</span><br><span class="line">        &#125;, (message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 消费方式:对message进行切割,获取年龄,按照指定的格式输出</span></span><br><span class="line">            String age = message.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">            System.out.println(<span class="string">"年龄: "</span> + age + <span class="string">"。"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Predicate-接口"><a href="#Predicate-接口" class="headerlink" title="Predicate 接口"></a><code>Predicate</code> 接口</h2><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 <code>java.util.function.Predicate&lt;T&gt;</code> 接口。 </p><h3 id="抽象方法-test"><a href="#抽象方法-test" class="headerlink" title="抽象方法 test"></a>抽象方法 <code>test</code></h3><p> <code>Predicate</code> 接口中包含一个抽象方法 <code>boolean test(T t)</code> ，用于条件判断的场景，对某种数据类型的数据进行判断，结果返回一个 boolean 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        参数传递一个String类型的字符串</span></span><br><span class="line"><span class="comment">        传递一个Predicate接口,泛型使用String</span></span><br><span class="line"><span class="comment">        使用Predicate中的方法test对字符串进行判断,并把判断的结果返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  pre.test(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abcdef"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用checkString方法对字符串进行校验,参数传递字符串和Lambda表达式</span></span><br><span class="line">        <span class="comment">/*boolean b = checkString(s, (String str) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            // 对参数传递的字符串进行判断,判断字符串的长度是否大于5,并把判断的结果返回</span></span><br><span class="line"><span class="comment">            return str.length() &gt; 5;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, str -&gt; str.length() &gt; <span class="number">5</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认方法-and"><a href="#默认方法-and" class="headerlink" title="默认方法 and"></a>默认方法 <code>and</code></h3><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。</p><p>使用逻辑运算符构成逻辑表达式可以连接多个条件判断：与运算符 <code>&amp;&amp;</code> 、或运算符 <code>||</code> 和 非（取反）运算符 <code>!</code> 。</p><p> <code>Predicate</code> 接口中有一个方法 <code>and</code>，表示并且关系，也可以用于连接两个判断条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; <span class="keyword">this</span>.test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内部的两个判断条件，也是使用 <code>&amp;&amp;</code> 运算符连接起来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicateAnd</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,方法的参数,传递一个字符串</span></span><br><span class="line"><span class="comment">        传递两个Predicate接口</span></span><br><span class="line"><span class="comment">            一个用于判断字符串的长度是否大于5</span></span><br><span class="line"><span class="comment">            一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">            两个条件必须同时满足</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.and(pre2).test(s); <span class="comment">// 等价于 return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abcdef"</span>;</span><br><span class="line">        <span class="comment">// 调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串的长度是否大于5</span></span><br><span class="line">            <span class="keyword">return</span> str.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串中是否包含a</span></span><br><span class="line">            <span class="keyword">return</span> str.contains(<span class="string">"a"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认方法-or"><a href="#默认方法-or" class="headerlink" title="默认方法 or"></a>默认方法 <code>or</code></h3><p> <code>Predicate</code> 接口中有一个方法 <code>or</code>，表示或者关系，也可以用于连接两个判断条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内部的两个判断条件，也是使用 <code>||</code> 运算符连接起来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicateOr</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          定义一个方法,方法的参数,传递一个字符串</span></span><br><span class="line"><span class="comment">          传递两个Predicate接口</span></span><br><span class="line"><span class="comment">              一个用于判断字符串的长度是否大于5</span></span><br><span class="line"><span class="comment">              一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">          满足一个条件即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  pre1.or(pre2).test(s); <span class="comment">// 等价于 return pre1.test(s) || pre2.test(s);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"bc"</span>;</span><br><span class="line">        <span class="comment">// 调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串的长度是否大于5</span></span><br><span class="line">            <span class="keyword">return</span> str.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串中是否包含a</span></span><br><span class="line">            <span class="keyword">return</span> str.contains(<span class="string">"a"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认方法-negate"><a href="#默认方法-negate" class="headerlink" title="默认方法 negate"></a>默认方法 <code>negate</code></h3><p> <code>Predicate</code> 接口中有一个方法 <code>negate</code>，表示取反的意思。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicateNegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">          定义一个方法,方法的参数,传递一个字符串</span></span><br><span class="line"><span class="comment">          使用Predicate接口判断字符串的长度是否大于5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  pre.negate().test(s); <span class="comment">// 等效于 return !pre.test(s);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 调用checkString方法,参数传递字符串和Lambda表达式</span></span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断字符串的长度是否大于5,并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> str.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习：集合信息筛选"><a href="#练习：集合信息筛选" class="headerlink" title="练习：集合信息筛选"></a>练习：集合信息筛选</h3><p>数组当中有多条“姓名+性别”的信息，请通过 <code>Predicate</code> 接口的拼装将符合要求的字符串筛选到集合 ArrayList 中，需要同时满足两个条件：</p><ol><li>必须为女生；</li><li>姓名为4个字。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">filter</span><span class="params">(String[] arr, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个ArrayList集合,存储过滤之后的信息</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组,获取数组中的每一条信息</span></span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            <span class="comment">// 使用Predicate接口中的方法test对获取到的字符串进行判断</span></span><br><span class="line">            <span class="keyword">boolean</span> b = pre1.and(pre2).test(s);</span><br><span class="line">            <span class="comment">// 对得到的布尔值进行判断</span></span><br><span class="line">            <span class="keyword">if</span>(b) &#123;</span><br><span class="line">                <span class="comment">// 条件成立,两个条件都满足,把信息存储到ArrayList集合中</span></span><br><span class="line">                list.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把集合返回</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span>, <span class="string">"赵丽颖,女"</span> &#125;;</span><br><span class="line">        <span class="comment">// 调用filter方法,传递字符串数组和两个Lambda表达式</span></span><br><span class="line">        ArrayList&lt;String&gt; list = filter(array, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取字符串中的性别,判断是否为女</span></span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">","</span>)[<span class="number">1</span>].equals(<span class="string">"女"</span>);</span><br><span class="line">        &#125;, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取字符串中的姓名,判断长度是否为4个字符</span></span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">","</span>)[<span class="number">0</span>].length() == <span class="number">4</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a><code>Function</code> 接口</h2><p> <code>java.util.function.Function&lt;T, R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p><h3 id="抽象方法-apply"><a href="#抽象方法-apply" class="headerlink" title="抽象方法 apply"></a>抽象方法 <code>apply</code></h3><p> <code>Function</code> 接口中最主要的抽象方法为 <code>R apply(T t)</code>，根据类型 T 的参数获取类型 R 的结果。使用的场景如将 <code>String</code> 类型转换为 <code>Integer</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFunction</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递一个字符串类型的整数</span></span><br><span class="line"><span class="comment">        方法的参数传递一个Function接口,泛型使用&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">        使用Function接口中的方法apply,把字符串类型的整数,转换为Integer类型的整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> in = fun.apply(s);<span class="comment">//自动拆箱 Integer-&gt;int</span></span><br><span class="line">        System.out.println(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"1234"</span>;</span><br><span class="line">        <span class="comment">// 调用change方法,传递字符串类型的整数,和Lambda表达式</span></span><br><span class="line">        change(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把字符串类型的整数,转换为Integer类型的整数返回</span></span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 优化Lambda</span></span><br><span class="line">        change(s, str -&gt; Integer.parseInt(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认方法-andThen-1"><a href="#默认方法-andThen-1" class="headerlink" title="默认方法 andThen"></a>默认方法 <code>andThen</code></h3><p> <code>Function</code> 接口中有一个默认的 <code>andThen</code> 方法，用来进行组合操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法同样用于“先做什么，再做什么”的场景，和 <code>Consumer</code> 中的 <code>andThen</code> 差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    需求:</span></span><br><span class="line"><span class="comment">        把String类型的"123",转换为Inteter类型,把转换后的结果加10</span></span><br><span class="line"><span class="comment">        把增加之后的Integer类型的数据,转换为String类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFunctionAndThen</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        参数串一个字符串类型的整数</span></span><br><span class="line"><span class="comment">        参数再传递两个Function接口</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;Integer,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun1, Function&lt;Integer,String&gt; fun2)</span> </span>&#123;</span><br><span class="line">        String ss = fun1.andThen(fun2).apply(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"123"</span>;</span><br><span class="line">        change(s, (String str) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把字符串转换为整数+10</span></span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(str) + <span class="number">10</span>;</span><br><span class="line">        &#125;, (Integer i) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把整数转换为字符串</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="string">""</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 优化Lambda表达式</span></span><br><span class="line">        change(s, str -&gt; Integer.parseInt(str) + <span class="number">10</span>, i -&gt; i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习：自定义函数模型拼接"><a href="#练习：自定义函数模型拼接" class="headerlink" title="练习：自定义函数模型拼接"></a>练习：<strong>自定义函数模型拼接</strong></h3><p>请使用 <code>Function</code> 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"赵丽颖,20"</span>;</span><br></pre></td></tr></table></figure><ol><li>将字符串截取数字年龄部分，得到字符串；</li><li>将上一步的字符串转换成为 int 类型的数字；</li><li>将上一步的 int 数字累加 100，得到结果 int 数字。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        参数传递包含姓名和年龄的字符串</span></span><br><span class="line"><span class="comment">        参数再传递3个Function接口用于类型转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,String&gt; fun1, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;String,Integer&gt; fun2, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;Integer,Integer&gt; fun3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用andThen方法把三个转换组合到一起</span></span><br><span class="line">        <span class="keyword">return</span> fun1.andThen(fun2).andThen(fun3).apply(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"赵丽颖,20"</span>;</span><br><span class="line">        <span class="keyword">int</span> num = change(str, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// "赵丽颖,20"-&gt;"20"</span></span><br><span class="line">           <span class="keyword">return</span> s.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">        &#125;, (String s) -&gt; &#123;</span><br><span class="line">            <span class="comment">// "20"-&gt;20</span></span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">        &#125;, (Integer i) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 20-&gt;120</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a><code>Stream</code> 流</h1><p>说到 <code>Stream</code> 便容易想到 I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在 Java 8 中，得益于 Lambda 所带来的函数式编程，引入了一个<strong>全新的 <code>Stream</code> 概念</strong>，用于解决已有集合类库既有的弊端。</p><h2 id="流式思想"><a href="#流式思想" class="headerlink" title="流式思想"></a>流式思想</h2><h3 id="传统集合的循环遍历弊端"><a href="#传统集合的循环遍历弊端" class="headerlink" title="传统集合的循环遍历弊端"></a>传统集合的循环遍历弊端</h3><p>几乎所有的集合（如 <code>Collection</code> 接口或 <code>Map</code> 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。</p><p>使用传统方式对集合中的数据进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">        list.add(<span class="string">"赵敏"</span>);</span><br><span class="line">        list.add(<span class="string">"张强"</span>);</span><br><span class="line">        list.add(<span class="string">"张三丰"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">                listA.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; listB = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : listA) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                listB.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : listB) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 的 Lambda 让我们更加专注于<strong>做什么</strong>（What）而不是<strong>怎么做</strong>（How），这点此前结合内部类进行了对比说明。现在我们仔细体会上述代码，可以发现：</p><ul><li>for 循环的语法就是“怎么做”；</li><li>for 循环的循环体才是“做什么”。</li></ul><p>上述代码中含有三个循环，每一个作用都不同：</p><ol><li>首先筛选所有姓张的人；</li><li>然后筛选名字中有三个字的人；</li><li>最后对结果进行打印输出。</li></ol><p>为什么使用循环？因为要遍历。但是循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并<strong>不是从第一个到最后一个顺次进行处理的循环</strong>。前者是方式，后者是目的。</p><h3 id="Stream-的更优写法"><a href="#Stream-的更优写法" class="headerlink" title="Stream 的更优写法"></a><code>Stream</code> 的更优写法</h3><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是。</strong>循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。那 Lambda 的衍生物 <code>Stream</code> 能给我们带来怎样更加优雅的写法呢？</p><p>使用 <code>Stream</code> 流的方式,遍历集合，对集合中的数据进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">        list.add(<span class="string">"赵敏"</span>);</span><br><span class="line">        list.add(<span class="string">"张强"</span>);</span><br><span class="line">        list.add(<span class="string">"张三丰"</span>);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">            .filter(name -&gt; name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">            .filter(name -&gt; name.length() == <span class="number">3</span>)</span><br><span class="line">            .forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流式思想概述"><a href="#流式思想概述" class="headerlink" title="流式思想概述"></a>流式思想概述</h3><p>整体来看，流式思想类似于工厂车间的“<strong>生产流水线</strong>”。 </p><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。</p><p><img src="/2020/02/23/java-advanced-5/流式思想示意图.png" alt></p><p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字 3 是最终结果。 </p><p>这里的 <code>filter</code>、<code>map</code>、<code>skip</code> 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 <code>count</code> 执行的时候，整个模型才会按照指定策略执行操作。而这得益于 Lambda 的延迟执行特性。</p><p><code>Stream</code>（流）是一个来自数据源的元素队列。</p><ul><li>元素是特定类型的对象，形成一个队列。 Java 中的 <code>Stream</code> 并<strong>不会存储元素</strong>，而是按需计算。 </li><li><strong>数据源</strong>（流的来源） 可以是集合、数组等。 </li></ul><p>和以前的 <code>Collection</code> 操作不同， <code>Stream</code> 操作还有两个基础的特征： </p><ul><li><strong>Pipelining</strong>：中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（flfluent style）。这样做可以对操作进行优化，比如延迟执行（laziness）和短路（short-circuiting）。 </li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过 <code>Iterator</code> 或者增强 for 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 <code>Stream</code> 提供了内部迭代的方式，流可以直接调用遍历方法。 </li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换 → 执行操作获取想要的结果，每次转换原有 <code>Stream</code> 对象不改变，返回一个新的 <code>Stream</code> 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。 </p><h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p> <code>java.util.stream.Stream&lt;T&gt;</code> 接口是 Java 8 新加入的最常用的流接口。（这并不是一个函数式接口。） </p><p>获取一个流非常简单，有以下几种常用的方式： </p><ol><li>所有的 <code>Collection</code> 集合都可以通过 <code>stream()</code> 默认方法获取流；<ul><li><code>default Stream&lt;E&gt; stream()</code> </li></ul></li><li><code>Stream</code> 接口的静态方法 <code>of(T... values)</code> 可以获取数组对应的流。<ul><li><code>static &lt;T&gt; Stream&lt;T&gt; of(T... values)</code> </li></ul></li></ol><h3 id="根据-Collection-获取流"><a href="#根据-Collection-获取流" class="headerlink" title="根据 Collection 获取流"></a>根据 <code>Collection</code> 获取流</h3><p>首先，<code>java.util.Collection</code> 接口中加入了 default 方法 <code>stream</code> 用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据-Map-获取流"><a href="#根据-Map-获取流" class="headerlink" title="根据 Map 获取流"></a>根据 Map 获取流</h3><p> <code>java.util.Map</code> 接口不是 <code>Collection</code> 的子接口，且其 K-V 数据结构不符合流元素的单一特征，所以获取对应的流需要分 key、value 或 entry 等情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取键,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; stream3 = keySet.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取值,存储到一个Collection集合中</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        Stream&lt;String&gt; stream4 = values.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取键值对(键与值的映射关系 entrySet)</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 <code>Stream</code> 接口中提供了静态方法 <code>of</code> ，使用很简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把数组转换为Stream流</span></span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 可变参数可以传递数组</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream7 = Stream.of(arr);</span><br><span class="line">        String[] arr2 = &#123;<span class="string">"a"</span>,<span class="string">"bb"</span>,<span class="string">"ccc"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream8 = Stream.of(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流的常用方法"><a href="#流的常用方法" class="headerlink" title="流的常用方法"></a>流的常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的 API。这些方法可以被分成两种： </p><ul><li><strong>延迟方法</strong>：返回值类型仍然是 <code>Stream</code> 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</li><li><strong>终结方法</strong>：返回值类型不再是 <code>Stream</code> 接口自身类型的方法，因此不再支持链式调用。本小节中，终结方法包括 <code>count</code> 和 <code>forEach</code> 方法。</li></ul><h3 id="逐一处理-forEach"><a href="#逐一处理-forEach" class="headerlink" title="逐一处理 forEach"></a>逐一处理 <code>forEach</code></h3><p>虽然方法名字叫 <code>forEach</code> ，但是与 for 循环中的 for-each 昵称不同。</p><p> <code>Stream</code> 流中的常用方法 <code>forEach</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法接收一个 <code>Consumer</code> 接口参数，会将每一个流元素交给该参数进行处理。<code>Consumer</code> 接口是一个消费型的函数式接口，可以传递 Lambda 表达式消费数据。</p><p>forEach 方法，用来<strong>遍历流中的数据</strong>，是一个<strong>终结方法</strong>，遍历之后就不能继续调用 <code>Stream</code> 流中的其他方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamForEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"赵六"</span>, <span class="string">"田七"</span>);</span><br><span class="line">        stream.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤 filter"></a>过滤 <code>filter</code></h3><p> <code>Stream</code> 流中的常用方法 <code>filter</code> ，用于对 <code>Stream</code> 流中的数据进行过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><p> <code>filter</code> 方法的参数 <code>Predicate</code> 是一个函数式接口，所以可以传递 Lambda 表达式，对数据进行过滤。</p><p>此前学习过 <code>Predicate</code> 中的抽象方法 <code>boolean test(T t)</code> ，该方法将会产生一个 boolean 值结果，代表指定的条件是否满足。</p><ul><li>如果结果为 <code>true</code>，那么 <code>Stream</code> 流的 <code>filter</code> 方法将会留用元素；</li><li>如果结果为 <code>false</code>，那么 <code>filter</code> 方法将会舍弃元素。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三丰"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        <span class="comment">// 对Stream流中的元素进行过滤,只要姓张的人</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.filter(name -&gt; name.startsWith(<span class="string">"张"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历stream2流</span></span><br><span class="line">        stream2.forEach(name -&gt; System.out.println(name));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历stream流</span></span><br><span class="line">        stream.forEach(name -&gt; System.out.println(name)); <span class="comment">// IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>Stream</code> 流属于管道流，只能被消费（使用）一次，上一个 <code>Stream</code> 流调用完毕方法，数据就会流转到下一个 <code>Stream</code> 上，而这时上一个 <code>Stream</code> 流已经使用完毕就会关闭，上一个 <code>Stream</code> 流再调用方法将会抛出 <code>IllegalStateException</code>。</p><h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 <code>map</code></h3><p> <code>Stream</code> 流中的常用方法 <code>map</code> 用于类型转换。如果需要将流中的元素映射到另一个流中，可以使用 <code>map</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>该接口需要一个 <code>Function</code> 函数式接口参数，可以将当前流中的 T 类型数据转换为另一种 R 类型的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>);</span><br><span class="line">        <span class="comment">// 使用map方法,把字符串类型的整数,转换(映射)为Integer类型的整数</span></span><br><span class="line">        Stream&lt;Integer&gt; stream2 = stream.map(s -&gt; Integer.parseInt(s));</span><br><span class="line">        <span class="comment">// 遍历Stream2流</span></span><br><span class="line">        stream2.forEach(i -&gt; System.out.println(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计个数-count"><a href="#统计个数-count" class="headerlink" title="统计个数 count"></a>统计个数 <code>count</code></h3><p> <code>Stream</code> 流中的常用方法 <code>count</code> ，用于统计 <code>Stream</code> 流中元素的个数，类似旧集合 <code>Collection</code> 当中的 <code>size</code> 方法一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p> <code>count</code> 方法是一个<strong>终结方法</strong>，返回值是一个 long 类型的整数，所以不能再继续调用 <code>Stream</code> 流中的其他方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        <span class="keyword">long</span> count = stream.count();</span><br><span class="line">        System.out.println(count); <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取用前几个元素-limit"><a href="#取用前几个元素-limit" class="headerlink" title="取用前几个元素 limit"></a>取用前几个元素 <code>limit</code></h3><p> <code>limit</code> 方法可以对流进行截取，只取用前 n 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure><p> <code>limit</code> 方法是一个延迟方法，只是对流中的元素进行截取，返回的是一个新的流，所以可以继续调用 <code>Stream</code> 流中的其他方法。参数是一个 long 型，如果集合当前长度大于参数则进行截取，否则不进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamLimit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>,<span class="string">"喜洋洋"</span>,<span class="string">"懒洋洋"</span>,<span class="string">"灰太狼"</span>,<span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 使用limit对Stream流中的元素进行截取,只要前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.limit(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 遍历stream2流</span></span><br><span class="line">        stream2.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳过前几个元素-skip"><a href="#跳过前几个元素-skip" class="headerlink" title="跳过前几个元素 skip"></a>跳过前几个元素 <code>skip</code></h3><p> <code>Stream</code> 流中的常用方法 <code>skip</code> ，用于跳过元素。如果希望跳过前几个元素，可以使用 <code>skip</code> 方法获取一个截取之后的新流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果流的当前长度大于 n，则跳过前 n 个；否则将会得到一个长度为 0 的空流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamSkip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>,<span class="string">"喜洋洋"</span>,<span class="string">"懒洋洋"</span>,<span class="string">"灰太狼"</span>,<span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 使用skip方法跳过前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.skip(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 遍历stream2流</span></span><br><span class="line">        stream2.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-concat"><a href="#组合-concat" class="headerlink" title="组合 concat"></a>组合 <code>concat</code></h3><p> <code>Stream</code> 流中的常用方法 <code>concat</code> ，用于把流组合到一起。如果有两个流，希望合并成为一个流，那么可以使用 <code>Stream</code> 接口的静态方法 <code>concat</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span>;</span><br></pre></td></tr></table></figure><p>这是一个静态方法，与 <code>java.lang.String</code> 当中的 <code>concat</code> 方法是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamConcat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"张三丰"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>, <span class="string">"喜洋洋"</span>, <span class="string">"懒洋洋"</span>, <span class="string">"灰太狼"</span>, <span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(arr);</span><br><span class="line">        <span class="comment">// 把以上两个流组合为一个流</span></span><br><span class="line">        Stream&lt;String&gt; concat = Stream.concat(stream1, stream2);</span><br><span class="line">        <span class="comment">// 遍历concat流</span></span><br><span class="line">        concat.forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><p>现在有两个 <code>ArrayList</code> 集合存储队伍当中的多个成员姓名，要求分别使用传统 for 循环和 <code>Stream</code> 流式处理依次进行以下若干操作步骤： </p><ol><li>第一个队伍只要名字为 3 个字的成员姓名，存储到一个新集合中。</li><li>第一个队伍筛选之后只要前 3 个人，存储到一个新集合中。</li><li>第二个队伍只要姓张的成员姓名，存储到一个新集合中。</li><li>第二个队伍筛选之后不要前 2 个人，存储到一个新集合中。</li><li>将两个队伍合并为一个队伍，存储到一个新集合中。</li><li>根据姓名创建 Person 对象，存储到一个新集合中。</li><li>打印整个队伍的 Person 对象信息。</li></ol><p>定义 Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传统-for-循环处理"><a href="#传统-for-循环处理" class="headerlink" title="传统 for 循环处理"></a>传统 for 循环处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoForTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        one.add(<span class="string">"宋远桥"</span>);</span><br><span class="line">        one.add(<span class="string">"苏星河"</span>);</span><br><span class="line">        one.add(<span class="string">"石破天"</span>);</span><br><span class="line">        one.add(<span class="string">"石中玉"</span>);</span><br><span class="line">        one.add(<span class="string">"老子"</span>);</span><br><span class="line">        one.add(<span class="string">"庄子"</span>);</span><br><span class="line">        one.add(<span class="string">"洪七公"</span>);</span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; one1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : one) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                one1.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; one2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            one2.add(one1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        two.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        two.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        two.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        two.add(<span class="string">"尼古拉斯赵四"</span>);</span><br><span class="line">        two.add(<span class="string">"张天爱"</span>);</span><br><span class="line">        two.add(<span class="string">"张二狗"</span>);</span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; two1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">                two1.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; two2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; two1.size(); i++) &#123;</span><br><span class="line">            two2.add(two1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        all.addAll(one2);</span><br><span class="line">        all.addAll(two2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : all) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Person(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream-流式处理"><a href="#Stream-流式处理" class="headerlink" title="Stream 流式处理"></a><code>Stream</code> 流式处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        one.add(<span class="string">"宋远桥"</span>);</span><br><span class="line">        one.add(<span class="string">"苏星河"</span>);</span><br><span class="line">        one.add(<span class="string">"石破天"</span>);</span><br><span class="line">        one.add(<span class="string">"石中玉"</span>);</span><br><span class="line">        one.add(<span class="string">"老子"</span>);</span><br><span class="line">        one.add(<span class="string">"庄子"</span>);</span><br><span class="line">        one.add(<span class="string">"洪七公"</span>);</span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；存储到一个新集合中。</span></span><br><span class="line">        Stream&lt;String&gt; oneStream = one.stream().filter(name -&gt; name.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        two.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        two.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        two.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        two.add(<span class="string">"尼古拉斯赵四"</span>);</span><br><span class="line">        two.add(<span class="string">"张天爱"</span>);</span><br><span class="line">        two.add(<span class="string">"张二狗"</span>);</span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；存储到一个新集合中。</span></span><br><span class="line">        Stream&lt;String&gt; twoStream = two.stream().filter(name -&gt; name.startsWith(<span class="string">"张"</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；存储到一个新集合中。</span></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        Stream.concat(oneStream, twoStream).map(name -&gt; <span class="keyword">new</span> Person(name)).forEach(p -&gt; System.out.println(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h2 id="冗余的-Lambda-场景"><a href="#冗余的-Lambda-场景" class="headerlink" title="冗余的 Lambda 场景"></a>冗余的 Lambda 场景</h2><p>来看一个简单的函数式接口以应用 Lambda 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过 Lambda 来使用它的代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrintable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">        p.print(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printString(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过 Lambda 表达式指定了函数式接口 Printable 的具体操作方案为：<strong>拿到 String（类型可推导，所以可省略）数据后，在控制台中输出它</strong>。 </p><p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out 对象中的 println(String) 方法。既然 Lambda 希望做的事情就是调用 println(String) 方法，那何必自己手动调用呢？ </p><h2 id="用方法引用改进"><a href="#用方法引用改进" class="headerlink" title="用方法引用改进"></a>用方法引用改进</h2><p>能否省去 Lambda 的语法格式（尽管它已经相当简洁）呢？</p><p>Lambda 表达式的目的是打印参数传递的字符串，把参数 s 传递给了 System.out 对象，调用 out 对象中的方法 println 对字符串进行输出，注意：</p><ol><li>System.out 对象是已经存在的；</li><li>println 方法也是已经存在的。</li></ol><p>所以我们可以使用方法引用来优化 Lambda 表达式，可以使用 System.out 对象直接引用（调用）println 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrintable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">        p.print(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printString(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法引用运算符"><a href="#方法引用运算符" class="headerlink" title="方法引用运算符 ::"></a>方法引用运算符 <code>::</code></h2><p>双冒号 <code>::</code> 为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果 Lambda 要表达的函数方案已经存在于某个方法的实现中，那么则可以<strong>通过双冒号来引用该方法作为 Lambda 的替代者</strong>。 </p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>上例中，System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效： </p><ul><li>Lambda 表达式写法： <code>s -&gt; System.out.println(s);</code> </li><li>方法引用写法： <code>System.out::println</code> </li></ul><p>第一种语义是指：拿到参数之后经 Lambda 之手，继而传递给 System.out.println 方法去处理。 </p><p>第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代 Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 </p><p>注意：Lambda 中传递的参数一定是方法引用中的那个方法可以接收的类型，否则会抛出异常。</p><h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><p>如果使用 Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定重载形式，它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 </p><p>函数式接口是 Lambda 的基础，而方法引用是 Lambda 的孪生兄弟。 </p><p>上例中可以推导出唯一匹配的 <code>println(int)</code> 重载形式。</p><h2 id="通过对象名引用成员方法"><a href="#通过对象名引用成员方法" class="headerlink" title="通过对象名引用成员方法"></a>通过对象名引用成员方法</h2><p>通过对象名引用成员方法是最常见的一种用法，使用前提：</p><ol><li>对象已经存在；</li><li>成员方法已经存在。</li></ol><p>定义一个 MethodRefObject 类，包含一个成员方法 printUpperCase。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRefObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员方法,传递字符串,把字符串按照大写输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCaseString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的 Lambda 的时候，已经具有了 MethodRefObject 类的对象实例，则可以通过对象名引用成员方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjectMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">        p.print(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用printString方法,传递Lambda表达式</span></span><br><span class="line">        printString(s -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建MethodRerObject对象</span></span><br><span class="line">            MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">            <span class="comment">// 调用MethodRerObject对象中的成员方法printUpperCaseString</span></span><br><span class="line">            obj.printUpperCaseString(s);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MethodRerObject对象</span></span><br><span class="line">        MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">        <span class="comment">// 使用方法引用优化</span></span><br><span class="line">        printString(obj::printUpperCaseString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过类名引用静态方法"><a href="#通过类名引用静态方法" class="headerlink" title="通过类名引用静态方法"></a>通过类名引用静态方法</h2><p>由于在 <code>java.lang.Math</code> 类中已经存在了静态方法 <code>abs</code> ，所以当我们需要通过 Lambda 来调用该方法时，有两种写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calcable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStaticMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,方法的参数传递要计算绝对值的整数,和函数式接口Calcable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> number,Calcable c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> c.calsAbs(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递计算绝对值得整数,和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> number = method(-<span class="number">10</span>, n -&gt; Math.abs(n));</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方法引用优化Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> number2 = method(-<span class="number">10</span>, Math::abs);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-super-引用成员方法"><a href="#通过-super-引用成员方法" class="headerlink" title="通过 super 引用成员方法"></a>通过 <code>super</code> 引用成员方法</h2><p>如果存在继承关系，当 Lambda 中需要出现 super 调用时，也可以使用方法引用进行替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义见面的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个见面的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个sayHello的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Human!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类重写父类sayHello的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法参数传递Greetable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable g)</span> </span>&#123;</span><br><span class="line">        g.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用method方法,传递Lambda</span></span><br><span class="line">        method(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建父类Human对象,调用父类的sayHello方法</span></span><br><span class="line">            <span class="keyword">new</span> Human().sayHello();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为有子父类关系,可以直接使用super调用父类的成员方法</span></span><br><span class="line">        method(() -&gt; <span class="keyword">super</span>.sayHello());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接使用super引用父类的成员方法</span></span><br><span class="line">        method(<span class="keyword">super</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Man().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-this-引用成员方法"><a href="#通过-this-引用成员方法" class="headerlink" title="通过 this 引用成员方法"></a>通过 <code>this</code> 引用成员方法</h2><p> <code>this</code> 代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用 <strong><code>this::成员方法</code></strong> 的格式来使用方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个富有的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Richable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个想买什么就买什么的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义丈夫类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个买房子的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"北京二环内买一套四合院!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个结婚的方法,参数传递Richable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Richable r)</span> </span>&#123;</span><br><span class="line">        r.buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个非常高兴的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">soHappy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用结婚的方法,传递Lambda表达式</span></span><br><span class="line">        marry(() -&gt; <span class="keyword">this</span>.buyHouse());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接使用this引用本类的成员方法buyHouse</span></span><br><span class="line">        marry(<span class="keyword">this</span>::buyHouse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Husband().soHappy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <strong><code>类名称::new</code></strong> 的格式表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个创建Person对象的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,根据传递的姓名,创建Person对象返回</span></span><br><span class="line">    <span class="function">Person <span class="title">builderPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法,参数传递姓名和PersonBuilder接口,方法中通过姓名创建Person对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name,PersonBuilder pb)</span> </span>&#123;</span><br><span class="line">        Person person = pb.builderPerson(name);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用printName方法,方法的参数传递Lambda</span></span><br><span class="line">        printName(<span class="string">"迪丽热巴"</span>, name -&gt; <span class="keyword">new</span> Person(name));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Person引用new创建对象</span></span><br><span class="line">        printName(<span class="string">"古力娜扎"</span>, Person::<span class="keyword">new</span>); <span class="comment">// 使用Person类的带参构造方法,通过传递的姓名创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h2><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同，数组的构造器引用使用 <strong><code>数据类型[]::new</code></strong> 的格式表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个创建数组的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个创建int类型数组的方法,参数传递数组的长度,返回创建好的int类型数组</span></span><br><span class="line">    <span class="keyword">int</span>[] builderArray(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递创建数组的长度和ArrayBuilder接口</span></span><br><span class="line"><span class="comment">        方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createArray(<span class="keyword">int</span> length, ArrayBuilder ab) &#123;</span><br><span class="line">        <span class="keyword">return</span> ab.builderArray(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用createArray方法,传递数组的长度和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = createArray(<span class="number">10</span>, len -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[len]);</span><br><span class="line">        System.out.println(arr1.length); <span class="comment">// 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用方法引用,int[]引用new,根据参数传递的长度来创建数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = createArray(<span class="number">10</span>, <span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">        System.out.println(arr2.length); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java语言高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java语言高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级（4）File类与IO流</title>
      <link href="/2020/02/20/java-advanced-4.html"/>
      <url>/2020/02/20/java-advanced-4.html</url>
      
        <content type="html"><![CDATA[<h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a><code>File</code> 类</h1><h2 id="File-类概述"><a href="#File-类概述" class="headerlink" title="File 类概述"></a><code>File</code> 类概述</h2><p> <code>java.io.File</code> 类是文件和目录路径名的抽象表示。</p><p>Java 把电脑中的文件和文件夹（目录）封装为了一个 <code>File</code> 类，可以使用 <code>File</code> 类对文件和文件夹进行操作，主要用于文件和目录的创建、查找和删除等操作。</p><p> <code>File</code> 类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法。</p><p>重点记住三个单词：</p><ol><li><code>file</code> ：文件</li><li><code>directory</code> ：文件夹（或目录）</li><li><code>path</code> ：路径</li></ol><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><ul><li><code>static String pathSeparator</code> ：与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</li><li><code>static char pathSeparatorChar</code> ：与系统有关的路径分隔符。</li><li><code>static String separator</code> ：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</li><li><code>static char separatorChar</code> ：与系统有关的默认名称分隔符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pathSeparator = File.pathSeparator;</span><br><span class="line">        System.out.println(pathSeparator); <span class="comment">// 路径分隔符 windows:分号;  linux:冒号:</span></span><br><span class="line">        String separator = File.separator;</span><br><span class="line">        System.out.println(separator); <span class="comment">// 文件名称分隔符 windows:反斜杠\  linux:正斜杠/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于当前项目根目录的路径，这是一个简化的路径，开发中经常使用。</li></ul><p>注意：</p><ol><li>路径是不区分大小写的。</li><li>路径中的文件名称分隔符：Windows 使用反斜杠 <code>\</code> ，需要转义。</li><li>路径可以是以文件结尾，也可以是以文件夹结尾。</li><li>路径可以是相对路径，也可以是绝对路径。</li><li>路径可以是存在，也可以是不存在。</li></ol><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File 实例。  </li><li><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File 实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File 实例。 </li></ul><p>注意：</p><ol><li>一个 File 对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02(<span class="string">"c:\\"</span>,<span class="string">"a.txt"</span>); <span class="comment">// c:\a.txt</span></span><br><span class="line">        show02(<span class="string">"d:\\"</span>,<span class="string">"a.txt"</span>); <span class="comment">// d:\a.txt</span></span><br><span class="line">        show03();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        File(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            String pathname:字符串的路径名称</span></span><br><span class="line"><span class="comment">            创建File对象,只是把字符串路径封装为File对象,不考虑路径的真假情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt"</span>);</span><br><span class="line">        System.out.println(f1); <span class="comment">// 重写了Object类的toString方法 C:\Users\itcast\IdeaProjects\shungyuan\a.txt</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan"</span>);</span><br><span class="line">        System.out.println(f2); <span class="comment">// C:\Users\itcast\IdeaProjects\shungyuan</span></span><br><span class="line"></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"b.txt"</span>);</span><br><span class="line">        System.out.println(f3); <span class="comment">// b.txt</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</span></span><br><span class="line"><span class="comment">        好处:</span></span><br><span class="line"><span class="comment">            父路径和子路径,可以单独书写,使用起来非常灵活;父路径和子路径都可以变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">(String parent, String child)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(parent, child);</span><br><span class="line">        System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</span></span><br><span class="line"><span class="comment">        好处:</span></span><br><span class="line"><span class="comment">             父路径是File类型,可以使用File的方法对路径进行一些操作,再使用路径创建对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File parent = <span class="keyword">new</span> File(<span class="string">"c:\\"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(parent, <span class="string">"hello.java"</span>);</span><br><span class="line">        System.out.println(file); <span class="comment">// c:\hello.java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><code>public String getAbsolutePath()</code> ：返回此 File 的绝对路径名字符串。</li><li><code>public String getPath()</code> ：将此 File 转换为路径名字符串。 </li><li><code>public String getName()</code>  ：返回由此 File 表示的文件或目录的名称。  </li><li><code>public long length()</code>  ：返回由此 File 表示的文件的长度。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02();</span><br><span class="line">        show03();</span><br><span class="line">        show04();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public String getAbsolutePath() ：返回此File的绝对路径名字符串。</span></span><br><span class="line"><span class="comment">        获取的构造方法中传递的路径</span></span><br><span class="line"><span class="comment">        无论路径是绝对的还是相对的,getAbsolutePath方法返回的都是绝对路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt"</span>);</span><br><span class="line">        String absolutePath1 = f1.getAbsolutePath();</span><br><span class="line">        System.out.println(absolutePath1); <span class="comment">// C:\Users\itcast\IdeaProjects\shungyuan\a.txt</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        String absolutePath2 = f2.getAbsolutePath();</span><br><span class="line">        System.out.println(absolutePath2); <span class="comment">// C:\Users\itcast\IdeaProjects\shungyuan\a.txt</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public String getPath() ：将此File转换为路径名字符串。</span></span><br><span class="line"><span class="comment">        获取的构造方法中传递的路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        toString方法调用的就是getPath方法</span></span><br><span class="line"><span class="comment">        源码:</span></span><br><span class="line"><span class="comment">            public String toString() &#123;</span></span><br><span class="line"><span class="comment">                return getPath();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        String path1 = f1.getPath();</span><br><span class="line">        System.out.println(path1); <span class="comment">// C:\Users\itcast\IdeaProjects\shungyuan\a.txt</span></span><br><span class="line">        String path2 = f2.getPath();</span><br><span class="line">        System.out.println(path2); <span class="comment">// a.txt</span></span><br><span class="line"></span><br><span class="line">        System.out.println(f1); <span class="comment">// C:\Users\itcast\IdeaProjects\shungyuan\a.txt</span></span><br><span class="line">        System.out.println(f1.toString()); <span class="comment">// C:\Users\itcast\IdeaProjects\shungyuan\a.txt</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public String getName()  ：返回由此File表示的文件或目录的名称。</span></span><br><span class="line"><span class="comment">        获取的就是构造方法传递路径的结尾部分(文件/文件夹)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt"</span>);</span><br><span class="line">        String name1 = f1.getName();</span><br><span class="line">        System.out.println(name1); <span class="comment">// a.txt</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan"</span>);</span><br><span class="line">        String name2 = f2.getName();</span><br><span class="line">        System.out.println(name2); <span class="comment">// shungyuan</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public long length()  ：返回由此File表示的文件的长度。</span></span><br><span class="line"><span class="comment">        获取的是构造方法指定的文件的大小,以字节为单位</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            文件夹是没有大小概念的,不能获取文件夹的大小</span></span><br><span class="line"><span class="comment">            如果构造方法中给出的路径不存在,那么length方法返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\develop\\a\\1.jpg"</span>);</span><br><span class="line">        <span class="keyword">long</span> l1 = f1.length();</span><br><span class="line">        System.out.println(l1); <span class="comment">// 780831字节</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"C:\\develop\\a\\2.jpg"</span>);</span><br><span class="line">        System.out.println(f2.length()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"C:\\develop\\a"</span>);</span><br><span class="line">        System.out.println(f3.length()); <span class="comment">// 0 文件夹没有大小概念的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此 File 表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此 File 表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此 File 表示的是否为文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public boolean exists() ：此File表示的文件或目录是否实际存在。</span></span><br><span class="line"><span class="comment">        用于判断构造方法中的路径是否存在</span></span><br><span class="line"><span class="comment">            存在:true</span></span><br><span class="line"><span class="comment">            不存在:false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan"</span>);</span><br><span class="line">        System.out.println(f1.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shung"</span>);</span><br><span class="line">        System.out.println(f2.exists()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"shungyuan.iml"</span>); <span class="comment">// 相对路径 C:\Users\itcast\IdeaProjects\shungyuan\shungyuan.iml</span></span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        System.out.println(f4.exists()); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public boolean isDirectory() ：此File表示的是否为目录。</span></span><br><span class="line"><span class="comment">            用于判断构造方法中给定的路径是否以文件夹结尾</span></span><br><span class="line"><span class="comment">                是:true</span></span><br><span class="line"><span class="comment">                否:false</span></span><br><span class="line"><span class="comment">        public boolean isFile() ：此File表示的是否为文件。</span></span><br><span class="line"><span class="comment">            用于判断构造方法中给定的路径是否以文件结尾</span></span><br><span class="line"><span class="comment">                是:true</span></span><br><span class="line"><span class="comment">                否:false</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            电脑的硬盘中只有文件/文件夹,两个方法是互斥</span></span><br><span class="line"><span class="comment">            这两个方法使用前提,路径必须是存在的,否则都返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shung"</span>);</span><br><span class="line">        <span class="comment">// 不存在,就没有必要获取</span></span><br><span class="line">        System.out.println(f1.isDirectory()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(f1.isFile()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f2.exists()) &#123;</span><br><span class="line">            System.out.println(f2.isDirectory()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(f2.isFile()); <span class="comment">// false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\shungyuan.iml"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f3.exists()) &#123;</span><br><span class="line">            System.out.println(f3.isDirectory()); <span class="comment">// false</span></span><br><span class="line">            System.out.println(f3.isFile()); <span class="comment">// true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此 File 表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此 File 表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此 File 表示的目录，包括任何必需但不存在的父目录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02();</span><br><span class="line">        show03();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</span></span><br><span class="line"><span class="comment">        创建文件的路径和名称在构造方法中给出(构造方法的参数)</span></span><br><span class="line"><span class="comment">        返回值:布尔值</span></span><br><span class="line"><span class="comment">            true:文件不存在,创建文件,返回true</span></span><br><span class="line"><span class="comment">            false:文件存在,不会创建,返回false</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            1.此方法只能创建文件,不能创建文件夹</span></span><br><span class="line"><span class="comment">            2.创建文件的路径必须存在,否则会抛出异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public boolean createNewFile() throws IOException</span></span><br><span class="line"><span class="comment">        createNewFile声明抛出了IOException,我们调用这个方法,就必须的处理这个异常,要么throws,要么trycatch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\08_FileAndRecursion\\1.txt"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b1 = f1.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">"b1:"</span> + b1); <span class="comment">// b1:true</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"08_FileAndRecursion\\2.txt"</span>);</span><br><span class="line">        System.out.println(f2.createNewFile()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"08_FileAndRecursion\\新建文件夹"</span>);</span><br><span class="line">        System.out.println(f3.createNewFile()); <span class="comment">// true 不要被名称迷糊,要看类型,是一个文件</span></span><br><span class="line"></span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">"08_File\\3.txt"</span>);</span><br><span class="line">        System.out.println(f4.createNewFile()); <span class="comment">// 路径不存在,抛出IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       public boolean mkdir() ：创建单级空文件夹</span></span><br><span class="line"><span class="comment">       public boolean mkdirs() ：既可以创建单级空文件夹,也可以创建多级文件夹</span></span><br><span class="line"><span class="comment">       创建文件夹的路径和名称在构造方法中给出(构造方法的参数)</span></span><br><span class="line"><span class="comment">        返回值:布尔值</span></span><br><span class="line"><span class="comment">            true:文件夹不存在,创建文件夹,返回true</span></span><br><span class="line"><span class="comment">            false:文件夹存在,不会创建,返回false</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            此方法只能创建文件夹,不能创建文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"08_FileAndRecursion\\aaa"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b1 = f1.mkdir();</span><br><span class="line">        System.out.println(<span class="string">"b1:"</span> + b1); <span class="comment">// b1:true</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"08_FileAndRecursion\\111\\222\\333\\444"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b2 = f2.mkdirs();</span><br><span class="line">        System.out.println(<span class="string">"b2:"</span> + b2); <span class="comment">// b2:true</span></span><br><span class="line"></span><br><span class="line">        File f3 = <span class="keyword">new</span> File(<span class="string">"08_FileAndRecursion\\abc.txt"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b3 = f3.mkdirs(); <span class="comment">// 看类型,是一个文件夹</span></span><br><span class="line">        System.out.println(<span class="string">"b3:"</span> + b3); <span class="comment">// b3:true</span></span><br><span class="line"></span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">"08_F\\ccc"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b4 = f4.mkdirs(); <span class="comment">// 不会抛出异常,路径不存在,也会创建</span></span><br><span class="line">        System.out.println(<span class="string">"b4:"</span> + b4); <span class="comment">// b4:true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public boolean delete() ：删除由此File表示的文件或目录。</span></span><br><span class="line"><span class="comment">        此方法,可以删除构造方法路径中给出的文件/文件夹</span></span><br><span class="line"><span class="comment">        返回值:布尔值</span></span><br><span class="line"><span class="comment">            true:文件/文件夹删除成功,返回true</span></span><br><span class="line"><span class="comment">            false:文件夹中有内容,不会删除返回false;构造方法中路径不存在返回false</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            delete方法是直接在硬盘删除文件/文件夹,不走回收站,删除要谨慎</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"08_FileAndRecursion\\新建文件夹"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b1 = f1.delete();</span><br><span class="line">        System.out.println(<span class="string">"b1:"</span> + b1); <span class="comment">// b1:true</span></span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"08_FileAndRecursion\\abc.txt"</span>);</span><br><span class="line">        System.out.println(f2.delete()); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。  </li></ul><p>注意：</p><ol><li>如果构造方法中给出的目录的路径不存在，会抛出空指针异常</li><li>如果构造方法中给出的路径不是一个目录，也会抛出空指针异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</span></span><br><span class="line"><span class="comment">        遍历构造方法中给出的目录,会获取目录中所有文件/文件夹的名称,把获取到的多个名称存储到一个String类型的数组中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// File file = new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\08_FileAndRecursion\\1.txt"); // NullPointerException</span></span><br><span class="line">        <span class="comment">// File file = new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\08_Fi"); // NullPointerException</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\08_FileAndRecursion"</span>);</span><br><span class="line">        String[] arr = file.list();</span><br><span class="line">        <span class="keyword">for</span> (String fileName : arr) &#123;</span><br><span class="line">            System.out.println(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。</span></span><br><span class="line"><span class="comment">        遍历构造方法中给出的目录,会获取目录中所有的文件/文件夹,把文件/文件夹封装为File对象,多个File对象存储到File数组中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\itcast\\IdeaProjects\\shungyuan\\08_FileAndRecursion"</span>);</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="递归概述"><a href="#递归概述" class="headerlink" title="递归概述"></a>递归概述</h2><ul><li><strong>递归</strong>：指在当前方法内调用自己的这种现象。</li><li><strong>递归的分类:</strong> <ul><li>直接递归：方法自身调用自己。</li><li>间接递归：可以 A 方法调用 B 方法，B 方法调用 C 方法，C 方法调用 A 方法。</li></ul></li><li><strong>注意事项</strong>：<ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多，否则也会发生栈内存溢出。</li><li>构造方法，禁止递归。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// a();</span></span><br><span class="line">        b(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</span></span><br><span class="line"><span class="comment">        Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a方法!"</span>);</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span></span><br><span class="line"><span class="comment">11157 Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">20000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 结束方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        b(++i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        构造方法,禁止递归</span></span><br><span class="line"><span class="comment">        编译报错:构造方法是创建对象使用的,一直递归会导致内存中有无数多个对象,直接编译报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo01Recurison</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demo01Recurison();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归执行过程"><a href="#递归执行过程" class="headerlink" title="递归执行过程"></a>递归执行过程</h2><h3 id="递归累加求和"><a href="#递归累加求和" class="headerlink" title="递归累加求和"></a>递归累加求和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算1~n的和，使用递归完成</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 调用求和的方法</span></span><br><span class="line"><span class="keyword">int</span> sum = getSum(n);</span><br><span class="line">      <span class="comment">// 输出结果</span></span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,使用递归计算1-n之间的和</span></span><br><span class="line"><span class="comment">        1+2+3+...+n</span></span><br><span class="line"><span class="comment">        n+(n-1)+(n-2)+...+1</span></span><br><span class="line"><span class="comment">        已知:</span></span><br><span class="line"><span class="comment">            最大值:n</span></span><br><span class="line"><span class="comment">            最小值:1</span></span><br><span class="line"><span class="comment">        使用递归必须明确:</span></span><br><span class="line"><span class="comment">            1.递归的结束条件</span></span><br><span class="line"><span class="comment">                获取到1的时候结束</span></span><br><span class="line"><span class="comment">            2.递归的目的</span></span><br><span class="line"><span class="comment">                获取下一个被加的数字(n-1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到1的时候结束</span></span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 获取下一个被加的数字(n-1)</span></span><br><span class="line"><span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="/2020/02/20/java-advanced-4/递归累和.jpg" alt></p><h3 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习:</span></span><br><span class="line"><span class="comment">        使用递归计算阶乘</span></span><br><span class="line"><span class="comment">        n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jiecheng = jc(<span class="number">5</span>);</span><br><span class="line">        System.out.println(jiecheng);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义方法使用递归计算阶乘</span></span><br><span class="line"><span class="comment">        5的阶乘: 5! = 5*(5-1)*(5-2)*(5-3)*(5-4)=5*4*3*2*1</span></span><br><span class="line"><span class="comment">        递归结束的条件</span></span><br><span class="line"><span class="comment">            获取到1的时候结束</span></span><br><span class="line"><span class="comment">        递归的目的</span></span><br><span class="line"><span class="comment">            获取下一个被乘的数字(n-1)</span></span><br><span class="line"><span class="comment">        方法的参数发生变化</span></span><br><span class="line"><span class="comment">            5,4,3,2,1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到1的时候结束</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取下一个被乘的数字(n-1)</span></span><br><span class="line">        <span class="keyword">return</span> n * jc(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h3><p><strong>分析</strong>：多级目录的打印，就是目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习:</span></span><br><span class="line"><span class="comment">        递归打印多级目录</span></span><br><span class="line"><span class="comment">    需求:</span></span><br><span class="line"><span class="comment">        遍历c:\\abc文件夹,及abc文件夹的子文件夹</span></span><br><span class="line"><span class="comment">        c:\\abc</span></span><br><span class="line"><span class="comment">        c:\\abc\\abc.txt</span></span><br><span class="line"><span class="comment">        c:\\abc\\abc.java</span></span><br><span class="line"><span class="comment">        c:\\abc\\a</span></span><br><span class="line"><span class="comment">        c:\\abc\\a\\a.jpg</span></span><br><span class="line"><span class="comment">        c:\\abc\\a\\a.java</span></span><br><span class="line"><span class="comment">        c:\\abc\\b</span></span><br><span class="line"><span class="comment">        c:\\abc\\b\\b.java</span></span><br><span class="line"><span class="comment">        c:\\abc\\b\\b.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRecurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"c:\\abc"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,参数传递File类型的目录</span></span><br><span class="line"><span class="comment">        方法中对目录进行遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="comment">// 对遍历得到的File对象f进行判断,判断是否是文件夹</span></span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">                System.out.println(f); <span class="comment">// 打印此文件夹名称</span></span><br><span class="line">                <span class="comment">// f是一个文件夹,则继续遍历这个文件夹</span></span><br><span class="line">                <span class="comment">// 我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法</span></span><br><span class="line">                <span class="comment">// 所以直接调用getAllFile方法即可:递归(自己调用自己)</span></span><br><span class="line">                getAllFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//f是一个文件,直接打印即可</span></span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>搜索 <code>c:\\abc</code> 目录中的 <code>.java</code> 文件。</p><p><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Recurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"c:\\abc"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,参数传递File类型的目录</span></span><br><span class="line"><span class="comment">        方法中对目录进行遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="comment">// 对遍历得到的File对象f进行判断,判断是否是文件</span></span><br><span class="line">            <span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">              <span class="comment">// 是文件，判断文件名并输出文件绝对路径</span></span><br><span class="line">                <span class="keyword">if</span> (f.getName().toLowerCase().endsWith(<span class="string">".java"</span>)) &#123;</span><br><span class="line">                    System.out.println(f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是目录，继续遍历,形成递归</span></span><br><span class="line">                getAllFile(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>在 <code>File</code> 类中有两个和 <code>file[] ListFiles()</code> 重载的方法，方法的参数传递的就是<strong>过滤器</strong>：</p><ol><li><code>File[] listFiles(FileFilter filter)</code> ；</li><li><code>File[] listFiles(FilenameFilter filter)</code> 。</li></ol><h2 id="FileFilter-接口"><a href="#FileFilter-接口" class="headerlink" title="FileFilter 接口"></a><code>FileFilter</code> 接口</h2><p> <code>java.io.FileFilter</code> 是一个接口，是用于抽象路径名（File 对象）的过滤器。接口中只有一个抽象方法：</p><ul><li><code>boolean accept(File pathname)</code> ：测试指定抽象路径名是否应该包含在某个路径名列表中。</li><li>参数 <code>File pathname</code> ：使用 <code>ListFiles</code> 方法遍历目录得到的每一个文件对象。</li></ul><h2 id="FilenameFilter-接口"><a href="#FilenameFilter-接口" class="headerlink" title="FilenameFilter 接口"></a><code>FilenameFilter</code> 接口</h2><p> <code>java.io.FilenameFilter</code> 接口：实现此接口的类实例可用于过滤器文件名。接口中只有一个抽象方法：</p><ul><li><code>boolean accept(File dir, String name)</code> ：测试指定文件是否应该包含在某一文件列表中。</li><li>参数：<ul><li><code>File dir</code> ：构造方法中传递的被遍历的目录</li><li><code>String name</code> ：使用 <code>ListFiles</code> 方法遍历目录获取的每一个文件/文件夹的名称</li></ul></li></ul><p>注意：两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤的方法 <code>accept()</code>，在方法中自己定义过滤的规则。</p><h2 id="过滤器优化文件搜索"><a href="#过滤器优化文件搜索" class="headerlink" title="过滤器优化文件搜索"></a>过滤器优化文件搜索</h2><p>使用 <code>FileFilter</code> 接口：</p><ol><li>使用需要传递子类对象，重写其中方法。选择匿名内部类方式，比较简单。</li><li><code>accept</code> 方法，参数为 <code>File</code>，表示当前 File 下所有的子文件和子目录。保留住则返回 true，过滤掉则返回 false。保留规则：<ol><li>要么是 <code>.java</code> 文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code> 返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"c:\\abc"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 传递过滤器对象 使用匿名内部类</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 过滤规则,pathname是文件夹或者是.java结尾的文件返回true</span></span><br><span class="line">                <span class="keyword">return</span> pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">                getAllFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>FilenameFilter</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"c:\\abc"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 过滤规则,pathname是文件夹或者是.java结尾的文件返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> File(dir, name).isDirectory() || name.toLowerCase().endsWith(<span class="string">".java"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">                getAllFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileFilter-过滤器的原理"><a href="#FileFilter-过滤器的原理" class="headerlink" title="FileFilter 过滤器的原理"></a><code>FileFilter</code> 过滤器的原理</h2><p><img src="/2020/02/20/java-advanced-4/FileFilter过滤器的原理.png" alt></p><h2 id="Lambda-优化"><a href="#Lambda-优化" class="headerlink" title="Lambda 优化"></a>Lambda 优化</h2><p> <code>FileFilter</code> 和 <code>FilenameFilter</code> 都是只有一个方法的接口，因此可以用 Lambda 表达式简写。</p><p>Lambda格式：<code>() -&gt; {}</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Lambda表达式优化匿名内部类(接口中只有一个抽象方法)</span></span><br><span class="line">    <span class="comment">/*File[] files = dir.listFiles((File pathname)-&gt;&#123;</span></span><br><span class="line"><span class="comment">        return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java");</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">    File[] files = dir.listFiles(pathname -&gt; pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>))</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getAllFile(f);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IO-概述"><a href="#IO-概述" class="headerlink" title="IO 概述"></a>IO 概述</h1><h2 id="什么是-IO"><a href="#什么是-IO" class="headerlink" title="什么是 IO"></a>什么是 IO</h2><p>数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p><p>我们把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为 <code>输入(input)</code> 和 <code>输出(output)</code> ，即流向内存是<strong>输入流</strong>，流出内存的输出流。</p><p>Java中 I/O 操作主要是指使用 <code>java.io</code> 包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p><h2 id="IO-的分类"><a href="#IO-的分类" class="headerlink" title="IO 的分类"></a>IO 的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="IO-的流向"><a href="#IO-的流向" class="headerlink" title="IO 的流向"></a>IO 的流向</h2><p><img src="/2020/02/20/java-advanced-4/IO流的概念和分类.png" alt></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="一切皆为字节"><a href="#一切皆为字节" class="headerlink" title="一切皆为字节"></a>一切皆为字节</h2><p>一切文件数据（文本、图片、视频等）在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为<strong>二进制数据</strong>。</p><h2 id="OutputStream-字节输出流"><a href="#OutputStream-字节输出流" class="headerlink" title="OutputStream 字节输出流"></a><code>OutputStream</code> 字节输出流</h2><p> <strong><code>java.io.OutputStream</code> 抽象类</strong>是表示<strong>字节输出流</strong>的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code> ：将 b.length 字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。  </li><li><code>public void write(int b)</code> ：将指定的字节写入此输出流。</li></ul><h2 id="FileOutputStream-文件字节输出流"><a href="#FileOutputStream-文件字节输出流" class="headerlink" title="FileOutputStream 文件字节输出流"></a><code>FileOutputStream</code> 文件字节输出流</h2><p> <code>OutputStream</code> 有很多子类， <code>java.io.FileOutputStream</code> 类是<strong>文件字节输出流</strong>，用于将内存中的数据写入到硬盘的文件中。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p> <code>FileOutputStream</code> 类的一个参数的构造方法有：</p><ul><li><code>public FileOutputStream(File file)</code> ：创建一个向<strong>指定 File 对象</strong>表示的文件中写入数据的文件输出流。</li><li><code>public FileOutputStream(String name)</code>：创建一个向具有<strong>指定名称</strong>的文件中写入数据的输出文件流。</li></ul><p>当创建一个输出流对象时，必须传入一个文件路径：</p><ul><li>该路径下，如果没有这个文件，会创建该文件。</li><li>如果有这个文件，会清空这个文件的数据。</li></ul><p>构造方法的作用：</p><ol><li>创建一个 <code>FileOutputStream</code> 对象；</li><li>会根据构造方法中传递的文件 / 文件路径，创建一个空的文件；</li><li>会把 <code>FileOutputStream</code> 对象指向创建好的文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入字节数据"><a href="#写入字节数据" class="headerlink" title="写入字节数据"></a>写入字节数据</h3><p>写入数据的原理（内存 → 硬盘）：</p><ul><li>Java 程序 → JVM → OS（操作系统） → OS 调用写数据的方法 → 把数据写入到文件中</li></ul><p>字节输出流的使用步骤：</p><ol><li>创建一个 <code>FileOutputStream</code> 对象，构造方法中传递写入数据的目的地；</li><li>调用 <code>FileOutputStream</code> 对象中的方法 <code>write</code>，把数据写入到文件中；</li><li>释放资源（流使用会占用一定的内存，使用完毕要把内存清空，提供程序的效率）。</li></ol><h4 id="写入一个字节"><a href="#写入一个字节" class="headerlink" title="写入一个字节"></a>写入一个字节</h4><p> <code>write(int b)</code> 方法，每次可以写入一个字节数据。虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        fos.write(<span class="number">97</span>); <span class="comment">// a</span></span><br><span class="line">        fos.write(<span class="number">98</span>); <span class="comment">// b</span></span><br><span class="line">        fos.write(<span class="number">99</span>); <span class="comment">// c</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件存储的原理"><a href="#文件存储的原理" class="headerlink" title="文件存储的原理"></a>文件存储的原理</h4><p><img src="/2020/02/20/java-advanced-4/文件存储的原理和记事本打开文件的原理.png" alt></p><h4 id="写入字节数组"><a href="#写入字节数组" class="headerlink" title="写入字节数组"></a>写入字节数组</h4><ul><li><code>public void write(byte[] b)</code> ：将 <code>b.length</code> 字节从指定的字节数组写入此输出流。</li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 <code>len</code> 字节，从偏移量 <code>off</code> 开始输出到此输出流。</li></ul><p>注意：</p><ul><li>如果写的第一个字节是<strong>正数</strong>（0-127），那么显示的时候会查询 ASCII 表。</li><li>如果写的第一个字节是<strong>负数</strong>，那第一个字节和第二个字节这两个字节组成一个中文显示，查询系统默认码表（GBK）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02OutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"b.txt"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。</span></span><br><span class="line"><span class="comment">            一次写多个字节:</span></span><br><span class="line"><span class="comment">                如果写的第一个字节是正数(0-127),那么显示的时候会查询ASCII表</span></span><br><span class="line"><span class="comment">                如果写的第一个字节是负数,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = &#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>&#125;; <span class="comment">// ABCDE</span></span><br><span class="line">        <span class="comment">// byte[] bytes = &#123;-65, -66, -67, 68, 69&#125;; // 烤紻E</span></span><br><span class="line">        fos.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public void write(byte[] b, int off, int len) ：把字节数组的一部分写入到文件中</span></span><br><span class="line"><span class="comment">                int off:数组的开始索引</span></span><br><span class="line"><span class="comment">                int len:写几个字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fos.write(bytes, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// BC</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            写入字符的方法:可以使用String类中的方法把字符串,转换为字节数组</span></span><br><span class="line"><span class="comment">                byte[] getBytes()  把字符串转换为字节数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes2 = <span class="string">"你好"</span>.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(bytes2)); <span class="comment">// [-28, -67, -96, -27, -91, -67]</span></span><br><span class="line">        fos.write(bytes2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><p>文件的追加续写使用两个参数的构造方法：</p><ul><li><code>public FileOutputStream(File file, boolean append)</code> ：创建文件输出流以写入由指定的 File 对象表示的文件。</li><li><code>public FileOutputStream(String name, boolean append)</code> ：创建文件输出流以指定的名称写入文件。</li></ul><p>这两个构造方法，参数中都需要传入一个 <code>boolean</code> 类型的值：</p><ul><li><code>true</code> ：创建对象不会覆盖源文件，继续在文件的末尾追加写数据</li><li><code>false</code> ：创建一个新文件，覆盖源文件。</li></ul><p>这样创建的输出流对象，就可以指定是否追加续写了。</p><h4 id="写入换行"><a href="#写入换行" class="headerlink" title="写入换行"></a>写入换行</h4><ul><li>回车符 <code>\r</code> 和换行符 <code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows 系统里，每行结尾是 <code>回车+换行</code> ，即 <code>\r\n</code>；</li><li>Linux 系统里，每行结尾只有 <code>换行</code> ，即 <code>/n</code>；</li><li>Mac 系统里，每行结尾是 <code>回车</code> ，即 <code>/r</code>。从 Mac OS X 开始与 Linux 统一。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);  </span><br><span class="line">      <span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          <span class="comment">// 写出一个换行, 换行符号转成字节数组写入</span></span><br><span class="line">            fos.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><h2 id="InputStream-字节输入流"><a href="#InputStream-字节输入流" class="headerlink" title="InputStream 字节输入流"></a><code>InputStream</code> 字节输入流</h2><p> <strong><code>java.io.InputStream</code> 抽象类</strong>是表示<strong>字节输入流</strong>的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的所有系统资源。</li><li><code>public int read()</code> ：从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code> ：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li></ul><h2 id="FileInputStream-文件字节输入流"><a href="#FileInputStream-文件字节输入流" class="headerlink" title="FileInputStream 文件字节输入流"></a><code>FileInputStream</code> 文件字节输入流</h2><p> <code>java.io.FileInputStream</code> 类是<strong>文件字节输入流</strong>，把硬盘文件中的数据，读取到内存中使用。</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileInputStream(File file)</code> ：通过打开与实际文件的连接来创建一个 <code>FileInputStream</code> 对象，该文件由文件系统中的 File 对象 file 命名。</li><li><code>FileInputStream(String name)</code> ：通过打开与实际文件的连接来创建一个 <code>FileInputStream</code> 对象，该文件由文件系统中的路径名 name 命名。</li></ul><p>当创建一个输入流对象时，必须传入一个文件路径。该路径下，如果没有该文件，会抛出 <code>FileNotFoundException</code> 。</p><p>构造方法的作用：</p><ol><li>会创建一个 <code>FileInputStream</code> 对象；</li><li>会把 <code>FileInputStream</code> 对象指向构造方法中要读取的文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><p>读取数据的原理（硬盘 → 内存）：</p><ul><li>Java 程序 → JVM → OS（操作系统） → OS 调用写数据的方法 → 把数据写入到文件中</li></ul><p>字节输入流的使用步骤：</p><ol><li>创建 <code>FileInputStream</code> 对象，构造方法中绑定要读取的数据源；</li><li>使用 <code>FileInputStream</code> 对象中的方法 <code>read</code>，读取文件；</li><li>释放资源。</li></ol><h4 id="读取一个字节"><a href="#读取一个字节" class="headerlink" title="读取一个字节"></a>读取一个字节</h4><p> <code>int read()</code> 方法，每次读取一个字节的数据并返回，提升为 int 类型，读取到文件末尾则返回 <code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c.txt"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            不知道文件中有多少字节,使用while循环</span></span><br><span class="line"><span class="comment">            while循环结束条件,读取到-1的时候结束</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            布尔表达式(len = fis.read())!=-1</span></span><br><span class="line"><span class="comment">                1.fis.read():读取一个字节</span></span><br><span class="line"><span class="comment">                2.len = fis.read():把读取到的字节赋值给变量len</span></span><br><span class="line"><span class="comment">                3.(len = fis.read())!=-1:判断变量len是否不等于-1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 记录读取到的字节</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取字节数组"><a href="#读取字节数组" class="headerlink" title="读取字节数组"></a>读取字节数组</h4><p> <code>int read(byte[] b)</code> 方法，一次读取多个字节。明确两件事情：</p><ol><li>方法的参数 <code>byte[]</code> 的作用？<ul><li>起到<strong>缓冲作用，存储每次读取到的多个字节</strong>。</li><li>数组的长度一般定义为 1024 (1kB) 或者 1024 的整数倍。</li></ul></li><li>方法的返回值 <code>int</code> 是什么？<ul><li>每次<strong>读取到的有效字节个数</strong>。</li><li>读取到文件末尾时，返回 <code>-1</code>。</li></ul></li></ol><p> <code>String</code> 类的构造方法：</p><ul><li><code>String(byte[] bytes)</code> ：把字节数组转换为字符串。</li><li><code>String(byte[] bytes, int offset, int length)</code> ：把字节数组的一部分转换为字符串。<ul><li><code>offset</code> ：数组的开始转换索引。</li><li><code>length</code> ：转换的字节个数。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>); <span class="comment">// ABCDE</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用FileInputStream对象中的方法read读取文件</span></span><br><span class="line">        <span class="comment">// int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> len = fis.read(bytes);</span><br><span class="line">        System.out.println(len); <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(bytes)); // [65, 66]</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes)); <span class="comment">// AB</span></span><br><span class="line"></span><br><span class="line">        len = fis.read(bytes);</span><br><span class="line">        System.out.println(len); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes)); <span class="comment">// CD</span></span><br><span class="line"></span><br><span class="line">        len = fis.read(bytes);</span><br><span class="line">        System.out.println(len); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes)); <span class="comment">// ED</span></span><br><span class="line"></span><br><span class="line">        len = fis.read(bytes);</span><br><span class="line">        System.out.println(len); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes)); <span class="comment">// ED</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            发现以上读取时一个重复的过程,可以使用循环优化</span></span><br><span class="line"><span class="comment">            不知道文件中有多少字节,所以使用while循环</span></span><br><span class="line"><span class="comment">            while循环结束的条件,读取到-1结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">// 存储读取到的多个字节</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 记录每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len)); <span class="comment">// ABCDE</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字节流读取文件的原理"><a href="#字节流读取文件的原理" class="headerlink" title="字节流读取文件的原理"></a>字节流读取文件的原理</h4><p><img src="/2020/02/20/java-advanced-4/字节流读取文件的原理.png" alt></p><h2 id="案例：文件复制"><a href="#案例：文件复制" class="headerlink" title="案例：文件复制"></a>案例：文件复制</h2><p>文件复制：</p><ol><li>创建一个字节输入流对象，构造方法中绑定要读取的数据源；</li><li>创建一个字节输出流对象，构造方法中绑定要写入的目的地；</li><li>使用字节输入流对象中的方法 <code>read</code> 读取文件；</li><li>使用字节输出流中的方法 <code>write</code>，把读取到的字节写入到目的地的文件中；</li><li>释放资源。</li></ol><p><img src="/2020/02/20/java-advanced-4/文件复制的原理.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    文件复制练习:一读一写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一次读取一个字节写入一个字节的方式</span></span><br><span class="line">        <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while((len = fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            fos.write(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用数组缓冲读取多个字节,写入多个字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源(先关写的,后关闭读的;如果写完了,肯定读取完毕了)</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"复制文件共耗时:"</span>+(e-s)+<span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字节流读取中文的问题"><a href="#字节流读取中文的问题" class="headerlink" title="字节流读取中文的问题"></a>字节流读取中文的问题</h2><p>1 个中文字符：</p><ul><li>GBK： 占用 2 个字节；</li><li>UTF-8：占用 3 个字节。</li></ul><p>使用字节流读取中文文件的时候，一个中文字符占多个字节，执行下面的代码会导致中文乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c.txt"</span>); <span class="comment">// 你好abc</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len); <span class="comment">// 转换了一个字符的1/n部分</span></span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以 Java 提供一些字符流类，<strong>以字符为单位读写数据，专门用于处理文本文件</strong>。</p><h2 id="Reader-字符输入流"><a href="#Reader-字符输入流" class="headerlink" title="Reader 字符输入流"></a><code>Reader</code> 字符输入流</h2><p> <code>java.io.Reader</code> 抽象类表示用于读取字符流的所有类的超类，是<strong>字符输入流</strong>的最顶层的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public int read()</code> ：从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code> ：从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。</li><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li></ul><h2 id="FileReader-文件字符输入流"><a href="#FileReader-文件字符输入流" class="headerlink" title="FileReader 文件字符输入流"></a><code>FileReader</code> 文件字符输入流</h2><p> <code>java.io.FileReader</code> 类是文件字符输入流，是用于读取字符文件的便利类，把硬盘文件中的数据以字符的方式读取到内存中。</p><p><code>FileReader extends InputStreamReader extends Reader</code>。</p><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造时使用系统默认的字符编码和默认字节缓冲区。</p><ul><li><code>FileReader(File file)</code> ：创建一个新的 <code>FileReader</code> ，给定要读取的 File 对象。   </li><li><code>FileReader(String fileName)</code> ：创建一个新的 <code>FileReader</code> ，给定要读取的文件的名称。  </li></ul><p>当创建一个输入流对象时，必须传入一个文件路径。类似于 <code>FileInputStream</code> 。</p><p>构造方法的作用：</p><ol><li>创建一个 <code>FileReader</code> 对象；</li><li>会把 <code>FileReader</code> 对象指向要读取的文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><p>字符输入流的使用步骤：</p><ol><li>创建 <code>FileReader</code> 对象，构造方法中绑定要读取的数据源；</li><li>使用 <code>FileReader</code> 对象中的方法 <code>read</code> 读取文件；</li><li>释放资源。</li></ol><h4 id="读取一个字符"><a href="#读取一个字符" class="headerlink" title="读取一个字符"></a>读取一个字符</h4><p> <code>int read()</code> 方法，每次可以读取一个字符的数据，提升为 int 类型返回，读取到文件末尾，返回 <code>-1</code>，循环读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"c.txt"</span>);</span><br><span class="line">        <span class="comment">// 使用FileReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="comment">// int read() 读取单个字符并返回。</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取字符数组"><a href="#读取字符数组" class="headerlink" title="读取字符数组"></a>读取字符数组</h4><p> <code>int read(char[] cbuf)</code> 方法，每次读取 <code>cbuf.length</code> 个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回 <code>-1</code> 。</p><p> <code>String</code> 类的构造方法：</p><ul><li><code>String(char[] value)</code> ：把字符数组转换为字符串。</li><li><code>String(char[] value, int offset, int count)</code> ：把字符数组的一部分转换为字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"c.txt"</span>);</span><br><span class="line">        <span class="comment">// int read(char[] cbuf)一次读取多个字符,将字符读入数组。</span></span><br><span class="line">        <span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>]; <span class="comment">// 存储读取到的多个字符</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 记录的是每次读取的有效字符个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cs, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Writer-字符输出流"><a href="#Writer-字符输出流" class="headerlink" title="Writer 字符输出流"></a><code>Writer</code> 字符输出流</h2><p> <strong><code>java.io.Writer</code> 抽象类</strong>是表示用于写入字符流的所有类的超类，将指定的字符信息写入到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> ：写入单个字符。</li><li><code>void write(char[] cbuf)</code> ：写入字符数组。 </li><li><code>void write(char[] cbuf, int off, int len)</code> ：写入字符数组的某一部分。<ul><li><code>off</code> ：数组的开始索引。</li><li><code>len</code> ：写的字符个数。 </li></ul></li><li><code>void write(String str)</code> ：写入字符串。 </li><li><code>void write(String str, int off, int len)</code> ：写入字符串的某一部分。<ul><li><code>off</code> ：字符串的开始索引。</li><li><code>len</code> ：写的字符个数。</li></ul></li><li><code>void flush()</code> ：刷新该流的缓冲。</li><li><code>void close()</code> ：关闭此流，但要先刷新它。 </li></ul><h2 id="FileWriter-文件字符输出流"><a href="#FileWriter-文件字符输出流" class="headerlink" title="FileWriter 文件字符输出流"></a><code>FileWriter</code> 文件字符输出流</h2><p> <code>java.io.FileWriter</code> 类是文件字符输出流，是写入字符到文件的便利类，用于把内存中字符数据写入到文件中。</p><p> <code>FileWriter extends OutputStreamWriter extends Writer</code>。</p><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造时使用系统默认的字符编码和默认字节缓冲区。</p><ul><li><code>FileWriter(File file)</code> ： 创建一个新的 <code>FileWriter</code>，给定要读取的 File 对象。</li><li><code>FileWriter(String fileName)</code> ： 创建一个新的 <code>FileWriter</code>，给定要读取的文件的名称。</li></ul><p>当创建一个流对象时，必须传入一个文件路径，类似于 <code>FileOutputStream</code>。</p><p>构造方法的作用：</p><ol><li>会创建一个 <code>FileWriter</code> 对象；</li><li>会根据构造方法中传递的文件 / 文件的路径，创建文件；</li><li>会把 <code>FileWriter</code> 对象指向创建好的文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入字符数据"><a href="#写入字符数据" class="headerlink" title="写入字符数据"></a>写入字符数据</h3><p>字符输出流的使用步骤：</p><ol><li>创建 <code>FileWriter</code> 对象，构造方法中绑定要写入数据的目的地；</li><li>使用 <code>FileWriter</code> 中的方法 <code>write</code> ，<strong>把数据写入到内存缓冲区中（字符转换为字节的过程）</strong>；</li><li>使用 <code>FileWriter</code> 中的方法 <code>flush</code> ，<strong>把内存缓冲区中的数据，刷新到文件中</strong>；</li><li>释放资源（会先把内存缓冲区中的数据刷新到文件中）。</li></ol><h4 id="写入一个字符"><a href="#写入一个字符" class="headerlink" title="写入一个字符"></a>写入一个字符</h4><p> <code>write(int b)</code> 方法，每次可以写入一个字符数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建FileWriter对象,构造方法中绑定要写入数据的目的地</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"d.txt"</span>);</span><br><span class="line">        <span class="comment">// 使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程)</span></span><br><span class="line">        <span class="comment">// void write(int c) 写入单个字符。</span></span><br><span class="line">        fw.write(<span class="number">97</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中</span></span><br><span class="line">        <span class="comment">// fw.flush();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放资源(会先把内存缓冲区中的数据刷新到文件中)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">             如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flush-与-close-的区别"><a href="#flush-与-close-的区别" class="headerlink" title="flush 与 close 的区别"></a><code>flush</code> 与 <code>close</code> 的区别</h4><p> <code>flush</code> 方法和 <code>close</code> 方法的区别：</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close</code> ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>即便是 <code>flush</code> 方法写入了数据，操作的最后还是要调用 <code>close</code> 方法，释放系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCloseAndFlush</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"e.txt"</span>);</span><br><span class="line">        fw.write(<span class="number">97</span>);</span><br><span class="line">        <span class="comment">// 使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        <span class="comment">// 刷新之后流可以继续使用</span></span><br><span class="line">        fw.write(<span class="number">98</span>);</span><br><span class="line">        <span class="comment">// 释放资源(会先把内存缓冲区中的数据刷新到文件中)</span></span><br><span class="line">        fw.close();</span><br><span class="line">        <span class="comment">// close方法之后流已经关闭了,已经从内存中消失了,流就不能再使用了</span></span><br><span class="line">        <span class="comment">// fw.write(99); // IOException: Stream closed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入多个字符"><a href="#写入多个字符" class="headerlink" title="写入多个字符"></a>写入多个字符</h4><p> <code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> 方法，每次可以写入字符数组中的数据，用法类似 <code>FileOutputStream</code>。</p><p> <code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> 方法，每次可以写入字符串中的数据，更为方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"f.txt"</span>);</span><br><span class="line">        <span class="keyword">char</span>[] cs = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">        <span class="comment">// void write(char[] cbuf)写入字符数组</span></span><br><span class="line">        fw.write(cs); <span class="comment">// abcde</span></span><br><span class="line">        <span class="comment">// void write(char[] cbuf, int off, int len)写入字符数组的某一部分</span></span><br><span class="line">        fw.write(cs, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// bcd</span></span><br><span class="line">        <span class="comment">// void write(String str)写入字符串</span></span><br><span class="line">        fw.write(<span class="string">"传智播客"</span>); <span class="comment">// 传智播客</span></span><br><span class="line">        <span class="comment">// void write(String str, int off, int len) 写入字符串的某一部分</span></span><br><span class="line">        fw.write(<span class="string">"黑马程序员"</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 程序员</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="续写和换行"><a href="#续写和换行" class="headerlink" title="续写和换行"></a>续写和换行</h3><p>续写：使用两个参数的构造方法。</p><ul><li><code>FileWriter(String fileName, boolean append)</code></li><li><code>FileWriter(File file, boolean append)</code><ul><li><code>String fileName</code> 与 <code>File file</code> ：写入数据的目的地。</li><li><code>boolean append</code> ：续写开关。<ul><li><code>true</code> ：不会创建新的文件覆盖源文件，可以续写；</li><li><code>false</code> ：创建新的文件覆盖源文件。</li></ul></li></ul></li></ul><p>换行：换行符号</p><ul><li>Windows：<code>\r\n</code> </li><li>Linux：<code>/n</code> </li><li>Mac：<code>/r</code> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"g.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fw.write(<span class="string">"HelloWorld"</span> + i + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符流的注意事项"><a href="#字符流的注意事项" class="headerlink" title="字符流的注意事项"></a>字符流的注意事项</h2><ul><li><strong>字符流，只能操作文本文件</strong>，不能操作图片，视频等非文本文件。</li><li>当我们单纯读或者写文本文件时使用字符流，其他情况使用字节流。</li></ul><h1 id="IO-异常的处理"><a href="#IO-异常的处理" class="headerlink" title="IO 异常的处理"></a>IO 异常的处理</h1><h2 id="JDK-7-之前的处理"><a href="#JDK-7-之前的处理" class="headerlink" title="JDK 7 之前的处理"></a>JDK 7 之前的处理</h2><p>在 JDK 7 之前使用 <code>try...catch...finally</code> 代码块处理流中的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会产出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类变量 变量名) &#123;</span><br><span class="line">    <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">    <span class="comment">// 资源释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>续写和换行案例中的异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTryCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提高变量fw的作用域,让finally可以使用</span></span><br><span class="line">        <span class="comment">// 变量在定义的时候,可以没有值,但是使用的时候必须有值</span></span><br><span class="line">        <span class="comment">// 如果fw = new FileWriter();执行失败,fw没有值,fw.close会报错</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会产出异常的代码</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"h:\\g.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                fw.write(<span class="string">"HelloWorld"</span> + i + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 一定会执行的代码</span></span><br><span class="line">            <span class="comment">// 创建对象失败了,fw的默认值就是null,null是不能调用方法的,会抛出NullPointerException,需要增加一个判断,不是null在把资源释放</span></span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// fw.close方法声明抛出了IOException异常对象,所以我们就的处理这个异常对象,要么throws,要么try catch</span></span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK-7-的处理"><a href="#JDK-7-的处理" class="headerlink" title="JDK 7 的处理"></a>JDK 7 的处理</h2><p>还可以使用 JDK 7 优化后的 <code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>在 <code>try</code> 的后边可以增加一个 <code>()</code>，在括号中可以定义流对象，那么这个流对象的作用域就在 <code>try</code> 中有效，<code>try</code> 中的代码执行完毕，会自动把流对象释放，不用写 <code>finally</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">';'</span>隔开) &#123;</span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件复制案例中的异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoJDK7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">// 创建一个字节输入流对象,构造方法中绑定要读取的数据源</span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">            <span class="comment">// 创建一个字节输出流对象,构造方法中绑定要写入的目的地</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);) &#123;</span><br><span class="line">            <span class="comment">// 可能会产出异常的代码</span></span><br><span class="line">            <span class="comment">// 使用字节输入流对象中的方法read读取文件</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">                fos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK-9-的处理"><a href="#JDK-9-的处理" class="headerlink" title="JDK 9 的处理"></a>JDK 9 的处理</h2><p>JDK 9 中 <code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动 close。</p><p> <code>try</code> 的前边可以定义流对象，在 <code>try</code> 后边的 <code>()</code> 中可以直接引入流对象的名称（变量名），在 <code>try</code> 代码执行完毕之后，流对象也可以自动释放掉，不用写 <code>finally</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">"resource1"</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">"resource2"</span>);</span><br><span class="line"><span class="comment">// 引入资源对象</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">    <span class="comment">// 使用对象</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型 异常变量名) &#123;</span><br><span class="line">    <span class="comment">// 异常处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件复制案例中的异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoJDK9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);</span><br><span class="line">        <span class="keyword">try</span>(fis; fos) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fos.write(1); // Stream Closed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Properties-属性集"><a href="#Properties-属性集" class="headerlink" title="Properties 属性集"></a><code>Properties</code> 属性集</h1><p> <code>java.util.Properties</code> 继承于 <code>Hashtable</code> ，来表示一个<strong>持久的属性集</strong>。它使用<strong>键值结构</strong>存储数据，<strong>每个键及其对应值都是一个字符串</strong>。该类也被许多 Java 类使用，比如获取系统属性时，<code>System.getProperties()</code> 方法就是返回一个 <code>Properties</code> 对象。</p><h2 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a><code>Properties</code> 类</h2><p> <code>java.util.Properties extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;</code>。</p><p> <code>Properties</code> 类表示了一个持久的属性集。<code>Properties</code> 可保存在流中或从流中加载。</p><p> <code>Properties</code> 集合是一个唯一<strong>和 IO 流相结合</strong>的集合。</p><ul><li>可以使用 <code>Properties</code> 集合中的方法 <code>store</code> ，把集合中的临时数据，持久化写入到硬盘中存储。</li><li>可以使用 <code>Properties</code> 集合中的方法 <code>load</code> ，把硬盘中保存的文件（键值对），读取到集合中使用。</li></ul><p>属性列表中每个键及其对应值都是一个字符串。</p><ul><li><code>Properties</code> 集合是一个双列集合，key 和 value 默认都是字符串。</li></ul><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public Properties()</code> ：创建一个空的属性列表。</li></ul><h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><p> <code>Properties</code> 集合有一些操作字符串的特有方法：</p><ul><li><code>public Object setProperty(String key, String value)</code> ：保存一对属性。调用 <code>Hashtable</code> 的方法 <code>put</code>。</li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。此方法相当于 <code>Map</code> 集合中的 <code>get(key)</code> 方法。</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：返回此属性列表中的键集。此方法相当于 <code>Map</code> 集合中的 <code>keySet</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProperties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Properties集合对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 使用setProperty往集合中添加数据</span></span><br><span class="line">        prop.setProperty(<span class="string">"赵丽颖"</span>,<span class="string">"168"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"165"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"160"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用stringPropertyNames把Properties集合中的键取出,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历Set集合,取出Properties集合的每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            <span class="comment">// 使用getProperty方法通过key获取value</span></span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与输出流相关的方法"><a href="#与输出流相关的方法" class="headerlink" title="与输出流相关的方法"></a>与输出流相关的方法</h3><p>可以使用 <code>Properties</code> 集合中的方法 <code>store</code>，把集合中的临时数据，持久化写入到硬盘中存储。</p><ul><li><code>void store(OutputStream out, String comments)</code> </li><li><code>void store(Writer writer, String comments)</code> <ul><li><code>OutputStream out</code> ：字节输出流，不能写入中文。</li><li><code>Writer writer</code> ：字符输出流，可以写中文。</li><li><code>String comments</code> ：注释，用来解释说明保存的文件是做什么用的。不能使用中文，会产生乱码，默认是 Unicode 编码，一般使用 <code>&quot;&quot;</code> 空字符串。</li></ul></li></ul><p>使用步骤：</p><ol><li>创建 <code>Properties</code> 集合对象，添加数据；</li><li>创建字节输出流 / 字符输出流对象，构造方法中绑定要输出的目的地；</li><li>使用 <code>Properties</code> 集合中的方法 <code>store</code>，把集合中的临时数据，持久化写入到硬盘中存储；</li><li>释放资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProperties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Properties集合对象,添加数据</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">"赵丽颖"</span>,<span class="string">"168"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"165"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"160"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"prop.txt"</span>);</span><br><span class="line">        <span class="comment">// 使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line">        prop.store(fw, <span class="string">"save data"</span>);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line"></span><br><span class="line">        prop.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"prop2.txt"</span>), <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与输入流相关的方法"><a href="#与输入流相关的方法" class="headerlink" title="与输入流相关的方法"></a>与输入流相关的方法</h3><p>可以使用 <code>Properties</code> 集合中的方法 <code>load</code>，把硬盘中保存的文件（键值对）读取到集合中使用。</p><ul><li><code>void load(InputStream inStream)</code> </li><li><code>void load(Reader reader)</code> <ul><li><code>InputStream inStream</code> ：字节输入流，不能读取含有中文的键值对。</li><li><code>Reader reader</code> ：字符输入流，能读取含有中文的键值对。</li></ul></li></ul><p>使用步骤：</p><ol><li>创建 <code>Properties</code> 集合对象；</li><li>使用 <code>Properties</code> 集合对象中的方法 <code>load</code> 读取保存键值对的文件；</li><li>遍历 <code>Properties</code> 集合。</li></ol><p>注意：</p><ol><li>存储键值对的文件中，键与值默认的连接符号可以使用 <code>=</code>、<code>:</code>、空格或其他符号；</li><li>存储键值对的文件中，可以使用 <code>#</code> 进行注释，被注释的键值对不会再被读取；</li><li>存储键值对的文件中，键与值默认都是字符串，不用再加引号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProperties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// prop.load(new FileInputStream("prop.txt"));</span></span><br><span class="line">        prop.load(<span class="keyword">new</span> FileReader(<span class="string">"prop.txt"</span>));</span><br><span class="line">        <span class="comment">// 遍历Properties集合</span></span><br><span class="line">        Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p>有一些功能更为强大的流，比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等，都是在基本的流对象基础之上创建而来的，相当于是对基本流对象的一种增强。</p><h2 id="缓冲流概述"><a href="#缓冲流概述" class="headerlink" title="缓冲流概述"></a>缓冲流概述</h2><p>缓冲流，也叫高效流，是对4个基本的 <code>FileXxx</code> 流的增强，所以也是 4 个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code> </li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率。</p><p><img src="/2020/02/20/java-advanced-4/缓冲流的原理.png" alt></p><h2 id="BufferedOutputStream-字节缓冲输出流"><a href="#BufferedOutputStream-字节缓冲输出流" class="headerlink" title="BufferedOutputStream 字节缓冲输出流"></a><code>BufferedOutputStream</code> 字节缓冲输出流</h2><p> <code>java.io.BufferedOutputStream</code> 类是 <code>OutputStream</code> 类的子类，是字节缓冲输出流。</p><p>继承自父类的共性成员方法：</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li><li><code>public void write(byte[] b)</code> ：将 b.length 字节从指定的字节数组写入此输出流。</li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。</li><li><code>public void write(int b)</code> ：将指定的字节输出流。</li></ul><p>构造方法：</p><ul><li><code>BufferedOutputStream(OutputStream out)</code> ：创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</li><li><code>BufferedOutputStream(OutputStream out, int size)</code> ：创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。<ul><li><code>OutputStream out</code> ：字节输出流，可以传递 <code>FileOutputStream</code>，缓冲流会给 <code>FileOutputStream</code> 增加一个缓冲区，提高 <code>FileOutputStream</code> 的写入效率。</li><li><code>int size</code> ：指定缓冲流内部缓冲区的大小，不指定则使用默认大小。</li></ul></li></ul><p>使用步骤：</p><ol><li>创建 <code>FileOutputStream</code> 对象，构造方法中绑定要输出的目的地；</li><li>创建 <code>BufferedOutputStream</code> 对象，构造方法中传递 <code>FileOutputStream</code> 对象，提高 <code>FileOutputStream</code> 对象效率；</li><li>使用 <code>BufferedOutputStream</code> 对象中的方法 <code>write</code>，把数据写入到内部缓冲区中；</li><li>使用 <code>BufferedOutputStream</code> 对象中的方法 <code>flush</code>，把内部缓冲区中的数据，刷新到文件中；</li><li>释放资源（会先调用 <code>flush</code> 方法刷新数据，第4部可以省略）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBufferedOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        bos.write(<span class="string">"我把数据写入到内部缓冲区中"</span>.getBytes());</span><br><span class="line">        <span class="comment">// bos.flush(); // 可省略</span></span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BufferedInputStream-字节缓冲输入流"><a href="#BufferedInputStream-字节缓冲输入流" class="headerlink" title="BufferedInputStream 字节缓冲输入流"></a><code>BufferedInputStream</code> 字节缓冲输入流</h2><p> <code>java.io.BufferedInputStream</code> 类继承 <code>InputStream</code> 类，是字节缓冲输入流。</p><p>继承自父类的共性成员方法：</p><ul><li><code>int read()</code> ：从输入流中读取数据的下一个字节。</li><li><code>int read(byte[] b)</code> ：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li><li><code>void close()</code> ：关闭此输入流并释放与该流关联的所有系统资源。</li></ul><p>构造方法：</p><ul><li><code>BufferedInputStream(InputStream in)</code> ：创建一个 <code>BufferedInputStream</code> 并保存其参数，即输入流 <code>in</code>，以便将来使用。</li><li><code>BufferedInputStream(InputStream in, int size)</code> ：创建具有指定缓冲区大小的 <code>BufferedInputStream</code> 并保存其参数，即输入流 <code>in</code>，以便将来使用。<ul><li><code>InputStream in</code> ：字节输入流，可以传递 <code>FileInputStream</code>，缓冲流会给 <code>FileInputStream</code> 增加一个缓冲区，提高 <code>FileInputStream</code> 的读取效率。</li><li><code>int size</code> ：指定缓冲流内部缓冲区的大小，不指定则使用默认大小。</li></ul></li></ul><p>使用步骤：</p><ol><li>创建 <code>FileInputStream</code> 对象，构造方法中绑定要读取的数据源；</li><li>创建 <code>BufferedInputStream</code> 对象，构造方法中传递 <code>FileInputStream</code> 对象，提高 <code>FileInputStream</code> 对象的读取效率；</li><li>使用 <code>BufferedInputStream</code> 对象中的方法 <code>read</code>，读取文件；</li><li>释放资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBufferedInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        <span class="comment">// 使用BufferedInputStream对象中的方法read,读取文件</span></span><br><span class="line">        <span class="comment">/*int len = 0; // 记录每次读取到的字节</span></span><br><span class="line"><span class="comment">        while((len = bis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">// 存储每次读取的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 记录每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BufferedWriter-字符缓冲输出流"><a href="#BufferedWriter-字符缓冲输出流" class="headerlink" title="BufferedWriter 字符缓冲输出流"></a><code>BufferedWriter</code> 字符缓冲输出流</h2><p> <code>java.io.BufferedWriter</code> 类继承 <code>Writer</code> 类，是字符缓冲输出流。</p><p>继承自父类的共性成员方法有：</p><ul><li><code>void write(int c)</code> ：写入单个字符。</li><li><code>void write(char[] cbuf)</code> ：写入字符数组。 </li><li><code>void write(char[] cbuf, int off, int len)</code> ：写入字符数组的某一部分。<ul><li><code>off</code> ：数组的开始索引。</li><li><code>len</code> ：写的字符个数。 </li></ul></li><li><code>void write(String str)</code> ：写入字符串。 </li><li><code>void write(String str, int off, int len)</code> ： 写入字符串的某一部分。<ul><li><code>off</code> ：字符串的开始索引。</li><li><code>len</code> ：写的字符个数。</li></ul></li><li><code>void flush()</code> ：刷新该流的缓冲。</li><li><code>void close()</code> ：关闭此流，但要先刷新它。 </li></ul><p>构造方法：</p><ul><li><code>BufferedWriter(Writer out)</code> ：创建一个使用默认大小输出缓冲区的缓冲字符输出流。</li><li><code>BufferedWriter(Writer out, int sz)</code> ：创建一个使用给定大小输出缓冲区的新缓冲字符输出流。<ul><li><code>Writer out</code> ：字符输出流，可以传递 <code>FileWriter</code>，缓冲流会给 <code>FileWriter</code> 增加一个缓冲区，提高 <code>FileWriter</code> 的写入效率。</li><li><code>int sz</code> ：指定缓冲区的大小，不写则使用默认大小。</li></ul></li></ul><p>特有的成员方法：</p><ul><li><code>void newLine()</code> ：写入一个行分隔符。会根据不同的操作系统，获取不同的行分隔符<ul><li>Windows：<code>\r\n</code> </li><li>Linux：<code>/n</code> </li><li>Mac：<code>/r</code> </li></ul></li></ul><p>使用步骤：</p><ol><li>创建字符缓冲输出流对象，构造方法中传递字符输出流；</li><li>调用字符缓冲输出流中的方法 <code>write</code>，把数据写入到内存缓冲区中；</li><li>调用字符缓冲输出流中的方法 <code>flush</code>，把内存缓冲区中的数据，刷新到文件中；</li><li>释放资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBufferedWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"c.txt"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            bw.write(<span class="string">"传智播客"</span>);</span><br><span class="line">            <span class="comment">// bw.write("\r\n");</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BufferedReader-字符缓冲输入流"><a href="#BufferedReader-字符缓冲输入流" class="headerlink" title="BufferedReader 字符缓冲输入流"></a><code>BufferedReader</code> 字符缓冲输入流</h2><p> <code>java.io.BufferedReader</code> 类继承 <code>Reader</code> 类，是字符缓冲输入流。</p><p>继承自父类的共性成员方法：</p><ul><li><code>int read()</code> ：读取单个字符并返回。</li><li><code>int read(char[] cbuf)</code> ：一次读取多个字符，将字符读入数组。</li><li><code>void close()</code> ：关闭该流并释放与之关联的所有资源。</li></ul><p>构造方法：</p><ul><li><code>BufferedReader(Reader in)</code> ：创建一个使用默认大小输入缓冲区的缓冲字符输入流。</li><li><code>BufferedReader(Reader in, int sz)</code> ：创建一个使用指定大小输入缓冲区的缓冲字符输入流。<ul><li><code>Reader in</code> ：字符输入流，可以传递 <code>FileReader</code>，缓冲流会给 <code>FileReader</code> 增加一个缓冲区，提高 <code>FileReader</code> 的读取效率。</li><li><code>int sz</code> ：指定缓冲区的大小，不写则使用默认大小。</li></ul></li></ul><p>特有的成员方法：</p><ul><li><code>String readLine()</code> ：<strong>读取一个文本行</strong>，读取一行数据。<ul><li>行的终止符号：通过下列字符之一即可认为某行已终止：换行 (<code>&#39;\n&#39;</code>)、回车 (<code>&#39;\r&#39;</code>) 或回车后直接跟着换行(<code>\r\n</code>)。</li><li>返回值：包含该行内容的字符串，<strong>不包含任何行终止符</strong>，如果已到达流末尾，则返回 <code>null</code>。</li></ul></li></ul><p>使用步骤：</p><ol><li>创建字符缓冲输入流对象，构造方法中传递字符输入流；</li><li>使用字符缓冲输入流对象中的方法 <code>read</code> / <code>readLine</code> 读取文本；</li><li>释放资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBufferedReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"10_IO\\c.txt"</span>));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            发现读取是一个重复的过程,可以使用循环优化</span></span><br><span class="line"><span class="comment">            不知道文件中有多少行数据,所以使用while循环</span></span><br><span class="line"><span class="comment">            while的结束条件,读取到null结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例：文本排序"><a href="#案例：文本排序" class="headerlink" title="案例：文本排序"></a>案例：文本排序</h2><p>请将文本信息恢复顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure><p>案例实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>], split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">            <span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key + <span class="string">"."</span> + value);</span><br><span class="line">            <span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><h2 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。</p><ul><li>编码：<ul><li>按照某种规则，将字符存储到计算机中。</li><li>字符（能看懂的）→ 字节（看不懂的）。</li></ul></li><li>解码：<ul><li>将存储在计算机中的二进制数按照某种规则解析显示出来。</li><li>字节(看不懂的)—&gt;字符(能看懂的)。</li></ul></li></ul><p><strong>字符编码 <code>Character Encoding</code></strong> ：就是一套自然语言的字符与二进制数之间的对应规则。</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><strong>字符集 <code>Charset</code></strong> ：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="/2020/02/20/java-advanced-4/charset.jpg" alt></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII 字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的 ASCII 字符集，使用 <strong>7 位（bits）表示一个字符</strong>，共 128 字符。ASCII 的扩展字符集使用 8 位（bits）表示一个字符，共 256 字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1 字符集</strong>：<ul><li>拉丁码表，别名 Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1 使用<strong>单字节编码</strong>，兼容 ASCII 编码。</li></ul></li><li><strong>GBxxx 字符集</strong>：<ul><li>GB 就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于 127 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含 7000 多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的“全角”字符，而原来在 127 号以下的那些就叫“半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了<strong>双字节编码</strong>方案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时<strong>支持繁体汉字以及日韩汉字</strong>等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字 70244 个，采用<strong>多字节编码</strong>，每个字可以由 <strong>1个、2 个或 4 个</strong>字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode 字符集</strong> ：<ul><li>Unicode 编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用 4 个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16 和 UTF-32。最为常用的 UTF-8 编码。</li><li>UTF-8 编码，可以用来表示 Unicode 标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持 UTF-8 编码。所以，我们开发 Web 应用，也要使用 UTF-8 编码。它<strong>使用一至四个字节</strong>为每个字符编码，编码规则：<ol><li>128 个 US-ASCII 字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的 Unicode 辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h2 id="编码引出的问题"><a href="#编码引出的问题" class="headerlink" title="编码引出的问题"></a>编码引出的问题</h2><p>在 IDEA 中，使用 <code>FileReader</code> 读取项目中的文本文件。由于 IDEA 的设置，都是默认的 <code>UTF-8</code> 编码，所以没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是 GBK 编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFileReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"我是GBK格式的文本.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换流的原理"><a href="#转换流的原理" class="headerlink" title="转换流的原理"></a>转换流的原理</h2><p><img src="/2020/02/20/java-advanced-4/转换流的原理.png" alt></p><h2 id="OutputStreamWriter-类"><a href="#OutputStreamWriter-类" class="headerlink" title="OutputStreamWriter 类"></a><code>OutputStreamWriter</code> 类</h2><p> <code>java.io.OutputStreamWriter</code> 类继承 <code>Writer</code> 类，是<strong>字符流通向字节流的桥梁</strong>，可使用指定的 <code>charset</code> 将要写入流中的字符编码成字节。（编码：把能看懂的变成看不懂）</p><p>继承自父类的共性成员方法：</p><ul><li><code>void write(int c)</code> ：写入单个字符。</li><li><code>void write(char[] cbuf)</code> ：写入字符数组。 </li><li><code>void write(char[] cbuf, int off, int len)</code> ：写入字符数组的某一部分。<ul><li><code>off</code> ：数组的开始索引。</li><li><code>len</code> ：写的字符个数。 </li></ul></li><li><code>void write(String str)</code> ：写入字符串。 </li><li><code>void write(String str, int off, int len)</code> ：写入字符串的某一部分。<ul><li><code>off</code> ：字符串的开始索引。</li><li><code>len</code> ：写的字符个数。</li></ul></li><li><code>void flush()</code> ：刷新该流的缓冲。</li><li><code>void close()</code> ：关闭此流，但要先刷新它。 </li></ul><p>构造方法：</p><ul><li><code>OutputStreamWriter(OutputStream out)</code> ：创建使用默认字符编码的 <code>OutputStreamWriter</code>。</li><li><code>OutputStreamWriter(OutputStream out, String charsetName)</code> ：创建使用指定字符集的 <code>OutputStreamWriter</code>。<ul><li><code>OutputStream out</code> ：字节输出流，可以用来写转换之后的字节到文件中。</li><li><code>String charsetName</code> ：指定的编码表名称，不区分大小写，可以是 utf-8 / UTF-8，gbk / GBK 等，不指定则默认使用UTF-8。</li></ul></li></ul><p>使用步骤：</p><ol><li>创建 <code>OutputStreamWriter</code> 对象，构造方法中传递字节输出流和指定的编码表名称；</li><li>使用 <code>OutputStreamWriter</code> 对象中的方法 <code>write</code>，把字符转换为字节存储缓冲区中（编码）；</li><li>使用 <code>OutputStreamWriter</code> 对象中的方法 <code>flush</code>，把内存缓冲区中的字节刷新到文件中（使用字节流写字节的过程）；</li><li>释放资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOutputStreamWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write_utf_8();</span><br><span class="line">        write_gbk();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("utf_8.txt"), "utf-8");</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"utf_8.txt"</span>)); <span class="comment">// 不指定默认使用UTF-8</span></span><br><span class="line">        osw.write(<span class="string">"你好"</span>);</span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_gbk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"gbk.txt"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        osw.write(<span class="string">"你好"</span>);</span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InputStreamReader-类"><a href="#InputStreamReader-类" class="headerlink" title="InputStreamReader 类"></a><code>InputStreamReader</code> 类</h2><p> <code>java.io.InputStreamReader</code> 类继承 <code>Reader</code> 类，是<strong>字节流通向字符流的桥梁</strong>，它使用指定的 <code>charset</code> 读取字节并将其解码为字符。（解码：把看不懂的变成能看懂的）</p><p>继承自父类的共性成员方法：</p><ul><li><code>public int read()</code> ：从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code> ：从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。</li><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li></ul><p>构造方法：</p><ul><li><code>InputStreamReader(InputStream in)</code> ：创建一个使用默认字符集的 <code>InputStreamReader</code>。</li><li><code>InputStreamReader(InputStream in, String charsetName)</code> ：创建使用指定字符集的 <code>InputStreamReader</code>。<ul><li><code>InputStream in</code> ：字节输入流，用来读取文件中保存的字节。</li><li><code>String charsetName</code> ：指定的编码表名称，不区分大小写，可以是 utf-8 / UTF-8，gbk / GBK 等，不指定则默认使用 UTF-8。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInputStreamReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read_utf_8();</span><br><span class="line">        read_gbk();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream("utf_8.txt"), "UTF-8");</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"utf_8.txt"</span>)); <span class="comment">// 不指定默认使用UTF-8</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_gbk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// InputStreamReader isr = new InputStreamReader(new FileInputStream("gbk.txt"), "UTF-8"); // ???</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"gbk.txt"</span>), <span class="string">"GBK"</span>); <span class="comment">// 你好</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例：转换文件编码"><a href="#案例：转换文件编码" class="headerlink" title="案例：转换文件编码"></a>案例：转换文件编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习：转换文件编码</span></span><br><span class="line"><span class="comment">        将GBK编码的文本文件，转换为UTF-8编码的文本文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"我是GBK格式的文本.txt"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">// 创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"我是utf_8格式的文件.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 使用InputStreamReader对象中的方法read读取文件</span></span><br><span class="line">        <span class="keyword">char</span> cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中</span></span><br><span class="line">            osw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h1><h2 id="序列化流概述"><a href="#序列化流概述" class="headerlink" title="序列化流概述"></a>序列化流概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该 <code>对象的数据</code>、<code>对象的类型</code> 和 <code>对象中存储的属性</code> 等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code> 和 <code>对象中存储的数据</code> 信息，都可以用来在内存中创建对象。</p><p><img src="/2020/02/20/java-advanced-4/序列化和反序列化的概述.png" alt="序列化和反序列化的概述"></p><h2 id="ObjectOutputStream-对象的序列化流"><a href="#ObjectOutputStream-对象的序列化流" class="headerlink" title="ObjectOutputStream 对象的序列化流"></a><code>ObjectOutputStream</code> 对象的序列化流</h2><p> <code>java.io.ObjectOutputStream</code> 类继承 <code>OutputStream</code> 类，是对象的序列化流，把 Java 对象以流的方式写入到文件中，实现对象的持久存储。</p><p>构造方法：</p><ul><li><code>ObjectOutputStream(OutputStream out)</code> ：创建写入指定 <code>OutputStream</code> 的 <code>ObjectOutputStream</code>。<ul><li>参数 <code>OutputStream out</code> ：字节输出流。</li></ul></li></ul><p>特有的成员方法：</p><ul><li><code>void writeObject(Object obj)</code> ：将指定的对象写入 <code>ObjectOutputStream</code>。</li></ul><p>使用步骤：</p><ol><li>创建 <code>ObjectOutputStream</code> 对象，构造方法中传递字节输出流；</li><li>使用 <code>ObjectOutputStream</code> 对象中的方法 <code>writeObject</code>，把对象写入到文件中；</li><li>释放资源。</li></ol><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a><code>Serializable</code> 接口</h3><p>类通过实现 <strong><code>java.io.Serializable</code> 接口</strong>以启用其序列化功能。</p><ul><li>要进行序列化和反序列化的类必须实现 <code>Serializable</code> 接口，未实现此接口的类将无法使其任何状态序列化或反序列化，序列化和反序列化的时候会抛出 <code>NotSerializableException</code> 异常。</li><li><code>Serializable</code> 接口是一个标记型接口，会给类添加一个标记，当进行序列化和反序列化的时候，就会检测类上是否有这个标记：<ul><li>有标记：可以序列化和反序列化；</li><li>没有标记：会抛出 <code>NotSerializableException</code> 。</li></ul></li></ul><h3 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a><code>transient</code> 关键字</h3><p> <code>static</code> 关键字：静态关键字</p><ul><li>静态优先于非静态加载到内存中（静态优先于对象进入到内存中）；</li><li>被 <code>static</code> 修饰的成员变量属于类，不能被序列化，序列化的都是对象。</li></ul><p><code>transient</code> 关键字：瞬态关键字</p><ul><li>被 <code>transient</code> 修饰的成员变量，不能被序列化。</li></ul><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><p>一个对象要想序列化，必须满足两个条件：</p><ul><li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用 <code>transient</code> 关键字修饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjectOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"小美女"</span>, <span class="number">18</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ObjectInputStream-对象的反序列化流"><a href="#ObjectInputStream-对象的反序列化流" class="headerlink" title="ObjectInputStream 对象的反序列化流"></a><code>ObjectInputStream</code> 对象的反序列化流</h2><p> <code>java.io.ObjectInputStream</code> 类继承 <code>InputStream</code> 类，是对象的反序列化流，把文件中保存的对象以流的方式读取出来使用。</p><p>构造方法：</p><ul><li><code>ObjectInputStream(InputStream in)</code> ：创建从指定 <code>InputStream</code> 读取的 <code>ObjectInputStream</code>。<ul><li>参数 <code>InputStream in</code> ：字节输入流。</li></ul></li></ul><p>特有的成员方法：</p><ul><li><code>Object readObject()</code> ：从 <code>ObjectInputStream</code> 读取对象。</li></ul><p>使用步骤:</p><ol><li>创建 <code>ObjectInputStream</code> 对象，构造方法中传递字节输入流；</li><li>使用 <code>ObjectInputStream</code> 对象中的方法 <code>readObject</code> 读取保存对象的文件；</li><li>释放资源；</li><li>使用读取出来的对象。</li></ol><h3 id="ClassNotFoundException-异常"><a href="#ClassNotFoundException-异常" class="headerlink" title="ClassNotFoundException 异常"></a><code>ClassNotFoundException</code> 异常</h3><p> <code>readObject</code> 方法声明抛出了 <code>ClassNotFoundException</code> （<code>class</code> 文件找不到异常），当不存在对象的 <code>class</code> 文件时抛出此异常。</p><p>反序列化的前提：</p><ol><li>类必须实现 <code>Serializable</code> 接口；</li><li>必须存在类对应的 <code>class</code> 文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02ObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="comment">// 使用读取出来的对象</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        Person p = (Person)o;</span><br><span class="line">        System.out.println(p.getName() + p.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InvalidClassException-异常"><a href="#InvalidClassException-异常" class="headerlink" title="InvalidClassException 异常"></a><code>InvalidClassException</code> 异常</h3><p>发生 <code>InvalidClassException</code> 异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配；</li><li>该类包含未知数据类型；</li><li>该类没有可访问的无参数构造方法。</li></ul><p> <code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号 <code>serialVersionUID</code> ，该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><p>当 JVM 反序列化对象时，能找到 <code>class</code> 文件，但是 <code>class</code> 文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 <code>InvalidClassException</code> 异常。</p><p><img src="/2020/02/20/java-advanced-4/序列号冲突异常的原理和解决方案.png" alt></p><h2 id="案例：序列化集合"><a href="#案例：序列化集合" class="headerlink" title="案例：序列化集合"></a>案例：序列化集合</h2><p>当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，对集合进序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));</span><br><span class="line">        </span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"list.txt"</span>));</span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        </span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"list.txt"</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o;</span><br><span class="line">        <span class="keyword">for</span> (Person p : list2) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ois.close();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><h2 id="打印流概述"><a href="#打印流概述" class="headerlink" title="打印流概述"></a>打印流概述</h2><p>平时我们在控制台打印输出，是调用 <code>print</code> 方法和 <code>println</code>方法完成的，这两个方法都来自于  <code>java.io.PrintStream</code> 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><p><code>PrintStream</code> 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p><p><code>PrintStream</code> 的特点：</p><ol><li><strong>只负责数据的输出</strong>，不负责数据的读取；</li><li>与其他输出流不同，<code>PrintStream</code> <strong>永远不会抛出 <code>IOException</code></strong>；</li><li>有特有的方法 <code>print</code>，<code>println</code>。</li></ol><p>构造方法：</p><ul><li><code>PrintStream(File file)</code> ：输出的目的地是一个文件。</li><li><code>PrintStream(OutputStream out)</code> ：输出的目的地是一个字节输出流。</li><li><code>PrintStream(String fileName)</code> ：输出的目的地是一个文件路径。</li></ul><p> <code>PrintStream</code> 类继承 <code>OutputStream</code> 类，继承自父类的成员方法有：</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code> ：将 b.length 字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。  </li><li><code>public void write(int b)</code> ：将指定的字节写入此输出流。</li></ul><p>注意：</p><ul><li>如果使用继承自父类的 <code>write</code> 方法写数据，那么查看数据的时候会查询编码表（如 97 → a）。</li><li>如果使用自己特有的方法 <code>print</code> / <code>println</code> 方法写数据，写的数据原样输出（如 97 → 97）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrintStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建打印流PrintStream对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"print.txt"</span>);</span><br><span class="line">        <span class="comment">// 如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a</span></span><br><span class="line">        ps.write(<span class="number">97</span>);</span><br><span class="line">        <span class="comment">// 如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97</span></span><br><span class="line">        ps.println(<span class="number">97</span>);</span><br><span class="line">        ps.println(<span class="number">8.8</span>);</span><br><span class="line">        ps.println(<span class="string">'a'</span>);</span><br><span class="line">        ps.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        ps.println(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h2><p>可以改变输出语句的目的地（打印流的流向）。输出语句，默认在控制台输出，使用 <code>System.setOut()</code> 方法将输出语句的目的地改为参数中传递的打印流的目的地。</p><ul><li><code>static void setOut(PrintStream out)</code> ：重新分配“标准”输出流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrintStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是在控制台输出"</span>);</span><br><span class="line"></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"目的地是打印流.txt"</span>);</span><br><span class="line">        System.setOut(ps); <span class="comment">// 把输出语句的目的地改变为打印流的目的地</span></span><br><span class="line">        System.out.println(<span class="string">"我在打印流的目的地中输出"</span>);</span><br><span class="line"></span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java语言高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java语言高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级（3）异常与多线程</title>
      <link href="/2020/02/14/java-advanced-3.html"/>
      <url>/2020/02/14/java-advanced-3.html</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p><strong>异常</strong>：指的是<strong>程序在执行过程中，出现的非正常的情况</strong>，最终会导致 JVM 的非正常停止。</p><p>在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出该异常对象。Java 处理异常的方式是中断处理。</p><p>异常指的<strong>并不是语法错误</strong>，语法错了，编译不通过，不会产生字节码文件，根本不能运行。</p><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p> <strong><code>java.lang.Throwable</code> 类</strong>：是 Java 语言中<strong>所有错误或异常的超类</strong>。</p><ul><li><strong><code>Error</code></strong> ：错误，因为这是系统内部的错误，运行时报错，无法处理。<ul><li>错误相当于绝症，必须修改源代码，程序才能继续执行。</li></ul></li><li><strong><code>Exception</code></strong> ：编译期异常，编译（写代码）Java 程序时出现的问题。<ul><li><strong><code>RuntimeException</code></strong> ：运行期异常，Java 程序运行过程中出现的问题。</li><li>异常相当于小毛病，把异常处理掉，程序可以继续运行。</li></ul></li></ul><p> <code>Throwable</code> 中的常用方法：</p><ul><li><code>public void printStackTrace()</code> ：打印异常的详细信息（包含异常的类型、原因、出现的位置）。</li><li><code>public String getMessage()</code> ：获取发生异常的原因。提示给用户的时候，就提示错误原因。</li><li><code>public String toString()</code> ：获取异常的类型和异常描述信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Exception:编译期异常,进行编译(写代码)java程序出现的问题</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);<span class="comment">//用来格式化日期</span></span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = sdf.parse(<span class="string">"1999-0909"</span>); <span class="comment">// 把字符串格式的日期,解析为Date格式的日期</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RuntimeException:运行期异常,java程序运行过程中出现的问题</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会出现异常的代码</span></span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Error:错误</span></span><br><span class="line"><span class="comment">            OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">            内存溢出的错误,创建的数组太大了,超出了给JVM分配的内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// int[] arr = new int[1024*1024*1024];</span></span><br><span class="line">        <span class="comment">// 必须修改代码,创建的数组小一点</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常的产生过程"><a href="#异常的产生过程" class="headerlink" title="异常的产生过程"></a>异常的产生过程</h2><p><img src="/2020/02/14/java-advanced-3/异常的产生过程解析.png" alt="异常产生过程"></p><h1 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h1><p>Java 异常处理的五个关键字：<strong><code>throw</code>、<code>throws</code>、<code>try</code>、<code>catch</code>、<code>finally</code></strong> 。</p><h2 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常 throw"></a>抛出异常 <code>throw</code></h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在 Java 中，提供了一个 <strong><code>throw</code> 关键字</strong>，用来抛出一个指定的异常对象。</p><ol><li>创建一个异常对象，封装一些提示信息。</li><li>通过关键字 <code>throw</code> 将这个异常对象告知给调用者。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> xxxExcepiton(<span class="string">"异常产生的原因"</span>);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>throw</code> 关键字必须写在<strong>方法的内部</strong>；</li><li><code>throw</code> 关键字后边 <strong><code>new</code> 的对象必须是 <code>Exception</code> 或者 <code>Exception</code> 的子类对象</strong>；</li><li><code>throw</code> 关键字抛出指定的异常对象，我们就必须处理这个异常对象：<ul><li><code>throw</code> 关键字后边创建的是 <code>RuntimeException</code> 或者是 <code>RuntimeException</code> 的子类对象，我们可以不处理，默认交给 <code>JVM</code> 处理（打印异常对象，中断程序）；</li><li><code>throw</code> 关键字后边创建的是<strong>编译期异常</strong>（写代码的时候报错），我们就必须处理这个异常，<strong>要么 <code>throws</code>，要么 <code>try...catch</code></strong>。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int[] arr = null;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> e = getElement(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,获取数组指定索引处的元素</span></span><br><span class="line"><span class="comment">        以后(工作中)我们首先必须对方法传递过来的参数进行合法性校验</span></span><br><span class="line"><span class="comment">        如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法的调用者,传递的参数有问题</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理</span></span><br><span class="line"><span class="comment">            ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以对传递过来的参数数组,进行合法性校验</span></span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"传递的数组的值是null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以对传递过来的参数index进行合法性校验</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"传递的索引超出了数组的使用范围"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ele = arr[index];</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Objects-非空判断"><a href="#Objects-非空判断" class="headerlink" title="Objects 非空判断"></a><code>Objects</code> 非空判断</h2><p>提到过 <code>Objects</code> 类由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的）。在 <code>Objects</code> 的源码中，对对象为 <code>null</code> 的值进行了抛出异常操作。</p><ul><li><code>public static &lt;T&gt; T requireNonNull(T obj)</code> ：查看指定引用对象不是 null。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjects</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对传递过来的参数进行合法性判断,判断是否为null</span></span><br><span class="line">        <span class="comment">/*if(obj == null) &#123;</span></span><br><span class="line"><span class="comment">            throw new NullPointerException("传递的对象的值是null");</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Objects.requireNonNull(obj);</span></span><br><span class="line">        Objects.requireNonNull(obj, <span class="string">"传递的对象的值是null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明异常-throws"><a href="#声明异常-throws" class="headerlink" title="声明异常 throws"></a>声明异常 <code>throws</code></h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。</p><p> <code>throws</code> 关键字：异常处理的第一种方式，交给别人去处理。当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象，可以使用 <code>throws</code> 关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终可以交给 JVM 处理（中断处理）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表) <span class="keyword">throws</span> 异常类名<span class="number">1</span>, 异常类名<span class="number">2</span>... &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>throws</code> 关键字必须写在<strong>方法声明处</strong>。</li><li><code>throws</code> 关键字后边声明的异常必须是 <code>Exception</code> 或者是 <code>Exception</code> 的子类。</li><li>方法内部如果抛出了多个异常对象，那么 <code>throws</code> 后边必须也声明多个异常。<ul><li>如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可。</li></ul></li><li>调用了一个声明抛出异常的方法,我们就必须的处理声明的异常：<ul><li>要么继续使用 <code>throws</code> 声明抛出，交给方法的调用者处理,最终交给 JVM；</li><li>要么 <code>try...catch</code> 自己处理异常。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThrows</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        FileNotFoundException extends IOException extends Excepiton</span></span><br><span class="line"><span class="comment">        如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// public static void main(String[] args) throws FileNotFoundException,IOException &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        readFile(<span class="string">"c:\\a.tx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,对传递的文件路径进行合法性判断</span></span><br><span class="line"><span class="comment">        如果路径不是"c:\\a.txt",那么我们就抛出文件找不到异常对象,告知方法的调用者</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常</span></span><br><span class="line"><span class="comment">            可以使用throws继续声明抛出FileNotFoundException这个异常对象,让方法的调用者处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fileName.equals(<span class="string">"c:\\a.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"传递的文件路径不是c:\\a.txt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果传递的路径,不是.txt结尾</span></span><br><span class="line"><span class="comment">            那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="捕获异常-try-catch"><a href="#捕获异常-try-catch" class="headerlink" title="捕获异常 try...catch"></a>捕获异常 <code>try...catch</code></h2><p>如果异常出现的话，会立刻终止程序，所以我们得处理异常：</p><ol><li>该方法不处理，而是声明抛出，由该方法的调用者来处理（<code>throws</code>）。</li><li>在方法中使用 <code>try-catch</code> 的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常，可以对出现的异常进行指定方式的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    可能产生异常的代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(定义一个异常的变量,用来接收<span class="keyword">try</span>中抛出的异常对象) &#123;</span><br><span class="line">    异常的处理逻辑,捕获异常对象之后,怎么处理异常对象</span><br><span class="line">    一般在工作中,会把异常的信息记录到一个日志中</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>try</code> 中可能会抛出多个异常对象，那么就可以使用多个 <code>catch</code> 来处理这些异常对象。</li><li>如果 <code>try</code> 中产生了异常，那么就会执行 <code>catch</code> 中的异常处理逻辑，执行完毕 <code>catch</code> 中的处理逻辑，继续执行 <code>try...catch</code> 之后的代码。</li><li>如果 <code>try</code> 中没有产生异常，那么就不会执行 <code>catch</code> 中异常的处理逻辑，执行完 <code>try</code> 中的代码，继续执行 <code>try...catch</code> 之后的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTryCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能产生异常的代码</span></span><br><span class="line">            readFile(<span class="string">"d:\\a.tx"</span>);</span><br><span class="line">            System.out.println(<span class="string">"资源释放"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象</span></span><br><span class="line">            <span class="comment">// 异常的处理逻辑,异常异常对象之后,怎么处理异常对象</span></span><br><span class="line">            System.out.println(<span class="string">"catch - 传递的文件后缀不是.txt"</span>);</span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">// 文件的后缀名不对    </span></span><br><span class="line">            System.out.println(e);<span class="comment">//java.io.IOException: 文件的后缀名不对</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                java.io.IOException: 文件的后缀名不对</span></span><br><span class="line"><span class="comment">                    at com.itheima.demo02.Exception.Demo01TryCatch.readFile(Demo01TryCatch.java:55)</span></span><br><span class="line"><span class="comment">                    at com.itheima.demo02.Exception.Demo01TryCatch.main(Demo01TryCatch.java:27)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a><code>finally</code> 代码块</h2><p>有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而 <code>finally</code> 就是解决这个问题的，<strong>在 <code>finally</code> 代码块中存放的代码都是一定会被执行的。</strong> </p><p>什么时候的代码必须最终执行？当我们在 <code>try</code> 语句块中打开了一些物理资源（磁盘文件/网络连接/数据库连接等），我们都得在使用完之后，最终关闭打开的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    可能产生异常的代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(定义一个异常的变量,用来接收<span class="keyword">try</span>中抛出的异常对象) &#123;</span><br><span class="line">    异常的处理逻辑,捕获异常对象之后,怎么处理异常对象</span><br><span class="line">    一般在工作中,会把异常的信息记录到一个日志中</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    无论是否出现异常都会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><code>finally</code> 不能单独使用，必须和 <code>try</code> 一起使用。</li><li><code>finally</code> 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放。</li><li>只有在 <code>try</code> 或者 <code>catch</code> 中调用退出 JVM 的相关方法，此时 <code>finally</code> 才不会执行，否则 <code>finally</code> 永远会执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTryCatchFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会产生异常的代码</span></span><br><span class="line">            readFile(<span class="string">"c:\\a.tx"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 异常的处理逻辑</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否出现异常,都会执行</span></span><br><span class="line">            System.out.println(<span class="string">"资源释放"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><ul><li>运行时异常被抛出可以不处理，即不捕获也不声明抛出。</li><li>多个异常使用捕获又该如何处理呢？<ol><li>多个异常分别处理。</li><li>多个异常一次捕获多次处理。（<code>catch</code> 里边定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在上边，否则就会报错。）</li><li>多个异常一次捕获一次处理。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 运行时异常被抛出可以不处理。即不捕获也不声明抛出。</span></span><br><span class="line">        <span class="comment">// 默认给虚拟机处理,终止程序,什么时候不抛出运行时异常了,在来继续执行程序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]); <span class="comment">// ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>)); <span class="comment">// IndexOutOfBoundsException: Index 3 out-of-bounds for length 3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 多个异常分别处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 多个异常一次捕获，多次处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            <span class="comment">// System.out.println(arr[3]);</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个try多个catch注意事项:</span></span><br><span class="line"><span class="comment">                catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错</span></span><br><span class="line"><span class="comment">                ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            <span class="comment">// System.out.println(arr[3]);</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 多个异常一次捕获一次处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            <span class="comment">// System.out.println(arr[3]);</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"后续代码!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>finally</code> 有 <code>return</code> 语句，永远返回 <code>finally</code> 中的结果，避免该情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = getA();</span><br><span class="line">        System.out.println(a); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,返回变量a的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 一定会执行的代码</span></span><br><span class="line">            a = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类与父类的异常：<ul><li>如果父类抛出了多个异常，子类重写父类方法时，<strong>抛出和父类相同的异常</strong>或者<strong>抛出父类异常的子类</strong>或者<strong>不抛出异常</strong>。</li><li>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</li><li>注意：父类异常是什么样，子类异常就什么样。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子类重写父类方法时,抛出和父类相同的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类重写父类方法时,抛出父类异常的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 子类重写父类方法时,不抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。</span></span><br><span class="line">    <span class="comment">// public void show04() throws Exception&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时子类产生该异常，只能捕获处理，不能声明抛出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"编译期异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>为什么需要自定义异常类？Java 中不同的异常类，分别表示着某一种具体的异常情况，那么在开发中总是有些异常情况是没有定义好的，此时我们根据自己业务的异常情况来定义异常类。</p><p>异常类如何定义：</p><ol><li>自定义一个编译期异常类：自定义类，并继承于 <code>java.lang.Exception</code>。</li><li>自定义一个运行期异常类：自定义类，并继承于 <code>java.lang.RuntimeException</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXExcepiton</span> <span class="keyword">extends</span> <span class="title">Exception</span> | <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    添加一个空参数的构造方法</span><br><span class="line">    添加一个带异常信息的构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>自定义异常类一般都是以 <code>Exception</code> 结尾，说明该类是一个异常类。</li><li>自定义异常类，必须的继承 <code>Exception</code> 或者 <code>RuntimeException</code>：<ul><li>继承 <code>Exception</code> ：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么 <code>throws</code>，要么 <code>try...catch</code>。</li><li>继承 <code>RuntimeException</code> ：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）。</li></ul></li></ol><p>自定义一个注册异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个空参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        添加一个带异常信息的构造方法</span></span><br><span class="line"><span class="comment">        查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRegisterException</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.使用数组保存已经注册过的用户名(数据库)</span></span><br><span class="line">    <span class="keyword">static</span> String[] usernames = &#123;<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RegisterException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.使用Scanner获取用户输入的注册的用户名(前端,页面)</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入您要注册的用户名:"</span>);</span><br><span class="line">        String username = sc.next();</span><br><span class="line">        checkUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.定义一个方法,对用户输入的中注册的用户名进行判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> RegisterException </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历存储已经注册过用户名的数组,获取每一个用户名</span></span><br><span class="line">        <span class="keyword">for</span> (String name : usernames) &#123;</span><br><span class="line">            <span class="comment">// 使用获取到的用户名和用户输入的用户名比较</span></span><br><span class="line">            <span class="keyword">if</span>(name.equals(username)) &#123;</span><br><span class="line">                <span class="comment">// true:用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册";</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">"亲，该用户名已经被注册"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RegisterException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 打印异常后结束方法，避免方法中后续代码继续执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!";</span></span><br><span class="line">        System.out.println(<span class="string">"恭喜您,注册成功!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src="/2020/02/14/java-advanced-3/并发与并行.png" alt></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><p><strong>进程</strong>：是指一个进入内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p><p><img src="/2020/02/14/java-advanced-3/进程概念.png" alt></p><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p><p><img src="/2020/02/14/java-advanced-3/线程概念.png" alt></p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul><li>分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</li><li><strong>抢占式调度</strong>：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java 使用的为抢占式调度。<ul><li>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos 窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</li><li>实际上，CPU 使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU 在多个线程间的切换速度相对我们的感觉要快，看上去就是在同一时刻运行。</li><li>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让 CPU 的使用率更高。</li></ul></li></ul><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p><strong>主线程</strong>：执行主（main）方法的线程。</p><ul><li>JVM 执行 main 方法，main 方法会进入到栈内存，JVM 会找操作系统开辟一条 main 方法通向 CPU 的执行路径，CPU 就可以通过这个路径来执行 main 方法。</li></ul><p><img src="/2020/02/14/java-advanced-3/主线程.png" alt></p><h2 id="创建-Thread-类"><a href="#创建-Thread-类" class="headerlink" title="创建 Thread 类"></a>创建 <code>Thread</code> 类</h2><p>创建多线程程序的第一种方式：创建 <code>Thread</code> 类的子类。</p><p> <code>java.lang.Thread</code> 类是描述线程的类，<strong>所有的线程对象都必须是 <code>Thread</code> 类或其子类的实例</strong>。</p><p>Java 中通过继承 <code>Thread</code> 类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义一个 <code>Thread</code> 类的子类，并重写 <code>Thread</code> 类中的 <code>run()</code> 方法，设置线程任务；</li><li>创建 <code>Thread</code> 子类的实例，即创建线程对象；</li><li>调用线程对象的 <code>start()</code> 方法，启动新的线程，执行 <code>run()</code> 方法。</li></ol><p>注意：多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</p><h2 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 4.调用Thread类中的方法start方法,开启新的线程,执行run方法</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程随机打印结果"><a href="#多线程随机打印结果" class="headerlink" title="多线程随机打印结果"></a>多线程随机打印结果</h3><p>程序启动运行 <code>main</code> 时，JVM 启动一个进程，主线程 <code>main</code> 在 <code>main()</code> 调用时候被创建。随着调用 mt 的对象的 <code>start()</code> 方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。  </p><p>结果是两个线程并发地运行：当前线程（main 线程）和另一个线程（创建的新线程，执行其 run 方法）。</p><ul><li>Java 程序属于抢占式调度，哪个线程的优先级高，哪个线程优先执行；同一个优先级，随机选择一个执行。</li></ul><p><img src="/2020/02/14/java-advanced-3/多线程随机性打印结果.png" alt></p><h3 id="多线程内存原理"><a href="#多线程内存原理" class="headerlink" title="多线程内存原理"></a>多线程内存原理</h3><p>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间</strong>，进行方法的压栈和弹栈。当执行线程的任务结束后，线程自动在栈内存中释放。但是当所有的执行线程都结束了，那么进程就结束了。  </p><p><img src="/2020/02/14/java-advanced-3/多线程内存图解.png" alt></p><h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a><code>Thread</code> 类</h2><p> <code>Thread</code> 类中定义了有关线程的一些方法：</p><ul><li>构造方法：<ul><li><code>public Thread()</code> ：分配一个新的线程对象。</li><li><code>public Thread(String name)</code> ：分配一个指定名字的新的线程对象。</li><li><code>public Thread(Runnable target)</code> ：分配一个带有指定目标新的线程对象。</li><li><code>public Thread(Runnable target, String name)</code> ：分配一个带有指定目标新的线程对象并指定名字。</li></ul></li><li>常用方法：<ul><li><code>public String getName()</code> ：获取当前线程名称。</li><li><code>public void start()</code> ：导致此线程开始执行； Java 虚拟机调用此线程的 run 方法。</li><li><code>public void run()</code> ：此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code> ：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li><code>public static Thread currentThread()</code> ：返回对当前正在执行的线程对象的引用。</li></ul></li></ul><h3 id="获取线程名称"><a href="#获取线程名称" class="headerlink" title="获取线程名称"></a>获取线程名称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写Thread类中的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程名称</span></span><br><span class="line">        String name = getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(t); <span class="comment">// Thread[Thread-0,5,main]</span></span><br><span class="line">        String name = t.getName();</span><br><span class="line">        System.out.println(name); <span class="comment">// Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGetThreadName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 调用start方法,开启新线程,执行run方法</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">// main</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置线程名称"><a href="#设置线程名称" class="headerlink" title="设置线程名称"></a>设置线程名称</h3><ol><li>使用 <code>Thread</code> 类中的 <code>setName(名字)</code> 方法。<ul><li><code>void setName(String name)</code> ：改变线程名称，使之与参数 name 相同。</li></ul></li><li>创建一个带参数的构造方法，参数传递线程的名称：调用父类的带参构造方法，把线程名称传递给父类，让父类（<code>Thread</code>）给子线程起一个名字。<ul><li><code>Thread(String name)</code> ：分配新的 <code>Thread</code> 对象。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name); <span class="comment">// 把线程名称传递给父类,让父类(Thread)给子线程起一个名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程的名称</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSetThreadName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启多线程</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.setName(<span class="string">"小强"</span>);</span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启多线程</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"旺财"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暂停执行线程"><a href="#暂停执行线程" class="headerlink" title="暂停执行线程"></a>暂停执行线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟秒表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用Thread类的sleep方法让程序睡眠1秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 <code>Runnable</code> 接口</h2><p>创建多线程程序的第二种方式：实现 <code>Runnable</code> 接口。</p><p> <code>java.lang.Runnable</code> 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 <code>run</code> 的无参数方法。</p><p>实现步骤：</p><ol><li>定义一个 <code>Runnable</code> 接口的实现类；</li><li>在实现类中重写 <code>Runnable</code> 接口的 <code>run()</code> 方法，设置线程任务；</li><li>创建一个 <code>Runnable</code> 接口的实现类对象；</li><li>创建 <code>Thread</code> 类对象，构造方法中传递 <code>Runnable</code> 接口的实现类对象；</li><li>调用 <code>Thread</code> 类中的 <code>start()</code> 方法，开启新的线程执行 <code>run()</code> 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.在实现类中重写Runnable接口的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"HelloWorld"</span> + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建一个Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">// 4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(run); <span class="comment">// 打印线程名称</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(new RunnableImpl2()); // 打印HelloWorld</span></span><br><span class="line">        <span class="comment">// 5.调用Thread类中的start方法,开启新的线程执行run方法</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现 <code>Runnable</code> 接口，使得该类有了多线程类的特征。<code>run()</code> 方法是多线程程序的一个执行目标，所有的多线程代码都在 <code>run()</code> 方法里面。<code>Thread</code> 类实际上也是实现了 <code>Runnable</code> 接口的类。</p><p>实现 <code>Runnable</code> 接口创建多线程程序的好处：</p><ol><li><strong>避免了单继承的局限性</strong>：<ul><li>一个类只能继承一个类，类继承了 <code>Thread</code> 类就不能继承其他的类。</li><li>实现了 <code>Runnable</code> 接口，还可以继承其他的类，实现其他的接口。</li></ul></li><li>增强了程序的扩展性，降低了程序的耦合性（解耦）：<ul><li>实现 <code>Runnable</code> 接口的方式，把<strong>设置线程任务</strong>和<strong>开启新线程</strong>进行了分离（解耦）。</li><li>实现类中，重写了 <code>run()</code> 方法：用来设置线程任务。</li><li>创建 <code>Thread</code> 类对象，调用 <code>start()</code> 方法：用来开启新线程。</li></ul></li></ol><h2 id="匿名内部类方式创建线程"><a href="#匿名内部类方式创建线程" class="headerlink" title="匿名内部类方式创建线程"></a>匿名内部类方式创建线程</h2><p>匿名：没有名字。</p><p>内部类：写在其他类内部的类。</p><p>匿名内部类作用：简化代码。</p><ul><li>把子类继承父类，重写父类的方法，创建子类对象合一步完成。</li><li>把实现类实现类接口，重写接口中的方法，创建实现类对象合成一步完成。</li><li>匿名内部类的最终产物：子类/实现类对象，而这个类没有名字。</li></ul><p>使用线程的匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 </p><p>使用匿名内部类的方式实现 <code>Runnable</code> 接口，重新 <code>Runnable</code> 接口中的 <code>run()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程的父类是Thread</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"Java"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程的接口Runnable</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"程序员"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化接口的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + <span class="string">"Java程序员"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>通过一个电影院卖票的案例，演示线程的安全问题： </p><p><img src="/2020/02/14/java-advanced-3/线程安全问题.png" alt="线程安全问题"></p><p>模拟卖票：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 出票操作</span></span><br><span class="line">                <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模拟卖票案例</span></span><br><span class="line"><span class="comment">    创建3个线程,同时开启,对共享的票进行出售</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Runnable接口的实现类对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">// 创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(ticket);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket);</span><br><span class="line">        <span class="comment">// 调用start方法开启多线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现程序出现了两个问题：</p><ol><li>相同的票数，比如 100 这张票被卖了两回。</li><li>不存在的票，比如 0 票与 -1 票，是不存在的。</li></ol><p>这样的线程是不安全的。</p><p>上述案例中造成线程安全问题的原因分析如下：<img src="/2020/02/14/java-advanced-3/线程安全问题产生的原理.png" alt></p><p>线程安全问题都是<strong>由全局变量及静态变量引起</strong>的。</p><ul><li>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</li><li>若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。</li></ul><h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 </p><p>要解决上述多线程并发访问一个资源的安全性问题：也就是解决重复票与不存在票问题，Java 中提供了同步机制 （<strong><code>synchronized</code></strong>）来解决。 </p><p>根据案例简述：窗口 1 线程进入操作的时候，窗口 2 和窗口 3 线程只能在外等着，窗口 1 操作结束，窗口 2 和窗口 3 才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺 CPU 资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p><p>为了保证每个线程都能正常执行原子操作，Java 引入了线程同步机制，有三种方式完成同步操作：</p><ol><li>同步代码块；</li><li>同步方法；</li><li>锁机制。</li></ol><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p><strong>同步代码块</strong>： <code>synchronized</code> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁对象) &#123;</span><br><span class="line">    可能会出现线程安全问题的代码(访问了共享数据的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>通过代码块中的锁对象，可以<strong>使用任意的对象</strong>。</li><li>但是必须保证多个线程<strong>使用的锁对象是同一个</strong>。</li><li>锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个锁对象</span></span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="comment">// 先判断票是否存在</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 出票操作</span></span><br><span class="line">                    <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步技术的原理"><a href="#同步技术的原理" class="headerlink" title="同步技术的原理"></a>同步技术的原理</h3><p>同步技术使用锁对象保证线程安全，这个锁对象叫<strong>同步锁（或对象监视器）</strong>。当某线程要执行同步代码时，会检查是否有锁对象。发现有锁对象时，就会获取到锁对象，进入同步中执行，执行完同步代码立刻归还锁对象；发现没有锁对象，线程就会进入阻塞状态，一直等待到获取到锁对象。</p><p><img src="/2020/02/14/java-advanced-3/同步的原理.png" alt></p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p><strong>同步方法</strong>：使用 <code>synchronized</code> 修饰的方法，就叫做同步方法，保证某一线程执行该方法的时候，其他线程只能在方法外等着。 </p><p>使用步骤：</p><ol><li>把访问了共享数据的代码抽取出来，放到一个方法中；</li><li>在方法上添加 <code>synchronized</code> 修饰符。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    可能会出现线程安全问题的代码(访问了共享数据的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>非静态同步方法的锁对象是 <code>this</code> 。</li><li>静态同步方法的锁对象是本类的 <code>class</code> 属性，也就是当前方法所在类的字节码文件对象（<code>类名.class</code>）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this:"</span> + <span class="keyword">this</span>); <span class="comment">// this:com.itheima.demo08.Synchronized.RunnableImpl@58ceff1</span></span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            payTicket();</span><br><span class="line">            payTicketStatic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个同步方法</span></span><br><span class="line"><span class="comment">        同步方法也会把方法内部的代码锁住</span></span><br><span class="line"><span class="comment">        只让一个线程执行</span></span><br><span class="line"><span class="comment">        同步方法的锁对象是谁?</span></span><br><span class="line"><span class="comment">        就是实现类对象 new RunnableImpl()</span></span><br><span class="line"><span class="comment">        也是就是this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态的同步方法</span></span><br><span class="line"><span class="comment">        锁对象是谁?</span></span><br><span class="line"><span class="comment">        不能是this</span></span><br><span class="line"><span class="comment">        this是创建对象之后产生的,静态方法优先于对象</span></span><br><span class="line"><span class="comment">        静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">payTicketStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RunnableImpl.class) &#123;</span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a><code>Lock</code> 锁</h3><p> <strong><code>java.util.concurrent.locks.Lock</code> 机制</strong>提供了比 <strong><code>synchronized</code> 代码块</strong>和 <strong><code>synchronized</code> 方法</strong>更广泛的锁定操作，同步代码块 / 同步方法具有的功能 <code>Lock</code> 都有，除此之外更强大，更体现面向对象。</p><p><code>Lock</code> 接口中的方法：</p><ul><li><code>public void lock()</code> ：获取锁。</li><li><code>public void unlock()</code> ：释放锁。</li></ul><p>使用步骤：</p><ol><li>在成员位置创建一个 <code>ReentrantLock</code> 对象（<code>java.util.concurrent.locks.ReentrantLock</code> 类实现了 <code>Lock</code> 接口）；</li><li>在可能会出现安全问题的代码前调用 <code>Lock</code> 接口中的方法 <code>lock()</code> 获取锁；</li><li>在可能会出现安全问题的代码后调用 <code>Lock</code> 接口中的方法 <code>unlock()</code> 释放锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.在成员位置创建一个ReentrantLock对象</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    <span class="comment">// 票存在,卖票 ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line">                    lock.unlock(); <span class="comment">// 无论程序是否异常,都会把锁释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><h2 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><div class="table-container"><table><thead><tr><th>线程状态</th><th>导致状态发生的条件</th></tr></thead><tbody><tr><td><code>NEW</code>（新建）</td><td>线程刚被创建，但是并未启动。还没调用 <code>start</code> 方法。</td></tr><tr><td><code>RUNNABLE</code>（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td></tr><tr><td><code>BLOCKED</code>（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 <code>Blocked</code> 状态；当该线程持有锁时，该线程将变成 <code>Runnable</code> 状态。</td></tr><tr><td><code>WAITING</code>（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 <code>Waiting</code> 状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用 <code>notify</code> 或者 <code>notifyAll</code> 方法才能够唤醒。</td></tr><tr><td><code>TIMED_WAITING</code>（计时等待）</td><td>同 <code>Waiting</code> 状态，有几个方法有超时参数，调用他们将进入 <code>Timed Waiting</code> 状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 <code>Thread.sleep</code> 、<code>Object.wait</code>。</td></tr><tr><td><code>TERMINATED</code>（终止）</td><td>因为 <code>run</code> 方法正常退出而死亡，或者因为没有捕获的异常终止了 <code>run</code> 方法而死亡。</td></tr></tbody></table></div><p>线程的状态图：<img src="/2020/02/14/java-advanced-3/线程的状态图.png" alt="线程的状态图"></p><h2 id="等待与唤醒"><a href="#等待与唤醒" class="headerlink" title="等待与唤醒"></a>等待与唤醒</h2><p>进入 <code>Time Waiting</code> （计时等待）状态有两种方式：</p><ol><li>使用 <code>Thread.sleep(long m)</code> 方法，在毫秒值结束之后，线程睡醒进入到 <code>Runnable</code> / <code>Blocked</code> 状态。</li><li>使用 <code>Object.wait(long m)</code> 方法，<code>wait</code> 方法如果在毫秒值结束之后，还没有被 <code>notify</code> 唤醒，就会自动醒来，线程睡醒进入到 <code>Runnable</code> / <code>Blocked</code> 状态。</li></ol><p>进入 <code>Waiting</code> 状态的方式：</p><ul><li>使用 <code>Object.wait()</code> 方法，在其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法前，导致当前线程等待。</li></ul><p>唤醒的方法：</p><ul><li><code>void notify()</code> 唤醒在此对象监视器上等待的单个线程。</li><li><code>void notifyAll()</code> 唤醒在此对象监视器上等待的所有线程。</li><li>会继续执行 <code>wait</code> 方法之后的代码。</li></ul><p>注意事项：</p><ul><li><code>Timed Waiting</code>（计时等待） 与 <code>Waiting</code>（无限等待） 状态联系很紧密。 <code>Waiting</code> 状态中 <code>wait</code> 方法是空参的，而 <code>Timed Waiting</code> 中 <code>wait</code> 方法是带参的。这种带参的方法，其实是一种倒计时操作，如果提前得到（唤醒）通知，设定时间也就显得多此一举了。那么，这种设计方案其实是一举两得，如果没有得到（唤醒）通知，那么线程就处于 <code>Timed Waiting</code> 状态，直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从 <code>Timed Waiting</code> 状态立刻唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建锁对象,保证唯一</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个顾客线程(消费者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 一直等着买包子</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"顾客1告知老板要的包子的种类和数量"</span>);</span><br><span class="line">                        <span class="comment">// 调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">                        System.out.println(<span class="string">"包子已经做好了,顾客1开吃!"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个顾客线程(消费者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 一直等着买包子</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"顾客2告知老板要的包子的种类和数量"</span>);</span><br><span class="line">                        <span class="comment">// 调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">                        System.out.println(<span class="string">"包子已经做好了,顾客2开吃!"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个老板线程(生产者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 一直做包子</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 花了5秒做包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>); <span class="comment">// 花5秒钟做包子</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"老板5秒钟之后做好包子,告知顾客,可以吃包子了"</span>);</span><br><span class="line">                        <span class="comment">// 做好包子之后,调用notify方法,唤醒顾客吃包子</span></span><br><span class="line">                        obj.notify(); <span class="comment">// 如果有多个等待线程,随机唤醒一个</span></span><br><span class="line">                        <span class="comment">// obj.notifyAll(); // 唤醒所有等待的线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p><strong>线程间通信：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p><img src="/2020/02/14/java-advanced-3/线程通信示意.png" alt></p><p>为什么要处理线程间通信？</p><ul><li>多个线程并发执行时, 在默认情况下 CPU 是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</li></ul><p>如何保证线程间通信有效利用资源？</p><ul><li>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即<strong>等待唤醒机制。</strong></li></ul><h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p><strong>等待唤醒机制</strong>是多个线程间的一种<strong>协作</strong>机制。谈到线程，经常想到的是线程间的<strong>竞争</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（<code>wait()</code>），等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）；在有多个线程进行等待时，如果需要，可以使用 <code>notifyAll()</code> 来唤醒所有的等待线程。</p><p> <code>wait/notify</code> 就是线程间的一种协作机制。使用到的3个方法的含义如下：</p><ol><li><code>wait</code> ：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 <code>WAITING</code>。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是通知在这个对象上等待的线程从 wait set 中释放出来，重新进入到调度队列（ready queue）中。</li><li><code>notify</code> ：则选取所通知对象的 wait set 中的一个线程释放。</li><li><code>notifyAll</code> ：则释放所通知对象的 wait set 上的全部线程。</li></ol><p>注意：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能<strong>在当初调用 <code>wait</code> 方法之后的地方恢复执行</strong>。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 <code>WAITING</code> 状态变成 <code>RUNNABLE</code> 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 <code>WAITING</code> 状态又变成 <code>BLOCKED</code> 状态。</li></ul><p>调用 <code>wait</code> 和 <code>notify</code> 方法需要注意的细节：</p><ol><li><code>wait</code> 方法与 <code>notify</code> 方法必须要由<strong>同一个锁对象</strong>调用。<ul><li>对应的锁对象可以通过 <code>notify</code> 唤醒使用同一个锁对象调用 <code>wait</code> 方法的线程。</li></ul></li><li><code>wait</code> 方法与 <code>notify</code> 方法是<strong>属于 <code>Object</code> 类的方法</strong>的。<ul><li>锁对象可以是任意对象，而任意对象的所属类都是继承了 <code>Object</code> 类的。</li></ul></li><li><code>wait</code> 方法与 <code>notify</code> 方法必须要在<strong>同步代码块</strong>或者是<strong>同步方法</strong>中使用。<ul><li>必须要通过锁对象调用这两个方法。</li></ul></li></ol><h2 id="等待唤醒案例"><a href="#等待唤醒案例" class="headerlink" title="等待唤醒案例"></a>等待唤醒案例</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p><p><img src="/2020/02/14/java-advanced-3/等待与唤醒案例分析.png" alt></p><p>定义包子资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    资源类:包子类</span></span><br><span class="line"><span class="comment">设置包子的属性</span></span><br><span class="line"><span class="comment">皮</span></span><br><span class="line"><span class="comment">陷</span></span><br><span class="line"><span class="comment">包子的状态: 有 true,没有 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    <span class="comment">//皮</span></span><br><span class="line">    String pi;</span><br><span class="line">    <span class="comment">//陷</span></span><br><span class="line">    String xian;</span><br><span class="line">    <span class="comment">//包子的状态: 有 true,没有 false,设置初始值为false没有包子</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义吃货线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消费者(吃货)类:是一个线程类,可以继承Thread</span></span><br><span class="line"><span class="comment">设置线程任务(run):吃包子</span></span><br><span class="line"><span class="comment">对包子的状态进行判断</span></span><br><span class="line"><span class="comment">false:没有包子</span></span><br><span class="line"><span class="comment">吃货调用wait方法进入等待状态</span></span><br><span class="line"><span class="comment">true:有包子</span></span><br><span class="line"><span class="comment">吃货吃包子</span></span><br><span class="line"><span class="comment">吃货吃完包子</span></span><br><span class="line"><span class="comment">修改包子的状态为false没有</span></span><br><span class="line"><span class="comment">吃货唤醒包子铺线程,生产包子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.需要在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.使用带参数构造方法,为这个包子变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置线程任务(run):吃包子</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用死循环,让吃货一直吃包子</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="comment">//对包子的状态进行判断</span></span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="comment">// 吃货调用wait方法进入等待状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被唤醒之后执行的代码,吃包子</span></span><br><span class="line">                System.out.println(<span class="string">"吃货正在吃:"</span> + bz.pi + bz.xian + <span class="string">"的包子"</span>);</span><br><span class="line">                <span class="comment">// 吃货吃完包子</span></span><br><span class="line">                <span class="comment">// 修改包子的状态为false没有</span></span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 吃货唤醒包子铺线程,生产包子</span></span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">"吃货已经把:"</span> + bz.pi + bz.xian + <span class="string">"的包子吃完了,包子铺开始生产包子"</span>);</span><br><span class="line">                System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义包子铺线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者(包子铺)类:是一个线程类,可以继承Thread</span></span><br><span class="line"><span class="comment">设置线程任务(run):生产包子</span></span><br><span class="line"><span class="comment">对包子的状态进行判断</span></span><br><span class="line"><span class="comment">true:有包子</span></span><br><span class="line"><span class="comment">包子铺调用wait方法进入等待状态</span></span><br><span class="line"><span class="comment">false:没有包子</span></span><br><span class="line"><span class="comment">包子铺生产包子</span></span><br><span class="line"><span class="comment">增加一些趣味性:交替生产两种包子</span></span><br><span class="line"><span class="comment">有两种状态(i%2==0)</span></span><br><span class="line"><span class="comment">包子铺生产好了包子</span></span><br><span class="line"><span class="comment">修改包子的状态为true有</span></span><br><span class="line"><span class="comment">唤醒吃货线程,让吃货线程吃包子</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意:</span></span><br><span class="line"><span class="comment">    包子铺线程和包子线程关系--&gt;通信(互斥)</span></span><br><span class="line"><span class="comment">    必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line"><span class="comment">    锁对象必须保证唯一,可以使用包子对象作为锁对象</span></span><br><span class="line"><span class="comment">    包子铺类和吃货的类就需要把包子对象作为参数传递进来</span></span><br><span class="line"><span class="comment">        1.需要在成员位置创建一个包子变量</span></span><br><span class="line"><span class="comment">        2.使用带参数构造方法,为这个包子变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.需要在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.使用带参数构造方法,为这个包子变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程任务(run):生产包子</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个变量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 让包子铺一直生产包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="comment">// 对包子的状态进行判断</span></span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 包子铺调用wait方法进入等待状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被唤醒之后执行,包子铺生产包子</span></span><br><span class="line">                <span class="comment">// 增加一些趣味性:交替生产两种包子</span></span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//生产 薄皮 三鲜馅</span></span><br><span class="line">                    bz.pi = <span class="string">"薄皮"</span>;</span><br><span class="line">                    bz.xian = <span class="string">"三鲜馅"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//生产 冰皮 牛肉大葱陷</span></span><br><span class="line">                    bz.pi = <span class="string">"冰皮"</span>;</span><br><span class="line">                    bz.xian = <span class="string">"牛肉大葱陷"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">"包子铺正在生产:"</span> + bz.pi + bz.xian + <span class="string">"包子"</span>);</span><br><span class="line">                <span class="comment">// 生产包子需要3秒钟</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 包子铺生产好了包子</span></span><br><span class="line">                <span class="comment">// 修改包子的状态为true有</span></span><br><span class="line">                bz.flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒吃货线程,让吃货线程吃包子</span></span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">"包子铺已经生产好了:"</span>+ bz.pi + bz.xian + <span class="string">"包子,吃货可以开始吃了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试类:</span></span><br><span class="line"><span class="comment">包含main方法,程序执行的入口,启动程序</span></span><br><span class="line"><span class="comment">创建包子对象;</span></span><br><span class="line"><span class="comment">创建包子铺线程,开启,生产包子;</span></span><br><span class="line"><span class="comment">创建吃货线程,开启,吃包子;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建包子对象;</span></span><br><span class="line">        BaoZi bz =<span class="keyword">new</span> BaoZi();</span><br><span class="line">        <span class="comment">// 创建包子铺线程,开启,生产包子;</span></span><br><span class="line">        <span class="keyword">new</span> BaoZiPu(bz).start();</span><br><span class="line">        <span class="comment">// 创建吃货线程,开启,吃包子;</span></span><br><span class="line">        <span class="keyword">new</span> ChiHuo(bz).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题，如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在 Java 中可以通过线程池来达到这样的效果。</p><h2 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h2><p><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p><p><img src="/2020/02/14/java-advanced-3/线程池.png" alt></p><p><img src="/2020/02/14/java-advanced-3/线程池原理.png" alt></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下（每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机）。</li></ol><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>Java 里面线程池的顶级接口是 <code>java.util.concurrent.Executor</code> ，但是严格意义上讲 <code>Executor</code> 并不是一个线程池，而只是一个执行线程的工具。真正的<strong>线程池接口是 <code>java.util.concurrent.ExecutorService</code></strong> 。</p><p> <strong><code>java.util.concurrent.Executors</code> 是线程池的工厂类</strong>，用来生成线程池。</p><p> <code>Executors</code> 类中的静态方法：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code> ：创建一个可重用<strong>固定线程数的线程池</strong>。<ul><li>参数 <code>int nThreads</code> ：创建线程池中包含的线程数量。</li><li>返回值 <code>ExecutorService</code> 接口：返回的是 <code>ExecutorService</code> 接口的实现类对象，可以使用<code>ExecutorService</code> 接口接收（面向接口编程）。</li></ul></li></ul><p> <code>java.util.concurrent.ExecutorService</code> 线程池接口用来从线程池中获取线程，调用 <code>start</code> 方法，执行线程任务。</p><ul><li><code>public Future&lt;?&gt; submit(Runnable task)</code> ：获取线程池中的某一个线程对象，提交一个 Runnable 任务用于执行。</li><li><code>public void shutdown()</code> ：关闭/销毁线程池。</li></ul><p>线程池的使用步骤：</p><ol><li>使用线程池的工厂类 <code>Executors</code> 里边提供的静态方法 <code>newFixedThreadPool</code> 生产一个指定线程数量的线程池；</li><li>创建一个类，实现 <code>Runnable</code> 接口，重写 <code>run</code> 方法，设置线程任务；</li><li>调用 <code>ExecutorService</code> 中的方法 <code>submit</code>，传递线程任务（实现类），开启线程，执行 <code>run</code> 方法；</li><li>调用 <code>ExecutorService</code> 中的方法 <code>shutdown</code> 销毁线程池（不建议执行）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"创建了一个新的线程执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-1创建了一个新的线程执行</span></span><br><span class="line">        <span class="comment">// 线程池会一直开启,使用完了线程,会自动把线程归还给线程池,线程可以继续使用</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-1创建了一个新的线程执行</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl()); <span class="comment">// pool-1-thread-2创建了一个新的线程执行</span></span><br><span class="line"></span><br><span class="line">        es.shutdown(); <span class="comment">// 不建议执行</span></span><br><span class="line">        <span class="comment">// es.submit(new RunnableImpl()); // 抛异常,线程池都没有了,就不能获取线程了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java语言高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java语言高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级（2）集合</title>
      <link href="/2020/02/12/java-advanced-2.html"/>
      <url>/2020/02/12/java-advanced-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Collection-集合"><a href="#Collection-集合" class="headerlink" title="Collection 集合"></a><code>Collection</code> 集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p><strong>集合</strong>：是 Java 中提供的一种容器，可以用来存储多个数据。</p><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的，集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值；集合存储的都是对象，而且对象的类型可以不一致。</li></ul><p>集合按照其存储结构可以分为两大类：</p><ul><li><strong>单列集合</strong> <code>java.util.Collection</code> </li><li><strong>双列集合</strong> <code>java.util.Map</code> </li></ul><h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a><code>Collection</code> 接口</h2><p><strong><code>Collection</code></strong> ：<strong>单列集合类的根接口</strong>，用于存储一系列符合某种规则的元素，它有两个重要的子接口：</p><ul><li><code>java.util.List</code> 接口：<ul><li><code>List</code> 的特点是元素有序、元素可重复。</li><li><code>List</code> 接口的主要实现类有 <code>java.util.ArrayList</code> 和 <code>java.util.LinkedList</code> 。</li></ul></li><li><code>java.util.Set</code> 接口：<ul><li><code>Set</code> 的特点是元素无序，而且不可重复。</li><li><code>Set</code> 接口的主要实现类有 <code>java.util.HashSet</code> 和 <code>java.util.TreeSet</code> 。</li></ul></li></ul><p>集合本身是一个工具，它存放在 java.util 包中。在 <code>Collection</code> 接口定义着单列集合框架中最最共性的内容。</p><p><img src="/2020/02/12/java-advanced-2/集合框架介绍.png" alt="集合框架"></p><h2 id="Collection-常用功能"><a href="#Collection-常用功能" class="headerlink" title="Collection 常用功能"></a><code>Collection</code> 常用功能</h2><p>Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合（List 和 Set）通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code> ：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> ：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code> ：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code> ：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code> ：判断当前集合是否为空。</li><li><code>public int size()</code> ：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code> ：把集合中的元素，存储到数组中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合对象,可以使用多态</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(coll); <span class="comment">// 重写了toString方法  []</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> b1 = coll.add(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b1:"</span>+b1); <span class="comment">// b1:true</span></span><br><span class="line">        System.out.println(coll); <span class="comment">// [张三]</span></span><br><span class="line">        coll.add(<span class="string">"李四"</span>);</span><br><span class="line">        coll.add(<span class="string">"李四"</span>);</span><br><span class="line">        coll.add(<span class="string">"赵六"</span>);</span><br><span class="line">        coll.add(<span class="string">"田七"</span>);</span><br><span class="line">        System.out.println(coll); <span class="comment">// [张三, 李四, 赵六, 田七]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> b2 = coll.remove(<span class="string">"赵六"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b2:"</span>+b2); <span class="comment">// b2:true</span></span><br><span class="line">        <span class="keyword">boolean</span> b3 = coll.remove(<span class="string">"赵四"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b3:"</span>+b3); <span class="comment">// b3:false</span></span><br><span class="line">        System.out.println(coll); <span class="comment">// [张三, 李四, 田七]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> b4 = coll.contains(<span class="string">"李四"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b4:"</span>+b4); <span class="comment">// b4:true</span></span><br><span class="line">        <span class="keyword">boolean</span> b5 = coll.contains(<span class="string">"赵四"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b5:"</span>+b5); <span class="comment">// b5:false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b6 = coll.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">"b6:"</span>+b6); <span class="comment">// b6:false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = coll.size();</span><br><span class="line">        System.out.println(<span class="string">"size:"</span>+size); <span class="comment">// size:3</span></span><br><span class="line">        </span><br><span class="line">        Object[] arr = coll.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(coll); <span class="comment">// []</span></span><br><span class="line">        System.out.println(coll.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a><code>Iterator</code> 迭代器</h1><h2 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a><code>Iterator</code> 接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK 专门提供了一个接口 <code>java.util.Iterator</code> 。 <code>Iterator</code> 接口也是 Java 集合中的一员，但它与 <code>Collection</code> 、 <code>Map</code> 接口有所不同， <code>Collection</code> 接口与 <code>Map</code> 接口主要用于存储元素，而 <strong><code>Iterator</code> 主要用于迭代访问（即遍历） <code>Collection</code> 中的元素，因此 <code>Iterator</code> 对象也被称为迭代器</strong>。</p><p><strong>迭代</strong>：即 <code>Collection</code> 集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><p><code>Iterator</code> 迭代器，是一个接口，我们无法直接使用，需要使用 <code>Iterator</code> 接口的实现类对象。获取实现类对象的方式比较特殊，<code>Collection</code> 接口中有一个方法：</p><ul><li><code>public Iterator&lt;E&gt; iterator()</code> ：返回在当前 collection 集合上的迭代器。</li></ul><p>Iterator 接口的常用方法有两个：</p><ul><li><code>public E next()</code> ：返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code> ：如果仍有元素可以迭代，则返回 true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个集合对象，往集合中添加元素</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">"姚明"</span>);</span><br><span class="line">        coll.add(<span class="string">"科比"</span>);</span><br><span class="line">        coll.add(<span class="string">"麦迪"</span>);</span><br><span class="line">        coll.add(<span class="string">"詹姆斯"</span>);</span><br><span class="line">        coll.add(<span class="string">"艾弗森"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用集合中的方法iterator()获取迭代器的实现类对象</span></span><br><span class="line">        <span class="comment">// 使用Iterator接口接收(多态)</span></span><br><span class="line">        <span class="comment">// 注意:Iterator&lt;E&gt;接口也是有泛型的，集合是什么泛型，迭代器就是什么泛型</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不知道集合中有多少元素，使用while循环</span></span><br><span class="line">        <span class="comment">// 循环结束的条件，hasNext方法返回false</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h2><p>当遍历集合时，首先通过调用集合的 <code>iterator()</code> 方法获得迭代器对象，然后使用 <code>hashNext()</code> 方法判断集合中是否存在下一个元素，如果存在，则调用 <code>next()</code> 方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p><code>Iterator</code> 迭代器对象在遍历集合时，<strong>内部采用指针的方式来跟踪集合中的元素</strong>。在调用 <code>Iterator</code> 的 <code>next()</code> 方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的 <code>next()</code> 方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用 <code>next()</code> 方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到 <code>hasNext()</code> 方法返回 <code>false</code>，表示到达了集合的末尾，终止对元素的遍历。</p><p>如果集合中没有元素，调用 <code>next()</code> 方法取出元素会抛出 <strong><code>NoSuchElementException</code> 异常</strong> 。</p><p><img src="/2020/02/12/java-advanced-2/迭代器的实现原理.png" alt="集合框架"></p><h2 id="增强-for-循环（foreach）"><a href="#增强-for-循环（foreach）" class="headerlink" title="增强 for 循环（foreach）"></a>增强 <code>for</code> 循环（<code>foreach</code>）</h2><p>增强 for 循环（也称 <strong><code>foreach</code> 循环</strong>）是 JDK 1.5 以后出来的一个高级 for 循环。</p><ul><li><code>public interface Iterable&lt;T&gt;</code> ：实现这个接口允许对象成为 foreach 语句的目标。</li><li><code>Collection&lt;E&gt; extends Iterable&lt;E&gt;</code> ：所有的单列集合都可以使用增强 for</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量名 : Collection集合名/数组名) &#123; </span><br><span class="line">    <span class="comment">// 操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foreach 循环</code> <strong>专门用来遍历数组和 Collection 集合</strong>。它的<strong>内部原理其实是个 Iterator 迭代器</strong>，所以在遍历的过程中，<strong>不能对集合中的元素进行增删操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoForeach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用增强for循环遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用增强for循环遍历集合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"aaa"</span>);</span><br><span class="line">        list.add(<span class="string">"bbb"</span>);</span><br><span class="line">        list.add(<span class="string">"ccc"</span>);</span><br><span class="line">        list.add(<span class="string">"ddd"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Generic-泛型"><a href="#Generic-泛型" class="headerlink" title="Generic 泛型"></a><code>Generic</code> 泛型</h1><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成 <code>Object</code> 类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="string">"abc"</span>);</span><br><span class="line">        coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">        coll.add(<span class="number">5</span>); <span class="comment">// 由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">        Iterator it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">            String str = (String) it.next();</span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于集合中什么类型的元素都可以存储，导致取出时强转引发运行时异常 <code>ClassCastException</code>。</p><p>Collection 虽然可以存储各种对象，但实际上通常 Collection 只存储同一类型对象，例如都是存储字符串对象。因此在 JDK 5 之后，新增了<strong>泛型</strong>（<strong><code>Generic</code></strong>）语法。</p><p><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</p><ul><li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型。</li><li>把运行期异常（代码运行后抛出的异常），提升到了编译期（写代码的时候会报错）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"itcast"</span>);</span><br><span class="line">        <span class="comment">// list.add(5); // 当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">// 当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/java-advanced-2/泛型的概念.png" alt="泛型的概念"></p><h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中，<strong>将数据类型作为参数进行传递</strong>。</p><h3 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>例如 API 中的 ArrayList 集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型：<strong>在创建对象的时候确定泛型</strong>。</p><p>例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code>，此时，变量 E 的值就是 String 类型，那么我们的类就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123; &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型类并进行使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGenericClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不写泛型默认为Object类型</span></span><br><span class="line">        GenericClass gc = <span class="keyword">new</span> GenericClass();</span><br><span class="line">        gc.setName(<span class="string">"只能是字符串"</span>);</span><br><span class="line">        Object obj = gc.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建GenericClass对象,泛型使用Integer类型</span></span><br><span class="line">        GenericClass&lt;Integer&gt; gc2 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc2.setName(<span class="number">1</span>);</span><br><span class="line">        Integer name = gc2.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建GenericClass对象,泛型使用String类型</span></span><br><span class="line">        GenericClass&lt;String&gt; gc3 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc3.setName(<span class="string">"小明"</span>);</span><br><span class="line">        String name1 = gc3.getName();</span><br><span class="line">        System.out.println(name1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123;  &#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个含有泛型的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(M m)</span></span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个含有泛型的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">method02</span><span class="params">(S s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建GenericMethod对象</span></span><br><span class="line">        GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用含有泛型的方法method01</span></span><br><span class="line">        <span class="comment">// 传递什么类型,泛型就是什么类型</span></span><br><span class="line">        gm.method01(<span class="number">10</span>);</span><br><span class="line">        gm.method01(<span class="string">"abc"</span>);</span><br><span class="line">        gm.method01(<span class="number">8.8</span>);</span><br><span class="line">        gm.method01(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        gm.method02(<span class="string">"静态方法,不建议创建对象使用"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 静态方法,通过类名.方法名(参数)可以直接使用</span></span><br><span class="line">        GenericMethod.method02(<span class="string">"静态方法"</span>);</span><br><span class="line">        GenericMethod.method02(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><ol><li><strong>定义实现类时确定泛型的类型</strong>。<ul><li>例如，Scanner 类实现了 Iterator 接口，并指定接口的泛型为 String，所以重写的 next 方法泛型默认是String。</li></ul></li><li><strong>始终不确定泛型的类型</strong>，直到创建对象时，确定泛型的类型。<ul><li>相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl2</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建GenericInterfaceImpl1对象</span></span><br><span class="line">        GenericInterfaceImpl1 gi1 = <span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">        gi1.method(<span class="string">"字符串"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建GenericInterfaceImpl2对象</span></span><br><span class="line">        GenericInterfaceImpl2&lt;Integer&gt; gi2 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi2.method(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        GenericInterfaceImpl2&lt;Double&gt; gi3 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        gi3.method(<span class="number">8.8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过<strong>通配符 <code>&lt;?&gt;</code></strong> 表示。但是<strong>一旦使用泛型通配符后，只能使用 Object 类中的共性方法</strong>，集合中元素自身方法无法使用。</p><h3 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h3><p>泛型的通配符 <code>?</code> ：代表任意的数据类型。</p><p>使用方式：不能创建对象使用，<strong>只能作为方法的参数使用</strong>。此时只能接受数据，<strong>不能往该集合中存储数据</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="number">1</span>);</span><br><span class="line">        list01.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list02.add(<span class="string">"a"</span>);</span><br><span class="line">        list02.add(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">        printArray(list01);</span><br><span class="line">        printArray(list02);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通配符只能作为方法参数使用</span></span><br><span class="line">        <span class="comment">// ArrayList&lt;?&gt; list03 = new ArrayList&lt;?&gt;(); // 错误写法！</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 泛型不存在继承关系</span></span><br><span class="line">        <span class="comment">// Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;(); // 错误写法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法,能遍历所有类型的ArrayList集合。</span></span><br><span class="line"><span class="comment">        这时候我们不知道ArrayList集合使用什么数据类型,</span></span><br><span class="line"><span class="comment">        可以泛型的通配符?来接收数据类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用迭代器遍历集合</span></span><br><span class="line">        Iterator&lt;?&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">// it.next()方法,取出的元素是Object,可以接收任意的数据类型</span></span><br><span class="line">            Object o = it.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符高级使用（受限泛型）"><a href="#通配符高级使用（受限泛型）" class="headerlink" title="通配符高级使用（受限泛型）"></a>通配符高级使用（受限泛型）</h3><p>前面设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在 Java 的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类&gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类&gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">        Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            类与类之间的继承关系</span></span><br><span class="line"><span class="comment">            Integer extends Number extends Object</span></span><br><span class="line"><span class="comment">            String extends Object</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        getElement1(list1);</span><br><span class="line">        <span class="comment">// getElement1(list2); // 报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line">        <span class="comment">// getElement1(list4); // 报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getElement2(list1); // 报错</span></span><br><span class="line">        <span class="comment">// getElement2(list2); // 报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a><code>List</code> 集合</h1><h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a><code>List</code> 接口</h2><p><code>java.util.List</code> 接口继承自 <code>Collection</code> 接口，是单列集合的一个重要分支，习惯性地会将实现了 <code>List</code> 接口的对象称为 <code>List</code> 集合。</p><p><code>List</code> 接口的特点：</p><ol><li>元素存取<strong>有序的集合</strong>；</li><li><strong>带有索引</strong>；</li><li><strong>允许存储重复的元素</strong>。</li></ol><p><code>List</code> 接口中的常用方法：</p><ul><li><code>Collection</code> 接口中的全部方法。</li><li>根据元素索引来操作集合的特有方法：<ul><li><code>public void add(int index, E element)</code> ：将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code> ：返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code> ：移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code> ：用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul></li></ul><p>注意事项：</p><ul><li>操作索引的时候,一定要防止索引越界异常<ul><li><code>IndexOutOfBoundsException</code> ：索引越界异常，集合会抛出</li><li><code>ArrayIndexOutOfBoundsException</code> ：数组索引越界异常</li><li><code>StringIndexOutOfBoundsException</code> ：字符串索引越界异常</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个List集合对象,多态</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用add方法往集合中添加元素</span></span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"d"</span>);</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        <span class="comment">// 打印集合</span></span><br><span class="line">        System.out.println(list); <span class="comment">// [a, b, c, d, a]  不是地址重写了toString</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在c和d之间添加一个itheima</span></span><br><span class="line">        list.add(<span class="number">3</span>, <span class="string">"itheima"</span>); <span class="comment">// [a, b, c, itheima, d, a]</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除元素</span></span><br><span class="line">        String removeE = list.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"被移除的元素:"</span> + removeE); <span class="comment">// 被移除的元素:c</span></span><br><span class="line">        System.out.println(list); <span class="comment">// [a, b, itheima, d, a]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把最后一个a,替换为A</span></span><br><span class="line">        String setE = list.set(<span class="number">4</span>, <span class="string">"A"</span>);</span><br><span class="line">        System.out.println(<span class="string">"被替换的元素:"</span> + setE); <span class="comment">// 被替换的元素:a</span></span><br><span class="line">        System.out.println(list); <span class="comment">// [a, b, itheima, d, A]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List集合遍历有3种方式</span></span><br><span class="line">        <span class="comment">// 使用普通的for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">            String s = list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String r = list.get(5); // IndexOutOfBoundsException</span></span><br><span class="line">        <span class="comment">// System.out.println(r);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List-的两个子类"><a href="#List-的两个子类" class="headerlink" title="List 的两个子类"></a><code>List</code> 的两个子类</h2><h3 id="ArrayList-集合"><a href="#ArrayList-集合" class="headerlink" title="ArrayList 集合"></a><code>ArrayList</code> 集合</h3><p><code>java.util.ArrayList</code> 集合数据存储的结构是<strong>数组结构</strong>。元素<strong>增删慢，查找快</strong>。</p><p>由于日常开发中使用最多的功能为查询数据、遍历数据，所以 <code>ArrayList</code> 是最常用的集合。许多程序员开发时非常随意地使用 <code>ArrayList</code> 完成任何需求，并不严谨，这种用法是不提倡的。</p><h3 id="LinkedList-集合"><a href="#LinkedList-集合" class="headerlink" title="LinkedList 集合"></a><code>LinkedList</code> 集合</h3><p><code>java.util.LinkedList</code> 集合的特点：</p><ol><li>底层是一个链表结构：<strong>查询慢，增删快</strong>；</li><li>里边包含了大量<strong>操作首尾元素的方法</strong>。注意：多态格式无法直接使用 <code>LinkedList</code> 集合特有的方法。</li></ol><p><code>LinkedList</code> 集合的常用方法：</p><ul><li><code>List</code> 接口的全部方法。</li><li>特有的操作首尾元素的方法：<ul><li><code>public void addFirst(E e)</code> ：将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code> ：将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code> ：返回此列表的第一个元素。</li><li><code>public E getLast()</code> ：返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code> ：移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code> ：移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code> ：从此列表所表示的堆栈处弹出一个元素，等效于 <code>removeFirst()</code> 。</li><li><code>public void push(E e)</code> ：将元素推入此列表所表示的堆栈，等效于 <code>addFirst()</code> 。</li></ul></li></ul><p>在开发时，<code>LinkedList</code> 集合也可以作为堆栈或队列的结构使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02();</span><br><span class="line">        show03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用add方法往集合中添加元素</span></span><br><span class="line">        linked.add(<span class="string">"a"</span>);</span><br><span class="line">        linked.add(<span class="string">"b"</span>);</span><br><span class="line">        linked.add(<span class="string">"c"</span>);</span><br><span class="line">        System.out.println(linked); <span class="comment">// [a, b, c]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// linked.addFirst("www");</span></span><br><span class="line">        linked.push(<span class="string">"www"</span>);</span><br><span class="line">        System.out.println(linked); <span class="comment">// [www, a, b, c]</span></span><br><span class="line"></span><br><span class="line">        linked.addLast(<span class="string">"com"</span>);</span><br><span class="line">        System.out.println(linked); <span class="comment">// [www, a, b, c, com]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用add方法往集合中添加元素</span></span><br><span class="line">        linked.add(<span class="string">"a"</span>);</span><br><span class="line">        linked.add(<span class="string">"b"</span>);</span><br><span class="line">        linked.add(<span class="string">"c"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清空集合中的元素，在获取集合中的元素会抛出NoSuchElementException</span></span><br><span class="line">        <span class="comment">// linked.clear();</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!linked.isEmpty())&#123;</span><br><span class="line">            String first = linked.getFirst();</span><br><span class="line">            System.out.println(first); <span class="comment">// a</span></span><br><span class="line">            String last = linked.getLast();</span><br><span class="line">            System.out.println(last); <span class="comment">// c</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建LinkedList集合对象</span></span><br><span class="line">        LinkedList&lt;String&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 使用add方法往集合中添加元素</span></span><br><span class="line">        linked.add(<span class="string">"a"</span>);</span><br><span class="line">        linked.add(<span class="string">"b"</span>);</span><br><span class="line">        linked.add(<span class="string">"c"</span>);</span><br><span class="line">        System.out.println(linked); <span class="comment">// [a, b, c]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// String first = linked.removeFirst();</span></span><br><span class="line">        String first = linked.pop();</span><br><span class="line">        System.out.println(<span class="string">"被移除的第一个元素:"</span> + first);</span><br><span class="line">        String last = linked.removeLast();</span><br><span class="line">        System.out.println(<span class="string">"被移除的最后一个元素:"</span> + last);</span><br><span class="line">        System.out.println(linked); <span class="comment">// [b]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a><code>Set</code> 集合</h1><h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a><code>Set</code> 接口</h2><p><code>java.util.Set</code> 接口和 <code>java.util.List</code> 接口一样，同样继承自 <code>Collection</code> 接口，它与 <code>Collection</code> 接口中的方法基本一致，并没有对 <code>Collection</code> 接口进行功能上的扩充，只是比 <code>Collection</code> 接口更加严格了。</p><p><code>Set</code> 接口的特点：</p><ol><li><strong>不允许存储重复的元素</strong>；</li><li><strong>没有索引</strong>，没有带索引的方法，也不能使用普通的 <code>for</code> 循环遍历。</li></ol><h2 id="HashSet-集合"><a href="#HashSet-集合" class="headerlink" title="HashSet 集合"></a><code>HashSet</code> 集合</h2><p><code>java.util.HashSet</code> 是 <code>Set</code> 接口的一个实现类，底层的实现其实是一个 <code>java.util.HashMap</code> 支持。</p><p><code>HashSet</code> 的特点:</p><ol><li>不允许存储重复的元素</li><li>没有索引，没有带索引的方法，也不能使用普通的 <code>for</code> 循环遍历</li><li>是一个<strong>无序的集合</strong>，存储元素和取出元素的顺序有可能不一致</li><li>底层是一个<strong>哈希表结构</strong>（查询的速度非常的快）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用add方法往集合中添加元素</span></span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用迭代器遍历set集合</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            Integer n = it.next();</span><br><span class="line">            System.out.println(n); <span class="comment">// 1,2,3</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用增强for遍历set集合</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : set) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p><strong>哈希值</strong>：是一个十进制的整数，由系统随机给出。</p><ul><li><strong>就是对象的地址值</strong>，是一个逻辑地址，不是数据实际存储的物理地址。</li></ul><p>在 <code>Object</code> 类有一个方法,可以获取对象的哈希值：</p><ul><li><code>int hashCode()</code> 返回该对象的哈希码值。</li></ul><p><code>hashCode</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p> <code>native</code> ：代表该方法调用的是本地操作系统的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Person类继承了Object类,所以可以使用Object类的hashCode方法</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">int</span> h1 = p1.hashCode();</span><br><span class="line">        System.out.println(h1); <span class="comment">// 1967205423</span></span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">int</span> h2 = p2.hashCode();</span><br><span class="line">        System.out.println(h2); <span class="comment">// 42121758</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            toString方法的源码:</span></span><br><span class="line"><span class="comment">            return getClass().getName() + "@" + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(p1); <span class="comment">// com.itheima.demo03.hashCode.Person@75412c2f</span></span><br><span class="line">        System.out.println(p2); <span class="comment">// com.itheima.demo03.hashCode.Person@282ba1e</span></span><br><span class="line">        System.out.println(p1==p2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String类的哈希值</span></span><br><span class="line"><span class="comment">            String类重写Obejct类的hashCode方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1.hashCode()); <span class="comment">// 96354</span></span><br><span class="line">        System.out.println(s2.hashCode()); <span class="comment">// 96354</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"重地"</span>.hashCode()); <span class="comment">// 1179395</span></span><br><span class="line">        System.out.println(<span class="string">"通话"</span>.hashCode()); <span class="comment">// 1179395</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet-存储数据的结构（哈希表结构）"><a href="#HashSet-存储数据的结构（哈希表结构）" class="headerlink" title="HashSet 存储数据的结构（哈希表结构）"></a><code>HashSet</code> 存储数据的结构（哈希表结构）</h3><p>在 <strong>JDK 1.8</strong> 之前，哈希表底层采用 <code>数组+链表</code> 实现，即使用链表处理冲突，同一 hash 值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。而 JDK 1.8 中，哈希表存储采用 <code>数组+链表+红黑树</code> 实现，<strong>当链表长度超过阈值 8 时，将链表转换为红黑树</strong>，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK 1.8 增加了红黑树部分）实现的，下图解释了 <code>HashSet</code> 的工作原理。<img src="/2020/02/12/java-advanced-2/HashSet集合存储数据的结构（哈希表）.png" alt></p><h3 id="HashSet-存储元素不重复的原理"><a href="#HashSet-存储元素不重复的原理" class="headerlink" title="HashSet 存储元素不重复的原理"></a><code>HashSet</code> 存储元素不重复的原理</h3><p>JDK 1.8 引入红黑树极大程度优化了 <code>HashMap</code> 的性能，而<strong>保证 HashSet 集合元素的唯一，其实是根据对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法来决定的</strong>。<img src="/2020/02/12/java-advanced-2/HashSet集合存储元素不重复的原理.png" alt></p><h3 id="HashSet-存储自定义类型元素"><a href="#HashSet-存储自定义类型元素" class="headerlink" title="HashSet 存储自定义类型元素"></a><code>HashSet</code> 存储自定义类型元素</h3><p>自定义类型中继承的默认 <code>hashCode()</code> 和 <code>equals()</code> 方法将自定义类型的相同内容的对象视为不同元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoHashSetSavePerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建HashSet集合存储Person</span></span><br><span class="line">        HashSet&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"小美女"</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"小美女"</span>,<span class="number">18</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"小美女"</span>,<span class="number">19</span>);</span><br><span class="line">        System.out.println(p1.hashCode()); <span class="comment">// 1967205423</span></span><br><span class="line">        System.out.println(p2.hashCode()); <span class="comment">// 42121758</span></span><br><span class="line"></span><br><span class="line">        System.out.println(p1 == p2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(p1.equals(p2)); <span class="comment">// false</span></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line">        System.out.println(set); <span class="comment">// 三个Person对象都存储在HashSet集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 <code>HashSet</code> 中存放自定义类型元素时，需要重写对象中继承自 <code>Object</code> 类的 <code>hashCode()</code> 和 <code>equals()</code> 方法，建立自己的比较方式，才能保证 <code>HashSet</code> 集合中的对象唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet-集合"><a href="#LinkedHashSet-集合" class="headerlink" title="LinkedHashSet 集合"></a><code>LinkedHashSet</code> 集合</h2><p>我们知道 <code>HashSet</code> 保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在 <code>HashSet</code> 下面有一个子类 <code>java.util.LinkedHashSet</code> ，它是<strong>链表和哈希表组合</strong>的一个数据存储结构。</p><ul><li>底层是 <code>哈希表（数组+链表/红黑树）+ 链表</code> ：多了一条链表（记录元素的存储顺序），保证元素有序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoLinkedHashSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">"www"</span>);</span><br><span class="line">        set.add(<span class="string">"abc"</span>);</span><br><span class="line">        set.add(<span class="string">"abc"</span>);</span><br><span class="line">        set.add(<span class="string">"itcast"</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">// [abc, www, itcast] 无序,不允许重复</span></span><br><span class="line"></span><br><span class="line">        LinkedHashSet&lt;String&gt; linked = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        linked.add(<span class="string">"www"</span>);</span><br><span class="line">        linked.add(<span class="string">"abc"</span>);</span><br><span class="line">        linked.add(<span class="string">"abc"</span>);</span><br><span class="line">        linked.add(<span class="string">"itcast"</span>);</span><br><span class="line">        System.out.println(linked); <span class="comment">// [www, abc, itcast] 有序,不允许重复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>可变参数：是 JDK 1.5 之后出现的新特性。</p><p>使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数。</p><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><p>定义方法时使用可变参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(数据类型...变量名) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数的原理"><a href="#可变参数的原理" class="headerlink" title="可变参数的原理"></a>可变参数的原理</h2><p>可变参数底层就是一个<strong>数组</strong>，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数。传递的参数个数，可以是 0 个（不传递），1 个或多个。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>一个方法的参数列表，<strong>只能有一个</strong>可变参数。</li><li>如果方法的参数有多个，那么可变参数必须<strong>写在参数列表的末尾</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoVarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int i = add();</span></span><br><span class="line">        <span class="comment">// int i = add(10);</span></span><br><span class="line">        <span class="keyword">int</span> i = add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        method(<span class="string">"abc"</span>, <span class="number">5.5</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,计算三个int类型整数的和</span></span><br><span class="line">    <span class="comment">/*public static int add(int a,int b,int c) &#123;</span></span><br><span class="line"><span class="comment">        return a+b+c;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,计算两个int类型整数的和</span></span><br><span class="line">    <span class="comment">/*public static int add(int a,int b) &#123;</span></span><br><span class="line"><span class="comment">        return a+b;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义计算(0-n)整数和的方法</span></span><br><span class="line"><span class="comment">        已知:计算整数的和,数据类型已经确定int</span></span><br><span class="line"><span class="comment">        但是参数的个数不确定,不知道要计算几个整数的和,就可以使用可变参数</span></span><br><span class="line"><span class="comment">        add(); 就会创建一个长度为0的数组, new int[0]</span></span><br><span class="line"><span class="comment">        add(10); 就会创建一个长度为1的数组,存储传递来过的参数 new int[]&#123;10&#125;;</span></span><br><span class="line"><span class="comment">        add(10,20); 就会创建一个长度为2的数组,存储传递来过的参数 new int[]&#123;10,20&#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(arr); // [I@2ac1fdc4 底层是一个数组</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a><code>Collections</code> 工具类</h1><p><code>java.utils.Collections</code> 是集合工具类，用来对集合进行操作。</p><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code> ：往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code> ：打乱集合中元素的顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code> ：将集合中元素按照<strong>默认规则</strong>排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code> ：将集合中元素按照<strong>指定规则</strong>排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 原来写法</span></span><br><span class="line">        <span class="comment">// list.add(12);</span></span><br><span class="line">        <span class="comment">// list.add(14);</span></span><br><span class="line">        <span class="comment">// list.add(15);</span></span><br><span class="line">        <span class="comment">// list.add(1000);</span></span><br><span class="line">        <span class="comment">// 采用工具类完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [5, 222, 1, 2]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list); <span class="comment">// [1, 2, 5, 222]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Comparator-比较器"><a href="#Comparator-比较器" class="headerlink" title="Comparator 比较器"></a><code>Comparator</code> 比较器</h2><h3 id="比较的实现方式"><a href="#比较的实现方式" class="headerlink" title="比较的实现方式"></a>比较的实现方式</h3><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code> 方法将集合中元素按照默认规则排序。那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，在 JAVA 中提供了两种<strong>比较实现的方式</strong>：</p><ol><li>比较死板地采用 <code>java.lang.Comparable</code> 接口去实现；</li><li>灵活地当需要排序的时候再去选择的 <code>java.util.Comparator</code> 接口完成。</li></ol><p>那么 <code>void sort(list)</code> 这个方法完成的排序，实际上<strong>要求被排序的类型需要实现 <code>Comparable</code> 接口</strong>，重写 <code>compareTo()</code> 方法，完成比较的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 重写排序的规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return 0; // 认为元素都是相同的</span></span><br><span class="line">        <span class="comment">// 自定义比较的规则,比较两个人的年龄(this,参数Person)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge() - o.getAge(); <span class="comment">// 年龄升序排序</span></span><br><span class="line">        <span class="comment">// return o.getAge() - this.getAge(); // 年龄降序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="number">1</span>);</span><br><span class="line">        list01.add(<span class="number">3</span>);</span><br><span class="line">        list01.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(list01); <span class="comment">// [1, 3, 2]</span></span><br><span class="line">        Collections.sort(list01); <span class="comment">// 默认是升序</span></span><br><span class="line">        System.out.println(list01); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list02.add(<span class="string">"a"</span>);</span><br><span class="line">        list02.add(<span class="string">"c"</span>);</span><br><span class="line">        list02.add(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(list02); <span class="comment">// [a, c, b]</span></span><br><span class="line">        Collections.sort(list02);</span><br><span class="line">        System.out.println(list02); <span class="comment">// [a, b, c]</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Person&gt; list03 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list03.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">18</span>));</span><br><span class="line">        list03.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>));</span><br><span class="line">        list03.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">15</span>));</span><br><span class="line">        System.out.println(list03); <span class="comment">// [Person&#123;name='张三', age=18&#125;, Person&#123;name='李四', age=20&#125;, Person&#123;name='王五', age=15&#125;]</span></span><br><span class="line">        Collections.sort(list03);</span><br><span class="line">        System.out.println(list03); <span class="comment">// [Person&#123;name='王五', age=15&#125;, Person&#123;name='张三', age=18&#125;, Person&#123;name='李四', age=20&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>String</code> 类型上如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>String</code> 与 <code>Person</code> 类实现了 <code>Comparable</code> 接口，并完成了比较规则的定义，但是这样就把这种规则写死了。这时可以使用 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code> 方法灵活地完成自定义比较规则，这个里面就涉及到了 <code>Comparator</code> 这个接口。</p><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a><code>Comparator</code> 接口</h3><p><code>java.util.Comparator</code> 接口包含的功能之一就是排序。该接口代表一个比较器，比较器具有可比性，顾名思义就是做排序的。</p><p><code>Comparator</code> 接口中比较的方法：</p><ul><li><code>int compare(T o1, T o2)</code>：比较其两个参数的顺序。<ul><li>两个对象比较的结果有三种：大于，等于，小于。<ul><li>如果要按照升序排序，则 o1 小于 o2 返回负数，相等返回 0，o1 大于 o2 返回正数。</li><li>如果要按照降序排序，则 o1 大于 o2 返回正数，相等返回 0，o1 小于 o2 返回负数。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="number">1</span>);</span><br><span class="line">        list01.add(<span class="number">3</span>);</span><br><span class="line">        list01.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(list01); <span class="comment">// [1, 3, 2]</span></span><br><span class="line">        </span><br><span class="line">        Collections.sort(list01, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">// 重写比较的规则</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2; <span class="comment">// 升序</span></span><br><span class="line">                <span class="comment">// return o2 - o1; // 降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list01); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Student&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list02.add(<span class="keyword">new</span> Student(<span class="string">"aaa"</span>,<span class="number">18</span>));</span><br><span class="line">        list02.add(<span class="keyword">new</span> Student(<span class="string">"bbb"</span>,<span class="number">20</span>));</span><br><span class="line">        list02.add(<span class="keyword">new</span> Student(<span class="string">"ccc"</span>,<span class="number">17</span>));</span><br><span class="line">        list02.add(<span class="keyword">new</span> Student(<span class="string">"ddd"</span>,<span class="number">18</span>));</span><br><span class="line">        System.out.println(list02);</span><br><span class="line">        </span><br><span class="line">        Collections.sort(list02, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 按照年龄升序排序</span></span><br><span class="line">                <span class="keyword">int</span> result = o1.getAge()-o2.getAge();</span><br><span class="line">                <span class="comment">// 如果两个人年龄相同,再使用姓名的第一个字比较</span></span><br><span class="line">                <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list02);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Comparable-和-Comparator-两个接口的区别"><a href="#Comparable-和-Comparator-两个接口的区别" class="headerlink" title="Comparable 和 Comparator 两个接口的区别"></a><code>Comparable</code> 和 <code>Comparator</code> 两个接口的区别</h2><p><code>Comparator</code> 和 <code>Comparable</code> 的区别：</p><ul><li><code>Comparable</code> ：自己（this）和别人（参数）比较，自己需要实现 <code>Comparable</code> 接口，重写比较的规则 <code>compareTo()</code> 方法；</li><li><code>Comparator</code> ：相当于找一个第三方的裁判，比较两个对象。</li></ul><p><strong><code>Comparable</code></strong> 强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 <code>compareTo()</code> 方法被称为它的自然比较方法。只能在类中实现 <code>compareTo()</code> 一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过 <code>Collections.sort()</code> 和 <code>Arrays.sort()</code>）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong><code>Comparator</code></strong> 强行对某个对象进行整体排序。可以将 <code>Comparator</code> 传递给 <code>sort()</code> 方法（如 <code>Collections.sort()</code> 和 <code>Arrays.sort()</code>），从而允许在排序顺序上实现精确控制。还可以使用 <code>Comparator</code> 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p><h1 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a><code>Map</code> 集合</h1><h2 id="Map-集合概述"><a href="#Map-集合概述" class="headerlink" title="Map 集合概述"></a><code>Map</code> 集合概述</h2><p>Java 提供了专门的集合类用来存放一一对应关系的对象，即 <code>java.util.Map&lt;K,v&gt;</code> 接口。</p><p><code>Map</code> 集合的特点：</p><ol><li>Map 集合是一个<strong>双列集合</strong>，一个元素包含两个值（一个 key，一个 value）；</li><li>key 和 value 的数据类型可以相同，也可以不同；</li><li><strong>key 是不允许重复的</strong>，value 是可以重复的；</li><li>key 和 value 是一一对应的。</li></ol><p><img src="/2020/02/12/java-advanced-2/Collection与Map.png" alt></p><h2 id="Map-的两个常用子类"><a href="#Map-的两个常用子类" class="headerlink" title="Map 的两个常用子类"></a><code>Map</code> 的两个常用子类</h2><h3 id="HashMap-集合"><a href="#HashMap-集合" class="headerlink" title="HashMap 集合"></a><code>HashMap</code> 集合</h3><p><strong><code>HashMap&lt;K,V&gt;</code></strong> ：存储数据采用的<strong>哈希表结构</strong>，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的 <code>hashCode()</code> 方法、<code>equals()</code> 方法。</p><h3 id="LinkedHashMap-集合"><a href="#LinkedHashMap-集合" class="headerlink" title="LinkedHashMap 集合"></a><code>LinkedHashMap</code> 集合</h3><p><strong><code>LinkedHashMap&lt;K,V&gt;</code></strong> ：<code>HashMap</code> 下有个子类 <code>LinkedHashMap</code>，存储数据采用的<strong>哈希表结构+链表结构</strong>。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 <code>hashCode()</code> 方法、<code>equals()</code> 方法。</p><h2 id="Map-接口中的常用方法"><a href="#Map-接口中的常用方法" class="headerlink" title="Map 接口中的常用方法"></a><code>Map</code> 接口中的常用方法</h2><ul><li><code>public V put(K key, V value)</code> ：把指定的键与指定的值添加到 Map 集合中。</li><li><code>public V remove(Object key)</code> ：把指定的键所对应的键值对元素在 Map 集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> ：根据指定的键，在 Map 集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> ：判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code> ：获取Map集合中所有的键，存储到 Set 集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> ：获取到 Map 集合中所有的键值对对象的集合（Set 集合）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02();</span><br><span class="line">        show03();</span><br><span class="line">        show04();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="comment">        返回值:v</span></span><br><span class="line"><span class="comment">            存储键值对的时候,key不重复,返回值V是null</span></span><br><span class="line"><span class="comment">            存储键值对的时候,key重复,会使用新的value替换map中</span></span><br><span class="line"><span class="comment">                           重复的value,返回被替换的value值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象,多态</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String v1 = map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span> + v1); <span class="comment">// v1:null</span></span><br><span class="line">        String v2 = map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span> + v2); <span class="comment">// v2:范冰冰1</span></span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;李晨=范冰冰2&#125;</span></span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"冷锋"</span>, <span class="string">"龙小云"</span>);</span><br><span class="line">        map.put(<span class="string">"杨过"</span>, <span class="string">"小龙女"</span>);</span><br><span class="line">        map.put(<span class="string">"尹志平"</span>, <span class="string">"小龙女"</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V remove(Object key): </span></span><br><span class="line"><span class="comment">        把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。</span></span><br><span class="line"><span class="comment">        返回值:V</span></span><br><span class="line"><span class="comment">            key存在,v返回被删除的值</span></span><br><span class="line"><span class="comment">            key不存在,v返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>, <span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>, <span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>, <span class="number">178</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line"></span><br><span class="line">        Integer v1 = map.remove(<span class="string">"林志玲"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span> + v1); <span class="comment">// v1:178</span></span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int v2 = map.remove("林志颖"); // 自动拆箱  NullPointerException</span></span><br><span class="line">        Integer v2 = map.remove(<span class="string">"林志颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span> + v2); <span class="comment">// v2:null</span></span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</span></span><br><span class="line"><span class="comment">        返回值:</span></span><br><span class="line"><span class="comment">            key存在,返回对应的value值</span></span><br><span class="line"><span class="comment">            key不存在,返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>, <span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>, <span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>, <span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        Integer v1 = map.get(<span class="string">"杨颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span> + v1); <span class="comment">// v1:165</span></span><br><span class="line"></span><br><span class="line">        Integer v2 = map.get(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span> + v2); <span class="comment">// v2:null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean containsKey(Object key) 判断集合中是否包含指定的键。</span></span><br><span class="line"><span class="comment">        包含返回true,不包含返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>, <span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>, <span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>, <span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = map.containsKey(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b1:"</span> + b1); <span class="comment">// b1:true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = map.containsKey(<span class="string">"赵颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b2:"</span> + b2); <span class="comment">// b2:false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map-集合遍历（键找值）"><a href="#Map-集合遍历（键找值）" class="headerlink" title="Map 集合遍历（键找值）"></a><code>Map</code> 集合遍历（键找值）</h2><p><code>Map</code> 集合的第一种遍历方式：通过键找值的方式，即通过元素中的键，获取键所对应的值。</p><p>实现步骤：</p><ol><li>使用 <code>Map</code> 集合中的方法 <code>keySet()</code> ，把 <code>Map</code> 集合所有的 key 取出来,存储到一个 <code>Set</code> 集合中；</li><li>遍历 <code>Set</code> 集合，获取 <code>Map</code> 集合中的每一个 key ；</li><li>通过 <code>Map</code> 集合中的方法 <code>get(key)</code> ，通过 key 找到 value 。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoKeySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>, <span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>, <span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>, <span class="number">178</span>);</span><br><span class="line">        <span class="comment">// 1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中</span></span><br><span class="line">        <span class="comment">// Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。</span></span><br><span class="line">        <span class="comment">// 2.遍历set集合,获取Map集合中的每一个key</span></span><br><span class="line">        <span class="comment">// 使用增强for遍历Set集合</span></span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Entry-键值对对象"><a href="#Entry-键值对对象" class="headerlink" title="Entry 键值对对象"></a><code>Entry</code> 键值对对象</h2><p><code>Map</code> 中存放的是两种对象，一种称为 <strong>key</strong> (键)，一种称为 <strong>value</strong> (值)，它们在 <code>Map</code> 中是一一对应关系，这一对对象又称做 <code>Map</code> 中的一个 <strong><code>Entry</code> (项)</strong>。 <strong><code>Entry</code> 将键值对的对应关系封装成了对象，即键值对对象</strong>，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p>既然 <code>Entry</code> 表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取 Entry 对象中的键。</li><li><code>public V getValue()</code>：获取 Entry 对象中的值。</li></ul><p>在 Map 集合中也提供了获取所有 Entry 对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> ：获取到 Map 集合中所有的键值对对象的集合（Set 集合）。</li></ul><h2 id="Map-集合遍历（键值对）"><a href="#Map-集合遍历（键值对）" class="headerlink" title="Map 集合遍历（键值对）"></a><code>Map</code> 集合遍历（键值对）</h2><p><code>Map</code> 集合遍历的第二种方式：键值对方式，即通过集合中每个 <code>Entry</code> 对象，获取 <code>Entry</code> 对象中的键与值。</p><p>实现步骤:</p><ol><li>使用 <code>Map</code> 集合中的方法 <code>entrySet()</code> ，把 <code>Map</code> 集合中多个 <code>Entry</code> 对象取出来，存储到一个 <code>Set</code> 集合中；</li><li>遍历 <code>Set</code> 集合,获取每一个 <code>Entry</code> 对象；</li><li>使用 <code>Entry</code> 对象中的方法 <code>getKey()</code> 和 <code>getValue()</code> 获取键与值。</li></ol><p><img src="/2020/02/12/java-advanced-2/Map集合遍历键值对方式.png" alt="键值对遍历图解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03EntrySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>, <span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>, <span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>, <span class="number">178</span>);</span><br><span class="line">        <span class="comment">// 1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="comment">// 2.遍历Set集合,获取每一个Entry对象</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : set) &#123;</span><br><span class="line">            <span class="comment">// 3.使用Entry对象中的方法getKey()和getValue()获取键与值</span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-存储自定义类型键值"><a href="#HashMap-存储自定义类型键值" class="headerlink" title="HashMap 存储自定义类型键值"></a><code>HashMap</code> 存储自定义类型键值</h2><p><code>HashMap</code> 存储自定义类型键值时，要保证 key 是唯一的：</p><ul><li>作为 key 的元素，<strong>必须重写 <code>hashCode()</code> 和 <code>equals()</code> 方法，以保证 key 唯一</strong>。</li></ul><p>编写学生类，学生姓名相同并且年龄相同视为同一名学生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoHashMapSavePerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show01();</span><br><span class="line">        show02();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        key:String类型</span></span><br><span class="line"><span class="comment">            String类重写了hashCode方法和equals方法,可以保证key唯一</span></span><br><span class="line"><span class="comment">        value:Person类型</span></span><br><span class="line"><span class="comment">            value可以重复(同名同年龄的人视为同一个)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建HashMap集合</span></span><br><span class="line">        HashMap&lt;String, Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 往集合中添加元素</span></span><br><span class="line">        map.put(<span class="string">"北京"</span>, <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">"上海"</span>, <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));</span><br><span class="line">        map.put(<span class="string">"广州"</span>, <span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));</span><br><span class="line">        map.put(<span class="string">"北京"</span>, <span class="keyword">new</span> Person(<span class="string">"赵六"</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">// 使用keySet+增强for遍历Map集合</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            Person value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">"--&gt;"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        上海--&gt;Person&#123;name='李四', age=19&#125;</span></span><br><span class="line"><span class="comment">        广州--&gt;Person&#123;name='王五', age=20&#125;</span></span><br><span class="line"><span class="comment">        北京--&gt;Person&#123;name='赵六', age=18&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        key:Person类型</span></span><br><span class="line"><span class="comment">            Person类就必须重写hashCode方法和equals方法,以保证key唯一</span></span><br><span class="line"><span class="comment">        value:String类型</span></span><br><span class="line"><span class="comment">            可以重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建HashMap集合</span></span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 往集合中添加元素</span></span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"女王"</span>,<span class="number">18</span>),<span class="string">"英国"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"秦始皇"</span>,<span class="number">18</span>),<span class="string">"秦国"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"普京"</span>,<span class="number">30</span>),<span class="string">"俄罗斯"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"女王"</span>,<span class="number">18</span>),<span class="string">"毛里求斯"</span>);</span><br><span class="line">        <span class="comment">// 使用entrySet和增强for遍历Map集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Person, String&gt; entry : set) &#123;</span><br><span class="line">            Person key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">"--&gt;"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        Person&#123;name='女王', age=18&#125;--&gt;毛里求斯</span></span><br><span class="line"><span class="comment">        Person&#123;name='秦始皇', age=18&#125;--&gt;秦国</span></span><br><span class="line"><span class="comment">        Person&#123;name='普京', age=30&#125;--&gt;俄罗斯</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap-的使用"><a href="#LinkedHashMap-的使用" class="headerlink" title="LinkedHashMap 的使用"></a><code>LinkedHashMap</code> 的使用</h2><p><code>java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt;</code> 是 <code>Map</code> 接口的<strong>哈希表和链接列表实现</strong>，具有可预知的迭代顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoLinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"c"</span>,<span class="string">"c"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>,<span class="string">"b"</span>);</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// key不允许重复,无序 &#123;a=d, b=b, c=c&#125;</span></span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String,String&gt; linked = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        linked.put(<span class="string">"a"</span>,<span class="string">"a"</span>);</span><br><span class="line">        linked.put(<span class="string">"c"</span>,<span class="string">"c"</span>);</span><br><span class="line">        linked.put(<span class="string">"b"</span>,<span class="string">"b"</span>);</span><br><span class="line">        linked.put(<span class="string">"a"</span>,<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(linked); <span class="comment">// key不允许重复,有序 &#123;a=d, c=c, b=b&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK-9-对集合添加元素的优化（of-方法）"><a href="#JDK-9-对集合添加元素的优化（of-方法）" class="headerlink" title="JDK 9 对集合添加元素的优化（of 方法）"></a>JDK 9 对集合添加元素的优化（<code>of</code> 方法）</h1><p>通常，我们在代码中创建一个集合（例如，<code>List</code> 或 <code>Set</code>），并直接用一些元素填充它。 实例化集合，几个 <code>add</code> 方法 调用，使得代码重复。</p><p>Java 9，添加了几种集合工厂方法，更方便创建少量元素的集合、<code>Map</code> 实例。新的 <code>List</code>、<code>Set</code>、<code>Map</code> 的静态工厂方法可以更方便地创建集合的<strong>不可变实例</strong>。</p><p>JDK 9 的新特性：</p><ul><li><strong><code>List</code> 接口、<code>Set</code> 接口、<code>Map</code> 接口</strong>：里边增加了一个静态的方法 <code>of(E...elements)</code> ，可以给集合一次性添加多个元素。</li><li><code>static &lt;E&gt; List&lt;E&gt; of(E... elements)</code> </li><li>使用前提：当集合中存储的元素的个数已经确定了，不再改变时使用。</li></ul><p>注意:</p><ol><li><code>of</code> 方法只适用于 <code>List</code> 接口，<code>Set</code> 接口，<code>Map</code> 接口，不适用于接口的父接口、子接口及实现类。</li><li><code>of</code> 方法的返回值是一个不能改变的集合，集合不能再使用 <code>add</code>，<code>put</code> 方法添加元素，会抛出异常。</li><li><code>Set</code> 接口和 <code>Map</code> 接口在调用 <code>of</code> 方法的时候，不能有重复的元素，否则会抛出异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoJDK9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [a, b, a, c, d]</span></span><br><span class="line">        <span class="comment">// list.add("w"); // UnsupportedOperationException:不支持操作异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set&lt;String&gt; set = Set.of("a", "b", "a", "c", "d"); // IllegalArgumentException:非法参数异常,有重复的元素</span></span><br><span class="line">        Set&lt;String&gt; set = Set.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="comment">// set.add("w"); // UnsupportedOperationException:不支持操作异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map&lt;String, Integer&gt; map = Map.of("张三", 18, "李四", 19, "王五", 20,"张三",19); // IllegalArgumentException:非法参数异常,有重复的元素</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = Map.of(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="string">"李四"</span>, <span class="number">19</span>, <span class="string">"王五"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// &#123;王五=20, 李四=19, 张三=18&#125;</span></span><br><span class="line">        <span class="comment">// map.put("赵四",30); // UnsupportedOperationException:不支持操作异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java语言高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java语言高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言高级（1）常用API</title>
      <link href="/2020/02/01/java-advanced-1.html"/>
      <url>/2020/02/01/java-advanced-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用-API-（一）"><a href="#常用-API-（一）" class="headerlink" title="常用 API （一）"></a>常用 <code>API</code> （一）</h1><p> <code>API</code> (Application Programming Interface)，应用程序编程接口。Java API 是一本程序员的字典 ，是 JDK 中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。</p><h2 id="引用类型使用步骤"><a href="#引用类型使用步骤" class="headerlink" title="引用类型使用步骤"></a>引用类型使用步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>使用 <strong><code>import</code> 关键字</strong>导包，在类的所有代码之前导包，引入要使用的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名</span><br></pre></td></tr></table></figure><ul><li>如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</li><li>只有 <code>java.lang</code> 包下的内容不需要导包，其他的包都需要 import 语句。</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>使用该类的构造方法，创建一个该类的对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(参数列表);</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>调用该类的成员方法，完成指定功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名();</span><br></pre></td></tr></table></figure><h2 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a><code>Scanner</code> 类</h2><p> <code>Scanner</code> 类，一个可以解析基本类型和字符串的简单文本扫描器，可以实现从键盘输入数据到程序当中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 1. 导包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 创建</span></span><br><span class="line">        <span class="comment">// 备注：System.in代表从键盘进行输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 3. 获取键盘输入的int数字</span></span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"输入的int数字是："</span> + num);</span><br><span class="line">        <span class="comment">// 4. 获取键盘输入的字符串</span></span><br><span class="line">        String str = sc.next();</span><br><span class="line">        System.out.println(<span class="string">"输入的字符串是："</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Random-类"><a href="#Random-类" class="headerlink" title="Random 类"></a><code>Random</code> 类</h2><p> <code>Random</code> 类，一个随机数生成器，用来生成随机数字。</p><ul><li><code>new Random().nextInt()</code> 随机生成一个整数 (-∞, +∞)</li><li><code>new Random().nextInt(n)</code> 随机生成一个小于 n 的非负整数 [0, n-1]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRandomGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomNum = r.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">// [1,100]</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入你猜测的数字："</span>);</span><br><span class="line">            <span class="keyword">int</span> guessNum = sc.nextInt(); <span class="comment">// 键盘输入猜测的数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessNum &gt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">"太大了，请重试。"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guessNum &lt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">"太小了，请重试。"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"恭喜你，猜中啦！"</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果猜中，不再重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"游戏结束。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a><code>ArrayList</code> 类</h2><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>到目前为止，我们想存储对象数据，选择的容器，只有对象数组。而<strong>数组的长度是固定的</strong>，无法适应数据变化的需求。为了解决这个问题，Java提供了另一个容器 <code>java.util.ArrayList</code> 集合类,让我们可以更便捷的存储和操作对象数据。</p><h3 id="什么是-ArrayList-类"><a href="#什么是-ArrayList-类" class="headerlink" title="什么是 ArrayList 类"></a>什么是 <code>ArrayList</code> 类</h3><p> <code>java.util.ArrayList&lt;E&gt;</code> 是大小<strong>可变的数组</strong>的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。</p><p>尖括号 <code>&lt;E&gt;</code> 表示一种指定的数据类型，叫做<strong>泛型</strong>。E，取自 Element（元素）的首字母。在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。</p><p>注意事项：</p><ul><li>泛型只能是引用类型，不能是基本类型。</li><li>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个ArrayList集合，集合的名称是list，里面装的全都是String类型的数据</span></span><br><span class="line">        <span class="comment">// 备注：从JDK 1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是要写的。</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向集合当中添加一些数据，需要用到add方法。</span></span><br><span class="line">        list.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [赵丽颖]</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        list.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        list.add(<span class="string">"玛尔扎哈"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 错误写法！因为创建的时候泛型已经说了是字符串，添加进去的元素就必须都是字符串</span></span><br><span class="line">        <span class="comment">// list.add(100); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法与遍历"><a href="#常用方法与遍历" class="headerlink" title="常用方法与遍历"></a>常用方法与遍历</h3><p>ArrayList当中的常用方法有：</p><ul><li><code>public boolean add(E e)</code> ：在集合的尾部添加元素，参数类型和泛型一致，返回值代表添加是否成功。</li><li><code>public E get(int index)</code> ：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</li><li><code>public E remove(int index)</code> ：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</li><li><code>public int size()</code> ：获取集合的尺寸长度，返回值是集合中包含的元素个数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArrayListMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向集合中添加元素：add</span></span><br><span class="line">        <span class="keyword">boolean</span> success = list.add(<span class="string">"柳岩"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩]</span></span><br><span class="line">        System.out.println(<span class="string">"添加的动作是否成功："</span> + success); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"高圆圆"</span>);</span><br><span class="line">        list.add(<span class="string">"赵又廷"</span>);</span><br><span class="line">        list.add(<span class="string">"李小璐"</span>);</span><br><span class="line">        list.add(<span class="string">"贾乃亮"</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中获取元素：get。索引值从0开始</span></span><br><span class="line">        String name = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"第2号索引位置："</span> + name); <span class="comment">// 赵又廷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中删除元素：remove。索引值从0开始。</span></span><br><span class="line">        String whoRemoved = list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"被删除的人是："</span> + whoRemoved); <span class="comment">// 李小璐</span></span><br><span class="line">        System.out.println(list); <span class="comment">// [柳岩, 高圆圆, 赵又廷, 贾乃亮]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取集合的长度尺寸，也就是其中元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        System.out.println(<span class="string">"集合的长度是："</span> + size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何存储基本数据类型"><a href="#如何存储基本数据类型" class="headerlink" title="如何存储基本数据类型"></a>如何存储基本数据类型</h3><p>ArrayList 对象不能存储基本类型，只能存储引用类型的数据。如果希望向集合 ArrayList 当中存储基本类型数据，必须使用<strong>基本类型对应的“包装类”</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本类型    包装类（引用类型，包装类都位于java.lang包下）</span></span><br><span class="line"><span class="comment">byte        Byte</span></span><br><span class="line"><span class="comment">short       Short</span></span><br><span class="line"><span class="comment">int         Integer     【特殊】</span></span><br><span class="line"><span class="comment">long        Long</span></span><br><span class="line"><span class="comment">float       Float</span></span><br><span class="line"><span class="comment">double      Double</span></span><br><span class="line"><span class="comment">char        Character   【特殊】</span></span><br><span class="line"><span class="comment">boolean     Boolean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">从JDK 1.5+开始，支持自动装箱、自动拆箱。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">自动装箱：基本类型 --&gt; 包装类型</span></span><br><span class="line"><span class="comment">自动拆箱：包装类型 --&gt; 基本类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArrayListBasic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 错误写法！泛型只能是引用类型，不能是基本类型</span></span><br><span class="line">        <span class="comment">// ArrayList&lt;int&gt; listB = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; listC = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        listC.add(<span class="number">100</span>);</span><br><span class="line">        listC.add(<span class="number">200</span>);</span><br><span class="line">        System.out.println(listC); <span class="comment">// [100, 200]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = listC.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"第1号元素是："</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a><code>String</code> 类</h2><p> <code>java.lang.String</code> 类代表字符串。</p><p>API 当中说：<strong>Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</strong> </p><h3 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h3><ol><li>字符串的值在创建后不能被更改，即字符串<strong>不可改变</strong>。</li><li>因为字符串不可改变，所以字符串<strong>可以共享使用</strong>。</li><li>字符串效果上相当于是 <code>char[]</code> 字符数组，但是底层原理是 <code>byte[]</code> 字节数组.</li></ol><h3 id="字符串的创建方式"><a href="#字符串的创建方式" class="headerlink" title="字符串的创建方式"></a>字符串的创建方式</h3><p>三种构造方法：</p><ul><li><code>public String()</code> ：创建一个空白字符串，不含有任何内容。</li><li><code>public String(char[] array)</code> ：根据字符数组的内容，来创建对应的字符串。</li><li><code>public String(byte[] array)</code> ：根据字节数组的内容，来创建对应的字符串。</li></ul><p>一种直接创建：</p><ul><li><code>String str = &quot;Hello&quot;;</code> ：直接用双引号表示字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用空参构造</span></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(); <span class="comment">// 小括号留空，说明字符串什么内容都没有。</span></span><br><span class="line">        System.out.println(<span class="string">"第1个字符串："</span> + str1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字符数组创建字符串</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span> &#125;;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(charArray);</span><br><span class="line">        System.out.println(<span class="string">"第2个字符串："</span> + str2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字节数组创建字符串</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(byteArray);</span><br><span class="line">        System.out.println(<span class="string">"第3个字符串："</span> + str3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接创建</span></span><br><span class="line">        String str4 = <span class="string">"Hello"</span>;</span><br><span class="line">        System.out.println(<span class="string">"第4个字符串："</span> + str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>字符串常量池：Java 程序当中直接写上的双引号字符串，就在字符串常量池中。</p><p>常量池的出现方便了频繁取用某些需要重复引用的东西，在使用前先在常量池中查找，如果查找失败再创建一个，也就是说常量池提高了效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStringPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abc"</span>;</span><br><span class="line">        String str2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str1 == str3); <span class="comment">// false</span></span><br><span class="line">        System.out.println(str2 == str3); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的内存原理如下图：</p><p><img src="/2020/02/01/java-advanced-1/字符串常量池示意.png" alt></p><ul><li>对于基本类型来说，<code>==</code>是进行数值的比较。</li><li>对于引用类型来说，<code>==</code> 是进行地址值的比较。</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="比较相关方法"><a href="#比较相关方法" class="headerlink" title="比较相关方法"></a>比较相关方法</h4><p>字符串的 <code>==</code> 操作符进行的是地址值的比较。如果需要进行字符串内容的比较，可以使用 <code>equals()</code> 方法。</p><ul><li><code>public boolean equals(Object obj)</code> ：将此字符串与指定对象进行内容比较。<ol><li>任何对象都能用 Object 进行接收。</li><li>equals 方法具有对称性，也就是 <code>a.equals(b)</code> 和 <code>b.equals(a)</code> 效果一样。</li><li>如果比较双方一个常量一个变量，推荐把常量字符串写在前面。</li></ol></li><li><code>public boolean equalsIgnoreCase(String str)</code> ：将此字符串与指定对象进行内容比较，忽略大小写。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStringEquals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String str2 = <span class="string">"Hello"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str3.equals(<span class="string">"Hello"</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>.equals(str1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String str4 = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(str1.equals(str4)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        String str5 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"abc"</span>.equals(str5)); <span class="comment">// 推荐：false</span></span><br><span class="line">        <span class="comment">// System.out.println(str5.equals("abc")); // 不推荐：报错，空指针异常NullPointerException</span></span><br><span class="line">        </span><br><span class="line">        String strA = <span class="string">"Java"</span>;</span><br><span class="line">        String strB = <span class="string">"java"</span>;</span><br><span class="line">        System.out.println(strA.equals(strB)); <span class="comment">// false，严格区分大小写</span></span><br><span class="line">        System.out.println(strA.equalsIgnoreCase(strB)); <span class="comment">// true，忽略大小写</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，只有英文字母区分大小写，其他都不区分大小写</span></span><br><span class="line">        System.out.println(<span class="string">"abc一123"</span>.equalsIgnoreCase(<span class="string">"abc壹123"</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取相关方法"><a href="#获取相关方法" class="headerlink" title="获取相关方法"></a>获取相关方法</h4><ul><li><code>public int length()</code> ：获取字符串当中含有的字符个数，即字符串长度。</li><li><code>public String concat(String str)</code> ：将当前字符串和参数字符串拼接成为新的字符串并返回。</li><li><code>public char charAt(int index)</code> ：获取指定索引位置的单个字符。</li><li><code>public int indexOf(String str)</code> ：查找参数字符串在本来字符串当中首次出现的索引位置，如果不存在则返回 -1 值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStringGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="string">"asdasfeutrvauevbueyvb"</span>.length();</span><br><span class="line">        System.out.println(<span class="string">"字符串的长度是："</span> + length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接字符串</span></span><br><span class="line">        String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String str2 = <span class="string">"World"</span>;</span><br><span class="line">        String str3 = str1.concat(str2);</span><br><span class="line">        System.out.println(str1); <span class="comment">// Hello，原封不动</span></span><br><span class="line">        System.out.println(str2); <span class="comment">// World，原封不动</span></span><br><span class="line">        System.out.println(str3); <span class="comment">// HelloWorld，新的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定索引位置的单个字符</span></span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">"Hello"</span>.charAt(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"在1号索引位置的字符是："</span> + ch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找参数字符串在本来字符串当中出现的第一次索引位置</span></span><br><span class="line">        <span class="comment">// 如果根本没有，返回-1值</span></span><br><span class="line">        String original = <span class="string">"HelloWorldHelloWorld"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = original.indexOf(<span class="string">"llo"</span>);</span><br><span class="line">        System.out.println(<span class="string">"第一次索引值是："</span> + index); <span class="comment">// 2</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>.indexOf(<span class="string">"abc"</span>)); <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="截取方法"><a href="#截取方法" class="headerlink" title="截取方法"></a>截取方法</h4><ul><li><code>public String substring(int index)</code> ：截取从 index 位置一直到字符串末尾，返回新字符串。</li><li><code>public String substring(int begin, int end)</code> ：截取从 begin 开始，一直到 end 结束，返回中间的字符串。注意：[begin, end)，包含 begin，不包含 end。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"HelloWorld"</span>;</span><br><span class="line">        String str2 = str1.substring(<span class="number">5</span>);</span><br><span class="line">        System.out.println(str1); <span class="comment">// HelloWorld，原封不动</span></span><br><span class="line">        System.out.println(str2); <span class="comment">// World，新字符串</span></span><br><span class="line"></span><br><span class="line">        String str3 = str1.substring(<span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(str3); <span class="comment">// oWo</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这种写法，字符串的内容仍然是没有改变的</span></span><br><span class="line">        <span class="comment">// 下面有两个字符串："Hello"，"Java"</span></span><br><span class="line">        <span class="comment">// strA当中保存的是地址值。</span></span><br><span class="line">        <span class="comment">// 本来地址值是"Hello"的，</span></span><br><span class="line">        <span class="comment">// 后来地址值变成了"Java"的</span></span><br><span class="line">        String strA = <span class="string">"Hello"</span>;</span><br><span class="line">        System.out.println(strA); <span class="comment">// Hello</span></span><br><span class="line">        strA = <span class="string">"Java"</span>;</span><br><span class="line">        System.out.println(strA); <span class="comment">// Java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换相关方法"><a href="#转换相关方法" class="headerlink" title="转换相关方法"></a>转换相关方法</h4><ul><li><code>public char[] toCharArray()</code> ：将当前字符串拆分成为字符数组作为返回值。</li><li><code>public byte[] getBytes()</code> ：获得当前字符串底层的字节数组。</li><li><code>public String replace(CharSequence target, CharSequence replacement)</code> ：将所有出现的 target 字符串替换成为 replacement 字符串，返回替换之后的结果新字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStringConvert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转换成为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="string">"Hello"</span>.toCharArray();</span><br><span class="line">        System.out.println(chars[<span class="number">0</span>]); <span class="comment">// H</span></span><br><span class="line">        System.out.println(chars.length); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换成为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">"abc"</span>.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            System.out.println(bytes[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串的内容替换</span></span><br><span class="line">        String str1 = <span class="string">"How do you do?"</span>;</span><br><span class="line">        String str2 = str1.replace(<span class="string">"o"</span>, <span class="string">"*"</span>);</span><br><span class="line">        System.out.println(str1); <span class="comment">// How do you do?</span></span><br><span class="line">        System.out.println(str2); <span class="comment">// H*w d* y*u d*?</span></span><br><span class="line"></span><br><span class="line">        String lang1 = <span class="string">"会不会玩儿呀！你大爷的！你大爷的！你大爷的！！！"</span>;</span><br><span class="line">        String lang2 = lang1.replace(<span class="string">"你大爷的"</span>, <span class="string">"****"</span>);</span><br><span class="line">        System.out.println(lang2); <span class="comment">// 会不会玩儿呀！****！****！****！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分割方法"><a href="#分割方法" class="headerlink" title="分割方法"></a>分割方法</h4><p> <code>public String[] split(String regex)</code> ：按照给定的 regex（规则），将字符串切分成为若干部分，并返回一个字符串数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStringSplit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"aaa,bbb,ccc"</span>;</span><br><span class="line">        String[] array1 = str1.split(<span class="string">","</span>); <span class="comment">// ["aaa","bbb","ccc"]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            System.out.println(array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="string">"aaa bbb ccc"</span>;</span><br><span class="line">        String[] array2 = str2.split(<span class="string">" "</span>); <span class="comment">// ["aaa","bbb","ccc"]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">            System.out.println(array2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str3 = <span class="string">"XXX.YYY.ZZZ"</span>;</span><br><span class="line">        String[] array3 = str3.split(<span class="string">"."</span>);</span><br><span class="line">        System.out.println(array3.length); <span class="comment">// 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array3.length; i++) &#123;</span><br><span class="line">            System.out.println(array3[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String str4 = <span class="string">"XXX.YYY.ZZZ"</span>;</span><br><span class="line">        String[] array3 = str3.split(<span class="string">"\\."</span>);</span><br><span class="line">        System.out.println(array3.length); <span class="comment">// ["XXX","YYY","ZZZ"]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array3.length; i++) &#123;</span><br><span class="line">            System.out.println(array3[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a><code>static</code> 关键字</h1><p>关于 <strong><code>static</code> 关键字</strong>的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是<strong>属于类</strong>的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 </p><h2 id="static-的使用"><a href="#static-的使用" class="headerlink" title="static 的使用"></a><code>static</code> 的使用</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>当 <code>static</code> 修饰成员变量时，该变量称为<strong>静态变量（或类变量）</strong>。这个变量不再属于对象自己，而是属于所在的类，该类的每个对象都共享同一个静态变量的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 数据类型 变量名;</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>当 <code>static</code> 修饰成员方法时，该方法称为<strong>静态方法（或类方法）</strong>。静态方法不属于对象，而是属于类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果没有 static 关键字，那么必须首先创建对象，然后通过对象才能调用方法。</li><li>如果有了 static 关键字，那么不需要创建对象，直接就能通过类名称来调用方法。</li></ul><h3 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h3><p>无论是成员变量，还是成员方法，如果有了 static 修饰：</p><ul><li>推荐<strong>使用类名称来进行调用</strong>：<code>类名.静态变量名</code> ，<code>类名.静态方法名(参数)</code> 。</li><li>依然可以使用对象来调用，编译后会转换成 <code>类名.静态成员</code> 形式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numStatic; <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个成员方法。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个静态方法。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass obj = <span class="keyword">new</span> MyClass(); <span class="comment">// 首先创建对象</span></span><br><span class="line">        <span class="comment">// 然后才能使用没有static关键字的内容</span></span><br><span class="line">        obj.method();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。</span></span><br><span class="line">        obj.methodStatic(); <span class="comment">// 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”</span></span><br><span class="line">        MyClass.methodStatic(); <span class="comment">// 正确，推荐</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于本类当中的静态方法，可以省略类名称</span></span><br><span class="line">        myMethod();</span><br><span class="line">        DemoStaticMethod.myMethod(); <span class="comment">// 完全等效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"自己的方法！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>静态方法和成员方法都可以直接访问静态内容。</li><li>静态方法不能直接访问非静态内容。因为在内存当中是先有的静态内容，后有的非静态内容。</li><li>静态方法当中不能用 this 关键字。this 代表当前对象，而静态内容与对象无关。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numStatic; <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个成员方法。"</span>);</span><br><span class="line">        <span class="comment">// 成员方法可以访问成员变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="comment">// 成员方法可以访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个静态方法。"</span>);</span><br><span class="line">        <span class="comment">// 静态方法可以访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">        <span class="comment">// 静态不能直接访问非静态</span></span><br><span class="line">        <span class="comment">// System.out.println(num); // 错误写法！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法中不能使用this关键字。</span></span><br><span class="line">        <span class="comment">// System.out.println(this); // 错误写法！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内存原理"><a href="#静态内存原理" class="headerlink" title="静态内存原理"></a>静态内存原理</h2><p> <code>static</code> 修饰的内容：</p><ul><li>是随着类的加载而加载的，且只加载一次。</li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</li><li>它优先于对象存在，所以，可以被所有对象共享。</li></ul><p><img src="/2020/02/01/java-advanced-1/%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98%E5%9B%BE.png" alt></p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p><strong>静态代码块</strong>：定义在成员位置，使用 static 修饰的代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>位置：类中方法外。 </li><li>执行：随着类的加载而执行且执行唯一的一次，优先于 main 方法和构造方法的执行。 </li><li>典型用途：用来一次性地对静态成员变量进行赋值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块执行！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造方法执行！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person one = <span class="keyword">new</span> Person();</span><br><span class="line">        Person two = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">静态代码块执行！</span></span><br><span class="line"><span class="comment">构造方法执行！</span></span><br><span class="line"><span class="comment">构造方法执行！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="常用-API-（二）"><a href="#常用-API-（二）" class="headerlink" title="常用 API （二）"></a>常用 <code>API</code> （二）</h1><h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a><code>Arrays</code> 类</h2><p> <code>java.util.Arrays</code> 是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。</p><ul><li><code>public static String toString(数组)</code> ：将参数数组变成字符串。<ul><li>按照默认格式：[元素1, 元素2, 元素3…]</li></ul></li><li><code>public static void sort(数组)</code> ：按照默认升序对数组的元素进行排序。<ol><li>如果是数值，sort 默认按照升序从小到大</li><li>如果是字符串，sort 默认按照字母升序</li><li>如果是自定义的类型，那么这个自定义的类需要有 Comparable 或者 Comparator 接口的支持。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">// 将int[]数组按照默认格式变成字符串</span></span><br><span class="line">        String intStr = Arrays.toString(intArray);</span><br><span class="line">        System.out.println(intStr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array1 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        Arrays.sort(array1);</span><br><span class="line">        System.out.println(Arrays.toString(array1)); <span class="comment">// [1, 2, 3, 6, 10]</span></span><br><span class="line"></span><br><span class="line">        String[] array2 = &#123;<span class="string">"bbb"</span>, <span class="string">"aaa"</span>, <span class="string">"ccc"</span>&#125;;</span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2)); <span class="comment">// [aaa, bbb, ccc]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a><code>Math</code> 类</h2><p> <code>java.util.Math</code> 类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</p><ul><li><code>public static double abs(double num)</code> ：获取绝对值。有多种重载。</li><li><code>public static double ceil(double num)</code>：向上取整。</li><li><code>public static double floor(double num)</code> ：向下取整。</li><li><code>public static long round(double num)</code> ：四舍五入。</li><li><code>Math.PI</code> ：近似的圆周率常量（double）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取绝对值</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">3.14</span>)); <span class="comment">// 3.14</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">2.5</span>)); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.9</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.1</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.0</span>)); <span class="comment">// 3.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下取整，抹零</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.1</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.9</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">31.0</span>)); <span class="comment">// 31.0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Math.round(<span class="number">20.4</span>)); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.5</span>)); <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a><code>Object</code> 类</h1><p> <code>java.lang.Object</code> 类是 Java 语言中的根类，即<strong>所有类的父类（超类）</strong>。如果一个类没有特别指定父类，那么默认则继承自 Object 类。所有对象（包括数组）都实现这个类的方法。</p><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a><code>toString()</code> 方法</h2><p> <code>public String toString()</code> ：返回该对象的字符串表示，字符串内容是 <strong>“对象的类型 + @ + 内存地址值”</strong>。</p><p>由于 toString 方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoToString</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>);</span><br><span class="line">        String s = p.toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">// 直接打印对象的名字,其实就是调用对象的toString</span></span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看一个类是否重写了toString,直接打印这个类的对象即可</span></span><br><span class="line">        <span class="comment">// 如果没有重写toString方法那么打印的是对象的地址值</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        System.out.println(r); <span class="comment">// 没有重写toString方法</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[1, 2, 3]  重写了toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a><code>equals()</code> 方法</h2><p> <code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</p><p>Object 类中的 equals 方法默认进行 <code>==</code> 运算符的对象地址比较，只要不是同一个对象，结果必然为 false。</p><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以重写 equals 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Objects-类"><a href="#Objects-类" class="headerlink" title="Objects 类"></a><code>Objects</code> 类</h2><p>在 JDK 7 添加了一个 <strong>Objects 工具类</strong>，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是 <strong>null-save（空指针安全的）或 null-tolerant（容忍空指针的）</strong>，用于计算对象的 hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object 的 equals 方法容易抛出空指针异常，而 Objects 类中的 equals 方法就优化了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用-API-（三）"><a href="#常用-API-（三）" class="headerlink" title="常用 API （三）"></a>常用 <code>API</code> （三）</h1><h2 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a><code>Date</code> 类</h2><p> <code>java.util.Date</code> 类表示特定的瞬间，精确到<strong>毫秒</strong>。</p><p>毫秒值的作用：可以对时间和日期进行计算。</p><ul><li>把日期转换为毫秒：计算某日期到基准时间之间一共经历了多少毫秒</li><li>把毫秒转换为日期：1 天 = 24 × 60 × 60 = 86400 秒  = 86400 x 1000 = 86400000 毫秒</li></ul><p>构造方法：</p><ul><li><code>public Date()</code> ：获取当前系统的日期和时间。</li><li><code>public Date(long date)</code> ：指定到标准基准时间（1970 年 1 月 1 日 00:00:00 GMT）的毫秒数。</li></ul><p>常用方法：</p><ul><li><code>public long getTime()</code> ：把日期对象转换成对应的时间毫秒值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line">        demo03();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Date类的空参数构造方法</span></span><br><span class="line"><span class="comment">        Date() 获取当前系统的日期和时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date); <span class="comment">// Sun Aug 08 12:23:03 CST 2088</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Date类的带参数构造方法</span></span><br><span class="line"><span class="comment">        Date(long date) :传递毫秒值,把毫秒值转换为Date日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">0L</span>);</span><br><span class="line">        System.out.println(date); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line"></span><br><span class="line">        date = <span class="keyword">new</span> Date(<span class="number">3742767540068L</span>);</span><br><span class="line">        System.out.println(date); <span class="comment">// Sun Aug 08 09:39:00 CST 2088</span></span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        long getTime() 把日期转换为毫秒值(相当于System.currentTimeMillis()方法)</span></span><br><span class="line"><span class="comment">        返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> time = date.getTime();</span><br><span class="line">        System.out.println(time); <span class="comment">// 3742777636267</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DateFormat-类"><a href="#DateFormat-类" class="headerlink" title="DateFormat 类"></a><code>DateFormat</code> 类</h2><p> <code>java.text.DateFormat</code> 是<strong>日期/时间格式化</strong>子类的抽象类，通过这个类可以完成日期和文本之间的转换，也就是可以在 Date 对象与 String 对象之间进行转换。</p><ul><li>格式化：从日期转换为文本</li><li>解析：从文本转换为日期</li></ul><p>由于 DateFormat 为抽象类，不能直接使用，所以需要使用子类 <code>java.text.SimpleDateFormat</code>。</p><p>构造方法：</p><ul><li><code>public SimpleDateFormat(String pattern)</code> ：用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat 对象。</li></ul><p>常用的格式规则为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">标识字母</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">年</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">月</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">日</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">时</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">分</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">秒</td></tr></tbody></table></div><p>常用方法：</p><ul><li><code>public String format(Date date)</code> ：将 Date 对象格式化为字符串。</li><li><code>public Date parse(String source)</code> ：将字符串解析为 Date 对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String d = sdf.format(date);</span><br><span class="line">        System.out.println(date); <span class="comment">// Sun Aug 08 15:51:54 CST 2088</span></span><br><span class="line">        System.out.println(d); <span class="comment">// 2088年08月08日 15时51分54秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">        Date date = sdf.parse(<span class="string">"2088年08月08日 15时51分54秒"</span>);</span><br><span class="line">        System.out.println(date); <span class="comment">// Sun Aug 08 15:51:54 CST 2088</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a><code>Calendar</code> 类</h2><p> <code>java.util.Calendar</code> 是日历类，在 Date 后出现，替换掉了许多 Date 的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><p>Calendar 为抽象类，由于语言敏感性，Calendar 类在创建对象时并非直接创建子类对象，而是<strong>通过静态方法创建子类对象</strong>：</p><ul><li><code>public static Calendar getInstance()</code> ：使用默认时区和语言环境获得一个日历</li></ul><p>常用方法：</p><ul><li><code>public int get(int field)</code> ：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code> ：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code> ：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code> ：返回一个表示此 Calendar 时间值（从历元到现在的毫秒偏移量）的 Date 对象。</li></ul><p>Calendar 类中提供很多成员常量，代表给定的日历字段：</p><div class="table-container"><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从 0 开始，可以 + 1 使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的第几天（几号）</td></tr><tr><td>DATE</td><td>月中的第几天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的第几天（周几，周日为 1，可以 - 1 使用）</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCalendar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line">        demo03();</span><br><span class="line">        demo04();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用getInstance方法获取Calendar对象</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置年为9999</span></span><br><span class="line">        c.set(Calendar.YEAR,<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 设置月为9月</span></span><br><span class="line">        c.set(Calendar.MONTH,<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 设置日9日</span></span><br><span class="line">        c.set(Calendar.DATE,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时设置年月日,可以使用set的重载方法</span></span><br><span class="line">        c.set(<span class="number">8888</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把年增加2年</span></span><br><span class="line">        c.add(Calendar.YEAR,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 把月份减少3个月</span></span><br><span class="line">        c.add(Calendar.MONTH,-<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> month = c.get(Calendar.MONTH);</span><br><span class="line">        System.out.println(month);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        Date date = c.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a><code>System</code> 类</h2><p> <code>java.lang.System</code> 类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。</p><p>常用方法：</p><ul><li><code>public static long currentTimeMillis()</code> ：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> ：将数组中指定的数据拷贝到另一个数组中。<ul><li><code>src</code>：源数组</li><li><code>srcPos</code>：源数组中的起始位置（起始索引）</li><li><code>dest</code>：目标数组</li><li><code>destPos</code>：目标数据中的起始位置</li><li><code>length</code>：要复制的数组元素的数量</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        currentTimeMillis()</span></span><br><span class="line"><span class="comment">        用来验证程序的效率</span></span><br><span class="line"><span class="comment">        验证for循环打印数字1-9999所需要使用的时间（毫秒）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 程序执行前,获取一次毫秒值</span></span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 执行for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">9999</span> ; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序执行后,获取一次毫秒值</span></span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"程序共耗时:"</span>+(e-s)+<span class="string">"毫秒"</span>);<span class="comment">//程序共耗时:106毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    arraycopy(src, srcPos, dest, destPos, length)</span></span><br><span class="line"><span class="comment">    将数组中指定的数据拷贝到另一个数组中</span></span><br><span class="line"><span class="comment">        练习:将src数组中前3个元素，复制到dest数组的前3个位置上</span></span><br><span class="line"><span class="comment">        复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]</span></span><br><span class="line"><span class="comment">        复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义源数组</span></span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">// 定义目标数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dest = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"复制前:"</span>+ Arrays.toString(dest));</span><br><span class="line">        <span class="comment">// 使用System类中的arraycopy把源数组的前3个元素复制到目标数组的前3个位置上</span></span><br><span class="line">        System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"复制后:"</span>+ Arrays.toString(dest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a><code>StringBuilder</code> 类</h2><p>由于 String 类的对象内容不可改变，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用 <code>java.lang.StringBuilder</code> 类。</p><p> <code>StringBuilder</code> 又称为<strong>可变字符序列</strong>，它是一个类似于 String 的<strong>字符串缓冲区</strong>，通过某些方法调用可以改变该序列的长度和内容，可以提高字符串的效率。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder 会自动维护数组的扩容。原理如下图所示：</p><p><img src="/2020/02/01/java-advanced-1/StringBuilder的原理.png" alt="StringBuilder的原理"></p><p>构造方法：</p><ul><li><code>public StringBuilder()</code>：构造一个空的 StringBuilder 容器。<ul><li>默认 16 字符空间，超过自动扩充</li></ul></li><li><code>public StringBuilder(String str)</code> ：构造一个 StringBuilder 容器，并将字符串添加进去。<ul><li>有参构造方法将不可变的 String 对象转换成可变的 StringBuilder 对象。</li></ul></li></ul><p>常用方法：</p><ul><li><code>public StringBuilder append(...)</code> ：添加任意类型数据的字符串形式，并返回当前对象自身。<ul><li>append 方法具有多种重载形式，可以接收任意类型的参数。</li><li>任何数据作为参数都会将对应的字符串内容添加到 StringBuilder 中。</li></ul></li><li><code>public String toString()</code> ：将当前 StringBuilder 对象转换为 String 对象。<ul><li>通过 toString 方法，StringBuilder 对象将会转换为不可变的 String 对象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String-&gt;StringBuilder</span></span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(<span class="string">"str:"</span>+str);</span><br><span class="line">        StringBuilder bu = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        <span class="comment">// 往StringBuilder中添加数据</span></span><br><span class="line">        bu.append(<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(<span class="string">"bu:"</span>+bu);</span><br><span class="line">        <span class="comment">// StringBuilder-&gt;String</span></span><br><span class="line">        String s = bu.toString();</span><br><span class="line">        System.out.println(<span class="string">"str:"</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java 提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><div class="table-container"><table><thead><tr><th>基本类型</th><th>对应的包装类（位于 java.lang 包中）</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>int</code></td><td><strong><code>Integer</code></strong></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td><strong><code>Character</code></strong></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table></div><p>基本类型与对应的包装类对象之间来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。（以 int 类型举例）<ul><li>构造方法：<ul><li><code>Integer(int value)</code> 构造一个新分配的 Integer 对象，它表示指定的 int 值。</li><li><code>Integer(String s)</code> 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。</li></ul></li><li>静态方法：<ul><li><code>static Integer valueOf(int i)</code> 返回一个表示指定的 int 值的 Integer 实例。</li><li><code>static Integer valueOf(String s)</code> 返回保存指定的 String 的值的 Integer 对象。</li></ul></li></ul></li><li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。<ul><li>成员方法：<ul><li><code>int intValue()</code> 以 int 类型返回该 Integer 的值。</li></ul></li></ul></li></ul><p>由于我们经常要做基本类型与包装类之间的转换，从 Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成，即<strong>自动拆箱</strong>与<strong>自动装箱</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoIneger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            自动装箱:直接把int类型的整数赋值包装类</span></span><br><span class="line"><span class="comment">            Integer in = 1; 就相当于 Integer in = new Integer(1);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Integer in = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            自动拆箱:in是包装类,无法直接参与运算,可以自动转换为基本数据类型,在进行计算</span></span><br><span class="line"><span class="comment">            in+2;就相当于 in.intVale() + 2 = 3</span></span><br><span class="line"><span class="comment">            in = in.intVale() + 2 = 3 又是一个自动装箱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        in = in + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ArrayList集合无法直接存储整数,可以存储Integer包装类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.add(<span class="number">1</span>); <span class="comment">//--&gt;自动装箱 list.add(new Integer(1));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = list.get(<span class="number">0</span>); <span class="comment">//--&gt;自动拆箱  list.get(0).intValue();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本类型与字符串之间的互相转换：</p><ul><li>基本类型转换为字符串：<ol><li>基本类型值与 <code>空字符串&quot;&quot;</code> 拼接；</li><li>使用包装类的静态方法 <code>static String toString(参数)</code> ，注意这是 Object 类 toString 方法的重载而非重写；</li><li>使用 String 类的静态方法 <code>static String valueOf(参数)</code> 。</li></ol></li><li>字符串转化为基本类型：<ul><li>使用包装类（除 Character）的静态方法 <code>static 数据类型 parseXXX(字符串)</code> ，如果字符串内容无法正确转换为对应基本类型，将抛出 <code>java.lang.NumberFormatException</code> 异常。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoIntegerAndString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基本类型-&gt;字符串(String)</span></span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">100</span>;</span><br><span class="line">        String s1 = i1 + <span class="string">""</span>;</span><br><span class="line">        System.out.println(s1 + <span class="number">200</span>); <span class="comment">// 100200</span></span><br><span class="line"></span><br><span class="line">        String s2 = Integer.toString(<span class="number">100</span>);</span><br><span class="line">        System.out.println(s2 + <span class="number">200</span>); <span class="comment">// 100200</span></span><br><span class="line"></span><br><span class="line">        String s3 = String.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(s3 + <span class="number">200</span>); <span class="comment">// 100200</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串(String)-&gt;基本类型</span></span><br><span class="line">        <span class="keyword">int</span> i = Integer.parseInt(s1);</span><br><span class="line">        System.out.println(i - <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = Integer.parseInt(<span class="string">"a"</span>); <span class="comment">// NumberFormatException</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java语言高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java语言高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/2020/01/15/java-object-oriented.html"/>
      <url>/2020/01/15/java-object-oriented.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用 Java 语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。</p><p>面向对象思想就是在计算机程序设计过程中，参照现实中事物，<strong>将属性特征、行为特征抽象出来，描述成计算机事件</strong>的设计思想。 它区别于面向过程思想，<strong>强调的是通过调用对象的行为来实现功能</strong>，而不是自己一步一步的去操作实现。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了<strong>三大基本特征，即封装、继承和多态。</strong></p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="什么是类和对象"><a href="#什么是类和对象" class="headerlink" title="什么是类和对象"></a>什么是类和对象</h2><p><strong>类</strong>：是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</p><ul><li><strong>属性</strong>：就是该事物的状态信息。</li><li><strong>行为</strong>：就是该事物能够做什么。</li></ul><p><strong>对象</strong>：是一类事物的具体体现。对象是<strong>类的一个实例</strong>，必然具备该类事物的属性和行为。</p><p>类和对象的关系：</p><ul><li>类是对一类事物的描述，是<strong>抽象</strong>的。</li><li>对象是一类事物的实例，是<strong>具体</strong>的。</li><li><strong>类是对象的模板，对象是类的实例。</strong></li></ul><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>Java 中用类（<code>class</code>） 来描述事物：</p><ul><li><strong>成员变量</strong>（属性）</li><li><strong>成员方法</strong>（行为）</li></ul><p>类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>成员变量直接定义在<strong>类中、方法外</strong>；</li><li>成员方法<strong>不加 static 关键字</strong>。</li></ol><h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><p>通常情况下，一个类不能直接使用，需要根据类创建一个对象才能使用。</p><p>创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName objectName  = <span class="keyword">new</span> ClassName();</span><br></pre></td></tr></table></figure><p>使用对象访问类中的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectName.成员变量名</span><br><span class="line">objectName.成员方法名(参数)</span><br></pre></td></tr></table></figure><p>成员变量的默认值：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>整数（byte、short、int、long）</td><td>0</td></tr><tr><td>浮点数（float、double）</td><td>0.0</td></tr><tr><td>字符（char）</td><td>\u0000</td></tr><tr><td>布尔（boolean）</td><td>false</td></tr><tr><td>引用（数组、类、接口）</td><td>null</td></tr></tbody></table></div><h2 id="对象内存原理"><a href="#对象内存原理" class="headerlink" title="对象内存原理"></a>对象内存原理</h2><ul><li>创建的对象存储在堆内存中<ul><li>成员变量</li><li>成员方法标记值（成员方法的地址值）</li></ul></li><li>类的信息存储在方法区中<ul><li>成员方法的信息</li></ul></li><li>程序运行在栈内存中<ul><li>main 方法首先入栈，最后出栈<ul><li>局部变量</li><li>引用变量（对象地址值）</li></ul></li><li>成员方法不断压栈和出栈<ul><li>局部变量</li></ul></li></ul></li></ul><p>只有一个对象的内存图如下：</p><p><img src="/2020/01/15/java-object-oriented/只有一个对象的内存图.png" alt></p><h2 id="使用对象类型作为方法的参数和返回值"><a href="#使用对象类型作为方法的参数和返回值" class="headerlink" title="使用对象类型作为方法的参数和返回值"></a>使用对象类型作为方法的参数和返回值</h2><p>引用类型作为参数和返回值时，传递的都是地址值。</p><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>变量根据<strong>定义位置的不同</strong>分成成员变量和局部变量两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    数据类型 成员变量名;<span class="comment">// 成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        数据类型 局部变量名;<span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在类中的位置不同<ul><li>成员变量：类中、方法外</li><li>局部变量：方法中或者方法声明中（形式参数）</li></ul></li><li>作用范围不同<ul><li>成员变量：类中</li><li>局部变量：方法中</li></ul></li><li>初始化值不同<ul><li>成员变量：有默认值</li><li>局部变量：没有默认值，必须定义后赋值才能使用</li></ul></li><li>在内存中的位置不同<ul><li>成员变量：堆内存</li><li>局部变量：栈内存</li></ul></li><li>生命周期不同<ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li></ul></li></ul><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><p>封装就是将一些细节信息隐藏起来，对于外界不可见。封装性在 Java 当中的体现：</p><ol><li><code>方法</code> 就是一种封装：调用者只知道方法会完成什么功能，并不知道功能具体是如何实现的。</li><li>关键字 <code>private</code> 也是一种封装：将类的属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</li></ol><h2 id="private-关键字"><a href="#private-关键字" class="headerlink" title="private 关键字"></a><code>private</code> 关键字</h2><p> <code>private</code> 的含义：</p><ul><li>private 是一个<strong>权限修饰符</strong>，代表最小权限，可以修饰成员变量和成员方法。</li><li>被 private 修饰后的成员变量和成员方法，<strong>在本类当中仍可以随意访问</strong>，但是超出了本类范围之外就不能再直接访问了。</li></ul><p>间接访问 private 成员变量：定义 <code>getXxx</code> 方法和 <code>setXxx</code> 方法</p><ul><li>Getter 方法：不能有参数，返回值类型和成员变量对应</li><li>Setter 方法：不能有返回值，参数类型和成员变量对应</li><li>对于基本类型当中的 boolean 值，Getter 方法一定要写成 <code>isXxx</code> 的形式，而 setXxx 规则不变</li></ul><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a><code>this</code> 关键字</h2><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，会优先使用局部变量，导致成员变量被隐藏，无法访问成员变量。</p><p>如果需要访问本类当中的成员变量，需要使用 <code>this</code> 关键字。使用格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名</span><br></pre></td></tr></table></figure><p>使用 this 关键字代表所在类的当前对象的引用（地址值），即对象自己的引用。<strong>谁在调用，谁就是this。</strong> </p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当我们<strong>通过关键字 new 来创建对象时，其实就是在调用构造方法。</strong>构造方法专门用来初始化对象，给对象的成员变量赋初始值。</p><p>构造方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassName</span><span class="params">(参数类型 参数名称, ...)</span> </span>&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法的名称必须与所在类的类名完全一致</li><li>构造方法<strong>没有返回值类型</strong>，也不能返回一个值</li><li>如果没有自定义构造方法，编译器会默认提供一个<strong>无参构造方法</strong> <code>public ClassName() {}</code> </li><li>一旦自定义构造方法，编译器不再提供默认的无参构造方法</li><li>构造方法可以重载</li></ul><h2 id="标准的类（JavaBean）"><a href="#标准的类（JavaBean）" class="headerlink" title="标准的类（JavaBean）"></a>标准的类（JavaBean）</h2><p>一个标准的类通常要满足下面的条件：</p><ol><li>类是具体的和公共的；</li><li>所有的成员变量都使用 private 关键字修饰；</li><li>为每一个成员变量都提供一对 Getter/Setter 方法；</li><li>必须具有一个无参数的构造方法；</li><li>建议具有一个全参数的构造方法；</li></ol><p>这样的标准规范也叫做 <code>Java Bean</code> 规范，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//构造方法，无参构造方法【必须】，有参构造方法【建议】</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="comment">//getXxx()</span></span><br><span class="line">    <span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为 <strong><code>子类</code></strong> ，单独那一个类称为 <strong><code>父类</code></strong> 、超类（superclass）或者基类。</p><p><strong>继承</strong>：就是子类继承父类的<strong>属性和行为</strong>，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</p><p>继承描述的是事物之间的所属关系，这种关系是 <strong><code>is-a</code></strong> 的关系。“子类就是一个父类”，也就是说，子类可以被当做父类看待。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p><h2 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a><code>extends</code> 关键字</h2><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承后的成员变量"><a href="#继承后的成员变量" class="headerlink" title="继承后的成员变量"></a>继承后的成员变量</h2><h3 id="成员变量的访问"><a href="#成员变量的访问" class="headerlink" title="成员变量的访问"></a>成员变量的访问</h3><p>在父子类的继承关系当中：</p><ul><li>如果成员变量<strong>不重名</strong>，这时的访问是没有影响的</li><li>如果成员变量<strong>重名</strong>，则创建子类对象时，访问有两种方式：<ul><li><strong>直接</strong>通过子类对象访问成员变量： <code>等号左边是谁，就优先用谁，没有则向上找。</code> </li><li><strong>间接</strong>通过成员方法访问成员变量： <code>该方法属于谁，就优先用谁，没有则向上找。</code> </li></ul></li></ul><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a><code>super</code> 关键字</h3><p>当子类和父类中出现了同名的成员变量时，如果在子类中需要访问父类中非私有成员变量，需要使用 <code>super</code> 关键字修饰父类成员变量，类似于 <code>this</code> 。</p><h3 id="访问重名的三种变量"><a href="#访问重名的三种变量" class="headerlink" title="访问重名的三种变量"></a>访问重名的三种变量</h3><p>访问重名的局部变量、本类成员变量和父类成员变量：</p><ul><li>局部变量： <code>直接写成员变量名</code> </li><li>本类的成员变量： <code>this.成员变量名</code> </li><li>父类的成员变量： <code>super.成员变量名</code> </li></ul><h2 id="继承后的成员方法"><a href="#继承后的成员方法" class="headerlink" title="继承后的成员方法"></a>继承后的成员方法</h2><h3 id="成员方法的调用"><a href="#成员方法的调用" class="headerlink" title="成员方法的调用"></a>成员方法的调用</h3><p>在父子类继承关系中：</p><ul><li>如果成员方法不重名，这时的调用是没有影响的， <code>创建的对象是谁，就优先用谁，如果没有则向上找。</code> </li><li>如果成员方法重名，这是的访问是一种特殊情况，叫做 <strong>方法重写（Override）</strong> 。</li></ul><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果。即方法的<strong>声明不变，重新实现。</strong> </p><ul><li>特点：创建的是子类对象，则优先用子类方法。</li><li>注意事项：<ol><li>必须保证父子类之间方法的名称相同，参数列表也相同； <code>@Override</code> </li><li>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围；</li><li>子类方法的权限必须<strong>大于等于</strong>父类方法的权限修饰符。 <code>public &gt; protected &gt; (default) &gt; private</code> </li></ol></li></ul><h2 id="继承后的构造方法"><a href="#继承后的构造方法" class="headerlink" title="继承后的构造方法"></a>继承后的构造方法</h2><p>构造方法的格式和作用：</p><ul><li>构造方法是与类名一致的，所以子类无法继承父类的构造方法。</li><li>构造方法是用来初始化成员变量的，所以在子类的初始化过程中，必须先执行父类的初始化动作。</li></ul><p>继承关系中，父子类构造方法的访问特点：</p><ol><li>子类构造方法当中有一个默认隐含的 <code>super()</code> 调用，所以一定是先调用的父类构造方法，后执行的子类构造方法。</li><li>子类构造方法可以通过 <code>super</code> 关键字来调用父类重载的构造方法。</li><li>super 的父类构造方法调用，必须是子类构造方法的第一个语句。</li><li>不能一个子类构造方法调用多次 super 构造方法。</li></ol><p>总结：子类构造方法必须调用父类构造方法，不写则隐含 super()；写了则调用写的指定的 super 调用。super 只能有一个，且必须是第一个。</p><h2 id="super-与-this"><a href="#super-与-this" class="headerlink" title="super 与 this"></a><code>super</code> 与 <code>this</code></h2><h3 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h3><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于<strong>子类对象中包含了其对应的父类空间</strong>，便可以包含其父类的成员，如果父类成员非 private 修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p><ul><li><code>super</code>  ：代表父类的存储空间标识。</li><li><code>this</code>  ：代表当前对象的引用。</li></ul><p>super 与 this 的内存图示如下：</p><p><img src="/2020/01/15/java-object-oriented/super与this的内存图.png" alt></p><h3 id="含义与用法总结"><a href="#含义与用法总结" class="headerlink" title="含义与用法总结"></a>含义与用法总结</h3><p> <code>super</code> 关键字用来访问父类内容，用法有三种：</p><ol><li>在子类的成员方法中，访问父类的成员变量。</li><li>在子类的成员方法中，访问父类的成员方法。</li><li>在子类的构造方法中，访问父类的构造方法。</li></ol><p> <code>this</code> 关键字用来访问本类内容，用法也有三种：</p><ol><li>在本类的成员方法中，访问本类的成员变量。</li><li>在本类的成员方法中，访问本类的另一个成员方法。</li><li>在本类的构造方法中，访问本类的另一个构造方法。</li></ol><p>注意事项： <code>this(...)</code> 和 <code>super(...)</code> 调用都必须是构造方法的第一个语句，且是唯一一个，因此 super 和 this 两种构造方法调用不能同时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super(); // 这一行不再默认添加</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">123</span>); <span class="comment">// 本类的无参构造，调用本类的有参构造</span></span><br><span class="line">        <span class="comment">// this(1, 2); // 错误写法！</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 隐含super();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 本类中的成员变量</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">// 父类中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AAA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodA();</span><br><span class="line">        System.out.println(<span class="string">"BBB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ol><li>继承主要解决的问题是<strong><code>共性抽取</code></strong>。</li><li>Java 只支持 <strong><code>单继承</code></strong> ，不支持多继承。一个类的直接父类只能有唯一一个。</li><li>Java 支持 <strong><code>多级继承</code></strong> 。所有类都默认继承 <code>java.lang.Object</code> 类。</li><li>一个类的直接父类是唯一的，但是一个父类可以拥有多个子类。</li><li>子类可以拥有父类的内容，还可以拥有自己的专属内容。</li></ol><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法体，只有声明还有意义，而方法体则没有存在的意义了。我们把<strong>没有方法体的方法称为抽象方法</strong>。Java语法规定，<strong>包含抽象方法的类就是抽象类。</strong> </p><h2 id="abstract-关键字"><a href="#abstract-关键字" class="headerlink" title="abstract 关键字"></a><code>abstract</code> 关键字</h2><p>抽象方法定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名();</span><br></pre></td></tr></table></figure><p>抽象类定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 类名 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象方法和抽象类的使用"><a href="#抽象方法和抽象类的使用" class="headerlink" title="抽象方法和抽象类的使用"></a>抽象方法和抽象类的使用</h2><p>如何使用抽象类和抽象方法：</p><ol><li>不能直接创建 new 抽象类对象。</li><li>必须用一个子类来继承抽象父类。</li><li>子类必须重写抽象父类当中所有的抽象方法。</li><li>创建子类对象进行使用。</li></ol><p>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>抽象类不能创建对象。</li><li>抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类的子类必须重写抽象父类中所有的抽象方法，否则该子类也是抽象类。</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口概述"><a href="#接口概述" class="headerlink" title="接口概述"></a>接口概述</h2><p>接口就是<strong>多个类的公共规范</strong>，是一种<strong>引用数据类型</strong>。</p><p>如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong>，包含<code>常量</code>、<code>抽象方法</code>（JDK 7 及以前）、<code>默认方法</code>、<code>静态方法</code>（JDK 8）、<code>私有方法</code> （JDK 9）。</p><h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>接口的定义方式，与类的定义方式相似，但是使用 <strong><code>interface</code> 关键字</strong>。它也会被编译成 .class 文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有抽象方法"><a href="#含有抽象方法" class="headerlink" title="含有抽象方法"></a>含有抽象方法</h3><p>在任何版本的 Java 中，接口都能定义抽象方法，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值类型 方法名称(参数列表);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>接口当中的抽象方法，修饰符必须是两个固定的关键字： <code>public abstract</code> ；</li><li>这两个关键字修饰符，可以选择性地省略；</li><li>方法的三要素（方法名、返回值、参数列表）可以随意定义。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这是一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有默认方法"><a href="#含有默认方法" class="headerlink" title="含有默认方法"></a>含有默认方法</h3><p>从 Java 8 开始，接口中允许定义<strong>默认方法</strong>，用来解决接口升级所导致的原有实现类未实现新添加抽象方法而报错的问题，为修改接口而不破坏原来的实现类的结构提供了便利。</p><p>默认方法使用 <strong><code>default</code> 关键字</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">default</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现类继承了接口的<strong>默认方法，既可以直接调用，也可以重写</strong>。</li><li><strong>一个声明在类里面的方法优先于任何默认方法</strong>，优先选取最具体的实现。</li><li>默认方法<strong>不能重写 <code>Object</code> 中的方法，但是可以重载 <code>Object</code> 中的方法</strong>。</li></ul><h3 id="含有静态方法"><a href="#含有静态方法" class="headerlink" title="含有静态方法"></a>含有静态方法</h3><p>从 Java 8 开始，接口中允许声明<strong>静态方法</strong>，并且可以实现，用 <strong><code>static</code> 关键字</strong>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">static</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不能通过接口实现类的对象来调用接口中的静态方法。</li><li>通过接口名称直接调用其中的静态方法，格式：<code>接口名称.静态方法名(参数);</code> </li></ul><h3 id="含有私有方法"><a href="#含有私有方法" class="headerlink" title="含有私有方法"></a>含有私有方法</h3><p>当需要抽取一个共有方法用来解决多个默认方法或静态方法之间的重复代码问题时，这个共有方法不应该让实现类使用，应该是私有化的。</p><p>从 Java 9 开始，接口当中允许定义<strong>私有方法</strong>，使用 <strong><code>private</code> 关键字</strong>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> [<span class="keyword">static</span>] 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通私有方法：解决多个默认方法之间重复代码问题，只有默认方法可以调用</li><li>静态私有方法：解决多个静态方法之间重复代码问题，只有静态方法可以调用</li></ul><h3 id="含有常量"><a href="#含有常量" class="headerlink" title="含有常量"></a>含有常量</h3><p>接口当中也可以定义“成员变量”，但是<strong>默认使用 <code>public static final</code> 三个关键字进行修饰</strong>。从效果上看，这其实就是接口的 <strong><code>常量</code></strong>，不可改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 数据类型 常量名称 = 数据值;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>接口当中的常量可以省略 public static final。</li><li>接口当中的常量<strong>必须赋值</strong>。</li><li>接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）</li></ol><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><h3 id="基本的实现"><a href="#基本的实现" class="headerlink" title="基本的实现"></a>基本的实现</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <strong><code>implements</code> 关键字</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 重写接口中的抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中的默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的使用步骤：</p><ol><li>接口不能直接使用，需要有一个 <code>实现类</code> 来 <code>实现</code> 该接口；</li><li>接口的实现类必须重写（实现）接口中所有的抽象方法；</li><li>创建实现类的对象，进行使用。</li></ol><p>注意事项：</p><ul><li>如果实现类并没有重写接口中所有的抽象方法，那么这个类就必须是<strong>抽象类</strong>。</li><li>接口是<strong>没有静态代码块和构造方法</strong>的。</li></ul><h3 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h3><p>在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<strong>多实现</strong>。</p><p>实现格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class 类名 [extends 父类名] implements 接口名1, 接口名2, ... &#123;</span><br><span class="line">    <span class="comment">// 重写接口中的抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中的默认方法【不重名时可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一个类能<strong>继承一个直接父类，同时实现多个接口。</strong> </li><li>如果实现类所实现的多个接口中存在重复的抽象方法，那么实现类<strong>只需要重写一次重复的抽象方法。</strong> </li><li>如果实现类没有重写多有接口中的所有抽象方法，那么实现类必须是一个抽象类。</li><li>如果实现类所实现的多个接口中存在重复的默认方法，那么实现类<strong>必须对重复的默认方法进行重写。</strong> </li><li>如果<strong>直接父类中的方法和接口中的默认方法发生冲突，优先使用父类中的方法。</strong> </li></ul><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。</p><p>接口的继承使用 <code>extends</code> 关键字，子接口继承父接口的方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父接口A</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父接口A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父接口A</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父接口B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子接口C</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子接口C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>多个父接口中的抽象方法重复，没有影响；</li><li>多个父接口中的默认方法重复，那么子接口必须进行默认方法的重写，而且不能省略 <code>default</code> 关键字。（注意：实现类重写多个接口的重复默认方法时必须去掉 <code>default</code> 关键字！）</li></ol><h2 id="类和接口相关的几种关系"><a href="#类和接口相关的几种关系" class="headerlink" title="类和接口相关的几种关系"></a>类和接口相关的几种关系</h2><ol><li>类与类之间是单继承的。</li><li>类与接口之间是多实现的。</li><li>接口与接口之间是多继承的。</li></ol><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a>多态概述</h2><p><code>多态</code> 是继封装、继承之后，面向对象的第三大特性，是指同一行为具有多种不同的表现形式。</p><p><strong>继承（extends）或实现（implements）是多态性的前提。</strong>一个对象拥有多种形态，这就是对象的多态性。</p><h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><p>多态性的格式体现就是<strong>父类引用指向子类对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名 = <span class="keyword">new</span> 子类类型();</span><br></pre></td></tr></table></figure><ul><li>父类类型，指子类对象继承的父类类型，或者实现的父接口类型。</li><li>当使用多态方式调用方法时，首先检查父类中是否具有该方法，如果没有，则编译报错；如果有，则<strong>执行子类重写后的方法</strong>。</li></ul><h2 id="多态中的成员变量与成员方法"><a href="#多态中的成员变量与成员方法" class="headerlink" title="多态中的成员变量与成员方法"></a>多态中的成员变量与成员方法</h2><p>访问成员变量的两种方式：</p><ol><li>直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。</li><li>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiField</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态的写法，父类引用指向子类对象</span></span><br><span class="line">        Fu obj = <span class="keyword">new</span> Zi();</span><br><span class="line">        </span><br><span class="line">        System.out.println(obj.num); <span class="comment">// 父：10</span></span><br><span class="line">        <span class="comment">// System.out.println(obj.age); // 错误写法！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类没有重写，就是父：10</span></span><br><span class="line">        <span class="comment">// 子类如果重写，就是子：20</span></span><br><span class="line">        obj.showNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用成员方法的规则是：看 new 的是谁，就优先用谁，没有则向上找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类特有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodZi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类特有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu obj = <span class="keyword">new</span> Zi(); <span class="comment">// 多态</span></span><br><span class="line"></span><br><span class="line">        obj.method(); <span class="comment">// 父子都有，优先用子</span></span><br><span class="line">        obj.methodFu(); <span class="comment">// 子类没有，父类有，向上找到父类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。</span></span><br><span class="line">        <span class="comment">// obj.methodZi(); // 错误写法！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问成员变量与调用成员方法的对比：</p><ul><li>成员变量：编译看左边，运行还看左边。</li><li>成员方法：编译看左边，运行看右边。</li></ul><h2 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h2><h3 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h3><p><strong>向上转型</strong>：多态本身就是子类类型向父类类型转换的过程，这个过程是默认的。 </p><ul><li>格式： <code>父类名称 对象名 = new 子类名称();</code> </li><li>含义：创建一个子类对象，把它当做父类来看待使用。</li><li>注意：向上转型一定是安全的，类似于基本数据类型中的自动类型转换。</li></ul><h3 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h3><p>对象一旦向上转型为父类类型，就无法调用子类原本特有的内容，所以需要将对象还原为子类类型。</p><p><strong>向下转型</strong>：父类类型向子类类型转换的过程，这个过程是强制的。 </p><ul><li>格式： <code>子类名称 对象名 = (子类名称)父类对象</code> </li><li>含义：将父类对象<strong>还原</strong>为本来的子类对象。</li><li>注意：如果对象不属于要还原的类型，运行时就会抛出 <code>ClassCastException</code> 异常。类似于基本数据类型中的强制类型转换。</li></ul><h2 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a><code>instanceof</code> 关键字</h2><p>为了避免 <code>ClassCastException</code> 的发生，Java 提供了 <code>instanceof</code> 关键字，给引用变量做类型校验，用来判断父类对象是否是某个引用类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名 <span class="keyword">instanceof</span> 引用数据类型</span><br></pre></td></tr></table></figure><p>这将得到一个 boolean 值结果。</p><h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a><code>final</code> 关键字</h1><h2 id="final-概述"><a href="#final-概述" class="headerlink" title="final 概述"></a><code>final</code> 概述</h2><p>子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承 API 中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写继承的 API 中提供的类的内容的情况，Java 提供了 <strong><code>final</code> 关键字</strong>，用于修饰<strong>不可改变</strong>内容。 </p><ul><li><code>final</code> ：代表最终，不可改变，可用于修饰 <code>类</code> 、<code>方法</code> 和 <code>变量</code>。<ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，不能被重新赋值。</li></ul></li></ul><h2 id="final-的使用方式"><a href="#final-的使用方式" class="headerlink" title="final 的使用方式"></a><code>final</code> 的使用方式</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>含义：当前这个类不能有任何的子类。</li><li>注意：一个类如果是 final 的，那么其中所有的成员方法都无法进行重写（因为没有子类）。</li></ul><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>含义：当前这个方法是最终方法，不能被重写。</li><li>注意：对类、方法来说，<code>abstract</code> 关键字和 <code>final</code> 关键字不能同时使用，因为二者的含义矛盾。</li></ul><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><h4 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h4><p>基本类型的局部变量，被 final 修饰后，<strong>只能赋值一次</strong>，不能再更改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalFieldDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明变量，使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="comment">// 第一次赋值</span></span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 第二次赋值</span></span><br><span class="line">        <span class="comment">// a = 20; // 报错,不可重新赋值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明变量，直接赋值，使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 第二次赋值</span></span><br><span class="line">        <span class="comment">// b = 20; // 报错,不可重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用类型的局部变量，被 final 修饰后，只能指向一个对象，<strong>地址不能再更改，但是不影响对象内部的成员变量值的修改</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalFieldDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 User 对象</span></span><br><span class="line">        <span class="keyword">final</span> User u = <span class="keyword">new</span> User();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 另一个 User对象</span></span><br><span class="line">        <span class="comment">// u = new User(); // 报错，指向了新的对象，地址值改变。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用setName方法</span></span><br><span class="line">        u.setName(<span class="string">"张三"</span>); <span class="comment">// 可以修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h4><p>对于成员变量来说，如果使用 final 关键字修饰，那么这个变量也照样是不可变。</p><ol><li>由于成员变量具有默认值，所以用了 final 之后必须手动赋值，不会再给默认值了。</li><li>对于 final 的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。</li><li>必须保证类当中所有重载的构造方法，都最终会对 final 的成员变量进行赋值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name<span class="comment">/* = "鹿晗"*/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">"关晓彤"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void setName(String name) &#123;</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h1><h2 id="访问修饰符概述"><a href="#访问修饰符概述" class="headerlink" title="访问修饰符概述"></a>访问修饰符概述</h2><p>在 Java 中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。 </p><ul><li><code>public</code>：公有的</li><li><code>protected</code>：受保护的</li><li><code>(default)</code>：默认的</li><li><code>private</code>：私有的</li></ul><h2 id="不同权限的访问能力"><a href="#不同权限的访问能力" class="headerlink" title="不同权限的访问能力"></a>不同权限的访问能力</h2><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:center"><code>public</code></th><th style="text-align:center"><code>protected</code></th><th style="text-align:center"><code>(default)</code></th><th style="text-align:center"><code>private</code></th></tr></thead><tbody><tr><td style="text-align:left">同一类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:left">同一包</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">不同包子类</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">不同包无关类</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><p>编写代码时，如果没有特殊的考虑，建议这样使用权限： </p><ul><li>成员变量使用 <code>private</code>，隐藏细节。 </li><li>构造方法使用 <code>public</code>，方便创建对象。 </li><li>成员方法使用 <code>public</code>，方便调用方法。 </li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="内部类概述"><a href="#内部类概述" class="headerlink" title="内部类概述"></a>内部类概述</h2><p>如果一个事物包含另一个事物，就对应着一个类包含另一个类。例如：身体和心脏的关系，汽车和发动机的关系。</p><p>将一个类 A 定义在另一个类 B 里面，类 A 就称为 <strong><code>内部类</code></strong>，B 则称为 <strong><code>外部类</code></strong>。 </p><p>内部类的分类：</p><ul><li>成员内部类</li><li>局部内部类（包含匿名内部类）</li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p><code>成员内部类</code> ：定义在<strong>类中方法外</strong>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123;</span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 内部类名称 </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h3><ul><li>内部类可以<strong>直接访问外部类的成员</strong>，包括私有成员。</li><li>外部类要访问内部类的成员，必须要<strong>创建内部类对象</strong>。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li>间接方式：在外部类方法中创建内部类对象，在 main 方法中调用外部类方法。</li><li>直接方式：在 main 方法中直接创建内部类对象。</li></ol><p>创建内部类对象的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名称.内部类名称 对象名 = <span class="keyword">new</span> 外部类名称().new 内部类名称();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123; <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="comment">// 内部类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"心脏跳动：蹦蹦蹦！"</span>);</span><br><span class="line">            System.out.println(<span class="string">"我叫："</span> + name); <span class="comment">// 正确写法！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的方法"</span>);</span><br><span class="line">        <span class="keyword">new</span> Heart().beat();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Body body = <span class="keyword">new</span> Body(); <span class="comment">// 外部类的对象</span></span><br><span class="line">        <span class="comment">// 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart</span></span><br><span class="line">        body.methodBody();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接按照格式创建内部类对象</span></span><br><span class="line">        Body.Heart heart = <span class="keyword">new</span> Body().new Heart();</span><br><span class="line">        heart.beat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同名变量访问"><a href="#同名变量访问" class="headerlink" title="同名变量访问"></a>同名变量访问</h3><p>如果外部类成员变量、内部类成员变量和局部变量同名：</p><ul><li>通过 <code>变量名</code> 访问局部变量</li><li>通过 <code>this.变量名</code> 访问内部类成员变量</li><li>通过 <code>外部类名称.this.变量名</code> 访问外部类成员变量（注意：没有继承关系，不能用 super）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 外部类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">// 内部类的成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>; <span class="comment">// 内部类方法的局部变量</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 局部变量，就近原则</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 内部类的成员变量</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num); <span class="comment">// 外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p><code>局部内部类</code> ：定义在方法内部的类。</p><p>“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123;</span><br><span class="line">    修饰符 返回值类型 外部类方法名称(参数列表) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 局部内部类名称 </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>在外部类方法中创建局部内部类对象来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(num); <span class="comment">// 10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建局部内部类对象</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问-final-局部变量"><a href="#访问-final-局部变量" class="headerlink" title="访问 final 局部变量"></a>访问 <code>final</code> 局部变量</h3><p>局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是 <code>有效final</code> 的。</p><ul><li>直接声明为 <code>final</code> </li><li>实际只赋值一次（注意：从 Java 8 开始，只要局部变量事实不变，那么 <code>final</code> 关键字可以省略。）</li></ul><p>原因：</p><ol><li>new 出来的对象在堆内存当中。</li><li>局部变量是跟着方法走的，在栈内存当中。</li><li>方法运行结束之后，立刻出栈，局部变量就会立刻消失。</li><li>但是 new 出来的对象会在堆当中持续存在，直到垃圾回收消失。</li></ol><h1 id="类的权限修饰符小结"><a href="#类的权限修饰符小结" class="headerlink" title="类的权限修饰符小结"></a>类的权限修饰符小结</h1><p>定义一个类的时候，权限修饰符规则如下：</p><ol><li>外部类：<code>public</code> / <code>(default)</code> </li><li>成员内部类：<code>public</code> / <code>protected</code> / <code>(default)</code> / <code>private</code> </li><li>局部内部类：什么权限修饰符都不能写（注意：不是 default）</li></ol><h1 id="匿名的使用"><a href="#匿名的使用" class="headerlink" title="匿名的使用"></a>匿名的使用</h1><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用 <code>匿名内部类</code>。</p><p><strong>匿名内部类</strong> ：是内部类的简化写法。它的本质是一个 <code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的</code> <strong>子类对象</strong>。 </p><p>匿名内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称() &#123;</span><br><span class="line">    <span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">抽象类名称 对象名 = <span class="keyword">new</span> 抽象类名称() &#123;</span><br><span class="line">    <span class="comment">// 覆盖重写所有抽象方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对格式 <code>new 父类名称() {...}</code> 进行解析：</p><ul><li><code>new</code> 代表创建对象的动作</li><li><code>父类名称</code> 就是匿名内部类需要实现的父类类型</li><li><code>{...}</code> 才是匿名内部类的内容</li></ul><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>创建对象的标准格式：<code>类名称 对象名 = new 类名称();</code> </p><p>匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><p>使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。</p><p>使用场景：</p><ol><li>创建匿名对象直接调用方法，没有变量名。</li><li>匿名对象可以作为方法的参数和返回值。</li></ol><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>匿名内部类，在<strong>创建对象</strong>的时候，只能使用唯一一次。<br> 如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。</li><li>匿名对象，在<strong>调用方法</strong>的时候，只能调用唯一一次。<br> 如果希望同一个对象，调用多次方法，那么必须给对象起个名字。</li><li>匿名内部类是<strong>省略了实现类/子类名称</strong>，但是匿名对象是<strong>省略了对象名称</strong>。<br> 强调：匿名内部类和匿名对象不是一回事！！！</li></ol><h1 id="引用类型用法总结"><a href="#引用类型用法总结" class="headerlink" title="引用类型用法总结"></a>引用类型用法总结</h1><p>基本类型可以作为成员变量、方法的参数以及方法的返回值，引用类型也可以。</p><p><code>String</code> 类型本身就是引用类型，因为它的使用方式类似常量，所以往往忽略了它是引用类型的存在。</p><h2 id="class-作为成员变量"><a href="#class-作为成员变量" class="headerlink" title="class 作为成员变量"></a>class 作为成员变量</h2><p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String code; <span class="comment">// 武器的代号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Weapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Weapon</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 英雄的名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 英雄的年龄</span></span><br><span class="line">    <span class="keyword">private</span> Weapon weapon; <span class="comment">// 英雄的武器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name, <span class="keyword">int</span> age, Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"年龄为"</span> + age + <span class="string">"的"</span> + name + <span class="string">"用"</span> </span><br><span class="line">                           + weapon.getCode() + <span class="string">"攻击敌方。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weapon <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeapon</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个英雄角色</span></span><br><span class="line">        Hero hero = <span class="keyword">new</span> Hero();</span><br><span class="line">        <span class="comment">// 为英雄起一个名字，并且设置年龄</span></span><br><span class="line">        hero.setName(<span class="string">"盖伦"</span>);</span><br><span class="line">        hero.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个武器对象</span></span><br><span class="line">        Weapon weapon = <span class="keyword">new</span> Weapon(<span class="string">"AK-47"</span>);</span><br><span class="line">        <span class="comment">// 为英雄配备武器</span></span><br><span class="line">        hero.setWeapon(weapon);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 年龄为20的盖伦用AK-47攻击敌方。</span></span><br><span class="line">        hero.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="interface-作为成员变量"><a href="#interface-作为成员变量" class="headerlink" title="interface 作为成员变量"></a>interface 作为成员变量</h2><p>接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Skill</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>; <span class="comment">// 释放技能的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 英雄的名称</span></span><br><span class="line">    <span class="keyword">private</span> Skill skill; <span class="comment">// 英雄的技能</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name, Skill skill)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.skill = skill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我叫"</span> + name + <span class="string">"，开始释放技能："</span>);</span><br><span class="line">        skill.use(); <span class="comment">// 调用接口中的抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">"释放技能完成。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Skill <span class="title">getSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> skill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSkill</span><span class="params">(Skill skill)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skill = skill;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero hero = <span class="keyword">new</span> Hero();</span><br><span class="line">        hero.setName(<span class="string">"艾希"</span>); <span class="comment">// 设置英雄的名称</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置英雄技能</span></span><br><span class="line">        <span class="comment">// 同时使用匿名内部类和匿名对象</span></span><br><span class="line">        hero.setSkill(<span class="keyword">new</span> Skill() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Biu~Pia~Biu~Pia~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        我叫艾希，开始释放技能：</span></span><br><span class="line"><span class="comment">        Biu~Pia~Biu~Pia~</span></span><br><span class="line"><span class="comment">        释放技能完成。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        hero.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="interface-作为方法参数和返回值类型"><a href="#interface-作为方法参数和返回值类型" class="headerlink" title="interface 作为方法参数和返回值类型"></a>interface 作为方法参数和返回值类型</h2><ul><li>接口作为参数时，传递它的子类对象。</li><li>接口作为返回值类型时，返回它的子类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.List正是ArrayList所实现的接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左边是接口名称，右边是实现类名称，这就是多态写法</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = addNames(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">            System.out.println(result.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">addNames</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        list.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        list.add(<span class="string">"玛尔扎哈"</span>);</span><br><span class="line">        list.add(<span class="string">"沙扬娜拉"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><h2 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h2><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法，<strong>强调做什么，而不是以什么形式做</strong>。</p><ul><li>面向对象的思想：做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。</li><li>函数式编程思想：只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。</li></ul><h2 id="冗余的传统代码"><a href="#冗余的传统代码" class="headerlink" title="冗余的传统代码"></a>冗余的传统代码</h2><p>给定一个计算器 <code>Calculator</code> 接口，内含抽象方法 <code>calc</code> 可以将两个 <code>int</code> 数字相加得到和值。在测试类中定义一个 <code>invokeCalc</code> 方法，完成加法计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用invokeCalc方法,方法的参数是一个接口,可以使用匿名内部类</span></span><br><span class="line">        invokeCalc(<span class="number">10</span>, <span class="number">20</span>, <span class="keyword">new</span> Calculator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = c.calc(a, b);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个 <code>Calculator</code> 接口的匿名内部类对象来明确加法计算内容，再将其传递给 <code>invokeCalc</code> 方法使用。</p><p>对于 <code>Calculator</code> 的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>invokeCalc</code> 方法需要 <code>Calculator</code> 接口作为参数，其中的抽象 <code>calc</code> 方法明确了两个数的运算方式；</li><li>为了指定 <code>calc</code> 的方法体，<strong>不得不</strong>需要 <code>Calculator</code> 接口的实现类；</li><li>为了省去定义一个 <code>PlusCalculator</code> 实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象 <code>calc</code> 方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h2 id="体验-Lambda-的更优写法"><a href="#体验-Lambda-的更优写法" class="headerlink" title="体验 Lambda 的更优写法"></a>体验 Lambda 的更优写法</h2><p>2014 年 3 月 Oracle 所发布的 Java 8（JDK 1.8）中，加入了 <strong>Lambda 表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><p>借助 Java 8 的全新语法，上述 <code>Calculator</code> 接口的匿名内部类写法可以通过更简单的 Lambda 表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Lambda表达式简化匿名内部类的书写</span></span><br><span class="line">        invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="keyword">int</span> a,<span class="keyword">int</span> b) -&gt; &#123;<span class="keyword">return</span> a + b;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda-标准格式"><a href="#Lambda-标准格式" class="headerlink" title="Lambda 标准格式"></a>Lambda 标准格式</h2><p>Lambda 省去面向对象的条条框框，格式由 <strong>3 个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123; 重写方法的代码 &#125;</span><br></pre></td></tr></table></figure><p>格式说明：</p><ul><li><code>()</code> ：与接口中抽象方法的参数列表一致，没有参数则留空；有参数就写出参数，多个参数使用逗号分隔。</li><li><code>-&gt;</code> ：是新引入的语法格式，代表指向动作，是传递的意思，把参数传递给方法体 <code>{}</code>。</li><li><code>{}</code>：重写接口的抽象方法的方法体。</li></ul><h2 id="Lambda-省略格式"><a href="#Lambda-省略格式" class="headerlink" title="Lambda 省略格式"></a>Lambda 省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda 强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用 Lambda 的省略写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在 Lambda 标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参数</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、<code>return</code> 关键字及语句分号。<br> 注意：要省略 <code>{}</code>，<code>return</code>，<code>;</code> 必须一起省略。</li></ol><h2 id="Lambda-的使用前提"><a href="#Lambda-的使用前提" class="headerlink" title="Lambda 的使用前提"></a>Lambda 的使用前提</h2><p>Lambda 的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用 Lambda 必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<ul><li>无论是 JDK 内置的 <code>Runnable</code>、<code>Comparator</code> 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用 Lambda。</li></ul></li><li>使用 Lambda 必须具有<strong>上下文推断</strong>。<ul><li>也就是方法的参数或局部变量类型必须为 Lambda 对应的接口类型，才能使用 Lambda 作为该接口的实例。</li></ul></li></ol><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/01/10/java-fundamentals.html"/>
      <url>/2020/01/10/java-fundamentals.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="Java-语言"><a href="#Java-语言" class="headerlink" title="Java 语言"></a>Java 语言</h2><p>Java 语言是美国 Sun 公司（Stanford University Network），在 1995 年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><h2 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h2><p><strong>JVM（Java Virtual Machine）</strong>：Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 代码，都运行在 JVM 之上。</p><p><strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用 Java 编写的软件可以运行在任何的操作系统上，这个特性称为 Java 语言的跨平台特性。该特性是由 JVM 实现的，我们编写的<strong>程序运行在 JVM 上，而  JVM 运行在操作系统上</strong>。</p><h2 id="JRE-和-JDK"><a href="#JRE-和-JDK" class="headerlink" title="JRE 和 JDK"></a>JRE 和 JDK</h2><p><strong>JRE (Java Runtime Environment)</strong>：是 Java 程序的运行时环境，包含 JVM 和运行时所需要的核心类库。</p><p><strong>JDK (Java Development Kit)</strong>：是 Java 程序开发工具包，包含 JRE 和开发人员使用的工具。</p><h1 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h1><h2 id="Java-程序开发"><a href="#Java-程序开发" class="headerlink" title="Java 程序开发"></a>Java 程序开发</h2><p>Java程序开发三步骤：<strong>编写、编译、运行</strong></p><ol><li>编写 Java 源程序（后缀名 <code>.java</code>）</li><li>编译 Java 源文件（使用 <code>javac</code> 命令编译源程序为<strong>字节码文件</strong>，文件后缀 <code>.class</code>）</li><li>运行（使用 <code>java</code> 命令在 JVM 上运行字节码文件）</li></ol><p>编译和运行的区别</p><ul><li><strong>编译</strong>：是指将我们编写的 Java 源文件翻译成 JVM 认识的 class 文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。</li><li><strong>运行</strong>：是指将 class 文件交给 JVM 去运行，此时 JVM 就会去执行我们编写的程序了。</li></ul><p>关于 <strong><code>main</code> 方法</strong></p><ul><li>main 方法，也称为主方法，是程序的入口或起点。</li><li>JVM 在运行的时候，都会从 main 方法开始执行。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>注释</strong>：就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须要的，它不影响程序的编译和运行。</p><ul><li>单行注释：<code>//开头，换行结束</code> </li><li>多行注释：<code>/*开头，*/结束</code> </li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>关键字</strong>：是指在 Java 程序中事先定义好的单词，具有特殊意义。</p><ul><li>完全小写的字母</li><li>在增强版的记事本中（如 notepad++）具有特殊颜色</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><strong>标识符</strong>：是指在程序中，我们自己定义的内容，比如类的名字、方法的名字和变量的名字等等。</p><p><strong>命名规则：<code>硬性要求</code></strong> </p><ul><li>标识符可以包含 <code>英文字母26个（区分大小写）</code> 、 <code>0-9数字</code> 、 <code>$（美元符号）</code> 和 <code>_（下划线）</code> </li><li>标识符不能以数字开头</li><li>标识符不能是关键字</li></ul><p><strong>命名规范：<code>软性建议</code></strong> </p><ul><li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</li><li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</li><li>变量名规范：同方法名。</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>常量</strong>：Java 程序中固定不变的量</p><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th><th>数据举例</th></tr></thead><tbody><tr><td>整型常量</td><td>所有的整数</td><td>0，1，100，-250</td></tr><tr><td>小数常量</td><td>所有的小数</td><td>0.0，2.5，-3.14</td></tr><tr><td>字符常量</td><td>单引号引起来，只能写一个字符，必须有内容</td><td>‘A’，’b’，’9’，’好’，’ ‘</td></tr><tr><td>字符串常量</td><td>双引号引起来，可以写多个字符，也可以不写</td><td>“A”， “Hello”，”123”，””</td></tr><tr><td>布尔常量</td><td>只有两个值</td><td>true，false</td></tr><tr><td>空常量</td><td>只有一个值</td><td>null</td></tr></tbody></table></div><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java 的数据类型分为两大类：</p><ul><li><strong>基本数据类型</strong>：包括 <code>整数</code> 、 <code>浮点数</code> 、 <code>字符</code> 、 <code>布尔</code>  </li><li><strong>引用数据类型</strong>：包括 <code>字符串</code> 、 <code>数组</code> 、 <code>类</code> 、 <code>接口</code> 、 <code>Lambda</code> </li></ul><p>基本数据类型（4 类 8 种）</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1 个字节</td><td>-128 ~ 127</td></tr><tr><td>短整型</td><td>short</td><td>2 个字节</td><td>-32768 ~ 32767</td></tr><tr><td>整型</td><td>int（默认）</td><td>4 个字节</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>长整型</td><td>long</td><td>8 个字节</td><td>-2^63 ~ 2^63-1</td></tr><tr><td>单精度浮点型</td><td>float</td><td>4 个字节</td><td>1.4013E-45 ~ 3.4028E+38</td></tr><tr><td>双精度浮点型</td><td>double（默认）</td><td>8 个字节</td><td>4.9E-324 ~ 1.7977E+308</td></tr><tr><td>字符型</td><td>char</td><td>2 个字节</td><td>0 ~ 65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>-</td><td>true，false</td></tr></tbody></table></div><p>注意事项：</p><ol><li>字符串不是基本类型，而是引用类型。</li><li>浮点型可能只是一个近似值，并非精确的值。</li><li><strong>数据范围与字节数不一定相关</strong>，例如 float 数据范围比 long 更加广泛，但是 float 是4字节，long 是 8 字节。</li><li>浮点数当中默认类型是 double。如果一定要使用 float 类型，需要加上一个<strong>后缀 F</strong>。如果是整数，默认为 int 类型，如果一定要使用 long 类型，需要加上一个<strong>后缀 L</strong>。推荐使用大写字母后缀。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量</strong>：程序运行期间，内容可以发生改变产生的量。</p><p>Java 中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。</p><p>创建和使用变量的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 数据类型 变量名称; <span class="comment">// 创建了一个变量</span></span><br><span class="line">   变量名称 = 数据值; <span class="comment">// 赋值，将右边的数据值赋值给左边的变量</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 数据类型 变量名称 = 数据值; <span class="comment">// 在创建变量的同时，立刻放入指定的数据值</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 变量<span class="number">1</span> = 变量<span class="number">2</span>; <span class="comment">// 将一个变量2的数据内容，赋值交给变量1</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>如果创建多个变量，那么变量之间的名称不可以重复。</li><li>对于 float 和 long 类型来说，字母后缀 F 和 L 不要丢掉。</li><li>如果使用 byte 或者 short 类型的变量，那么右侧的数据值不能超过左侧类型的范围。</li><li><strong>没有进行赋值的变量，不能直接使用</strong>；一定要赋值之后，才能使用。</li><li>变量使用不能超过作用域的范围。<br><strong>作用域</strong>：从定义变量的一行开始，一直到直接所属的大括号结束为止。</li><li>可以通过一个语句来创建多个变量，但是一般情况不推荐这么写。</li></ol><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>Java 程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果<strong>数据类型不一致将发生类型转换</strong>。</p><h2 id="自动类型转换（隐式）"><a href="#自动类型转换（隐式）" class="headerlink" title="自动类型转换（隐式）"></a>自动类型转换（隐式）</h2><ul><li>特点：代码不需要进行特殊处理，自动完成。</li><li>规则： <code>数据范围小的类型</code> 向 <code>数据范围大的类型</code> 提升。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>/<span class="keyword">short</span>/<span class="keyword">char</span> --&gt; <span class="keyword">int</span> --&gt; <span class="keyword">long</span> --&gt; <span class="keyword">float</span> --&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><h2 id="强制类型转换（显式）"><a href="#强制类型转换（显式）" class="headerlink" title="强制类型转换（显式）"></a>强制类型转换（显式）</h2><ul><li>特点：代码需要进行特殊的格式处理，不能自动完成。</li><li>规则：将 <code>数据范围大的类型</code> 强制转换成 <code>数据范围小的类型</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范围小的类型 范围小的变量名 = (范围小的类型) 原本的范围大的数据值</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>强制类型转换一般不推荐使用，因为有可能发生<strong>精度损失、数据溢出</strong>。</li><li>byte / short / char 这三种类型都可以发生数学运算，例如加法 “+”。在运算的时候，都会被<strong>首先提升成为 int 类型</strong>，然后再计算。</li><li>boolean 类型不能发生数据类型转换。</li></ol><h2 id="ASCII-amp-Unicode-编码表"><a href="#ASCII-amp-Unicode-编码表" class="headerlink" title="ASCII &amp; Unicode 编码表"></a>ASCII &amp; Unicode 编码表</h2><p><strong>编码表</strong> ：数字和字符的对照关系表，就是将人类的文字和一个十进制数进行对应起来组成的一张表格。</p><ul><li>ASCII 码表：American Standard Code for Information Interchange，美国信息交换标准代码。</li><li>Unicode 码表：万国码，开头 0-127 部分和 ASCII 完全一样，但是从 128 开始包含有更多字符。</li></ul><h1 id="运算符-amp-表达式"><a href="#运算符-amp-表达式" class="headerlink" title="运算符 &amp; 表达式"></a>运算符 &amp; 表达式</h1><p>运算符：进行特定操作的符号。</p><p>表达式：用运算符连起来的式子。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><div class="table-container"><table><thead><tr><th>算术运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法运算，字符串连接运算</td></tr><tr><td><code>-</code></td><td>减法运算</td></tr><tr><td><code>*</code></td><td>乘法运算</td></tr><tr><td><code>/</code></td><td>除法运算（整数相除只看商）</td></tr><tr><td><code>%</code></td><td>取模运算（整数相除取余数）</td></tr><tr><td><code>++</code> <code>--</code></td><td>自增和自减运算</td></tr></tbody></table></div><p>注意事项：</p><ol><li>整数使用上述运算符的结果只会是整数。</li><li>一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。</li></ol><p>运算符 <code>+</code> 的用法：</p><ul><li>对数值来说，就是加法；</li><li>对字符 <code>char</code> 类型来说，计算之前先被提升为 <code>int</code> ；</li><li>对字符串 <code>String</code> 来说，加号代表<strong>字符串连接</strong>操作，任何数据类型与字符串进行连接的结果都是字符串。</li></ul><p>运算符 <code>++</code> 的用法：</p><ul><li>基本含义：变量自己增长 1 </li><li>使用格式：写在变量名称之前，或写在变量名称之后</li><li>使用方式：<ol><li>单独使用：不和其他任何操作混合，自己独立成为一个步骤。此时 <code>前++</code> 和 <code>后++</code> 没有区别。</li><li>混合使用：与其他操作混合。如果是前++，那么变量马上加 1，然后拿着结果进行使用；如果是后++，那么首先使用变量本来的值，然后再加 1。</li></ol></li><li>注意：只有变量才能使用自增和自减运算，常量不可发生改变。</li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><div class="table-container"><table><thead><tr><th>赋值运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>=</code></td><td>基本赋值运算</td></tr><tr><td><code>+=</code></td><td>加等于</td></tr><tr><td><code>-=</code></td><td>减等于</td></tr><tr><td><code>*=</code></td><td>乘等于</td></tr><tr><td><code>/=</code></td><td>除等于</td></tr><tr><td><code>%=</code></td><td>取模等</td></tr></tbody></table></div><p>基本赋值运算：是将等号右边的值，赋值给等号左边的变量</p><p>复合赋值运算：将等号右边的值进行复合操作后，赋值给等号左边的变量</p><p>注意事项：</p><ol><li>只有变量才能使用赋值运算符，常量不能进行赋值。</li><li><strong>复合赋值运算符其中隐含了一个强制类型转换。</strong></li></ol><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><div class="table-container"><table><thead><tr><th>比较运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>!=</code></td><td>不等于</td></tr></tbody></table></div><p>比较运算：是两个数据之间进行比较的运算，运算结果都是布尔值 <code>true</code> 和 <code>false</code> 。</p><p>注意事项：如果进行多次判断，不能像数学中一样连着写。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><div class="table-container"><table><thead><tr><th>逻辑运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code> （与）</td><td>全都是 true 才是 true，否则就是 false</td></tr><tr><td>&#124; &#124; （或）</td><td>至少一个是 true 就是 true，全都是 false 才是 false</td></tr><tr><td><code>!</code> （非）</td><td>本来是 true 变成 false，本来是 false 变成 true</td></tr></tbody></table></div><p>注意事项：</p><ol><li>逻辑运算符只能用于 boolean 值。</li><li>与、或需要左右各自有一个 boolean 值，但是取反只要有唯一的一个 boolean 值即可。</li><li>与、或两种运算符，如果有多个条件，可以连续写 <code>条件A &amp;&amp; 条件B &amp;&amp; 条件C</code> 。</li><li>与“&amp;&amp;”，或“||”，具有<strong>短路</strong>效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。</li></ol><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名称 = 布尔类型表达式 ? 表达式A : 表达式B</span><br></pre></td></tr></table></figure><p>流程：</p><ul><li>如果布尔表达式成立（为 true），那么将表达式 A 的值赋值给左侧的变量；</li><li>如果布尔表达式不成立（为 false），那么将表达式 B 的值赋值给左侧的变量。</li></ul><p>注意事项：</p><ol><li>必须同时保证表达式 A 和表达式 B 都符合左侧数据类型的要求。</li><li><strong>三元运算符的结果必须被使用</strong>。</li></ol><h1 id="方法入门"><a href="#方法入门" class="headerlink" title="方法入门"></a>方法入门</h1><h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p><strong>方法</strong>：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了<strong>代码的复用性</strong>，也<strong>解决了代码冗余的现象</strong>。</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>方法定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法名：方法名称的命名规则和变量一样，使用小驼峰。</li><li>方法体：也就是大括号当中可以包含任意条语句。</li></ul><p>注意事项：</p><ul><li>方法定义的先后顺序无所谓</li><li>方法的定义不能产生嵌套关系</li></ul><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法 main 中来调用我们自己定义好的方法。</p><p>在主方法中，直接写要调用的方法名字就可以调用了，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名(实参);</span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。</p><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>顺序结构：按照编写的顺序，依次运行。</p><div id="flowchart-0" class="flow-chart"></div><h2 id="分支（选择）结构"><a href="#分支（选择）结构" class="headerlink" title="分支（选择）结构"></a>分支（选择）结构</h2><h3 id="判断语句（if）"><a href="#判断语句（if）" class="headerlink" title="判断语句（if）"></a>判断语句（<code>if</code>）</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-1" class="flow-chart"></div><h4 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a><code>if-else</code> 语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-2" class="flow-chart"></div><h4 id="if-else-if-else-语句"><a href="#if-else-if-else-语句" class="headerlink" title="if-else if-else 语句"></a><code>if-else if-else</code> 语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">    语句体n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-3" class="flow-chart"></div><h3 id="选择语句（switch）"><a href="#选择语句（switch）" class="headerlink" title="选择语句（switch）"></a>选择语句（<code>switch</code>）</h3><p> <code>switch</code> 语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-4" class="flow-chart"></div><p>注意事项：</p><ol><li>多个 case 后面的数值不可以重复。</li><li>switch 后面小括号当中只能是下列数据类型：<ul><li>基本数据类型：<code>byte</code> 、 <code>short</code> 、 <code>char</code> 、 <code>int</code></li><li>引用数据类型：<code>String</code> 、 <code>enum</code> </li></ul></li><li>switch 语句格式可以很灵活：前后顺序可以颠倒，而且 break 语句还可以省略。<strong>匹配哪一个 case 就从哪一个位置向下执行，直到遇到了 break 或者整体结束为止。</strong></li></ol><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为 false，从而结束循环，否则循环将一直执行下去，形成死循环。</p><p>循环结构的基本组成部分，一般可以分成四部分：</p><ol><li><strong>初始化语句</strong>：在循环开始最初执行，而且只做唯一一次。</li><li><strong>条件判断</strong>：如果成立，则循环继续；如果不成立，则循环退出。</li><li><strong>循环体</strong>：重复要做的事情内容，若干行语句。</li><li><strong>步进语句</strong>：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次。</li></ol><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h3><p> <code>for</code> 循环语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式; 布尔表达式; 步进表达式) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-5" class="flow-chart"></div><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h3><p> <code>while</code> 循环语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(布尔表达式) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-6" class="flow-chart"></div><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a><code>do-while</code> 循环</h3><p> <code>do while</code> 循环语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><div id="flowchart-7" class="flow-chart"></div><p> <code>do-while</code> 循环的特点：<strong>无条件执行一次循环体</strong>，即使我们将循环条件直接写成 false，也依然会循环一次。这样的循环具有一定的风险性。</p><h3 id="三种循环的区别"><a href="#三种循环的区别" class="headerlink" title="三种循环的区别"></a>三种循环的区别</h3><ol><li>如果条件判断从来没有满足过，那么 for 循环和 while 循环将会执行 0 次，但是 do-while 循环会执行至少一次。</li><li>for 循环的变量在小括号当中定义，只有循环内部才可以使用。while 循环和 do-while 循环初始化语句本来就在循环外定义变量，所以出来循环结束后还可以继续使用。</li></ol><h3 id="跳出语句"><a href="#跳出语句" class="headerlink" title="跳出语句"></a>跳出语句</h3><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a><code>break</code> 语句</h3><p>使用场景：终止 <code>switch</code> 或循环</p><ol><li>可以用在 switch 语句当中，一旦执行，整个 switch 语句立刻结束。</li><li>还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。</li></ol><h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a><code>continue</code> 语句</h3><p>使用场景：结束本次循环，继续下一次循环</p><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>永远停不下来的循环，叫做死循环。</p><p>死循环的标准格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>所谓嵌套循环，是指一个循环的循环体内包含另一个循环。比如 for 循环里面还有一个 for 循环，就是嵌套循环。</p><p> <code>总共的循环次数 = 外循环次数 * 内循环次数</code> 。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法（Method）就是若干语句的功能集合。</p><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><p>定义方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名, ...) &#123;</span><br><span class="line">    方法体;</span><br><span class="line">    [<span class="keyword">return</span> 返回值;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当一个方法需要一些数据条件，才能完成任务的时候，就有参数。</li><li>一个方法不需要任何数据条件，自己就能独立完成任务，就无参数。</li><li>返回值类型：必须要和 return 语句返回值的类型相同，否则编译失败 。</li><li>不能在 return 后面写代码，return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。</li></ul><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>方法的三种调用格式：</p><ol><li>单独调用： <code>方法名(参数);</code> </li><li>打印调用： <code>System.out.println(方法名(参数));</code></li><li>赋值调用： <code>数据类型 变量名 = 方法名(参数);</code> </li></ol><p>注意：返回值类型为 void 的方法只能单独调用，不能进行打印调用和赋值调用</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>方法应该定义在类当中，但是不能在方法当中再定义方法。</li><li>方法定义的前后顺序无所谓。</li><li>方法定义之后不会执行，如果希望执行，一定要调用。</li><li>如果方法有返回值，那么必须写上 <code>return 返回值;</code> ，不能没有。</li><li>return 后面的返回值数据，必须和方法的返回值类型，对应起来。</li><li>对于一个 void 方法，不能写 return 后面的返回值，只能写 <code>return;</code> 。</li><li>对于 void 方法当中最后一行的 return 可以省略不写。</li><li>一个方法当中可以有多个 return 语句，但是必须保证同时只有一个会被执行到，两个 return 不能连写。</li></ol><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p><strong>方法重载（Overload）</strong>：指在同一个类中，允许存在一个以上的<strong>同名方法</strong>，只要它们的<strong>参数列表不同</strong>即可，<strong>与参数名称、修饰符和返回值类型无关</strong>。</p><ul><li>好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。</li><li>参数列表：<strong>个数</strong>不同，<strong>数据类型</strong>不同，<strong>多类型顺序</strong>不同。</li><li>重载方法调用：JVM 通过方法的参数列表，调用不同的方法。</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组的概念：是一种容器，可以同时存放多个数据值。</p><p>数组的特点：</p><ol><li>数组是一种引用数据类型</li><li>数组当中的多个数据，类型必须统一</li><li><strong>定长</strong>特性：数组的长度在程序运行期间不可改变</li></ol><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。</p><p>两种常见的初始化方式：</p><ol><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ol><h3 id="动态初始化数组"><a href="#动态初始化数组" class="headerlink" title="动态初始化数组"></a>动态初始化数组</h3><p>动态初始化数组的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><p>使用动态初始化数组时，其中的元素将在自动拥有一个默认值。规则如下：</p><ul><li>如果是整数类型，默认值为 <code>0</code> </li><li>如果是浮点数类型，默认值为 <code>0.0</code> </li><li>如果是字符类型，默认值为 <code>\u0000</code> （不可见字符）</li><li>如果是布尔类型，默认值为 <code>false</code> </li><li>如果是引用类型，默认值为 <code>null</code> </li></ul><h3 id="静态初始化数组"><a href="#静态初始化数组" class="headerlink" title="静态初始化数组"></a>静态初始化数组</h3><p>静态初始化数组的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[] &#123;元素<span class="number">1</span>,元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;;<span class="comment">// 标准格式</span></span><br><span class="line"></span><br><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;;<span class="comment">// 省略格式</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>静态初始化没有直接指定长度，但是仍然会自动推算得到长度。</li><li>动态初始化和静态初始化标准格式可以拆分成为 <code>声明数组</code> 和 <code>创建数组</code> 两个步骤。</li><li>静态初始化一旦使用省略格式，就不能拆分成为两个步骤来写了，但依然隐含了 new 操作。</li></ol><h2 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h2><p><strong>数组索引</strong>： 每一个存储到数组的元素，都会自动的拥有一个编号， <code>从 0 开始，一直到数组长度减 1 为止</code> ，这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素。</p><p>访问数组元素的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure><p>索引访问数组中的元素：</p><ul><li><code>数组名[索引] = 数据值</code> ，为数组中的元素赋值</li><li><code>变量名 = 数组名[索引]</code> ，获取出数组中的元素</li></ul><h2 id="数组的内存原理"><a href="#数组的内存原理" class="headerlink" title="数组的内存原理"></a>数组的内存原理</h2><p>内存是用于程序运行的临时存储区域，程序运行完毕后会清空内存。</p><p>Java 虚拟机为了提高运算效率，对内存空间进行了不同区域的划分：</p><div class="table-container"><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器（PC Register）</td><td>与 CPU 相关</td></tr><tr><td>本地方法栈（Native Method Stack）</td><td>JVM 在使用操作系统功能的时候使用</td></tr><tr><td>方法区（Method Area）</td><td>存储 .class 文件，包含方法的信息</td></tr><tr><td>堆（Heap）</td><td>存储对象或数组，凡是 new 创建的都存储在堆中</td></tr><tr><td>栈（Stack）</td><td>存储方法中的局部变量，方法一定在栈中运行</td></tr></tbody></table></div><p>数组名称：存储数组<strong>内存地址哈希值</strong>。</p><p> <code>数组A = 数组B</code> 将数组 A 的引用赋值给数组 B，结果数组 A 和 B 将会指向同一片内存空间。</p><p>有两个独立数组的内存图如下：</p><p><img src="/2020/01/10/java-fundamentals/有两个独立数组的内存图.png" alt></p><h2 id="数组操作的常见异常"><a href="#数组操作的常见异常" class="headerlink" title="数组操作的常见异常"></a>数组操作的常见异常</h2><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><p>如果访问数组元素的时候，索引编号并不存在，程序运行后，将会抛出 <code>ArrayIndexOutOfBoundsException</code> 数组越界异常。</p><h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><p>所有的引用类型变量，都可以赋值为一个 null 值，但是代表其中什么都没有。</p><p>数组必须进行 new 初始化才能使用其中的元素。如果只是赋值了一个 null，没有进行 new 创建，那么将会发生 <code>NullPointerException</code> 空指针异常。</p><h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>每个数组都具有长度，而且是固定的。</p><p>Java 中赋予了数组的一个属性，可以获取到数组的长度，语句为： <code>数组名.length</code> ，属性 length 的执行结果是数组的长度，int 类型结果。</p><p>数组一旦创建，程序运行期间，长度不可改变。</p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>数组遍历： 将数组中的每个元素分别获取出来，就是遍历。</p><p>遍历也是数组操作中的基石。</p><p>数组的索引是 <code>0</code> 到 <code>lenght-1</code> ，可以作为循环的条件出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.println(array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组作为方法参数和返回值"><a href="#数组作为方法参数和返回值" class="headerlink" title="数组作为方法参数和返回值"></a>数组作为方法参数和返回值</h2><p>一个方法<strong>可以有0、1 或多个参数</strong>；但是只能有0或者1个返回值，<strong>不能有多个返回值</strong>。</p><p>任何数据类型都能作为方法的参数类型或返回值类型。</p><ul><li>数组作为方法参数传递，传递的参数是数组内存的地址。</li><li>数组作为方法的返回值，返回的其实也是数组的地址值。</li></ul><h2 id="方法的参数类型区别"><a href="#方法的参数类型区别" class="headerlink" title="方法的参数类型区别"></a>方法的参数类型区别</h2><ul><li><strong>方法的参数为基本类型时，传递的是数据值。</strong> </li><li><strong>方法的参数为引用类型时，传递的是地址值。</strong> <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始e=>end: 结束op1=>operation: 步骤1op2=>operation: 步骤2opdots=>operation: ...opn=>operation: 步骤nst->op1->op2->opdots->opn->e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>operation: 其他语句cond=>condition: 关系表达式op2=>operation: 语句体op3=>operation: 其他语句op1->condcond(yes)->op2->op3cond(no)->op3</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: 其他语句op2=>operation: 其他语句cond=>condition: 关系表达式op3=>operation: 语句体1op4=>operation: 语句体2op1->condcond(yes)->op3->op2cond(no)->op4->op2</textarea><textarea id="flowchart-2-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句cond1=>condition: 判断条件1cond2=>condition: 判断条件2conddots=>condition: ……condn=>condition: 判断条件nop1=>operation: 语句体1op2=>operation: 语句体2opdots=>operation: ……opn=>operation: 语句体nopn+1=>operation: 语句体n+1st->cond1cond1(yes)->op1->econd1(no)->cond2cond2(yes)->op2->econd2(no)->conddotsconddots(yes)->opdots->econddots(no)->condncondn(yes)->opn->econdn(no)->opn+1->e</textarea><textarea id="flowchart-3-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句cond1=>condition: 表达式=常量值1cond2=>condition: 表达式=常量值2conddots=>condition: ......op1=>operation: 语句体1op2=>operation: 语句体2opdots=>operation: ......opn+1=>operation: 语句体n+1st->cond1cond1(yes)->op1->econd1(no)->cond2cond2(yes)->op2->econd2(no)->conddotsconddots(yes)->opdots->econddots(no)->opn+1->e</textarea><textarea id="flowchart-4-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script><textarea id="flowchart-5-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句op1=>operation: 初始化语句cond=>condition: 条件判断语句op2=>operation: 循环体语句op3=>operation: 步进语句st->op1->condcond(yes)->op2->op3(left)->condcond(no)->e</textarea><textarea id="flowchart-5-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-5-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-5-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-5", options);</script><textarea id="flowchart-6-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句op1=>operation: 初始化语句cond=>condition: 条件判断语句op2=>operation: 循环体语句op3=>operation: 步进语句st->op1->condcond(yes)->op2->op3(left)->condcond(no)->e</textarea><textarea id="flowchart-6-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-6-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-6-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-6", options);</script><textarea id="flowchart-7-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句op1=>operation: 初始化语句cond=>condition: 条件判断语句op2=>operation: 循环体语句op3=>operation: 步进语句st->op1->op2->op3->condcond(yes)->op2cond(no)->e</textarea><textarea id="flowchart-7-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-7-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-7-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-7", options);</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代计算机网络考试复习整理</title>
      <link href="/2020/01/08/computer-networks-systems-approach.html"/>
      <url>/2020/01/08/computer-networks-systems-approach.html</url>
      
        <content type="html"><![CDATA[<h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><h2 id="Ch1-网络体系结构"><a href="#Ch1-网络体系结构" class="headerlink" title="Ch1 网络体系结构"></a>Ch1 网络体系结构</h2><h3 id="什么是网络"><a href="#什么是网络" class="headerlink" title="什么是网络"></a>什么是网络</h3><h4 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h4><p>计算机网络最大的特点是<strong>通用性</strong>，传输的是通用数据，连接的通用的计算机。</p><p>计算机网络是<strong>互联的通用计算机的集合</strong>。</p><ul><li>互联：经传输媒质交换数据</li><li>自治：面向用户自管理</li><li>作为一个通用的网络，需要满足不同的网络需求</li></ul><h4 id="计算机网络的需求与约束"><a href="#计算机网络的需求与约束" class="headerlink" title="计算机网络的需求与约束"></a>计算机网络的需求与约束</h4><p>需求总结起来最重要的是三个点：</p><ol><li>互联（Connectivity）</li><li>为用户提供高效的资源共享（Cost Effective Resource Sharing）</li><li>为开发者支持常用服务（Support for Common Services）</li></ol><h4 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h4><h4 id="网络性能测量与评价"><a href="#网络性能测量与评价" class="headerlink" title="网络性能测量与评价"></a>网络性能测量与评价</h4><ul><li><strong>带宽</strong>（Bandwidth）<ul><li>习惯把带宽作为数字信道的数据率或比特率</li><li><strong>比特率</strong>：某时段内网络上可能传输的比特数，或传输每比特数据所需的时间</li><li><strong>吞吐率</strong>（Throughput）：链路上实际每秒传输的比特数</li></ul></li><li><strong>延迟</strong>（delay）<ul><li>delay：把一个报文从网络一端传输到另一端所需的时间</li><li>Round Trip Time（<strong>RTT</strong>）：发收来回时间（2 次时延）</li><li>定义：<strong>延迟 = 处理＋排队 + 传输 + 传播</strong>， 主要考虑后两个<ul><li>处理时延：检查包首部、决定导向何处；比特差错检测，高速Router一般在微秒或更低数量级，接收完整的一个分组的时间＝包容量/链路速率</li><li>排队时延：等待输出链路空闲，与当时流量和排队规则有关</li><li>传输时延：数据量/带宽，微秒到毫秒级</li><li>传播时延：距离/光速（光缆中1000km传播延迟约5ms)），广域网在毫秒级</li><li><strong>传输时延和传播时延的比较</strong>：<ul><li>传输时延是路由器把分组发送出去所需时间，由<strong>数据量和链路实际带宽决定</strong>，与两个路由器间距离无关</li><li>传播时延是一个比特从发送路由器到接收路由器传播所需的时间，是<strong>距离的函数</strong>，ms级</li></ul></li></ul></li></ul></li><li><strong>延迟带宽积</strong><ul><li>一对进程通道间的延迟（总体延迟）带宽积：信道管道的体积 = 链路上所容纳的比特数</li></ul></li></ul><h4 id="互联网的管理"><a href="#互联网的管理" class="headerlink" title="互联网的管理"></a>互联网的管理</h4><h3 id="Direct-Link-Networks-的基本理论与技术"><a href="#Direct-Link-Networks-的基本理论与技术" class="headerlink" title="Direct Link Networks 的基本理论与技术"></a>Direct Link Networks 的基本理论与技术</h3><h4 id="Hardware-Building-Blocks"><a href="#Hardware-Building-Blocks" class="headerlink" title="Hardware Building Blocks"></a>Hardware Building Blocks</h4><p>结点（Node）&amp; 链路（Links）</p><p><strong>香农定理</strong>决定了一个链路传输能力上限</p><ul><li>这个传输能力 C 用 bps 为单位，跟链路上信号的信噪比相关（S/N，decibels or dB）</li><li>$C=B\cdot\log_2(1+S/N)$</li></ul><h4 id="编码技术"><a href="#编码技术" class="headerlink" title="编码技术"></a>编码技术</h4><p>信号：表示信息的物理量</p><ul><li><p>模拟信号：一组特别的数据点之间及所有可能点之间都是连续的信号</p></li><li><p>数字信号：离散点构成的信号</p></li></ul><p><strong>信号调制</strong>：修改信号的幅度、频率和相位及其组合形式来标示和携带数据信息的过程</p><p>调制的一个原因：我们知道链路上信噪比的重要性，影响信号的噪声在不同频率上的强度并非完全一样。如果能把原始信号移动到噪声频率谱上噪声强度最低的频率上去，就可以避开本底噪声很高的区域，和其他没有被彻底屏蔽掉的干扰信号。信号调制时，需要选择一个「载波」——这个载波就可以选择系统噪声强度最低区域的频率。</p><p><strong>信号的物理层处理</strong></p><ul><li>模拟 → 模拟（调制）</li><li>模拟 → 数字（编码）</li><li>数字 → 数字（编码）</li><li>数字 → 模拟（调制）<ul><li>比特率（Bit Rate）：bps = bit/s，每秒内传输的比特数</li><li><strong>波特率</strong>（Baud Rate）：每秒内为表示某些比特而需要的信号单元数（或码元数）</li><li>当仅当一个信号单元表示一比特时，比特率才等于波特率</li><li>$Bit Rate = log_2Bit Unit× Baud Rate$</li></ul></li></ul><p><strong>信号的逻辑层编码</strong></p><ul><li><strong>NRZ 编码</strong><ul><li>这是一种不归零（Non-Return Zero）的编码方案，<strong>将数值 1 映射为高电平，数值 0 映射为低电平</strong>。</li><li>连续的 1 或 0 易导致<strong>基线漂移</strong>，即接收方保持它所接收的信号平均值用来区分高低电平受到干扰。</li><li>编解码需要双方的<strong>时钟同步</strong>，这依赖于信号内有许多跳变，只有信号跳变才能进行时钟同步。</li></ul></li><li><strong>NRZI 编码</strong><ul><li>不归零反转（Non-Return Zero Inverted），<strong>1 表示信号跳变，0 表示信号保持</strong></li><li><strong>解决了连续 1 的问题</strong></li></ul></li><li><strong>曼彻斯特编码</strong><ul><li>把本地时钟看作一个从低到高变化的内部信号，一对低/高变化的电平看作一个时钟周期</li><li><strong>0 表示从低到高的跳变，1 表示从高到低的跳变</strong></li><li>使链路上的信号跳变速率加倍，比特率是波特率的一半</li><li><strong>差分曼彻斯特编码</strong>：信号前一半与前一比特信号后一半相等则编码为 1，相反则编码为 0</li></ul></li><li><strong>4B/5B 编码</strong><ul><li>用 5 个比特编码 4 个比特的数据</li><li>在比特流中插入额外的比特以打破一连串的 0 或 1</li><li>5 比特代码的选择方式为：<strong>每个代码最多有 1 个前导 0，并且末端最多有 2 个 0</strong></li><li>因此当连续传送时，任何一个 5 比特代码连续 0 的个数最多为 3，<strong>解决了连续 0 的问题</strong></li><li><strong>将得到的 5 比特代码使用 NRZI 编码传输</strong></li></ul></li></ul><h4 id="成帧技术"><a href="#成帧技术" class="headerlink" title="成帧技术"></a>成帧技术</h4><p>Frame 是一个在具体网络（与类型和厂家有关）第二层上实现的、与硬件有关的特殊分组。是网上传输的最小数据单元。</p><p>Frame＝数据部分＋发送和接收站点的物理地址＋处理控制部分。</p><p><strong>面向字节的协议</strong></p><ul><li><strong>BISYN</strong><ul><li>用起止标记法组帧</li><li>帧的开始由发送一个特定的 <strong><code>SYN</code></strong> 字符表示</li><li>帧的数据部分包含在两个起止字符 <strong><code>STX</code></strong>（正文开始符）和 <strong><code>ETX</code></strong>（正文结束符）之间</li><li><code>ETX</code> 有可能出现在帧的数据部分，通过对 <code>ETX</code> 字符转义来解决这个问题，在其前加上 <strong><code>DLE</code></strong>（数据链路转义字符）（字符填充法）</li></ul></li><li>DDCMP</li><li>PPP / SLIP</li></ul><p><strong>面向比特的协议</strong></p><ul><li>不关心字符的边界，把帧看作比特的集合</li><li>SDLC（Synchronous Data Link Control Protocol）</li><li><strong>HDLC</strong>（High-level Data Link Control Protocol）<ul><li>用特定的比特序列 <strong><code>01111110</code></strong> 表示帧的开始和结束</li><li>使用类似 <code>DLE</code> 字符的方法，称为比特填充法</li><li>发送方任意时刻在消息体中发出连续的 5 个 1 后（试图发送特定序列 <code>01111110</code> 除外），在发送下一比特前插入一个 0</li><li>接收方接收连续的 5 个 1 后，如果下一比特是 0，则一定是填充的，丢掉它；如果下一比特是 1，再查看下一比特，如果为 0，则是帧结束消息，如果为 1，则是出错了，丢弃整个帧</li></ul></li></ul><p><strong>基于时钟的组帧</strong></p><ul><li><strong>SONET</strong>（Synchronous Optical Network）<ul><li>使用字节交叉的多路复用</li><li>基本 SONET 帧（STS-1 帧）每 125 us 产生 810 字节，有无数据都同步发送，故每秒 8000 帧</li><li>9 x 90 = 810 Bytes/s x 8000＝51.84 Mbps，构成基本 SONET 信道</li><li>一帧包含 9 行，每行 90 Bytes，每行的前 3 bit 留作系统管理信息</li><li>STS-N 帧可认为是由 N 个 STS-1 帧构成（多路复用），这些帧中的字节是交叉的</li></ul></li></ul><h4 id="信道共享技术"><a href="#信道共享技术" class="headerlink" title="信道共享技术"></a>信道共享技术</h4><p>信道（Channel）是通信中传递信息的通道，它由发送与接收信息的设备及传输介质组成。</p><p>信道有独占或共享两种使用方式。</p><p>复用：把共享信道划分成多个子信道，每个子信道传输一路数据。</p><ul><li>时分复用TDM（Time Division Multiplexing），统计时分复用STDM。按时间划分不同的信道，目前应用最广泛</li><li>频分复用FDM（Frequency Division Multiplexing）按频率划分不同的信道，如CATV系统</li><li>波分复用WDM（Wave Division Multiplexing：DWDM/CWDM）按波长划分不同的信道，用于光纤传输</li><li>码分复用CDM（Code Division Multiplexing）按地址码划分不同的信道，如手机</li></ul><h4 id="差错控制技术"><a href="#差错控制技术" class="headerlink" title="差错控制技术"></a>差错控制技术</h4><p>什么是差错控制？<br>在通信过程中，发现、检测差错并进行纠正</p><p>为何要进行差错控制？<br>不存在理想的信道 → 传输总会出错 与语音、图像传输不同，计算机通信要求极低的差错率。</p><p>基本思想：发方编码、收方检错，能纠则纠，不能则重传</p><p>基本方法：收方进行差错检测，并向发送方应答，告知是否正确接收。</p><p>差错控制技术：<strong>自动请求重传 ARQ</strong>（Automatic Repeat Request）</p><ul><li>停等 ARQ<ul><li>每发送一帧就需要一个应答帧</li><li>只重传刚才出错的帧</li></ul></li><li>Go-back-N ARQ<ul><li>每发送N帧需要一个应答帧</li><li>需重传前面（N-i+1）帧（0≤i≤N）</li></ul></li><li>选择重传 ARQ<ul><li>每发送N帧需要一个应答帧</li><li>只重传出错的帧</li></ul></li></ul><p>任何检验纠错技术的基本思想</p><ul><li>加入冗余信息到帧中去（极端：两份拷贝）</li><li>一般为 n 位信息加入 k&lt;&lt;n 比特冗余，例如 12000bits (1500bytes) 的报文仅需要 32 比特 CRC 码</li></ul><p>纠错码主要的编码方法：</p><ul><li>奇偶校验（Parity Checking）</li><li>循环冗余校验（CRC, Cyclic Redundancy Check）</li><li>校验和：Check sum</li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>直连网络存在两个问题：</p><ol><li>由于共享链路，所以仅仅允许少量的节点连接到网络，例如早期的以太网最多不超过 1024 个节点</li><li>仅仅能分布在很小的范围，早期以太网距离不超过 2500m</li></ol><p>所以出现 Packet Switch 这样的设备，将多个直连网络连接起来，组建更大范围的网络。</p><h4 id="以太网及其发展"><a href="#以太网及其发展" class="headerlink" title="以太网及其发展"></a>以太网及其发展</h4><p>以太网优势</p><ul><li>可扩展（10M-10G），灵活（多种媒介、全/半双工、共享/交换），便宜、易于安装使用、稳健性好</li></ul><p>网卡功能</p><ul><li>数据的封装与解封</li><li>链路管理：<strong>CSMA/CD</strong>（带冲突检测的载波侦听多路访问）</li><li>bit 的编码与解码</li></ul><p>MAC地址</p><ul><li>Unicast：单播帧地址,仅对某个网卡</li><li>Broadcast：广播帧地址,仅对某个子网</li><li>Multicast：多播帧地址,组地址</li><li>杂收模式（Promiscuous mode）：接收总线上所有的可能接收的帧</li></ul><h4 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h4><p>以太网</p><ul><li>可以是一组直连的主机</li><li>也可以通过连接设备进行扩展<ul><li>集线器（HUB）：物理层互联设备</li><li>交换机（Switch）：链路层互联设备</li></ul></li></ul><p>广播域和冲突域</p><ul><li><strong>广播域</strong>：广播报文可以达到的范围</li><li><strong>冲突域</strong>：可以发生报文冲突的范围</li></ul><ol><li>HUB 的所有端口都在一个冲突域和一个广播域</li><li>Switch 的所有端口都在一个广播域，每个端口是一个冲突域，只有在划分 VLAN 之后才能分割广播域</li><li>Router 的每个端口是一个冲突域，也是一个广播域</li></ol><p><strong>虚拟局域网（VLAN）</strong></p><ul><li>虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网</li><li>不依赖三层交换，通过虚拟局域网 VLAN，可以将同一交换机或者多个交换机的广播域划分多个广播域（每个虚拟局域网一个广播域）</li></ul><p>交换机的自学习功能</p><ul><li>转发表可由交换机学习自动得到</li></ul><h4 id="交换机生成树协议-STP-Spanning-Tree-Protocol"><a href="#交换机生成树协议-STP-Spanning-Tree-Protocol" class="headerlink" title="交换机生成树协议 STP (Spanning Tree Protocol )"></a>交换机生成树协议 STP (Spanning Tree Protocol )</h4><p>交换机的自学习机制可以工作良好，但是一旦交换机连接存在环路，会造成严重后果。</p><p>当交换机之间存在多条活动链路时，容易形成环路，导致转发表的不正确与不稳定，并且还会导致重复的数据包在网络中传递，引起广播风暴，使网络不稳定。</p><p>为了防止交换机之间由于多条活动链路而导致的网络故障，必须将多余的链路置于非活动状态，即不转发用户数据包，而只留下单条链路作为网络通信。</p><p><strong>生成树协议</strong>（Spanning Tree Protocol）</p><ul><li>STP 将交换网络中任何两个点之间的多余链路置于 Blocking（关闭）状态，而只留一条活动链路，当使用中的活动链路失效时，立即启用被Block的链路，以此来提供网络的冗余效果。</li><li>需要所有交换机支持。</li><li>每个交换机实际上需要 disable 掉自己的某些端口，不转发 frame。极端情况下，可能一个交换机完全不参与任何 frame 的转发。</li></ul><p>去掉环路的方法： <strong>所有交换机按照树的方式进行连通</strong></p><ul><li>STP 的核心思想是网络中<strong>选出一台交换机做为核心交换机</strong>， STP 称其为 Root，也就是根，功能相当于 hub spoke 网络中的 Hub。</li><li>其它不是 Root 的交换机则需要留出一条活动链路去往根交换机，因为只要普通交换机到根是通的，到其它交换机也就是通的。</li><li>一个广播域内独立选举 STP<ul><li>交换机之间选举根交换机（Root）<ul><li>一 个广播域 内只能 选举一台根交换机。 Bridge ID 中优先级最高（即数字最小）的为根交换机，优先级范围为 0 65535 ，如果优先级相同，则 MAC 地址小的为根交换机。</li></ul></li><li>交换机端口之间选举根端口（Root Port）<ul><li>所有非根交换机都要选举根端口，选举规则为到根交换机的 Path Cost 值最小的链路。</li></ul></li><li>非根交换机选择指定端口（Designated Port）<ul><li>简单地理解为每条连接交换机的 link 有两个端口（属于不同交换机）中，有一个要被选举为指定端口。</li><li>选举规则和选举根端口一样，即：到根交换机的 Path Cost 值最小的端口，如果多条链路到达根交换机的 Path Cost 值相同，则选举上一跳交换机 Bridge ID 最小的链路。</li></ul></li><li>剩余端口状态为 Blocking<ul><li>在 STP 选出根交换机，根端口以及指定端口后，其它所有端口全部为 Blocking 状态，为了防止环路，所有 Blocking 端口只有在根端口或指定端口失效、拓扑改变的时候才会被启用 。</li><li>一个端口，在 STP 中只能处于一种角色，不可能是两种角色</li></ul></li></ul></li></ul><p><strong>选举</strong></p><ul><li><p>使用 BPDU（Bridge Protocol Data Unit）</p><ol><li>当交换机打开的时候，所有的端口都处于 Listening 状态，每个交换机都会认为自己是根交换机（Root ID 为自己），然后都每隔两秒就向外发送一次自己的 BPDU。</li><li>如果收到的 BPDU 的 Bridge ID 比自己的小，则停止转发自己的 BPDU，开始转发更优的 BPDU，如果比自己的 Bridge ID 大或者和自己的 Bridge ID 相等，则丢弃该 BPDU。</li><li>持续 15s（转发延迟）等到 BPDU 扩散完毕之后，开始各种端口的选举，这时候每个 BID 最小的交换机成了根交换机，各个交换机通过收到的 BPDU 来确定根端口和指定端口。剩下的成为非指定端口，转到 blocking 状态。然后进入 learning 状态</li><li>进入 Learning 状态之后，填写 MAC 地址表，经过 15s（转发延迟）之后进入 Forwarding 状态。</li><li>进入 Forwarding 状态之后，开始转发数据，并且同时接受转发来自于根的 BPDU（Root ID为根交换机），维护拓扑。这时只有根交换机发 BPDU，其他交换机都只是转发 BPDU。</li><li>当一个新的交换机加入的时候，端口状态是 Learning，新的交换机认为自己是根交换机开始发送 BPDU，也接收对端的 BPDU，然后进行进一步的竞选。</li><li>若竞选成功，则网络拓扑就重新变化了，若竞选失败则计算根端口指定端口和非指定端口。（30s 可以完成）</li></ol></li><li><p>第二种类型的 BPDU 包：TCN（Topology Change Notification）BPDU</p><ol><li>当一台交换机检测到拓扑变化后,它就可以发送 TCN 给 root 交换机，注意 TCN 是通过 root port 向 root  交换机方向发出的.</li><li>当交换机从它的 designate port 接收到 TCN 类 BPDU 时,它必须为其做转发，从它自已的 root port 上发送出去 TCN 类型的 BPDU 包，这样一级一级地传到 root bridge 后，TCN 的任务才算完成.</li><li>在以上的过程中,无论是哪台交换机从它的designate port上收到了TCN类型的BPDU包，它都必须给一个回复，必须从 designate port 上发出 TCA 位被置 1 的 normal configuration BPDU 包</li><li>那么当 TCN 传遍全网,直至到达 ROOT BRIDGE 后，root bridge 也要做出一种回应,它会发出一个正常的 configuration BPDU 包,当然会有一些不同,就是包内的 TC 字段会被置 1，TC 即 topology change，表示发现拓扑变化。</li><li>这个包会被所有交换机转发,同样的 TC 位会置 1，直至传遍全网，所有交换机都得知拓扑变化为止，原来转发表作废，重新开始选举。</li></ol></li></ul><h3 id="TCP-IP-技术"><a href="#TCP-IP-技术" class="headerlink" title="TCP/IP 技术"></a>TCP/IP 技术</h3><p>报文交换网络无法组成一个大范围网络</p><ol><li>报文交换网络默认在一个广播域（VLAN 是手工分割广播域）</li><li>Forwarding table 无法扩展</li><li>以太网地址是厂商生产序号，无法更改，也无法聚合</li></ol><p>需要更好的方案组成大范围的网络</p><h4 id="命名与定位-Naming-amp-Locating"><a href="#命名与定位-Naming-amp-Locating" class="headerlink" title="命名与定位 (Naming &amp; Locating)"></a>命名与定位 (Naming &amp; Locating)</h4><p>因特网的三地址</p><ul><li>用户识别地址：公司/机关/团体/个人注册的因特网可访问的 ID：<strong>域名</strong></li><li>网络地址：同一体系结构中的可访问的计算机ID：<strong>IP 地址</strong></li><li>物理地址：物理媒体可访问的计算机某端口的唯一 ID：<strong>MAC 地址</strong></li></ul><h4 id="IP-互连与分组交换"><a href="#IP-互连与分组交换" class="headerlink" title="IP 互连与分组交换"></a>IP 互连与分组交换</h4><p><strong>ICMP</strong>（Internet Control Message Protocol）</p><h4 id="路由与寻址-Routing-amp-Addressing"><a href="#路由与寻址-Routing-amp-Addressing" class="headerlink" title="路由与寻址 (Routing &amp; Addressing)"></a>路由与寻址 (Routing &amp; Addressing)</h4><p><strong>距离向量算法（RIP）</strong></p><p><strong>链路状态算法（OSPF）</strong></p><ul><li>OSPF 一个 Domain 中的路由器会交换链路状态，LSP（Link-State Packet）采用洪泛的方法传给所有 Domain 中的路由器</li></ul><h4 id="传输层技术"><a href="#传输层技术" class="headerlink" title="传输层技术"></a>传输层技术</h4><h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>IP 组播是介于单播和广播之间的一种分组传送形式 ，它既不指定明确的接收者，也不是将数据分发给网络上的所有主机。</p><p>发送者不关心接收者所处 的位置 ，只要将数据发送到约定的目的地址，剩下的工作就交给网络去完成 。</p><p>这样做的好处在于， 发送者只产生一份数据，而不用为每个接收者分别复制一份，而且发送者不必维护接收者的信息 。</p><p>网络中的路由器 设备必须收集接收者的信息，并按照正确的路径实现组播报文的转发和复制。</p><h4 id="IGMP-协议"><a href="#IGMP-协议" class="headerlink" title="IGMP 协议"></a>IGMP 协议</h4><p>组成员机制</p><ul><li>查询 ，就是一台路由器向网络中发出查询消息，查询是否要主机要加入组如果有主机应答，那么路由器就可以请求上游路由器把组播流量前转到这个子网中，如果没有主机应答，则请求上游路由器停止向其前转组播流量。</li><li>报告 ，主机也可以不必等待路由器的查询，可以主动向路由器请求加入某个组，退出时也要向路由器发送退出消息，让路由器停止向 其转发组播流量。</li><li>IGMP 实现的功能是双向的：一方面，主机通过 IGMP 协议通知本地路由器希望加入并接收某个特定组播组的信息；另一方面，路由器通过 IGMP 协议周期性地查询局域网内某个已知组的成员是否处于活动状态（即该网段是否仍有属于某个组播组的成员），实现对所连网络组成员关系的收集与维护。</li><li>至于数据报文在路由器之间如何转发 则由组播路由协议决定， IGMP 协议并不负责 。</li></ul><h4 id="组播路由协议"><a href="#组播路由协议" class="headerlink" title="组播路由协议"></a>组播路由协议</h4><p>PIM 协议（Protocol Independent Multicast）</p><ul><li>可以让组播源和目的之间的路由表生成单播表一样地生成组播表，最后路由器根据这张组播路由表来完成组播的转发 。</li><li>组播发送者到接收者之间的转发线路，被称为<strong>组播转发树</strong> 。</li><li>防止组播反向路径转发（RPF）<ul><li>组播路由器上朝发送者方向的接口被称为 RPF 接口， 只有从 RPF 接口发来的数据才能被转发，从其它接口过来的数据被认为是无效的。</li></ul></li></ul><p>PIM-DM</p><ul><li>组播源会向所有 PIM邻居发出查询，查询数据包中包含组的地址，下一跳 PIM 邻居路由器还会继续向它的邻居发出查询数据包，这些查询数据包会在所有 PIM 邻居之间传递。</li><li>如果查询数据包到一个连接了组成员的网络，这时路由器收到组成员的报告之后，就会向自己上一跳邻居（ RPF 接口方向的邻居）发送加入组的消息，以宣布自己要接收组播，从而将组播转发到组成员。</li><li>组播路由记录 (S,G)，G)，其中 S 就是组播源地址， G 就是组地址，而出口则会被标为 forwarding 。</li><li>对于不需要接收组播的 PIM 接口， PIM-DM 模式照样会将其记录在路由表中，但被标为 pruning 。</li><li>（S,G）记录的组播树被称为最短路径树 Shortest Path Tree ( SPT)</li></ul><p>PIM-SM</p><ul><li>在建立组播树时， PIM-SM 并不会让路由器发送查询数据包去查询组成员，而组成员的发现是靠组成员自己主动向路由器发送报告。</li><li>当一台路由器从接口上收到组成员的报告之后，就会向自己的上一跳邻居发送加入消息，以通告自己需要接收组播，如果上一跳邻居还不是组播发送者，那么上一跳邻居会继续再向上一跳邻居发送加入消息，直到组播源收到加入消息为止。</li><li>(<em>，G) ，其中 </em> 就是组播源地址， G 就是组地址。</li><li>PIM-SM 模式只记录连接着接收者的接口，其它没有接收者，不需要接收组播的接口是不会被记录的 。</li><li>Rendezvous Point ( RP)：RP 就是组播网络的核心，发送者统一将组播数据发送到 RP ，然后 RP 再将数据发到接收者，也就是说接收者收到的数据，都是由 RP 转发过来 的。</li><li>(*，G)  形式的树被称为共享树（RPT）</li><li>真正 的源向 RP 发出第一个组播包时，DR 将此包封装在单播中发向 RP。发送的注册消息会从 DR 到 RP 之间建立一条源树 ，也就是 （S，G ）的记录，这样，在源到 RP 之间创建的源树就可以帮助避免 RPF 检测失败。</li></ul><h2 id="Ch2-IPv6"><a href="#Ch2-IPv6" class="headerlink" title="Ch2 IPv6"></a>Ch2 IPv6</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="IPv4-的问题"><a href="#IPv4-的问题" class="headerlink" title="IPv4 的问题"></a>IPv4 的问题</h4><h4 id="IPv6-设计目标和主要特征"><a href="#IPv6-设计目标和主要特征" class="headerlink" title="IPv6 设计目标和主要特征"></a>IPv6 设计目标和主要特征</h4><ul><li>扩大地址空间、路由更结构层次化<ul><li>32bits →128 bits</li><li>全局 unicast 地址等价于 IPv4 公开地址</li><li>直接使用 CIDR，网络前缀取代掩码，前缀表示子网号</li></ul></li><li>报头格式大简化，方便硬件处理<ul><li>基本报头固定 40 bytes</li><li>简化路由器的操作</li><li>引入结构化扩展报头，取消可选项长度限制</li></ul></li><li>网络管理 更加简单<ul><li>建立一系列自动发现和自动配置功能</li><li>最大单元发现（MTU discovery）</li><li>邻接节点发现（neighbor discovery ）</li><li>路由器通告（router advertisement ）</li><li>路由器请求（router solicitation）</li><li>节点自动配置（auto-configuration）</li></ul></li><li>安全性支持<ul><li>IP security ,提供IP层的安全 IPSec</li><li>实现认证头（Authentication Header）</li><li>安全载荷封装（Encapsulated Security Payload）</li></ul></li><li>QoS 能力<ul><li>流标号（flow label），20比特,发送者可以要求路由器对此流进行特殊处理，路由器可以鉴别特殊流的所有报文</li></ul></li><li>多播寻址<ul><li>在 multicast 地址中增加了 范围“scope”字段，允许将多播路由限定在正确的范围内</li><li>设置flog允许区分永久性多播地址和临时性多播地址</li></ul></li><li>可移动性<ul><li>信宿选项报头、路由选项报头、自动配置、安全机制、以及 anycast 技术，将 QoS 同移动节点结合，从而强化对移动的支持</li></ul></li></ul><h3 id="IPv6-的报文结构"><a href="#IPv6-的报文结构" class="headerlink" title="IPv6 的报文结构"></a>IPv6 的报文结构</h3><p>主要改变</p><ul><li>对齐（alignment）已经从32bit的整数倍改为64bit整数倍（5×64 bits = 40×8B=320 bits ）</li><li>取消了报头长度字段，基本报头长度固定40Bytes</li><li>Total Length长度字段被Payload Length字段取代</li><li>源目地址字段增加到每个字段16个bytes</li><li>分片信息已经从基本报头的固定字段移到一个扩展报头中生存时间TTL改为跳数极限hop limit字段</li><li>业务类型改为数据流标号flow label 字段</li><li>协议字段改为下一个报头字段，以指明下一个报头类型</li></ul><h3 id="IPv6-的地址空间"><a href="#IPv6-的地址空间" class="headerlink" title="IPv6 的地址空间"></a>IPv6 的地址空间</h3><p>地址的三种文本表示</p><ul><li><strong>点分十进制</strong><ul><li>104.230.140.100.255.255.255.255.0.0.17.128.150.10.255.255</li></ul></li><li><strong>冒分 16 进制</strong><ul><li>共8个，相同字间距</li><li>上面地址为 68E6:8C64:FFFF:FFFF:0:1180:96A:FFFF</li></ul></li><li><strong>0 压缩 :: 表示</strong><ul><li>对连续长串0用::代替，一个地址中仅出现一次</li><li>2080:0:0:0:8:800:200C:417A → 2080::8: … ；unicast address</li><li>FF01:0:0:0:0:0:0:101→ FF01::101 ; multicast address</li><li>0:0:0:0:0:0:0:1 → ::1 ; loopback address</li><li>0:0:0:0:0:0:0:0 →:: ; undefined address</li></ul></li><li><strong>混合表示</strong><ul><li>x: x: x: x: x: x: d.d.d.d， x :表示16进制(16 Bits)， d.表示10进制(8 Bits )</li><li>0:0:0:0:0:0:13.1.168.3 或 ::13.1.168.3</li><li>0:0:0:0:0:FFFF:129.144.52.38或 :: FFFF:129.144.52.38</li></ul></li></ul><p><strong>CIDR形式</strong></p><ul><li>IPv6 地址/前缀长度，长度是 10 进制，表明地址最左端连续比特个数</li><li>正确表示 12AB00000000CD3 的 60 bits 前缀是：<ul><li>12AB:0000:0000:CD30:0000:0000:0000:0000/60</li><li>12AB::CD30:0:0:0:0/60</li><li>12AB:0:0:CD30::/60</li></ul></li><li>不正确的表示为（没有准确体现前缀=60个bit后面为0）：<ul><li>12AB:0:0:CD3/60 ；可理解为0CD3</li><li>12AB::CD30/60 ；可理解为12AB:0:0:0:0:0:0:CD30</li></ul></li><li>HUST的IPV6地址=2^81 = 2^80 ×2<ul><li>2001:0250:4000::/48</li><li>2001:0DA8:3000::/48</li></ul></li></ul><p>地址类型</p><ul><li>Unicast：One to One (Global，Link local，Site local，Compatible)</li><li>Anycast：One to Nearest (Allocated from Unicast)</li><li>Multicast：One to Many</li><li>Reserved</li></ul><p><strong>可聚类全局Unicast地址</strong></p><ul><li>共分3级，6个部分</li><li>前缀 <code>001</code>：全球可聚合Unicast地址</li><li>TLA ID（13 bits）（Top Level Aggregator）：顶级聚合标识符，分配给大型 ISP，从 IANA 直接获得。</li><li>RES（8 bits）：留做将来使用－Reserved for future use</li><li>NLA ID（24 bits）（Next Level Aggregator）：次级聚合标识符，中型 ISP 从 TLA 获取。</li><li>SLA ID（16bits）（Site Level Aggregator）：站点级聚合标识符，小型 ISP 从 NLA 获得</li><li>接口ID（64bits）：接口标识符Interface Identifier</li></ul><h3 id="IPv6-邻居发现协议"><a href="#IPv6-邻居发现协议" class="headerlink" title="IPv6 邻居发现协议"></a>IPv6 邻居发现协议</h3><p>基于 ICMPv6 报文实现其功能</p><ul><li><p>路由器请求（Router Solicitation）</p></li><li><p>路由器通告（Router Advertisement）</p></li><li><p>邻居请求（Neighbor Solicitation）</p></li><li><p>邻居通告（Neighbor Advertisement）</p></li></ul><p><strong>地址自动配置</strong></p><ul><li>当一台 IPV6 的主机第一次连接到链路上时，它能够自动配置接口的链路地址。在接口的 48 位的 MAC 地址中间插入一个保留的 16 位数值 <code>0xFFFE</code>，并把它的 U/L 位（第七位）翻转，这样就得到了一个 64 位接口 ID。在接口 ID 前面加上链路本地前缀 <code>FE80::/10</code>，就得到了链路本地地址</li><li>Stateless：在主机和路由器之间，利用 ICMPv6 协议中的 RA 和 RS 消息完成无状态自动配置过程。主机通过 RS 发现链路上的路由器，而路由器通过 RA 向主机通告 IPv6 地址前缀信息，主机在收到 IPv6 前缀信息后，与自己的网卡接口 ID 组合构成 128 位 IPv6 单播地址。</li><li>Stateful：主机通过配置协议（如 DHCPv6）获取 IPv6 地址以及其他信息（如 DNS），相比 Stateless 更加可控，但需要额外的应用服务器（如 DHCPv6 服务器）。</li></ul><p><strong>地址解析</strong></p><ul><li>地址解析在三层完成，不同的二层介质可以采用相同的地址解析协议</li><li>使用组播方式发送请求报文，减少了二层网络的性能压力</li><li>使用两种 ICMPv6 报文完成交互过程<ul><li>邻居请求（NS）<ul><li>IPv6 报头目的地址：请求节点多播地址</li></ul></li><li>邻居通告（NA）</li></ul></li></ul><p><strong>DAD（Duplicate Address Detection）</strong></p><ul><li>确保网络中无两个相同的单播地址</li><li>每次系统默认一个主机在应用新的 IP 地址之前会<strong>发送 3 次 DAD</strong>, 如果三次以后均没有收到任何回应，那么该地址被认为是可以配置在接口上的</li><li>若发现有地址重复（存在 NA 报文，目的地址为 FF02::1）<ul><li>全局单播地址：不安排给接口</li><li>链路本地地址 ：将接口置于不可用状态</li></ul></li></ul><h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3><p>IPSec 定义了在网际层使用的安全服务，其功能包括数据加密、对网络单元的访问控制、数据源地址验证、数据完整性检查和防止重放攻击。</p><h3 id="IPv4-到-IPv6-过渡"><a href="#IPv4-到-IPv6-过渡" class="headerlink" title="IPv4 到 IPv6 过渡"></a>IPv4 到 IPv6 过渡</h3><h2 id="Ch3-拥塞控制"><a href="#Ch3-拥塞控制" class="headerlink" title="Ch3 拥塞控制"></a>Ch3 拥塞控制</h2><h3 id="拥塞控制相关基础"><a href="#拥塞控制相关基础" class="headerlink" title="拥塞控制相关基础"></a>拥塞控制相关基础</h3><h4 id="拥塞控制的基本原理"><a href="#拥塞控制的基本原理" class="headerlink" title="拥塞控制的基本原理"></a>拥塞控制的基本原理</h4><p>拥塞产生的原因（需求大于供给，无准入控制）</p><ul><li>宏观原因：网络资源分布不均匀，流量分布不均匀，</li><li>微观原因：报文聚合到达率大于路由器输出链路的带宽</li></ul><p>拥控：</p><ul><li><p>问题：某些点上存在资源瓶颈</p></li><li><p>防止发送者把太多的数据发送到网路中，适应瓶颈链路和路由器有限 buffer ，保护网络</p></li></ul><p>流控：</p><ul><li><p>问题：接收方可能存在缓存不足、进程等待</p></li><li><p>防止发送方的发送速度比接收方的接收速度快，适应收发双方的 buffer + cpu 能力，保护端点。</p></li></ul><h4 id="拥塞控制方法分类"><a href="#拥塞控制方法分类" class="headerlink" title="拥塞控制方法分类"></a>拥塞控制方法分类</h4><p>解决拥塞本质上是<strong>更合理的资源分配</strong></p><ul><li>以路由器为中心与以主机为中心<ul><li>链路算法：在网络设备中执行，作用是检测网络拥塞的发生，产生拥塞反馈信息（主要集中在主动队列管理 AQM 算法方面）</li><li>源算法：在主机和网络边缘设备中执行，作用是根据反馈信息调整发送速率（使用最广泛的是 TCP 协议中的拥塞控制算法）</li></ul></li><li>基于预留与基于反馈<ul><li>基于预留：建立流时，端主机请求网络给予一定的容量，每个 R 分配足够的资源（缓冲区或链路带宽的比例）来满足这一请求。如果由于资源的过量则 R 不能满足该请求而拒绝该流。</li><li>基于反馈：端主机首先没有预留任何容量，而按照它们接收到的反馈来调整其发送。调整或者是显式的，如拥塞 R 发送一个“请慢下来”消息到主机，或隐式的，如端主机根据外部可观察的网络行为，如包丢失率，来调整其发送率</li></ul></li><li>基于窗口与基于速率<ul><li>用窗口大小来描述：如 TCP ：流控也可用窗口通告机制来预留缓冲空间，来支持资源分配</li><li>用速率大小来描述：用速率控制发送者行为，如接收方可说它可处理 1Mbps 的视频，而发送方则坚持这一速率</li></ul></li></ul><h4 id="资源分配评价标准"><a href="#资源分配评价标准" class="headerlink" title="资源分配评价标准"></a>资源分配评价标准</h4><p>有效性</p><ul><li>用<strong>吞吐率和延迟之比</strong>来描述资源分配模式的有效性，该比称为<strong>网络能力</strong></li><li>power = 吞吐率 / 延迟</li><li>目标是最大化吞吐/延迟比</li></ul><p>公平性</p><ul><li>赋予 0-1 公平性指数的函数（<strong>n 数和的平方 / n 数平方和的 n 倍</strong>）</li><li>当 n 个流都获得 1 个单位吞吐量时，公平指数为 1</li><li>当 1 个流获得 1 + delta 的吞吐量时，公平指数小于 1</li><li>当 n 个流中只有 k 个接收相等吞吐量，其余为 0 时，公平指数为 k/n</li></ul><h3 id="排队规则与流量整形"><a href="#排队规则与流量整形" class="headerlink" title="排队规则与流量整形"></a>排队规则与流量整形</h3><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p><strong>首先到达的包首先发送</strong></p><p>当 R 的缓冲空间满时，尾部的包就丢弃（tail drop）不考虑包是否重要，</p><p>FIFO 和 tail drop 是不同的概念，前者是发送调度策略，后者是丢弃策略，但二者常捆绑在一起叫做 FIFO。</p><h4 id="优先排队"><a href="#优先排队" class="headerlink" title="优先排队"></a>优先排队</h4><p>对基本 FIFO 的简单变化是优先排队策略</p><p>给每个包打上可携带的<strong>优先权标记</strong> ，如 IP 服务类型 TOS（DiffServ）</p><p>R 先发送其优先权高的包</p><p>这一方式离 Best effort delivery 并不远</p><h4 id="公平排队-FQ"><a href="#公平排队-FQ" class="headerlink" title="公平排队 FQ"></a>公平排队 FQ</h4><p>为每个正在被路由器处理的流分别维护一个队列，路由器以轮循方式服务每个队列。</p><p>当一个流发送包太快，则其队列填满；当一个队列到达一个特定的长度，属于该队列的后继包就被丢掉，这样，任何源就不可能多占用其他流的网络容量。</p><p>FQ 并不告诉源端任何有关路由器的状态，或并不限制源端发送怎样快。</p><p>主要的复杂性是路由器中处理的包长度不相同，公平须考虑包的长度。</p><p>先判断如果该包按位轮流方式发送何时可发完，然后根据完成时间对要发送的包排序。</p><p>$F_i = \max(F_{i-1},A_i) + P_i$</p><h4 id="加权公平排队-WFQ"><a href="#加权公平排队-WFQ" class="headerlink" title="加权公平排队 WFQ"></a>加权公平排队 WFQ</h4><p>给排队流加权，R 服务每个队列时每次发送多少比特，它直接控制每个流将得到多少链路带宽</p><p>$F_i = \max(F_{i-1},A_i) + P_i/W$</p><h4 id="流量整形-Traffic-Shaping"><a href="#流量整形-Traffic-Shaping" class="headerlink" title="流量整形 (Traffic Shaping)"></a>流量整形 (Traffic Shaping)</h4><p>造成拥塞的主要原因是网络流量通常是突发性的</p><p>强迫包以一种可预测的速率发送</p><p>漏桶算法强迫输出按平均速率进行，不灵活，溢出时要丢包。</p><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>基本思想：漏桶存放令牌，每 $\Delta T$ 秒产生一个 令牌，令牌累积到超过漏桶上界时就不再增加。包传输之前必须<br>获得一个令牌，传输之后删除该令牌.</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>智端 + 傻网，端端拥塞控制</p><p>无预约，先渐增发，后观察事件反应</p><p>TCP假设网络中R仅用 FIFO 排队，但也可能使用 FQ 规则</p><p>拥塞包在 R 中丢弃后，由端来重传解决</p><p>TCP又叫自定时（self clocking）</p><ul><li>重传定时器</li><li>坚持定时器（接收窗口为0，期性地向接收方查询，发一个字节）</li><li>保活定时器（默认是2小时）</li><li>2MSL（报文段最大生存时间）定时器</li><li>……</li></ul><p>分组不能被传送和导致超时的主要原因是拥塞造成分组丢弃，<strong>发生拥塞的标志</strong>：</p><ul><li><strong>duplicate ACK（接收方发现包到达失序，不能确认，因此对已确认的字节再次确认）</strong></li><li><strong>超时</strong></li></ul><h4 id="加乘式-AIMD"><a href="#加乘式-AIMD" class="headerlink" title="加乘式 (AIMD)"></a>加乘式 (AIMD)</h4><p>TCP 根据网络中存在的拥塞级别来设定 Congestion Window 值</p><ul><li>拥塞级别上升，则减少 CW<ul><li>每发生一次超时，CW 减半</li></ul></li><li>拥塞级别下降，则增加 CW<ul><li>每成功确认一个分组，CW 加 1</li><li>当前 CW 对应的分组数全部确认后，CW 将翻倍</li></ul></li></ul><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>源最开始将 CW 设定为 1，每收到一个 ACK 线性增加 CW，最终 TCP 在每个 RTT 内将传送的分组数加倍</p><p>慢启动只发生在<strong>刚开始和发生超时</strong>的时候。</p><h4 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h4><p>发送方TCP等到 3 个 Duplicate ACK 后就重发丢失的包；即快速重传，比等待报文超时要快。（合理性：既然ACK报文可以通过网络，证明网络是通畅的，应该加快发送速度）</p><p>当快速重传同时快速恢复</p><ol><li>把 ssthresh 设置为 cwnd 的一半</li><li>把 cwnd 再设置为等于 ssthresh 的值，不再从 1 开始 (具体实现有些为 ssthresh + 3，因为三个重复的 ACK，表示有三个报文离开网络了，可以新增三个)</li><li>重新进入拥塞避免阶段，再收到重复 ACK，拥塞窗口+1（不会加剧拥塞，因为有 ACK 报文，说明可以增加发送）</li><li>收到新的报文 ACK 时候，ssthresh 变为第一步的大小（说明所有丢失的报文都收到了，可以快速恢复）</li></ol><h3 id="TCP-拥塞避免"><a href="#TCP-拥塞避免" class="headerlink" title="TCP 拥塞避免"></a>TCP 拥塞避免</h3><p>拥塞避免策略：拥塞将要发生时进行预测，在包将被丢弃之前减少主机发送数据的速率</p><h4 id="DECbit"><a href="#DECbit" class="headerlink" title="DECbit"></a>DECbit</h4><p>把拥塞任务更均匀分担在路由器和端节点之间，每个路由器监视它正在经历的负载，在拥塞将要发生时明确地通告端节点，通过设置流过路由器包中的二进制拥塞位来实现。目端把这拥塞位拷贝进 ACK 报文并返送回源端，源端调整自己的发送速率以避免拥塞，设置标志位告诉接收方，已经处理了拥塞。</p><p>测量平均队列长度的时间间隔是：最近的忙期 + 空闲期 + 当前忙期（R传输时为忙，不传输时为闲）。</p><p>用队列长度 1 作为设置拥塞位的触发器，是在有效排队(维持高吞吐率)和增加闲期(较低延迟)之间的折中，即队长1是网络能力（吞吐率/延迟）函数的优化。</p><p>源主机的工作，记录有多少包导致其在路由器中记下拥塞位，维护一个拥塞窗口，并观察最近等价窗口值导致设置拥塞的比例，若比例 $&lt;$ 50%，源增加拥塞窗口1个包，若比例 $\geq$ 50%，源减拥塞窗口至原值0.875倍。</p><h4 id="ECN-显式拥塞控制"><a href="#ECN-显式拥塞控制" class="headerlink" title="ECN 显式拥塞控制"></a>ECN 显式拥塞控制</h4><p>标记包而不是丢弃包，减少超时长度和重传次数</p><h4 id="基于源的拥塞避免"><a href="#基于源的拥塞避免" class="headerlink" title="基于源的拥塞避免"></a>基于源的拥塞避免</h4><h4 id="路由器主动队列管理-AQM"><a href="#路由器主动队列管理-AQM" class="headerlink" title="路由器主动队列管理 AQM"></a>路由器主动队列管理 AQM</h4><p>随机早期检测 RED</p><ul><li>R 在其缓冲被完全填满前就丢少量包，使源方减慢发率</li><li>RED 不明确发送拥塞通知到源，而是<strong>通过丢弃一个包来隐含已发生拥塞</strong>。源会被随后的超时或重复ACK所提示，这可与 TCP 配合使用</li><li>当队列超过某阈值时按某概率丢弃到达包</li><li>动态加权平均队长<ul><li>Avglen = (1 - Weight) × Avglen + Weight × SampleLen</li></ul></li><li>丢包函数<ul><li>TempP = MaxP * (Avglen - MinThreshold) / (MaxThreshold - MinThreshold)</li><li>P = TempP / (1 - count × TempP)，count 记录从上一次丢包开始到现在有多少刚到的包已加入队列</li></ul></li></ul><h2 id="Ch4-对等网络-P2P"><a href="#Ch4-对等网络-P2P" class="headerlink" title="Ch4 对等网络 P2P"></a>Ch4 对等网络 P2P</h2><h3 id="P2P-网络基本概念"><a href="#P2P-网络基本概念" class="headerlink" title="P2P 网络基本概念"></a>P2P 网络基本概念</h3><p>对等网络，计算 端到端</p><p>经系统间直接交换来共享计算资源和服务的应用模式</p><p>以非集中方式使用分布式资源来完成关键任务的一类系统和应用</p><p>既是客户端 consumer 也是服务器端</p><p>任何时候都有加入或离开的自由</p><p>无限的 peer diversity: 服务能力、存储空间 、网络带宽和服务需求</p><p>开放的广域无中心分布系统</p><h3 id="混合式-P2P-网络（第一代）"><a href="#混合式-P2P-网络（第一代）" class="headerlink" title="混合式 P2P 网络（第一代）"></a>混合式 P2P 网络（第一代）</h3><p>拓扑结构： 服务器仍然是网络的核心</p><p>底层协议： 全部使用 TCP ，限制了链接的 Peer 数量</p><p>查询与路由简单高效：</p><ul><li><p>Napster 和 BT 的用户访问服务器；服务器返回文件索引或种子文件；用户再直接同另一 Peer 连接</p></li><li><p>故路由跳数为 O(1) 1)，即常数跳</p></li></ul><p>容错、自适应和匿名性</p><ul><li><p>服务器单点失效率高</p></li><li><p>自组织和自适应主要依靠服务器</p></li><li><p>服务器的存在使匿名性实际不可能</p></li></ul><p>用户接入无安全认证机制</p><h3 id="无结构-P2P-网络（第二代）"><a href="#无结构-P2P-网络（第二代）" class="headerlink" title="无结构 P2P 网络（第二代）"></a>无结构 P2P 网络（第二代）</h3><p>容错性与自适应</p><ul><li>幂率特性对随机节点失效有高容错性</li><li>自适应：检测邻居在线否</li><li>超级节点列表定期更新</li></ul><p>可扩展性</p><ul><li>改造洪泛提高可扩展性</li></ul><p>安全性与匿名性</p><ul><li>无结构不易追踪</li></ul><p>增强机制 复制</p><ul><li>查询分布：均匀、 Zipf</li><li>复制份数：均匀、依查询概率比例、方根复制</li></ul><p>优势和缺陷</p><ul><li>高容错性和良好自适应性，较高安全性和匿名性</li><li>路由效率低 可扩展差 准确定位差</li></ul><h3 id="结构化-P2P-网络（第三代）"><a href="#结构化-P2P-网络（第三代）" class="headerlink" title="结构化 P2P 网络（第三代）"></a>结构化 P2P 网络（第三代）</h3><p>目标相同</p><ul><li>减少路由到指定文件的 P2P 跳数</li><li>减少每个 Peer 必须保持的路由状态</li></ul><p>算法异同</p><ul><li>节点与对象 Hash 映射到 同一空间 ，走 最接近 路由</li><li>都保证算法的跳数与 Peer 群组的大小相关</li><li>方法上的差别很小</li></ul><h3 id="BitCoin-和区块链"><a href="#BitCoin-和区块链" class="headerlink" title="BitCoin 和区块链"></a>BitCoin 和区块链</h3><p>区块奖励</p><ul><li>新产生的比特币奖励</li><li>交易费</li></ul><p>防止双花交易</p><ul><li>区块链是一个分布式数据库，每个区块拥有一段时间内的交易信息和上一个区块的摘要</li><li>同时可能出现两个合法的区块，但是只有最长链是最大算力保证的</li><li>如果有人想一个币使用两次，就会出现同一个交易输出被打包到两个新的交易中，非常容易检测，只有最长链才是被所有节点认可的，这样就防止了双花交易</li></ul><h1 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h1><ul><li><strong>OSI</strong>：Open Systems Interconnection，开放式系统互联</li><li><strong>TCP</strong>：Transmission Control Protocol，传输控制协议</li><li><strong>UDP</strong>：User Datagram Protocol，用户数据报协议</li><li><strong>IP</strong>：Internet Protocol，网际协议</li><li><strong>API</strong>：Application Programming Interface，应用程序接口</li><li><strong>RTT</strong>：Round Trip Time，往返时延</li><li><strong>QoS</strong>：Quality of Service，服务质量</li><li><strong>EoS</strong>：Experience of Service，服务体验（Ethernet over SDH，基于SDH的以太网）</li><li><strong>RFC</strong>：Request For Comment，请求评议</li><li><strong>DDoS</strong>：Distributed Denial of Service，分布式拒绝服务</li><li><strong>AS</strong>：Autonomous System，自治域</li><li><strong>S/N（SNR）</strong>：signal to noise ratio，信噪比</li><li><strong>GSM</strong>：Global System for Mobile Communications ，全球移动通信</li><li><strong>EIRP</strong>：Equivalent Isotropically Radiated Power，等效全向辐射频率</li><li><strong>OC</strong>：Optical Carrier，光载波</li><li><strong>SONET</strong>：Synchronous Optical Network，同步光纤网络</li><li><strong>STS</strong>：Synchronous Transport Signal，同步传输信号</li><li><strong>SDH</strong>：Synchronous Digital Hierarchy，同步数字体系</li><li><strong>STM</strong>：Synchronous Transport Module，同步传输模块</li><li><strong>PAM</strong>：Pulse Amplitude Modulation，脉冲幅度调制</li><li><strong>PCM</strong>：Pulse Code Modulation，脉冲码调制</li><li><strong>ASK</strong>：Amplitude Shift Keying，幅移键控</li><li><strong>FSK</strong>：Frequency Shift Keying，频移键控</li><li><strong>PSK</strong>：Phase Shift Keying，相移键控</li><li><strong>QAM</strong>：Quadrature Amplitude Modulation，正交幅度编码</li><li><strong>NRZ</strong>：Non-Return Zero，不归零编码</li><li><strong>NRZI</strong>：Non-Return Zero Inverted，不归零反转编码</li><li><strong>BISYN</strong>：Binary Synchronous Communication Message Protocol，二进制同步通信协议</li><li><strong>DDCMP</strong>：Digital Data Communication Message Protocol，数字数据通信消息协议</li><li><strong>PPP</strong>：Point to Point Protocol，点到点协议</li><li><strong>SDLC</strong>：Synchronous Data Link Control Protocol，同步数据链路控制协议</li><li><strong>HDLC</strong>：High-level Data Link Control Protocol，高级数据链路控制协议</li><li><strong>TDM</strong>：Time Division Multiplexing，时分复用</li><li><strong>STDM</strong>：Statistical Time Division Multiplexing，统计时分复用</li><li><strong>FDM</strong>：Frequency Division Multiplexing，频分复用</li><li><strong>WDM</strong>：Wavelength Division Multiplexing，波分复用</li><li><strong>CWDM</strong>：Coarse Wavelength Division Multiplexing，稀疏波分复用</li><li><strong>DWDM</strong>：Dence Wavelength Division Multiplexing，密集波分复用</li><li><strong>CDM</strong>：Code Division Multiplexing，码分复用</li><li><strong>ARQ</strong>：Automatic Repeat Request，自动请求重传</li><li><strong>CRC</strong>：Cyclic Redundency Check，循环冗余校验</li><li><strong>ATM</strong>：Asynchronous Transfer Mode，异步传输模式</li><li><strong>CSMA/CD</strong>：Carrier Sense Multiple Access with Collision Detection，带冲突检测的载波侦听多路访问</li><li><strong>VLAN</strong>：Virtual Local Area Network，虚拟局域网</li><li><strong>STP</strong>：Spanning Tree Protocol，生成树协议</li><li><strong>CST</strong>：Common Spanning Tree，公共生成树</li><li><strong>BPDU</strong>：Bridge Protocol Data Unit，网桥协议数据单元</li><li><strong>TCN</strong>：Topology Change Notification，拓扑更改通知</li><li><strong>URL</strong>：Uniform Resource Locater，统一资源定位器</li><li><strong>DNS</strong>：Domain Name System，域名系统</li><li><strong>MAC 地址</strong>：Media Access Control Address，媒介存取控制地址</li><li><strong>ARP</strong>：Address Resolution Protocol，地址解析协议</li><li><strong>NAT</strong>：Network Address Translation，网络地址转换</li><li><strong>TTL</strong>：Time To Live，生存期</li><li><strong>MTU</strong>：Maximum Transmission Unit，最大传输单元</li><li><strong>FDDI</strong>：Fiber Distributed Data Interface，光纤分布式数据接口</li><li><strong>ICMP</strong>：Internet Control Message Protocol ，网际控制报文协议</li><li><strong>IGP</strong>：Interior Gateway Protocol，内部网关协议</li><li><strong>RIP</strong>：Routing Information Protocol，路由信息协议</li><li><strong>OSPF</strong>：Open Shortest Path First，开放最短路径优先</li><li><strong>EGP</strong>：Exterior Gateway Protocol，外部网关协议</li><li><strong>BGP</strong>：Border Gateway Protocol，边界网关协议</li><li><strong>LSP</strong>：Link-State Packet，链路状态分组</li><li><strong>LSA</strong>：Link-State Advertisement，链路状态通知</li><li><strong>CIDR</strong>：Classless Inter-Domain Routing，无类别域间路由</li><li><strong>DHCP</strong>：Dynamic Host Configuration Protocol，动态主机配置协议</li><li><strong>IPSec</strong>：Internet Protocol Security，网际协议安全</li><li><strong>EUI</strong>：Extended Unique Identifier，扩展唯一标识符</li><li><strong>DAD</strong>：Dupicate Address Detection，重复地址检测</li><li><strong>NDP</strong>：Neighbor Discovery Protocol，邻居发现协议</li><li><strong>AQM</strong>：Active Queue Management，主动队列管理</li><li><strong>FIFO</strong>：First In First Out，先进先出</li><li><strong>ToS</strong>：Type of Service，服务类型</li><li><strong>DSCP</strong>：Differentiated Services Code Point，差分服务代码点</li><li><strong>ECN</strong>：Explict Congestion Notification，显示拥塞通知</li><li><strong>FQ</strong>：Fair Queuing，公平排队</li><li><strong>WFQ</strong>：Weighted Fair Queuing，加权公平排队</li><li><strong>ssthresh</strong>：slow start threshold，慢启动阈值</li><li><strong>AIMD</strong>：Additive Increase Multiplicative Decrease，加性增乘性减（加法式增加乘法式减少）</li><li><strong>RED</strong>：Random Early Detection，随机早期检测</li><li><strong>IGMP</strong>：Internet Group Management Protocol，因特网组管理协议</li><li><strong>CGMP</strong>：Cisco Group Management Protocol，思科组管理协议</li><li><strong>PIM</strong>：Protocol Independent Multicast，协议独立组播</li><li><strong>PIM-DM</strong>：Protocol Independent Multicast-Dense Mode，协议独立组播密集模式</li><li><strong>PIM-SM</strong>：Protocol Independent Multicast-Sparse Mode，协议独立组播稀疏模式</li><li><strong>RPF</strong>：Reverse Protocol Forwarding，逆向路径转发</li><li><strong>SPT</strong>：Shortest-Path Tree，最短路径树</li><li><strong>RPT</strong>: Rendezvous Point Tree，PIM-SM 协议共享树</li><li><strong>MBGP</strong>：Multi-protocol Border Gateway Protocol，多协议边界网关协议</li><li><strong>MSDP</strong>：Multicast Source Discovery Protocol，组播源发现协议</li><li><strong>RTP</strong>：Real-time Transport Protocol，实时传输协议</li><li><strong>RTCP</strong>：Real-time Transport Control Protocol，实时传输控制协议</li><li><strong>RSVP</strong>：Resource Reservation Protocol，资源预留协议</li><li><strong>P2P</strong>：Peer to Peer，端到端，对等</li><li><strong>CDN</strong>：Content Delivery Network，内容分发网络</li><li><strong>ALM</strong>：Application Level Multicast，应用层组播</li><li><strong>DHT</strong>：Distributed Hash Table，分布式哈希表</li><li><strong>CFS</strong>：Cooperative File System，协同文件系统</li><li><strong>UTXO</strong>：Unspent Transaction Output，没有花出去的输出</li><li><strong>SDN</strong>：Software Defined Networking，软件定义网络</li><li><strong>SIP</strong>：Session Initiation Protocol，会话初始化协议</li><li><strong>NDN</strong>：Named Data Networking，命名数据网络</li><li><strong>NFV</strong>：Network Function Virtualization，网络功能虚拟化</li><li><strong>LTE</strong>：Long Term Evolution，长期演进技术</li><li><strong>OTN</strong>：Optical Transport Network，光传输网络</li><li><strong>IOT</strong>：the Internet of Things，物联网</li><li><strong>RTS</strong>：Request to Send，请求发送</li><li><strong>CTS</strong>：Clear to Send，允许发送</li></ul>]]></content>
      
      
      <categories>
          
          <category> 现代计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《图像处理》频域图像增强</title>
      <link href="/2019/10/20/frequency-domain-enhancement-by-book-image-processing.html"/>
      <url>/2019/10/20/frequency-domain-enhancement-by-book-image-processing.html</url>
      
        <content type="html"><![CDATA[<h1 id="频域图像增强"><a href="#频域图像增强" class="headerlink" title="频域图像增强"></a>频域图像增强</h1><ul><li>前面对图像的加工都是在图像空间进行的，也可以考虑将图像变换到其他空间里再进行加工，这些利用变换以后空间的方法称为基于变换域的方法<ol><li>将图像从图像空间转换到变换域空间</li><li>在变换域空间中对图像进行增强</li><li>将增强后的图像再从变换域空间转换到图像空间</li></ol></li><li>最常用的变换空间是<strong>频域空间</strong>，所采用的变换是<strong>傅里叶变换</strong></li><li>频域空间里的图像信息表现为不同频率分量的组合，如果能让不同频率范围内的分量受到不同的抑制，即进行不同的滤波，就可以改变输出图的频率分布，达到不同的增强目的</li></ul><h1 id="频域技术原理"><a href="#频域技术原理" class="headerlink" title="频域技术原理"></a>频域技术原理</h1><h2 id="频域增强步骤"><a href="#频域增强步骤" class="headerlink" title="频域增强步骤"></a>频域增强步骤</h2><ul><li>如果将图像从图像空间转换到频域空间所需的变换用 $T$ 表示（反变换用 $T^{-1}$ 表示），将在频域空间对图像进行增强加工的操作仍用 $E_H$ 表示，则要将 $f(x,y)$ 增强成 $g(x,y)$ 可表示为 $g(x,y) = T^{-1} \{E_H[T[f(x,y)]] \}$ . </li><li>卷积理论是频域技术的基础<ul><li>设函数 $f(x,y)$ 与线性位不变算子 $h(x,y)$ 的卷积结果是 $g(x,y)$，即 $g(x,y)=h(x,y)*f(x,y)$，那么根据卷积定理在频域有 $G(u,v)=H(u,v)F(u,v)$，其中 $G(u,v)$，$H(u,v)$，$F(u,v)$ 分别是 $g(x,y)$，$h(x,y)$，$f(x,y)$ 的傅里叶变换。根据线性系统理论，$H(x,y)$ 是转移函数。</li><li>在具体增强应用中，$f(x,y)$ 是给定的输入图像，需要确定的是 $H(u,v)$，具有所需特性的 $g(x,y)$ 就可以通过算出 $G(x,y)$ 后得到：$g(x,y)=T^{-1}[H(u,v)F(u,v)]$。</li></ul></li><li>频域增强的步骤<ol><li>计算需增强图像的傅里叶变换</li><li>将其与一个根据需要设计的转移函数相乘</li><li>再将结果进行傅里叶反变换以得到增强的图像</li></ol></li><li>转移函数<ul><li>根据增强目的进行设计</li><li>基本思路<ul><li>要允许一定频率通过（保留某些频率分量），限制或阻止另外一些频率通过（消除某些频率分量）</li></ul></li><li>类型<ul><li>低通滤波</li><li>高通滤波</li><li>带阻滤波</li><li>带通滤波</li><li>同态滤波</li></ul></li></ul></li></ul><h2 id="频域技术与空域技术"><a href="#频域技术与空域技术" class="headerlink" title="频域技术与空域技术"></a>频域技术与空域技术</h2><ul><li>空域和频域技术基本可实现相同功能<ul><li>频域中滤波器的转移函数和空域中的脉冲响应函数或点扩散函数构成傅里叶变换对</li></ul></li><li>在频域中设计滤波器比较方便<ul><li>在频域中分析，在空域中实现</li></ul></li><li>空域技术基于（部分象素）局部性质，频域技术利用（所有象素）全局性质</li></ul><h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><ul><li><a href="https://blog.csdn.net/u013921430/article/details/79683853" target="_blank" rel="noopener">傅里叶变换</a><ul><li>是可分离和正交变换的一个特例</li><li>对图像的傅里叶变换将图像从图像空间变换到频率空间，从而可利用傅里叶频谱特性进行图像处理</li></ul></li></ul><h2 id="2-D-傅里叶变换"><a href="#2-D-傅里叶变换" class="headerlink" title="2-D 傅里叶变换"></a>2-D 傅里叶变换</h2><ul><li><p>变换定义</p><ul><li>2-D 图像 $f(x,y)$ 的 <code>正反傅里叶变换</code> 分别定义如下（其中 $u$ 和 $v$ 均为频率分量）<ul><li>$F(u,v)=\cfrac{1}{N}\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi(ux+vy)/N} \quad u,v=0,1,\cdots,N-1$ </li><li>$f(x,y)=\cfrac{1}{N}\sum_{u=0}^{N-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi(ux+vy)/N} \quad x,y=0,1,\cdots,N-1$ </li></ul></li><li>可得<ul><li>$\bar{f}(x,y)=\cfrac{1}{N^2}\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}f(x,y)=\cfrac{1}{N}F(0,0)$<ul><li>一个 2-D 离散函数的傅里叶变换在原点的值（<strong>零频率分量</strong>）与该函数的均值成正比</li></ul></li></ul></li><li>2-D 傅里叶变换的 <code>频谱</code>（幅度函数）、<code>相位角</code> 和 <code>功率谱</code>（频谱的平方）定义如下<ul><li>$|F(u,v)|=\sqrt{R^2(u,v)+I^2(u,v)}$ </li><li>$\phi(u,v)=\arctan\cfrac{I(u,v)}{R(u,v)}$ </li><li>$P(u,v)=|F(u,v)|^2=R^2(u,v)+I^2(u,v)$ </li></ul></li></ul></li><li><p><strong>变换核</strong></p><ul><li>正向变换 $f(x,y) \Rightarrow F(u,v)$ <ul><li>正向变换核 $\cfrac{1}{N} e^{-j2\pi(ux+vy)/N}$ </li></ul></li><li>反向变化 $F(u,v) \Rightarrow f(x,y)$ <ul><li>反向变换核 $\cfrac{1}{N}e^{j2\pi(ux+vy)/N}$ </li></ul></li><li>可分离性<ul><li>$ux$ 和 $vy$ 可分开<ul><li>$\cfrac{1}{N} e^{-j2\pi(ux+vy)/N} = \cfrac{1}{\sqrt{N}} e^{-j 2\pi ux/N} \times \cfrac{1}{\sqrt{N}} e^{-j 2\pi vy/N}$ </li><li>$\cfrac{1}{N} e^{j2\pi(ux+vy)/N} = \cfrac{1}{\sqrt{N}} e^{j 2\pi ux/N} \times \cfrac{1}{\sqrt{N}} e^{j 2\pi vy/N}$ </li></ul></li><li>1 个 2-D 变换核可分解成 2 个 1-D 变换核</li></ul></li><li>对称性<ul><li>分离后的两部分函数形式一样</li></ul></li><li>具有可分离且对称变换核的 2-D 傅里叶变换可分解成两个步骤计算，每个步骤用一个 1-D 变换<ul><li>正变换分解<ol><li>列变换 $F(x,v)=\cfrac{1}{\sqrt{N}}\sum_{y=0}^{N-1} f(x,y) e^{-j 2\pi vy/N} \quad x,v=0,1,\cdots,N-1$ </li><li>行变换 $F(u,v)=\cfrac{1}{\sqrt{N}}\sum_{x=0}^{N-1} F(x,v) e^{-j 2\pi ux/N} \quad u,v=0,1,\cdots,N-1$ </li></ol></li><li><img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/由2步1-D变换计算2-D变换.jpg" alt></li></ul></li></ul></li></ul><h2 id="傅里叶变换定理"><a href="#傅里叶变换定理" class="headerlink" title="傅里叶变换定理"></a>傅里叶变换定理</h2><ul><li>设图像空间的 f(x,y) 与频域空间的 F(u,v) 构成一对变换，即 $f(x,y) \Leftrightarrow F(u,v)$，则有一下基本定理成立</li><li><strong>平移定理</strong><ul><li>$f(x-a,y-b) \Leftrightarrow F(u,v) e^{-j2\pi(au+bv)/N}$ </li><li>$F(u-c,v-d) \Leftrightarrow f(x,y) e^{j2\pi(cx+dy)/N}$ </li><li>将 f(x,y) 在空间平移相当于把其变换在频域与一个指数项相乘</li><li>将 f(x,y) 在图像空间与一个指数项相乘相当于把其在变换在频域平移</li><li>平移不影响正反变换的幅值</li><li>平移定理证明<img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/平移定理证明.png" alt></li><li>傅里叶变换频域平移示例<img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/频域平移.png" alt></li></ul></li><li><strong>旋转定理</strong><ul><li>反映傅里叶变换的旋转性质</li><li>首先借助极坐标变换</li><li>$\begin{cases}<br>  x=r\cos\theta \\<br>  y=r\sin\theta \\<br>  u=\omega\cos\phi \\<br>  v=\omega\sin\phi \\<br>  \end{cases}$ </li><li>将 $f(x,y)$ 和 $F(u,v)$ 转换为 $f(r,\theta)$ 和 $F(\omega,\phi)$ </li><li>直接将它们带入傅里叶变换对得到</li><li>$f(r,\theta+\theta_0) \Leftrightarrow F(\omega,\phi+\theta_0)$ </li><li>其中 $\theta_0$ 为旋转角度</li><li>傅里叶变换旋转性质示例<img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/傅里叶变换旋转示例.png" alt></li></ul></li><li><strong>尺度定理（相似定理）</strong><ul><li>给出傅里叶变换在尺度（放缩）变化时的性质</li><li>$af(x,y) \Leftrightarrow aF(u,v)$ </li><li>$f(ax,by) \Leftrightarrow \cfrac 1 {|ab|}F \left(\cfrac u a,\cfrac v b \right)$ </li><li>对 f(x,y) 在<strong>幅度方面的尺度变化</strong>导致对其傅里叶变换 F(u,v) 在<strong>幅度方面的对应尺度变化 </strong></li><li>对 f(x,y) 在<strong>空间尺度方面的放缩</strong>导致对其傅里叶变换 F(u,v) 在<strong>频域尺度方面的相反放缩</strong> </li><li>对 f(x,y) 的收缩 (a&gt;1, b&gt;1) 不仅导致 F(u,v) 的膨胀，而且会使 F(u,v) 的幅度减小</li><li>傅里叶变换尺度性质示例<img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/傅里叶变换尺度性质示例.png" alt></li></ul></li><li><strong>剪切定理</strong><ul><li>描述傅里叶变换在剪切变化时的性质</li><li>对 f(x,y) 的纯剪切会导致 F(x,y) 在<strong>正交方向</strong>的纯剪切</li><li>水平剪切 $f(x+by,y) \Leftrightarrow F(u,v-bu)$ </li><li>垂直剪切 $f(x,y+dx) \Leftrightarrow F(u-dv,v)$ </li><li>傅里叶变换剪切性质示例<img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/傅里叶变换剪切性质示例.png" alt></li><li>组合剪切 $f(x+by,y+dx) \Leftrightarrow \cfrac{1}{|1-bd|}F \left( \cfrac{u-dv}{1-bd},\cfrac{-bu+v}{1-bd} \right)$ </li><li>矩阵表达<ul><li>用矢量 $\boldsymbol{x}$ 表示 $(x,y)$，用矢量 $\boldsymbol{x’}$ 表示 $(x’,y’)$ </li><li>$\boldsymbol{x’}=\begin{bmatrix}1&amp;b\\d&amp;1\end{bmatrix}\boldsymbol{x}$ </li><li>对水平剪切，变换矩阵为 <script type="math/tex">\begin{bmatrix}1&b\\0&1\end{bmatrix}</script> 或 $\begin{bmatrix} 1 &amp; \tan s \\ 0 &amp; 1 \end{bmatrix}$</li><li>对垂直剪切，变换矩阵为 $\begin{bmatrix}1&amp;0\\d&amp;1\end{bmatrix}$ 或 $\begin{bmatrix} 1 &amp; 0 \\ \tan t &amp; 1\end{bmatrix}$ </li><li>先水平剪切后垂直剪切可表示为 $\begin{bmatrix}1&amp;0\\d&amp;1\end{bmatrix} \begin{bmatrix}1&amp;b\\0&amp;1\end{bmatrix} = \begin{bmatrix} 1 &amp; b \\ d &amp; 1+bd \end{bmatrix}$ </li><li>先垂直剪切后水平剪切可表示为 $\begin{bmatrix}1&amp;b\\0&amp;1\end{bmatrix} \begin{bmatrix}1&amp;0\\d&amp;1\end{bmatrix} = \begin{bmatrix} 1+bd &amp; b \\ d &amp; 1 \end{bmatrix}$ </li><li>其中角度 s 和 t 如图所示 <img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/单位正方形受到剪切后的效果.jpg" alt><ul><li>(a) 水平剪切</li><li>(b) 垂直剪切</li><li>(c) 组合剪切</li><li>(d) 先水平剪切后垂直剪切</li><li>(e) 先垂直剪切后水平剪切</li></ul></li><li>简单的剪切操作依次使用会产生不同的结果<ul><li>矩阵相乘的次序是不能交换的</li><li><strong>组合剪切</strong>的结果具有与<strong>简单剪切</strong>相同的倾斜角 s 和 t<ul><li>$\tan s = b$ </li><li>$\tan t = d$</li></ul></li><li><strong>先水平剪切后垂直剪切</strong>保持了 t，但产生了一个新角 p<ul><li>$\tan p = \cfrac{b}{1+bd}$ </li></ul></li><li><strong>先垂直剪切后水平剪切</strong>保持了 s，但产生了一个新角 q<ul><li>$\tan q = \cfrac{d}{1+bd}$ </li></ul></li></ul></li></ul></li></ul></li><li><strong>卷积定理</strong><ul><li>指出两个函数<strong>在空间的卷积</strong>与它们的傅里叶变换<strong>在频域的乘积</strong>构成一对变换，而两个函数<strong>在空间的乘积</strong>与它们的傅里叶变换<strong>在频域的卷积</strong>构成一对变换</li><li>$f(x,y) \ast g(x,y) \Leftrightarrow F(u,v)G(u,v)$ </li><li>$f(x,y)g(x,y) \Leftrightarrow F(u,v) \ast G(u,v)$ </li></ul></li><li><strong>相关定理</strong><ul><li>指出两个函数在空间的相关与它们的傅里叶变换（其中一个为其复共轭）在频域的乘积构成一对变换，而两个函数（其中一个为其复共轭）在空间的乘积与它们的傅里叶变换在频域的相关构成一对变换</li><li>$f(x,y) \circ g(x,y) \Leftrightarrow F^{\ast}(u,v)G(u,v)$ </li><li>$f^{*}(x,y)g(x,y) \Leftrightarrow F(u,v) \circ G(u,v)$ </li><li>如果 $f(x,y) = g(x,y)$，称为自相关</li><li>如果 $f(x,y) \neq g(x,y)$，称为互相关</li></ul></li></ul><h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><ul><li>直接进行一个 $N \times N$ 的 2-D 傅里叶变换需要 $N^4$ 次<strong>复数乘法</strong>运算和 $N^2(N^2–1)$ 次<strong>复数加法</strong>运算<ul><li>对 $N^2$ 个点中的每个点都需要进行 $N^2$ 次复数乘法运算和 $N^2–1$ 次复数加法运算</li></ul></li><li>2-D 傅里叶变化可由连续两次 1-D 傅里叶变换得到<ul><li>$\mathcal{F}\{f(x)\}=F(u)=\cfrac{1}{N}\sum_{x=0}^{N-1}f(x)e^{-j 2\pi ux/N} \quad u=0,1,\cdots,N-1$ </li><li>1-D 傅里叶变换对 $u$ 的 $N$ 个值中的每一个都需要进行 $N$ 次复数乘法和 $N-1$ 次复数加法，即复数乘法和加法的次数都正比于 $N^2$ </li></ul></li><li><a href="https://blog.csdn.net/enjoy_pascal/article/details/81478582" target="_blank" rel="noopener">快速傅里叶变换</a><ul><li>注意到 $e^{-j 2\pi ux/N}$ 可只计算一次后存到一个表中以备查用，正确地分解 1-D 傅里叶变换可以将复数乘法和加法的次数减少为正比于 $N\log_2N$ </li></ul></li></ul><h1 id="低通滤波和高通滤波"><a href="#低通滤波和高通滤波" class="headerlink" title="低通滤波和高通滤波"></a>低通滤波和高通滤波</h1><ul><li>低通滤波和高通滤波的<strong>目的或功能相反</strong>，但低通滤波器和高通滤波器又<strong>具有对偶性</strong></li><li>下述讨论中仅考虑对 F(u,v) 的实部和虚部影响完全相同的滤波函数（称为<strong>零相移滤波器</strong>）</li></ul><h2 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h2><ul><li>低通滤波是要保留图像中的低频分量而除去高频分量</li><li>图像中的边缘和噪声都对应图像傅里叶频谱中的高频部分，所以通过在频域中的低通滤波可以除去或削弱噪声中的影响并模糊边缘轮廓，与空域中的平滑方法类似</li><li><p>要实现低通滤波需要设计一个合适的滤波转移函数 H(u,v)</p><h3 id="理想低通滤波"><a href="#理想低通滤波" class="headerlink" title="理想低通滤波"></a>理想低通滤波</h3></li><li><p>一个理想的低通滤波器的转移函数满足以下条件</p></li><li>$H(u,v)=\begin{cases} 1 &amp; D(u,v) \leq D_0 \\<br>  0 &amp; D(u,v) \gt D_0 \end{cases}$</li><li>其中 $D_0$ 是一个非负整数，也叫<strong>截断频率</strong> </li><li>$D(u,v)=\sqrt{u^2+v^2}$ 是从点 $(u,v)$ 到频率平面原点的距离</li><li><img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/理想低通滤波器转移函数的剖面图.png" alt></li><li>理想是指小于截断频率的频率可以完全不受影响地通过滤波器，而大于截断频率的频率则完全通不过</li><li>在数学上定义得很清楚，在计算机模拟中也可实现，但是在截断频率处直上直下的理想低筒滤波器是不能勇士级的电子器件实现的</li></ul><h3 id="理想低通滤波的模糊"><a href="#理想低通滤波的模糊" class="headerlink" title="理想低通滤波的模糊"></a>理想低通滤波的模糊</h3><ul><li>理想低通滤波器是“非物理”的滤波器，使用它来对图像进行滤波，其<strong>输出图像会变得模糊并有“振铃”现象出现</strong> </li><li><img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/理想低通滤波的空间模糊示意图.png" alt></li><li>理想低通滤波所产生的“振铃”现象在 2-D 图象上表现为<strong>一系列同心圆环</strong> <ul><li>圆环半径反比于截断频率</li><li>如果截断频率较小，就会使 h(x,y) 产生数量较少但较宽的同心圆环，并使得 g(x,y) 模糊得更比较厉害</li><li>当增加截断频率时，圆环就会变得数量较多但较窄，且 g(x,y) 的模糊减小</li><li>如果截断频率超过 F(u,v) 的定义域，则 h(x,y) 在其对应的空间区域值为 1，h(x,y) 与 f(x,y) 的卷积仍是 f(x,y)，这相当于没有滤波</li></ul></li></ul><h3 id="巴特沃斯低通滤波"><a href="#巴特沃斯低通滤波" class="headerlink" title="巴特沃斯低通滤波"></a>巴特沃斯低通滤波</h3><ul><li>物理上可以实现的一种低通滤波器</li><li>一个阶为 $n$、截断频率为 $D_0$ 的巴特沃斯低通滤波器的转移函数为 $H(u,v)=\cfrac{1}{1+[D(u,v)/D_0]^{2n}}$ </li><li>阶为 1 的巴特沃斯低通滤波器转移函数的剖面图如下<img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/巴特沃斯低通滤波器转移函数的剖面示意图.png" alt><ul><li>在高低频率间的过渡比较光滑</li><li>可减少振铃效应</li></ul></li><li>常取<strong>使 H 最大值降到某个百分比的频率</strong>为截断频率<ul><li>当 $D(u,v)=D_0$ 时，$H(u,v)=1/2$ （即降到 50%）</li><li>另一个常用的截断频率值是使 $H(u,v)=\sqrt{1/2}$ 的频率</li></ul></li></ul><h2 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h2><ul><li>要保留图像中的高频分量而除去低频分量</li><li>图像中的边缘对应高频分量，所以要锐化图像可使用高通滤波器</li></ul><h3 id="理想高通滤波"><a href="#理想高通滤波" class="headerlink" title="理想高通滤波"></a>理想高通滤波</h3><ul><li>一个理想的高通滤波器的转移函数满足以下条件</li><li>$H(u,v)=\begin{cases} 0 &amp; D(u,v) \leq D_0 \\<br>  1 &amp; D(u,v) \gt D_0 \end{cases}$</li><li><img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/理想高通滤波器转移函数的剖面图.png" alt></li></ul><h3 id="巴特沃斯高通滤波"><a href="#巴特沃斯高通滤波" class="headerlink" title="巴特沃斯高通滤波"></a>巴特沃斯高通滤波</h3><ul><li>一个阶为 $n$、截断频率为 $D_0$ 的巴特沃斯高通滤波器的转移函数为 $H(u,v)=\cfrac{1}{1+[D_0/D(u,v)]^{2n}}$ </li><li>阶为 1 的巴特沃斯高通滤波器的转移函数的剖面图如下<img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/巴特沃斯高通滤波器转移函数的剖面示意图.png" alt></li><li>常取<strong>使 H 最大值降到某个百分比的频率</strong>为截断频率</li></ul><h3 id="高频增强滤波"><a href="#高频增强滤波" class="headerlink" title="高频增强滤波"></a>高频增强滤波</h3><ul><li>一般图像中<strong>大部分能量集中在低频分量中</strong>，高通滤波会将很多低频分量（特别是直流分量）滤除，导致曾庆图中边缘得到增强但光滑区域灰度减弱变暗甚至接近黑色</li><li>为解决这个问题，可<strong>对频域里的高通滤波器的转移函数加一个常数以将一些低频分量加回去</strong>，获得既保持光滑区域灰度又改善边缘区域对比度的效果，这样得到的滤波器称为<strong>高频增强滤波器</strong> <ul><li>设原始模糊图的傅里叶变换为 $F(u,v)$，高通滤波所用的转移函数为 $H(u,v)$，则输出图的傅里叶变换为 $G(u,v) = H(u,v)F(u,v)$ </li><li>现对转移函数加一个常数 $c$ 得到高频增强转移函数 $H_e(u,v)=H(u,v)+c$ ，其中 $c$ 为 [0,1] 间常数</li><li>这样高频增强输出图的傅里叶变换为 $G_e(u,v)=G(u,v)+cF(u,v)$，即在高通的基础上又保留了一定的低频分量 $cF(u,v)$ </li><li>如果将高频增强输出图的傅里叶变换再反变换回去，则可得 $g_e(x,y)=g(x,y)+cf(x,y)$，可见增强图中既包含了高通滤波的结果，也包含了一部分原始的图像。或者说，在原始图的基础上叠加了一些高频成分，因而增强图中高频分量更多了</li></ul></li><li>实际中，还可以给高频增强滤波所用转移函数乘以一个常数 k（k为大于 1 的常数）以进一步加强高频成分<ul><li>$H_e(u,v)=kH(u,v)+c$ </li><li>$G_e(u,v)=kG(u,v)+cF(u,v)$ </li></ul></li></ul><h3 id="高频提升滤波"><a href="#高频提升滤波" class="headerlink" title="高频提升滤波"></a>高频提升滤波</h3><ul><li>用原始图减去低通图可以得到高通滤波效果</li><li>高频提升滤波<strong>先将原始图乘以一个放大系数 A 再减去低通图</strong><ul><li>设原始图的傅里叶变换为 $F(u,v)$，原始图被低通滤波后的傅里叶变换为 $F_L(u,v)$，原始图高通滤波后的傅里叶变换为 $F_H(u,v)$ </li><li>则高频提升滤波结果 $G_{HB}(u,v)=AF(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v)$ <ul><li>当 A=1 时，就是普通的高通滤波</li><li>当 A&gt;1 时，原始图的一部分与高通图相加，恢复了部分高通滤波时丢失的低频分量，使得最终结果与原图更接近</li></ul></li><li>因为低通滤波常使图像模糊，所以一般从原始图中减去模糊图也称为（非锐化）掩模</li></ul></li></ul><h1 id="带通和带阻滤波"><a href="#带通和带阻滤波" class="headerlink" title="带通和带阻滤波"></a>带通和带阻滤波</h1><ul><li>带通滤波和带阻滤波都属于选择性滤波</li></ul><h2 id="带阻滤波"><a href="#带阻滤波" class="headerlink" title="带阻滤波"></a>带阻滤波</h2><ul><li>阻止一定频率范围内的信号通过而允许其他频率范围内的信号通过<ul><li>如果下限是 0 (上限不为 $\infty$) $\rightarrow$ 高通滤波</li><li>如果上限是 $\infty$ (下限不为 0) $\rightarrow$ 低通滤波</li></ul></li><li>带阻滤波器设计成能除去以原点为中心的一定频率范围内的信号<ul><li>$H(u,v)=\begin{cases} 1 &amp; D(u,v) \lt D_d-W/2 \\<br>  0 &amp; D_d-W/2 \leq D(u,v) \leq D_d+W/2 \\<br>  1 &amp; D(u,v) \gt D_d+W/2 \end{cases}$ </li><li>其中 $W$ 为带的宽度，$D_d$ 为带中心到频率平面原点的距离</li><li><img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/带阻滤波转移函数剖面图.png" alt></li><li><img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/放射对称的带阻滤波透视图.png" alt></li></ul></li><li>巴特沃斯带阻滤波器的转移函数为 $H(u,v)=\cfrac{1}{1+\left[\cfrac{D(u,v)W}{D^2(u,v)-D_d^2}\right]^{2n}}$ <ul><li>在 $D_d-W/2$ 处的上升沿比较陡而在 $D_d+W/2$ 处的上升沿要缓一些</li></ul></li></ul><h2 id="带通滤波"><a href="#带通滤波" class="headerlink" title="带通滤波"></a>带通滤波</h2><ul><li>允许一定频率范围内的信号通过而阻止其他频率范围内的信号通过<ul><li>如果下限是 0 (上限不为 $\infty$) $\rightarrow$ 低通滤波</li><li>如果上限是 $\infty$ (下限不为 0) $\rightarrow$ 高通滤波</li></ul></li><li>带通滤波器和带阻滤波器是互补的<ul><li>设 $H_R(u,v)$ 为带阻滤波器的转移函数</li><li>则对应的带通滤波器 $H_P(u,v)$ 只需将 $H_R(u,v)$ 翻转即可</li><li>$H_P(u,v)=-[H_R(u,v)-1]=1-H_R(u,v)$ </li></ul></li></ul><h2 id="陷波滤波"><a href="#陷波滤波" class="headerlink" title="陷波滤波"></a>陷波滤波</h2><ul><li>能通过或阻断在频率域上某点周围预先确定的邻域中的频率</li><li>零相移的滤波器相对于原点是对称的<ul><li>中心在 $(u_0,v_0)$ 的陷波有一个对应的中心在 $(-u_0,-v_0)$ 的陷波</li><li>陷波器必须两两对称地工作</li></ul></li><li>带阻陷波器由其中心转到陷波中心的高通滤波器的乘积来获得<ul><li>通用形式 $H_{NR}(u,v)=\prod_{k=1}^Q H_k(u,v)H_{-k}(u,v)$ </li><li>其中 $H_k(u,v)$ 和 $H_{-k}(u,v)$ 分别是中心在 $(u_0,v_0)$ 和 $(-u_0,-v_0)$ 的高通滤波器</li></ul></li><li>如果频域中心为 $(M/2,N/2)$，则距离函数<ul><li>$D_k(u,v)=\sqrt{(u-M/2-u_k)^2+(v-N/2-v_k)^2}$ </li><li>$D_{-k}(u,v)=\sqrt{(u-M/2+u_k)^2+(v-N/2+v_k)^2}$ </li></ul></li><li>一个用于消除以 $(u_0,v_0)$ 为中心、$D_0$ 为半径的区域内所有频率的理想阻断陷波器的转移函数为 $H(u,v)=\begin{cases} 0 &amp; D_k(u,v) \leq D_0 或 D_{-k}(u,v) \leq D_0 \\<br>  1 &amp; \text{其他} \end{cases}$ </li><li><img src="/2019/10/20/frequency-domain-enhancement-by-book-image-processing/理想带阻陷波器和带通陷波器透视图.png" alt></li></ul><h1 id="同态滤波"><a href="#同态滤波" class="headerlink" title="同态滤波"></a>同态滤波</h1>]]></content>
      
      
      <categories>
          
          <category> 《图像处理》章毓晋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（10）红黑树</title>
      <link href="/2019/08/13/red-black-tree.html"/>
      <url>/2019/08/13/red-black-tree.html</url>
      
        <content type="html"><![CDATA[<h1 id="Balanced-search-tree-平衡搜索树"><a href="#Balanced-search-tree-平衡搜索树" class="headerlink" title="Balanced search tree (平衡搜索树)"></a>Balanced search tree (平衡搜索树)</h1><ul><li>A search-tree data structure maintaining dynamic set of n elements using tree of height O(lgn).</li><li>Examples:<ul><li>AVL trees (AVL树)</li><li>2-3 trees</li><li>2-3-4 trees</li><li>B-trees (B树)</li><li>Red-black trees (红黑树)</li><li>Skip lists (跳跃表)</li><li>Treaps (treap树)</li></ul></li></ul><h1 id="Red-black-tree-红黑树"><a href="#Red-black-tree-红黑树" class="headerlink" title="Red-black tree (红黑树)"></a>Red-black tree (红黑树)</h1><ul><li>内容参考<ul><li><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a></li></ul></li></ul><h2 id="Red-black-properties-红黑性质"><a href="#Red-black-properties-红黑性质" class="headerlink" title="Red-black properties (红黑性质)"></a>Red-black properties (红黑性质)</h2><ul><li>Red-black tree is a BST data structure with <strong>extra color field</strong> for each node, satisfying <code>red-black properties</code>:<ol><li>Every node is either red or black.</li><li>The root is black.</li><li>Every leaf (NIL) is black.</li><li>Every red node has two black children. (红色节点的孩子和父亲都不能是红色, 不能有两个连续的红色结点)</li><li>Every simple path from a node x to a descendant leaf contains the same number of black nodes [= <strong>black-height(x)</strong> (不包含出发结点)].</li></ol></li><li><img src="/2019/08/13/red-black-tree/red-black-properties.png" alt></li></ul><h2 id="Height-of-a-red-black-tree"><a href="#Height-of-a-red-black-tree" class="headerlink" title="Height of a red-black tree"></a>Height of a red-black tree</h2><ul><li>Theorem<ul><li>A red-black tree with $n$ keys has height $h ≤ 2 \lg (n+1)$.</li></ul></li><li>Intuition<ul><li>Merge red nodes into their black parents.<ul><li><img src="/2019/08/13/red-black-tree/height-of-red-black-tree.png" alt></li></ul></li><li>This process produces a <code>2-3-4 tree</code>.<ul><li>Every internal node has 2, 3, or 4 children.</li><li>Every leaf has the same depth namely black-height(root).</li></ul></li><li>The number of leaves in each tree is $n+1$.<ul><li>⇒ $2^{h’} ≤ n+1$</li><li>⇒ $h’ ≤ \lg (n+1)$</li></ul></li><li>At most 1/2 of nodes on any root to leaf path are red.<ul><li>⇒ $h ≤ 2h’$</li><li>⇒ $h ≤ 2 \lg (n+1)$</li></ul></li></ul></li><li>Corollary<ul><li>Red-black trees ensure that no such path from the root to a leaf is more than twice as long as any other, so that the tree is approximately balanced. (最长路径不超过最短路径的 2 倍，达到近似平衡的状态)</li><li>The queries (查询操作) <code>SEARCH</code>, <code>MINIMUM</code>, <code>MAXIMUM</code>, <code>SUCCESSOR</code> and <code>PREDECESSOR</code> all run in O(lgn) time on a red-black tree with n nodes.</li></ul></li></ul><h1 id="Modifying-operations-修改操作"><a href="#Modifying-operations-修改操作" class="headerlink" title="Modifying operations (修改操作)"></a>Modifying operations (修改操作)</h1><ul><li>The operations <code>INSERT</code> and <code>DELETE</code> cause modifications to the red-black tree.</li><li>How to restore red-black properties:<ul><li>BST operation</li><li>Color changes (变色)</li><li>Restructuring the links of the tree via <code>rotations</code> (旋转)<ul><li>Left rotations (左旋)</li><li>Right rotations (右旋)</li></ul></li></ul></li></ul><h2 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h2><ul><li><img src="/2019/08/13/red-black-tree/rotations.png" alt></li><li>Rotations preserves the inorder ordering of keys.<ul><li>$a ∈ α, b ∈ β, c ∈ γ \quad\Rightarrow\quad a ≤ A ≤ b ≤ B ≤ c$</li></ul></li><li>A rotation can be performed in $O(1)$ time.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Left-Rotate(T, x)</span><br><span class="line">    y = x.right</span><br><span class="line">    x.right = y.left</span><br><span class="line">    <span class="keyword">if</span> y.left != T.nil</span><br><span class="line">        y.left.parent = x</span><br><span class="line">    y.parent = x.parent</span><br><span class="line">    <span class="keyword">if</span> x.parent == T.nil</span><br><span class="line">        T.root = y</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">        x.parent.left = y</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x.parent.right = y</span><br><span class="line">    y.left = x</span><br><span class="line">    x.parent = y</span><br></pre></td></tr></table></figure><h1 id="Insertion-into-a-red-black-tree"><a href="#Insertion-into-a-red-black-tree" class="headerlink" title="Insertion into a red-black tree"></a>Insertion into a red-black tree</h1><ul><li>IDEA<ul><li>Insert x in tree. (BST serach, 查找插入的位置)</li><li>Color x red. (插入红色结点，在父结点(如果存在)为黑色时不会破坏黑平衡，但如果插入结点是黑色，插入位置所在的子树黑色结点总是多 1，必须做自平衡)</li><li>Only red-black property 4 might be violated.</li><li>Move the violation up the tree by recoloring until it can be fixed with rotations and recoloring.</li></ul></li><li>Example<ul><li><img src="/2019/08/13/red-black-tree/rb-insertion-1.png" alt></li><li>Insert x = 15.</li><li><img src="/2019/08/13/red-black-tree/rb-insertion-2.png" alt></li><li>Recolor, moving the violation up the tree.</li><li><img src="/2019/08/13/red-black-tree/rb-insertion-3.png" alt></li><li>Right-Rotate(18).</li><li><img src="/2019/08/13/red-black-tree/rb-insertion-4.png" alt></li><li>Left-Rotate(7) and recolor.</li><li><img src="/2019/08/13/red-black-tree/rb-insertion-5.png" alt></li></ul></li></ul><h2 id="Insertion-cases"><a href="#Insertion-cases" class="headerlink" title="Insertion cases"></a>Insertion cases</h2><ul><li><img src="/2019/08/13/red-black-tree/rb-insertion-cases.png" alt></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RB_Insert(T, z)</span><br><span class="line">    y = T.nil</span><br><span class="line">    x = T.root</span><br><span class="line">    <span class="keyword">while</span> x != T.nil</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right</span><br><span class="line">    z.parent = y</span><br><span class="line">    <span class="keyword">if</span> y == T.nil</span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y.right = z</span><br><span class="line">    z.left = T.nil</span><br><span class="line">    z.right = T.nil</span><br><span class="line">    z.color = RED  //新插入结点标记为红色</span><br><span class="line">    RB_Insert_Fixup(T, z)  //进行调整，使得满足红黑树性质</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB_Insert_Fixup(T, z)</span><br><span class="line">    <span class="keyword">while</span> z.parent.color == RED</span><br><span class="line">        <span class="keyword">if</span> z.parent == z.parent.parent.left</span><br><span class="line">            y = z.parent.parent.right</span><br><span class="line">            <span class="keyword">if</span> y.color == RED                 // Case <span class="number">4.1</span></span><br><span class="line">                z.parent.color = BLACK</span><br><span class="line">                y.color = BLACK</span><br><span class="line">                z.parent.parent.color = RED</span><br><span class="line">                z = z.parent.parent</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> z == z.parent.right   // Case <span class="number">4.2</span><span class="number">.2</span></span><br><span class="line">                    z = z.parent</span><br><span class="line">                    Left-Rotate(T, z)</span><br><span class="line">                z.parent.color = BLACK        // Case <span class="number">4.2</span><span class="number">.1</span></span><br><span class="line">                z.parent.parent.color = RED</span><br><span class="line">                Right-Rotate(T, z.parent.parent)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    T.root.color = BLACK</span><br></pre></td></tr></table></figure><ul><li><strong>Case 4.1</strong>: the uncle of z is red<ul><li><img src="/2019/08/13/red-black-tree/rb-insertion-case4.1.png" alt></li><li>Push C’s black onto A and D, and recurs, since C’s parent may be red.</li></ul></li><li><strong>Case 4.2.2</strong>: the uncle of z is black and z is a right child<ul><li><img src="/2019/08/13/red-black-tree/rb-insertion-case4.2.2.png" alt></li><li>Transform to Case 4.2.1.</li></ul></li><li><strong>Case 4.2.1</strong>: the uncle of z is black and z is a left child<ul><li><img src="/2019/08/13/red-black-tree/rb-insertion-case4.2.1.png" alt></li></ul></li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><ul><li>Insert the node<ul><li>takes $O(\lg n)$ time.</li></ul></li><li>RB_Insert_Fixup<ul><li>Going up the tree performing Case 4.1 for the <code>while</code>, which only recolors nodes, takes $O(\lg n)$ time.</li><li>If Case 4.2.1 or Case 4.2.2 occurs, perform 1 or 2 rotations, and terminate the processing, taking $O(1)$ time.</li></ul></li><li><strong>RB_Insert Running time</strong><ul><li>$O(\lg n)$ with $O(1)$ rotations.</li></ul></li></ul><h1 id="Delete-a-red-black-tree-node"><a href="#Delete-a-red-black-tree-node" class="headerlink" title="Delete a red-black tree node"></a>Delete a red-black tree node</h1><ul><li>IDEA：<ul><li>Perform standard BST delete. <ol><li>Delete a leaf node: <ul><li>Reset its parent link to NIL.</li></ul></li><li>Delete a degree-1 node: <ul><li>Replace the node by its single child.</li></ul></li><li>Delete a degree-2 node: <ul><li>Replace the node by the largest one in its left subtree or the smallest one in its right subtree (choose the successor).</li><li>Delete the replacing node from the subtree.</li></ul></li></ol><ul><li>The <strong>replacing node</strong>, which is formally deleted, is leaf node or degree-1 node. </li><li>The final replacing node is must leaf node.</li></ul></li><li>Red-black properties 2, 4, 5 might be violated.<ol><li>If the deleted node is red, red-black properties is still satisfied.</li><li>If the deleted node id black, red-black property 5 must be violated.<ul><li>If the deleted black node is root and the replacing node is red, red-property 2 is violated.</li><li>If the deleted black node’s parent and non-empty child both are red, red-black property 4 is violated.</li></ul></li></ol></li><li>Like insertion, recoloring and rotations are used to maintain the red-black properties. <ul><li>In insert operation, we check color of <code>uncle</code> to decide the appropriate case, which maintains the <code>color</code> (bottom-up). </li><li>In delete operation, we check color of <code>sibling</code> (兄弟) to decide the appropriate case, which maintains the <code>black height</code> (top-down). </li></ul></li></ul></li></ul><h2 id="Deletion-cases"><a href="#Deletion-cases" class="headerlink" title="Deletion cases"></a>Deletion cases</h2><ul><li><img src="/2019/08/13/red-black-tree/rb-deletion-cases.png" alt></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RE-TRANSPLANT(T, u, v)</span><br><span class="line">    <span class="keyword">if</span> u.p == T.nil</span><br><span class="line">        T.root = v</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">        u.p.left = v</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u.p.right = v</span><br><span class="line">    v.p = u.p// v.p的赋值无条件执行，因为u是root时v.p是T.nil该赋值依然成立</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z)</span><br><span class="line">    y=z</span><br><span class="line">    y-original-color = y.color</span><br><span class="line">    <span class="keyword">if</span> z.left == T.nil</span><br><span class="line">        x = z.right</span><br><span class="line">        RB-TRANSPLANT(T, z, z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil</span><br><span class="line">        x = z.left</span><br><span class="line">        RB-TRANSPLANT(T, z, z.left)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = TREE-MINIMUM(z.right)</span><br><span class="line">        x = y.right</span><br><span class="line">        <span class="keyword">if</span> y.p == z</span><br><span class="line">            x.p = y</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            RB-TRANSPLANT(T, y, y.right)</span><br><span class="line">            y.right.p = y</span><br><span class="line">        RB-TRANSPLANT(T, z, y)</span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.p = y</span><br><span class="line">        y.color = z.color</span><br><span class="line">    <span class="keyword">if</span> y-original-color == BLACK</span><br><span class="line">        RE-DELETE-FIXUP(T, x)// 若y原本是黑色则移走y后原本包含y路径的黑高会改变导致破坏红黑树性质</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x)</span><br><span class="line">    <span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK</span><br><span class="line">        <span class="keyword">if</span> x == x.p.left</span><br><span class="line">            w = x.p.right</span><br><span class="line">            <span class="keyword">if</span> w.color == RED</span><br><span class="line">                w.color = BLACK             // case <span class="number">2.1</span><span class="number">.1</span></span><br><span class="line">                x.p.color = RED</span><br><span class="line">                LEFT-ROTATE(T, x, p)</span><br><span class="line">                w = x.p.right</span><br><span class="line">            <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK</span><br><span class="line">                w.color = RED               // case <span class="number">2.1</span><span class="number">.2</span><span class="number">.3</span></span><br><span class="line">                x = x.p</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK</span><br><span class="line">                    w.left.color = BLACK        // case <span class="number">2.1</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">                    w.color = RED</span><br><span class="line">                    RIGHT-ROTATE(T, w)</span><br><span class="line">                    w = x.p.right</span><br><span class="line">                w.color = x.p.color             // case <span class="number">2.1</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">                x.p.color = BLACK</span><br><span class="line">                w.right.color = BLACK</span><br><span class="line">                LEFT-ROTATE(T, x, p)</span><br><span class="line">                x = T.root</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    x.color = BLACK// case <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>Case 2.1.1: the sibling of replacing node is red<ul><li><img src="/2019/08/13/red-black-tree/rb-deletion-case-2.1.1.png" alt></li><li>Transform to case 2.1.2.3.</li></ul></li><li>Case 2.1.2.3: the sibling is black and its child both are black<ul><li><img src="/2019/08/13/red-black-tree/rb-deletion-case-2.1.2.3.png" alt></li></ul></li><li>Case 2.1.2.2: the sibling is black, its left child is red and its right child is black<ul><li><img src="/2019/08/13/red-black-tree/rb-deletion-case-2.1.2.2.png" alt></li></ul></li><li>Case 2.1.2.1: the sibling is black and its right child is red<ul><li><img src="/2019/08/13/red-black-tree/rb-deletion-case-2.1.2.1.png" alt></li></ul></li></ul><h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><ul><li>delete the node<ul><li>takes $O(\lg n)$ time.</li></ul></li><li>RB_Delete_Fixup<ul><li>Going up the tree performing Case 2.1.2.3 for the <code>while</code> takes $O(\lg n)$ time.</li><li>Constant times recoloring and at most 3 times rotations takes $O(1)$ time.</li></ul></li><li><strong>RB_Delete Running time</strong><ul><li>Always $O(\lg n)$.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 平衡搜索树 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（9）二叉搜索树</title>
      <link href="/2019/08/09/binary-search-tree.html"/>
      <url>/2019/08/09/binary-search-tree.html</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-binary-search-tree-BST"><a href="#What-is-binary-search-tree-BST" class="headerlink" title="What is binary search tree (BST)?"></a>What is binary search tree (BST)?</h1><ul><li>Properties:<ul><li>Each node x in the binary tree has a key key(x).</li><li>Nodes other than the root have a parent p(x).</li><li>Nodes may have a left child left(x) and/or a right child right(x). These are pointers unlike in a heap.</li><li>The invariant is: For any node x, for all nodes y in the left subtree of x, key(y) ≤ key(x). For all nodes y in the right subtree of x, key(y) ≥ key(x).</li></ul></li><li>BST can output the key in particular order recursively.<ul><li>Inorder tree walk (中序遍历)</li><li>Preorder tree walk (先序遍历)</li><li>Postorder tree walk (后序遍历)</li><li>Traversing a binary tree with n nodes takes  Θ(n) time.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Inorder-Tree-Walk(x)</span><br><span class="line">    <span class="keyword">if</span> x != NIL</span><br><span class="line">        Inorder-tree-walk(x.left)</span><br><span class="line">        <span class="keyword">print</span> x.key</span><br><span class="line">        Inorder-tree-walk(x.right)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="BST-operations"><a href="#BST-operations" class="headerlink" title="BST operations"></a>BST operations</h1><h2 id="Insertion-into-BST"><a href="#Insertion-into-BST" class="headerlink" title="Insertion into BST"></a>Insertion into BST</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Tree-Insert(T, val)</span><br><span class="line">    y = NIL</span><br><span class="line">    x = T.root</span><br><span class="line">    <span class="keyword">while</span> x != NIL</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> val.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right</span><br><span class="line">    val.parent = y</span><br><span class="line">    <span class="keyword">if</span> y == NIL</span><br><span class="line">        T.root = val</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> val.key &lt; y.key</span><br><span class="line">        y.left = val</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y.right = val</span><br></pre></td></tr></table></figure><ul><li><img src="/2019/08/09/binary-search-tree/insertion.png" alt></li></ul><h2 id="Query-BST"><a href="#Query-BST" class="headerlink" title="Query BST"></a>Query BST</h2><h3 id="Finding-a-value-in-the-BST-if-it-exist"><a href="#Finding-a-value-in-the-BST-if-it-exist" class="headerlink" title="Finding a value in the BST if it exist"></a>Finding a value in the BST if it exist</h3><ul><li>Follow left and right pointers until you find it or hit NIL.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tree-Search(x, k) <span class="comment"># recursion</span></span><br><span class="line">    <span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">        <span class="keyword">return</span> Tree-Search(x.left, k)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Tree-Search(x.right, k)</span><br><span class="line">    </span><br><span class="line">Iterative-Tree-Search(x, k) <span class="comment"># iterative</span></span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> k != x.key</span><br><span class="line">        <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="Finding-the-minimum-maximum-element"><a href="#Finding-the-minimum-maximum-element" class="headerlink" title="Finding the minimum/maximum element"></a>Finding the minimum/maximum element</h3><ul><li>Go left/right till leaf.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tree-Minimum()</span><br><span class="line">    <span class="keyword">while</span> x.left != NIL</span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">Tree-Maximum()</span><br><span class="line">    <span class="keyword">while</span> x.right != NIL</span><br><span class="line">        x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="Finding-the-predecessor-前驱-and-successor-后继"><a href="#Finding-the-predecessor-前驱-and-successor-后继" class="headerlink" title="Finding the predecessor (前驱) and successor (后继)"></a>Finding the predecessor (前驱) and successor (后继)</h3><ul><li>If the right subtree of node x is nonempty, then the successor of x is just the left-most node in the right subtree.</li><li>if the right subtree of node x is empty and x has a successor y, then y is the lowest ancestor of x whose left child is also an ancestor of x.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Successor(x)</span><br><span class="line">    <span class="keyword">if</span> x.right != NIL</span><br><span class="line">        <span class="keyword">return</span> Tree-Minimum(x.right)</span><br><span class="line">    y = x.parent</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.right</span><br><span class="line">        x = y</span><br><span class="line">        y = y.parent</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><ul><li>If the left subtree of node x is nonempty, then the predecessor of x is just the right-most node in the left subtree.</li><li>if the left subtree of node x is empty and x has a predecessor y, then y is the lowest ancestor of x whose right child is also an ancestor of x.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Predecessor(x)</span><br><span class="line">    <span class="keyword">if</span> x.left != NIL</span><br><span class="line">        <span class="keyword">return</span> Tree-Maximum(x.left)</span><br><span class="line">    y = x.parent</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.left</span><br><span class="line">        x = y</span><br><span class="line">        y = y.parent</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="Delete-one-element"><a href="#Delete-one-element" class="headerlink" title="Delete one element"></a>Delete one element</h2><ul><li>If node z has no children, simply modify the field of its parent with NIL.</li><li>If node z has only a single child, delete z by making a new link between its child and its parent.</li><li>If node z has two children, find z’s successor y to replace z.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Transplant(T, u, v)</span><br><span class="line">    <span class="keyword">if</span> u.parent == NIL</span><br><span class="line">        T.root = v</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> u == u.parent.left</span><br><span class="line">        u.parent.left = v</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u.parent.right = v</span><br><span class="line">    <span class="keyword">if</span> v != NIL</span><br><span class="line">        v.parent = u.parent</span><br><span class="line"></span><br><span class="line">Tree-Delete(T, z)</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL</span><br><span class="line">        Transplant(T, z, z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == NIL</span><br><span class="line">        Transplant(T, z, z.left)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = Tree-Minimum(z.right)</span><br><span class="line">        <span class="keyword">if</span> y.parent != z</span><br><span class="line">            Transplant(T, y, y.right)</span><br><span class="line">            y.right = z.right</span><br><span class="line">            y.right.parent = y</span><br><span class="line">        Transplant(T, z, y)</span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.parent = y</span><br></pre></td></tr></table></figure><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><ul><li>All operations on dynamic sets are O(h)​ where h is height of the BST.</li></ul><h1 id="BST-sort"><a href="#BST-sort" class="headerlink" title="BST sort"></a>BST sort</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Binary-search-tree Sort(T)</span><br><span class="line">    T ← ∅        //Create an empty BST</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        do Tree-Insert(T, A[i])</span><br><span class="line">    Perform an inorder tree walk of T.</span><br></pre></td></tr></table></figure><ul><li><img src="/2019/08/09/binary-search-tree/BST-sort.png" alt></li><li>BST sort performs the same comparisons as quicksort, but in a different order!</li><li>The expected time to build the tree is asymptotically the same as the running time of quicksort.</li><li>Randomized BST sort<ol><li>Randomly permute the array A.</li><li>BST sort(A).</li></ol></li><li>E[running time(randomized BST sort)]<br>  = E[running time(randomized quicksort)]<br>  = Θ(nlgn)</li></ul><h2 id="Node-depth-节点深度"><a href="#Node-depth-节点深度" class="headerlink" title="Node depth (节点深度)"></a>Node depth (节点深度)</h2><ul><li>The depth of a node = the number of comparisons made during Tree-Insert.</li><li>Running time of BST sort = the sum of all node depths.</li><li>E[average node depth]<br>  = E[(1/n)sum(all node depths)]<br>  = (1/n)E[running time of BST sort]<br>  = Θ(nlgn)/n<br>  = Θ(lgn)</li></ul><h2 id="Expected-tree-height-树的期望高度"><a href="#Expected-tree-height-树的期望高度" class="headerlink" title="Expected tree height (树的期望高度)"></a>Expected tree height (树的期望高度)</h2><ul><li>Average node depth of a randomly built BST = O(lg n) <strong>does not necessarily mean</strong> that its expected height is also O(lgn).</li><li>although it is, proof below.</li><li><img src="/2019/08/09/binary-search-tree/expected-tree-height.png" alt></li></ul><h1 id="Randomly-build-BST"><a href="#Randomly-build-BST" class="headerlink" title="Randomly build BST"></a>Randomly build BST</h1><ul><li>Define a <strong>randomly built binary search tree</strong> on n distinct keys as one that arises from inserting the keys in random order into an initially empty tree.<ul><li>Each of the n! permutations of the input keys is equally likely.</li><li>Randomly built BST = tree resulting from randomized BST sort. (BST排序的结果树)</li></ul></li><li><strong>Theorem</strong><ul><li>The expected height of a randomly built binary tree on n keys is O(lgn).</li></ul></li></ul><h2 id="Outline-of-the-analysis"><a href="#Outline-of-the-analysis" class="headerlink" title="Outline of the analysis"></a>Outline of the analysis</h2><ul><li>Firstly, prove <code>Jensen&#39;s inequality</code>, which says that $f(E[X]) ≤ E[f(X)]$ for any convex function (下凸函数) $f$ and random variable $X$.</li><li>Secondly, analyze <code>the exponential height</code> of a randomly built BST on n nodes, which is the random variable $Y_n = 2^{X_n}$, where $X_n$ is the random variable denoting the height of the BST.</li><li>Thirdly, prove that $E[Y_n] = O(n^3)$.</li><li>At last, conclude that $2^{E[X_n]} ≤ E[2^{X_n}] = E[Y_n] = O(n^3)$, and hence that $E[X_n] = O(\lg n)$.</li></ul><h2 id="Jensen’s-inequality"><a href="#Jensen’s-inequality" class="headerlink" title="Jensen’s inequality"></a>Jensen’s inequality</h2><ul><li>Lemma<ul><li>Let $f$ be a convex function, and let $X$ be a random variable. Then, $f(E[X]) ≤ E[f(X)]$.</li></ul></li><li>Proof<ul><li>$\begin{equation}\begin{split}<br>  f(E[X]) &amp; = f \left( \sum_{k=-\infty}^\infty k \cdot Pr \{ X=k \} \right) \\<br>  &amp; \leq \sum_{k=-\infty}^\infty f(k) \cdot Pr \{ X=k \} \\<br>  &amp; = E(f(X))<br>  \end{split}\end{equation}$</li></ul></li></ul><h2 id="Analysis-of-BST-height"><a href="#Analysis-of-BST-height" class="headerlink" title="Analysis of BST height"></a>Analysis of BST height</h2><ul><li>Let $X_n$ be the random variable denoting the height of a randomly built BST on n nodes.</li><li>Let $Y_n = 2^{X_n}$ be its exponential height.</li><li>If the root of the tree has rank $k$, then $X_n = 1 + \max \{ X_{k-1}, X_{n-k} \}$, since each of the left and right subtrees of the root are randomly built. Hence, we have $Y_n = 2 \cdot \max \{ Y_{k-1}, Y_{n-k} \}$.</li><li>Define the indicator random variable $Z_{nk} = I \{ \text{root has the rank k} \}$, thus, $Pr \{ Z_{nk}=1 \} = E[Z_{nk}] = 1/n$.</li><li>$\begin{equation}\begin{split}<br>  E[Y_n] &amp; = E[\sum_{k=1}^n Z_{nk} (2 \cdot \max \{ Y_{k-1}, Y_{n-k} \})] \\<br>  &amp; = \sum_{k=1}^n E[Z_{nk} (2 \cdot \max \{ Y_{k-1}, Y_{n-k} \})] \\<br>  &amp; = 2 \sum_{k=1}^n E[Z_{nk}] \cdot E[\max \{ Y_{k-1}, Y_{n-k} \}] \\<br>  &amp; \leq {2 \over n} \sum_{k=1}^n E[Y_{k-1} + Y_{n-k}] \\<br>  &amp; = {4 \over n} \sum_{k=0}^{n-1} E[Y_k]<br>  \end{split}\end{equation}$</li><li>Use substitution to show that $E[Y_n] ≤ cn^3$ for some positive constant $c$, which we can pick sufficiently large to handle the initial conditions (base case).</li><li>$\begin{equation}\begin{split}<br>  E[Y_n] &amp; = {4 \over n} \sum_{k=0}^{n-1} E[Y_k] \\<br>  &amp; \leq {4 \over n} \sum_{k=0}^{n-1} ck^3 \\<br>  &amp; \leq {4c \over n} \int_0^n x^3 dx \\<br>  &amp; = {4c \over n} \cdot {n^4 \over 4} \\<br>  &amp; = cn^3<br>  \end{split}\end{equation}$</li><li>Putting it all together, we have $2^{E[X_n]} ≤ E[2^{X_n}] = E[Y_n] ≤ cn^3$.</li><li>Taking the $\lg$ of both sides yields, $E[X_n] ≤ 3 \lg n + c = 3 \lg n + O(1)$.</li></ul><h2 id="Some-words-at-last"><a href="#Some-words-at-last" class="headerlink" title="Some words at last"></a>Some words at last</h2><ul><li>Why bother with analyzing exponential height? Why not just develop the recurrence on $X_n = 1 + \max \{ X_{k-1}, X_{n-k} \}$ directly?<ul><li>The inequality $\max \{ a, b \} ≤ a + b$ provides a poor upper bound, since the RHS approaches the LHS slowly as |a – b| increases.</li><li>The bound $\max \{ 2^a, 2^b \} ≤ 2^a + 2^b$ allows the RHS to approach the LHS far more quickly as |a – b| increases.</li><li>By using the convexity of $f(x) = 2^x$ via Jensen’s inequality, we can manipulate the sum of exponential, resulting in a tight analysis.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（8）散列表</title>
      <link href="/2019/08/08/hash-table.html"/>
      <url>/2019/08/08/hash-table.html</url>
      
        <content type="html"><![CDATA[<h1 id="Symbol-table-problem-符号表问题"><a href="#Symbol-table-problem-符号表问题" class="headerlink" title="Symbol-table problem (符号表问题)"></a>Symbol-table problem (符号表问题)</h1><ul><li>Table S holding n records</li><li><img src="/2019/08/08/hash-table/symbol-table-problem.png" alt></li><li>Operations on S:<ul><li><code>INSERT(S, x)</code>: S ← S ∪ {x}</li><li><code>DELETE(S, x)</code>: S ← S - {x}</li><li><code>SEARCH(S, k)</code>: return x such that key[x] = k, or return nil (无)  if no such x.</li></ul></li></ul><h1 id="Direct-access-table-直接寻址表"><a href="#Direct-access-table-直接寻址表" class="headerlink" title="Direct-access table (直接寻址表)"></a>Direct-access table (直接寻址表)</h1><ul><li>Suppose that keys are drawn from universe (全域) <code>U = {0, 1, 2, ... , m-1}</code>.</li><li>Assume that keys are distinct.</li><li>Set up an array <code>T[0..m-1]</code> to represent the dynamic set <code>S</code></li><li>$T(k) = \begin{cases}<br>  x &amp; \text{if $x \in S$ and $key[x] = k$} \\<br>  \text{NIL} &amp; \text{otherwise}<br>  \end{cases}$</li><li>Operations takes $\Theta(1)$ time.</li><li>Problem: The range of keys can be large.<ul><li>64-bit numbers (which represent 18,446,744,073,709,551,616 different keys)</li><li>character strings (even larger!)</li></ul></li></ul><h1 id="Hash-table-散列表-哈希表"><a href="#Hash-table-散列表-哈希表" class="headerlink" title="Hash table (散列表/哈希表)"></a>Hash table (散列表/哈希表)</h1><ul><li>Use a <strong>hash function</strong> (哈希函数) <code>h</code> to map keys “randomly” into slots (槽) of table T.</li><li><img src="/2019/08/08/hash-table/hash-function-example.jpg" alt></li><li>When a record to be inserted maps to an already occupied slot in T, a <strong>collision</strong> (冲突) occurs.</li></ul><h2 id="Resolving-collisions-by-chaining-通过链接法解决冲突"><a href="#Resolving-collisions-by-chaining-通过链接法解决冲突" class="headerlink" title="Resolving collisions by chaining (通过链接法解决冲突)"></a>Resolving collisions by chaining (通过链接法解决冲突)</h2><ul><li>IDEA: link records in same slot into a list.</li><li><img src="/2019/08/08/hash-table/chaining.png" alt></li></ul><h2 id="Analysis-of-chaining"><a href="#Analysis-of-chaining" class="headerlink" title="Analysis of chaining"></a>Analysis of chaining</h2><ul><li>Worst-case<ul><li>Every key hashes to same slot. </li><li>Access takes $\Theta(n)$ time if $|S|  = n$.</li></ul></li><li>Average-case<ul><li>Assumption of simple <strong>uniform hashing</strong> (简单均匀哈希). </li><li>Each key $k \in S$ is equally likely to be hashed to any slot of table T, independent of where other keys are hashed.</li><li>Define the <strong>load factor</strong> (装载因子) of a hash table with $n$ keys and $m$ slots is $\alpha = n/m$ = average numbers of keys per slot.</li><li>Expected unsuccessful search time = $\Theta(1 + \alpha)$.</li><li><img src="/2019/08/08/hash-table/chaining-unsuccessful-search.png" alt></li><li>Actually, expected successful search time = $\Theta(1 + \alpha)$.</li><li><img src="/2019/08/08/hash-table/chaining-successful-search.png" alt></li><li>Expected search time = $\Theta(1)$ if $\alpha = O(1)$, or equivalently, if $n = O(m)$.</li></ul></li></ul><h1 id="Choosing-a-hash-function"><a href="#Choosing-a-hash-function" class="headerlink" title="Choosing a hash function"></a>Choosing a hash function</h1><ul><li>The assumption of simple uniform hashing is hard to guarantee, but several common techniques tend to work well in practice as long as their deficiencies can be avoided.</li><li>A good hash function should distribute the keys uniformly into the slots of the table.</li><li>Regularity in the key distribution should not affect this uniformity.</li></ul><h2 id="Division-method-除法散列法"><a href="#Division-method-除法散列法" class="headerlink" title="Division method (除法散列法)"></a>Division method (除法散列法)</h2><ul><li>$h(k) = k \mod m$</li><li><strong>Don’t pick m with small divisor d.</strong> A preponderance of keys that are congruent modulo d (同余模 d) can adversely affect uniformity.</li><li>If $m = 2^r$, then the hash doesn’t depend on all the bits of $k$.</li><li><img src="/2019/08/08/hash-table/division-method.png" alt></li><li>Pick m to be a prime (质数) but not too close to a power of 2 or 10.</li><li>But it is inconvenient to find a prime number, and division is slow.</li></ul><h2 id="Multiplication-method-乘法散列法"><a href="#Multiplication-method-乘法散列法" class="headerlink" title="Multiplication method (乘法散列法)"></a>Multiplication method (乘法散列法)</h2><ul><li>Assume that all keys are integers, $m = 2^r$, and our computer has <strong>w-bit words</strong>.</li><li>$h(k) = [(A \cdot k) \mod 2^w] &gt;&gt; (w − r)$</li><li>$A$ is odd (奇数), $2^{w-1} &lt; a &lt; 2^w$, $A$ is not too close to $2^{w-1}$ or $2^w$.</li><li><img src="/2019/08/08/hash-table/multiplication-method-1.png" alt></li><li><img src="/2019/08/08/hash-table/multiplication-method-2.png" alt></li><li>Multiplication and bit extraction are faster than division.</li></ul><h1 id="Resolving-collisions-by-open-addressing-开放寻址法"><a href="#Resolving-collisions-by-open-addressing-开放寻址法" class="headerlink" title="Resolving collisions by open addressing (开放寻址法)"></a>Resolving collisions by open addressing (开放寻址法)</h1><ul><li>No storage for links. (没有链表) </li><li>Probe table systematically until an empty slot is found.</li><li>The hash function depends on both the key (关键字) and probe number (探查号) .</li><li>$h: U \times \{0, 1, \cdots, m-1 \}  \rightarrow \{ 0, 1, \cdots, m-1 \}$</li><li>The probe sequence $\langle h(k,0), h(k,1), \cdots, h(k,m-1) \rangle$ should be a permutation of $\{ 0, 1, \cdots, m-1 \}$.</li><li>The table may fill up (溢出) , and deletion is difficult (but not impossible).</li><li><img src="/2019/08/08/hash-table/open-addressing.jpg" alt></li><li>Search uses the same probe sequence.<ul><li>Terminating successfully if it finds the key.</li><li>Terminating unsuccessfully if it encounters an empty slot.</li></ul></li></ul><h2 id="Probing-strategies"><a href="#Probing-strategies" class="headerlink" title="Probing strategies"></a>Probing strategies</h2><ul><li><strong>Linear probing 线性探查)</strong><ul><li>$h(k, i) = [h’(k) + i] \mod m$</li><li>This method, though simple, suffers from <strong>primary clustering (一次群集)</strong>, where long runs of filled slots build up, increasing the average search time.</li></ul></li><li><strong>Quadratic probing (二次探查)</strong><ul><li>$h(k, i) = [h’(k) + c_1 i + c_2 i^2] \mod m$</li><li>This method suffers from <strong>secondary clustering</strong> (二次群集，初始探测位置相同的关键字的探查序列也是相同的).</li></ul></li><li><strong>Double hashing (双重散列)</strong><ul><li>$h(k, i) = [h_1(k) + i \cdot h_2(k)] \mod m$</li><li>This method generally produces excellent results, but $h_2(k)$ must be relatively prime to $m$.</li><li>One way is to make  $m = 2^r$ and design $h_2(k)$ to produce only odd numbers (奇数).</li><li>The other way is to make $m$ prime number and design $h_2(k)$ to produce integers smaller than $m$.</li></ul></li></ul><h2 id="Analysis-of-open-addressing"><a href="#Analysis-of-open-addressing" class="headerlink" title="Analysis of open addressing"></a>Analysis of open addressing</h2><ul><li>Make the assumption of uniform hashing<ul><li>Each key is equally likely to have any one of the m! permutations as its probe sequence, independent of other keys.</li></ul></li><li><strong>Theorem</strong><ul><li>Given an open-addressed hash table with load factor $\alpha = n/m &lt; 1$, the expected number of probes in an unsuccessful search is at most $1/(1–\alpha)$.</li></ul></li><li>Proof<ul><li>At least one probe is always necessary.</li><li>With probability $n/m$, collision makes a second probe.</li><li>With probability $(n-1)/(m-1)$, collision makes a third probe.</li><li>Observe that $(n-i)/(m-i) &lt; n/m = \alpha$ for $i = 1, 2, \cdots, n-1$.</li><li>Therefore, the expected number of probes is</li><li>$\begin{equation}\begin{split}<br>  E[\text{probe number}] &amp; = 1 + {n \over m} \left( 1 + {n-1 \over m-1} \left( 1 + {n-2 \over m-2} \left( \cdots \left( 1 + {1 \over m-n+1} \right) \cdots \right) \right) \right) \\<br>  &amp; \leq 1 + \alpha \left( 1 + \alpha \left( 1 + \alpha \left( \cdots \left( 1 + \alpha \right) \cdots \right) \right) \right) \\<br>  &amp; = 1 + \alpha + \alpha^2 + \alpha^3 + \cdots \\<br>  &amp; = \sum_{i=0}^\infty \alpha^i \\<br>  &amp; = {1 \over 1-\alpha}<br>  \end{split}\end{equation}$</li></ul></li><li><strong>Implication of the theorem</strong><ul><li>If $\alpha$ is constant, accessing an open-addressed hash table takes $O(1)$ time.</li></ul></li></ul><h1 id="Universal-hashing-全域哈希"><a href="#Universal-hashing-全域哈希" class="headerlink" title="Universal hashing (全域哈希)"></a>Universal hashing (全域哈希)</h1><ul><li><strong>Definition</strong><ul><li>Let $U$ be a universe of keys, and let $\mathcal{H}$ be a finite collection (有限集) of hash functions mapping $U$ to $\{0, 1, \cdots, m-1\}$. We say $\mathcal{H}$ is universal if for all $x, y \in U$, where $x \not= y$, we have $|\{h: h \in \mathcal{H}, h(x) = h(y)\}| \leq |\mathcal{H}|/m$. That is, if $h$ is chosen randomly from $\mathcal{H}$, the probability of collision between x and y is no more than $1/m$.</li></ul></li><li>Universality id good.<ul><li><strong>Theorem</strong><ul><li>Choose hash function h randomly from universal set $\mathcal{H}$. Suppose hashing n keys into m slots in table T. Then, for a given key x, $E[\text{collision with x}] &lt; n/m$.</li></ul></li><li><strong>Proof</strong><ul><li>Let $C_x$ be the random variable denoting the total number of collisions of keys in T with x, and let $c_{xy} = I \{ h(x)=h(y) \}$.</li><li>$\begin{equation}\begin{split}<br>  E[C_x] &amp; = E[\sum_{y \in T - \{ x \}} c_{xy}] \\<br>  &amp; = \sum_{y \in T - \{ x \}} E[c_{xy}] \\<br>  &amp; \leq \sum_{y \in T - \{ x \}} {1 \over m} \\<br>  &amp; = {n-1 \over m}<br>  \end{split}\end{equation}$</li></ul></li></ul></li></ul><h2 id="Constructing-a-set-of-universal-hash-functions"><a href="#Constructing-a-set-of-universal-hash-functions" class="headerlink" title="Constructing a set of universal hash functions"></a>Constructing a set of universal hash functions</h2><ul><li>Let $m$ be prime. Decompose key $k$ into $r+1$ digits: $k = \langle k_0, k_1, \cdots, k_r \rangle$, where $0 \leq k_i \leq m-1$.</li><li>Randomized strategy<ul><li>Pick $a = \langle a_0, a_1, \cdots, a_r \rangle$, each $a_i$ is chosen randomly from $\{ 0, 1, \cdots, m-1 \}$.</li><li>Define $h_a(k) = \sum_{i=0}^r a_i k_i \mod m, \quad |\mathcal{H}| = m^{r+1}$</li><li>Theorem: $\mathcal{H}$ is universal.</li></ul></li><li>Proof<ul><li>Suppose that $x = \langle x_0, x_1, \cdots, x_r \rangle$ and $y = \langle y_0, y_1, \cdots, y_r \rangle$ are distinct keys. Thus, they differ in at least one digit, without loss of generality position 0.（不失一般性，选择第0位不同）For how many $h_a \in H$ do x and y collide?</li><li>We must have $h_a(x) = h_a(y)$</li><li>$\Longrightarrow \quad \sum_{i=0}^r a_i x_i \equiv \sum_{i=0}^r a_i y_i \quad (\text{mod $m$})$</li><li>$\Longrightarrow \quad a_0(x_0 - y_0) + \sum_{i=1}^r a_i(x_i - y_i) \equiv 0 \quad (\text{mod $m$})$</li><li>$\Longrightarrow \quad a_0(x_0 - y_0) \equiv -\sum_{i=1}^r a_i(x_i - y_i) \quad (\text{mod $m$})$</li><li>since $x_0 \not= y_0$, an inverse $(x_0 - y_0)^{-1}$ must exist</li><li>$\Longrightarrow \quad a_0 \equiv [ - \sum_{i=1}^r a_i (x_i - y_i) ] (x_0 - y_0)^{-1} \quad (\text{mod $m$})$</li><li>Thus, for any choice of $a_1, a_2, \cdots, a_r$, exactly one choice of $a_0$ cause x and y to collide, and no collision for other $m-1$ choice for $a_0$.</li><li>Thus, the number of $h_a$’s that cause x and y to collide is $m^r = |\mathcal{H}|/m$.</li></ul></li></ul><h2 id="Construct-another-set-of-universal-hash-functions"><a href="#Construct-another-set-of-universal-hash-functions" class="headerlink" title="Construct another set of universal hash functions"></a>Construct another set of universal hash functions</h2><ul><li><img src="/2019/08/08/hash-table/universal-hashing-1.png" alt></li><li><img src="/2019/08/08/hash-table/universal-hashing-2.png" alt></li></ul><h1 id="Perfect-hashing-完全哈希"><a href="#Perfect-hashing-完全哈希" class="headerlink" title="Perfect hashing (完全哈希)"></a>Perfect hashing (完全哈希)</h1><ul><li>Problem<ul><li>Given n keys, construct a static hash table of size $m = O(n)$, such that search takes $O(1)$ time in the worst case.</li></ul></li><li>IDEA<ul><li>Use <strong>2-level scheme</strong> (双级结构) with universal hashing at both levels.</li></ul></li><li>No collisions at level-2 (secondary hash table, 二次散列表).</li><li><img src="/2019/08/08/hash-table/perfect-hashing.png" alt></li><li>If $n_i$ items hash to a level-1 slot i, then use $m_i = n_i^2$ slots in level-2 hash table $S_i$.</li></ul><h2 id="Level-2-analysis"><a href="#Level-2-analysis" class="headerlink" title="Level-2 analysis"></a>Level-2 analysis</h2><ul><li><strong>Theorem</strong><ul><li>Hash n keys into $m = n^2$ slots using random $h$ in universal $\mathcal{H}$, the expected number of collisions is less than 1/2​.</li></ul></li><li><strong>Proof</strong> <ul><li>By the definition of universality, the probability that 2 given keys in the table collide under h is $1/m = 1/n^2$.</li><li>Since there are $\mathrm{C}_n^2$ pairs of keys that can possibly collide, the expected number of collisions is $\mathrm{C}_2^n \cdot {1 \over n^2} = {n(n-1) \over 2} \cdot {1 \over n^2} &lt; {1 \over 2}$.</li></ul></li><li><strong>Corollary</strong><ul><li>The probabilty of no collision ia at least 1/2.</li></ul></li><li><strong>Proof</strong><ul><li>Markov’s inequality (马尔可夫不等式)<ul><li>For any non-negative random variable $X$, we have $Pr \{ X \geq t \} \leq E(X) /t$.</li><li>$Pr \{ \text{collision} \geq 1 \} \leq E[\text{collision}]/1 &lt; 1/2$</li></ul></li></ul></li><li>Thus, to find a good level-2 hash function, just test a few at random. We will quickly find one that works since at least 1/2 will work.</li></ul><h2 id="Analysis-of-storage"><a href="#Analysis-of-storage" class="headerlink" title="Analysis of storage"></a>Analysis of storage</h2><ul><li>For the level-1 hash table T, choose $m = n$, and let $n_i$ be random variable for the number of keys that hash to slot $i$ in T. Use $m_i = n_i^2$ slots for the level-2 hash table $S_i$.</li><li>$\begin{equation}\begin{split}<br>  E[\text{total storage}] &amp; = n + E[\sum_{i=0}^{m-1} n_i^2] \\<br>  &amp; = n + E[\sum_{i=0}^{m-1} (n_i + 2 \mathrm{C}_{n_i}^2)] \\<br>  &amp; = n + E[\sum_{i=0}^{m-1} n_i] + 2 E[\sum_{i=0}^{m-1} \mathrm{C}_{n_i}^2] \quad\text{和式正是散列表中发生冲突的关键字的总对数} \\<br>  &amp; \leq 2n + 2 \mathrm{C}_n^2 {1 \over m} \\<br>  &amp; = 2n + 2 {n(n-1) \over 2m} \\<br>  &amp; = 3n-1 \\<br>  &amp; = \Theta(n)<br>  \end{split}\end{equation}$</li><li>The analysis is identical to the analysis from recitation of the expected running time of bucket sort.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（7）动态集合与基本数据结构</title>
      <link href="/2019/08/04/dynamic-set-and-elementary-data-structure.html"/>
      <url>/2019/08/04/dynamic-set-and-elementary-data-structure.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dynamic-Sets-动态集合"><a href="#Dynamic-Sets-动态集合" class="headerlink" title="Dynamic Sets (动态集合)"></a>Dynamic Sets (动态集合)</h1><ul><li>Dynamic sets are data structures that support some or all the following operations: </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Operation</th><th style="text-align:center">Effect</th></tr></thead><tbody><tr><td style="text-align:center">Search(S, k)</td><td style="text-align:center">return x with x.key = k</td></tr><tr><td style="text-align:center">Insert(S, x)</td><td style="text-align:center">insert x into S</td></tr><tr><td style="text-align:center">Delete(S, x)</td><td style="text-align:center">delete x from S</td></tr><tr><td style="text-align:center">Minimum(S)</td><td style="text-align:center">return y with the smallest key</td></tr><tr><td style="text-align:center">Maximum(S)</td><td style="text-align:center">return y with the largest key</td></tr><tr><td style="text-align:center">Successor(S, x)</td><td style="text-align:center">return y with the next key lager than x.key</td></tr><tr><td style="text-align:center">Predecessor(S, x)</td><td style="text-align:center">return y with the next key smaller than x.key</td></tr></tbody></table></div><blockquote><p>S is a set, x and y are elements, k is a key<br>NIL is returned if operations can’t be performed</p></blockquote><h1 id="Elementary-Data-Structures-基本数据结构"><a href="#Elementary-Data-Structures-基本数据结构" class="headerlink" title="Elementary Data Structures (基本数据结构)"></a>Elementary Data Structures (基本数据结构)</h1><h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack (栈)"></a>Stack (栈)</h2><ul><li>LIFO (Last-In-First-Out)</li><li>Operations:<ul><li><code>Push</code> (压栈)</li><li><code>Pop</code> (出栈)</li></ul></li><li>Array implementation S[1..S.top]<ul><li>1 → the bottom of Stack</li><li><code>S.top</code> → the top of Stack</li><li>if <code>S.top == 0</code>, Stack is <code>empty</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stack-Empty(S)</span><br><span class="line">    <span class="keyword">if</span> S.top == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> true</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> false</span><br><span class="line"></span><br><span class="line">Push(S, x)</span><br><span class="line">    S.top = S.top + <span class="number">1</span></span><br><span class="line">    S[S.top] = x</span><br><span class="line"></span><br><span class="line">Pop(S)</span><br><span class="line">    <span class="keyword">if</span> Stack-Empty(S)</span><br><span class="line">        error <span class="string">"underflow"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        S.top = S.top - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> S[S.top + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue (队列)"></a>Queue (队列)</h2><ul><li>FIFO (First-In-First-Out)</li><li>Operations:<ul><li><code>Enqueue</code> (入队)</li><li><code>Dequeue</code> (出队)</li></ul></li><li>Array implementation  Q[1..n]<ul><li><code>Q.head</code> → the head element of Queue</li><li><code>Q.tail</code> → the tail element of Queue</li><li>If <code>Q.head == Q.tail</code>, Queue is <code>empty</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Enqueue(Q, x)</span><br><span class="line">    Q[Q.tail] = x</span><br><span class="line">    <span class="keyword">if</span> Q.tail == Q.length</span><br><span class="line">        Q.tail = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q.tail = Q.tail + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Dequeue(Q)</span><br><span class="line">    x = Q[Q.head]</span><br><span class="line">    <span class="keyword">if</span> Q.head == Q.length</span><br><span class="line">        Q.head = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q.head = Q.head + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List (链表)"></a>Linked List (链表)</h2><ul><li>A linked list is a data structure in which the objects are arranged in a linear order.</li><li>Unlike an array, though, in which the linear order is determined by the array indices (数组下标), the order in a linked list is determined by a pointer in each object.</li><li>Doubly linked list (双向链表)<ul><li>Each element is an object with a <code>key</code> field and two other pointer fields: <code>next</code> and <code>prev</code>.</li><li><img src="/2019/08/04/dynamic-set-and-elementary-data-structure/doubly-linked-list.png" alt></li><li>If <code>x.prev == NIL</code>, the element x has no predecessor (前驱) and is therefore the first element, or <code>head</code></li><li>If <code>x.next == NIL</code>, the element <em>x</em> has no successor (后继) and is therefore the last element, or <code>tail</code></li><li>If <code>L.head == NIL</code>, the list is empty</li></ul></li><li>Singly linked list (单向链表)<ul><li>omit (省略) the <code>prev</code> pointer in each element</li></ul></li><li>Circular linked list (循环链表)<ul><li>The prev pointer of the head of the list points to the tail</li><li>The next pointer of the tail of the list points to the head</li><li><img src="/2019/08/04/dynamic-set-and-elementary-data-structure/circular-linked-list.png" alt></li></ul></li></ul><h3 id="Searching-a-linked-list"><a href="#Searching-a-linked-list" class="headerlink" title="Searching a linked list"></a>Searching a linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List-Search(L, k) <span class="comment"># worst case: Θ(n)</span></span><br><span class="line">    x = L.head</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> x.key != k</span><br><span class="line">        x = x.next</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="Inserting-into-a-linked-list"><a href="#Inserting-into-a-linked-list" class="headerlink" title="Inserting into a linked list"></a>Inserting into a linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List-Insert(L, x, i) <span class="comment"># average: Θ(n)</span></span><br><span class="line">    p = L.head</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span></span><br><span class="line">        L.head = x</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span></span><br><span class="line">        p = p.next</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    x.next = p</span><br><span class="line">    <span class="keyword">if</span> p.prev != NIL</span><br><span class="line">        p.prev.next = x</span><br><span class="line">    x.prev = p.prev</span><br><span class="line">    p.prev = x</span><br></pre></td></tr></table></figure><h3 id="Deleting-from-a-linked-list"><a href="#Deleting-from-a-linked-list" class="headerlink" title="Deleting from a linked list"></a>Deleting from a linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List-Delete(L, k) <span class="comment"># worst case: Θ(n)</span></span><br><span class="line">    x = List-Search(L, k)</span><br><span class="line">    <span class="keyword">if</span> x.prev != NIL</span><br><span class="line">        x.prev.next = x.next</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L.head = x.next</span><br><span class="line">    <span class="keyword">if</span> x.next != NIL</span><br><span class="line">        x.next.prev = x.prev</span><br></pre></td></tr></table></figure><h3 id="Sentinel-哨兵"><a href="#Sentinel-哨兵" class="headerlink" title="Sentinel (哨兵)"></a>Sentinel (哨兵)</h3><ul><li>A sentinel is a dummy object (哑对象) that allows us to simplify boundary conditions (简化边界).</li><li>Object <code>L.nil</code> represents <code>NIL</code> but has all the fields of the other list elements.<ul><li>Wherever we have a reference to <code>NIL</code> in list code, we replace it by a reference to the sentinel <code>L.nil</code>, this turns a regular doubly linked list into a circular list<ul><li><code>L.nil</code> placed between the head and tail<ul><li>L.nil.next → L.head</li><li>L.nil.prev → L.tail</li></ul></li><li><code>L.tail.next</code> and <code>L.head.prev</code> point to <code>L.nil</code><ul><li>L.head.prev → L.nil</li><li>L.tail.next → L.nil</li></ul></li></ul></li><li><img src="/2019/08/04/dynamic-set-and-elementary-data-structure/sentinel.png" alt></li></ul></li></ul><h2 id="Rooted-Trees-有根树"><a href="#Rooted-Trees-有根树" class="headerlink" title="Rooted Trees (有根树)"></a>Rooted Trees (有根树)</h2><h3 id="Binary-trees-二叉树"><a href="#Binary-trees-二叉树" class="headerlink" title="Binary trees (二叉树)"></a>Binary trees (二叉树)</h3><ul><li>Use the fields <code>p</code>, <code>left</code>, and <code>right</code> to store pointers to the parent, left child, and right child of each node in a binary tree</li><li><img src="/2019/08/04/dynamic-set-and-elementary-data-structure/binary-tree.png" alt></li><li>If <code>x.p == NIL</code>, x is the root</li><li>If <code>x.left == NIL</code>, x has no left child</li><li>If <code>T.root == NIL</code>, T is empty</li></ul><h3 id="Rooted-trees-with-unbounded-branching-分支无限制的有根树"><a href="#Rooted-trees-with-unbounded-branching-分支无限制的有根树" class="headerlink" title="Rooted trees with unbounded branching (分支无限制的有根树)"></a>Rooted trees with unbounded branching (分支无限制的有根树)</h3><ul><li>The scheme for representing a binary tree can be extended to any class of trees in which the number of children of each node is at most some constant $k$. <ul><li>We replace the $left$ and $right$ fields by $child_1, child_2, \cdots, child_k$.</li><li>This scheme no longer works when the number of children of a node is unbounded.<ul><li>Don’t know how many fields to allocate in advance.</li><li>Even if the number of children k is bounded by a large constant but most nodes have a small number of children, we may waste a lot of memory.</li></ul></li></ul></li><li><strong>left-child, right-sibling representation (左孩子右兄弟表示法)</strong><ul><li>Using only $O(n)$ space for any n-node rooted tree</li><li>Node x<ul><li>parent pointer <code>x.p</code> and <code>T.root</code> points to the root of tree</li><li><code>x.left-child</code> points to the leftmost child of node x<ul><li>If node x has no children, x.left-child = NIL</li></ul></li><li><code>x.right-sibling</code> points to the sibling of x immediately to the right<ul><li>If node x is the rightmost child of its parent, x.right-sibling = NIL</li></ul></li></ul></li><li><img src="/2019/08/04/dynamic-set-and-elementary-data-structure/left-child-right-sibling-representation.png" alt></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 动态集合 </tag>
            
            <tag> 基本数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（6）中位数与顺序统计量</title>
      <link href="/2019/08/03/median-and-order-statistics.html"/>
      <url>/2019/08/03/median-and-order-statistics.html</url>
      
        <content type="html"><![CDATA[<h1 id="Selection-选择问题"><a href="#Selection-选择问题" class="headerlink" title="Selection (选择问题)"></a>Selection (选择问题)</h1><ul><li>Given $n$ elements in array, find the $k^{th}$ smallest element (the element with rank $k$)<ul><li>Naive algorithm<ul><li>Sort and index $k^{th}$ element.</li><li>Worst-case running time $= \Theta(n \lg n) + \Theta(1) = \Theta(n \lg n)$, using merge sort or heap sort (not quick sort).</li></ul></li><li>k = 1: <strong>minimum</strong></li><li>k = n: <strong>maximum</strong></li><li>k = (n+1)/2: <strong>median</strong></li></ul></li></ul><h1 id="Randomized-selection-algorithm-随机选择算法"><a href="#Randomized-selection-algorithm-随机选择算法" class="headerlink" title="Randomized selection algorithm (随机选择算法)"></a>Randomized selection algorithm (随机选择算法)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Randomized-Select(A, p, q, i)</span><br><span class="line">    <span class="keyword">if</span> p == q</span><br><span class="line">        <span class="keyword">return</span> A[p]</span><br><span class="line">    r = Randomized-Partition(A, p, q)</span><br><span class="line">    k = r - p + <span class="number">1</span>   //k = rank(A[r])</span><br><span class="line">    <span class="keyword">if</span> i == k</span><br><span class="line">        <span class="keyword">return</span> A[r]</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> i &lt; k</span><br><span class="line">        <span class="keyword">return</span> Randomized-Select(A, p, r<span class="number">-1</span>, i)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Randomized-Select(A, r+<span class="number">1</span>, q, i-k)</span><br></pre></td></tr></table></figure><p><img src="/2019/08/03/median-and-order-statistics/随机选择算法.png" alt></p><h2 id="Intuition-for-analysis"><a href="#Intuition-for-analysis" class="headerlink" title="Intuition for analysis"></a>Intuition for analysis</h2><ul><li>All our analyses assume that all elements are distinct.</li><li>Lucky: $T(n) = T(9n/10) + \Theta(n) = \Theta(n)$</li><li>Unlucky: $T(n) = T(n-1) + \Theta(n) = \Theta(n^2)$</li></ul><h2 id="Analysis-of-expected-time"><a href="#Analysis-of-expected-time" class="headerlink" title="Analysis of expected time"></a>Analysis of expected time</h2><ul><li>The analysis follows that of randomized quick-sort, but it’s a little different.</li><li>Let $T(n) =$  the random variable for the running time of Randomized-Select on an input of size n, assuming random numbers are independent.</li><li>For $k = 0, 1, \cdots, n–1$, define the indicator random variable</li><li>$X_k = \begin{cases}<br>  1 &amp; \text{if partition generates a $k : n-k-1$ split} \\<br>  0 &amp; \text{otherwise}<br>  \end{cases}$</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; \leq \begin{cases} T(\max \{ 0, n-1 \}) + \Theta(n) &amp; \text{if $0 : n-1$ split} \\<br>  T(\max \{ 1, n-2 \}) + \Theta(n) &amp; \text{if $1 : n-2$ split}\\<br>  \cdots \\<br>  T(\max \{ n-1, 0 \}) + \Theta(n) &amp; \text{if $n-1 : 0$ split}\end{cases} \\<br>  &amp; = \sum_{k=0}^{n-1} X_k(T(\max \{ k, n-k-1 \}) + \Theta(n))<br>  \end{split}\end{equation}$</li><li>$\begin{equation}\begin{split} E(T(n)) &amp; \leq E\left[ \sum_{k=0}^{n-1} X_k (T(\max \{ k, n-k-1 \}) + \Theta(n)) \right] \\<br>  &amp; = \sum_{k=0}^{n-1} E[X_k(T(\max \{ k, n-k-1 \}) + \Theta(n))] \\<br>  &amp; = \sum_{k=0}^{n-1} E[X_k] \cdot E[(T(\max \{ k, n-k-1 \}) + \Theta(n))] \\<br>  &amp; = {1 \over n} \sum_{k=0}^{n-1} E[(T(\max \{ k, n-k-1 \})] + {1 \over n} \sum_{k=0}^{n-1} \Theta(n) \\<br>  &amp; \leq {2 \over n} \sum_{k = \lfloor n/2 \rfloor}^{n-1} E[T(k)] + \Theta(n)<br>  \end{split}\end{equation}$</li><li>Use substitution method to get $E(T(n)) = O(n)$</li><li>$\begin{equation}\begin{split}<br>  E(T(n)) &amp; \leq {2 \over n} \sum_{k = \lfloor n/2 \rfloor}^{n-1} E[T(k)] + \Theta(n) \\<br>  &amp; \leq {2 \over n} \sum_{k = \lfloor n/2 \rfloor}^{n-1} ck + \Theta(n) \\<br>  &amp; \leq {2c \over n} \left( {3 \over 8} n^2 \right) + \Theta(n)\\<br>  &amp; = cn - \left( {cn \over 4} - \Theta(n) \right) \\<br>  &amp; \leq cn<br>  \end{split}\end{equation}$</li><li>$\text{if $c$ is chosen large enough so that $cn/4$ dominates the $\Theta(n)$}$</li></ul><h2 id="Summary-of-randomized-order-statistic-selection"><a href="#Summary-of-randomized-order-statistic-selection" class="headerlink" title="Summary of randomized order statistic selection"></a>Summary of randomized order statistic selection</h2><ul><li>Works fast: linear expected time.</li><li>Excellent algorithm in practice.</li><li>But, the worst case is very bad: $\Theta(n^2)$.</li></ul><h1 id="Worst-case-linear-time-order-statistics-selection-最坏情况为线性时间的选择算法"><a href="#Worst-case-linear-time-order-statistics-selection-最坏情况为线性时间的选择算法" class="headerlink" title="Worst-case linear-time order statistics selection (最坏情况为线性时间的选择算法)"></a>Worst-case linear-time order statistics selection (最坏情况为线性时间的选择算法)</h1><ul><li>IDEA: generate good pivot recursively.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT(i, n)</span><br><span class="line">    <span class="number">1.</span> Divide the n elements into groups of <span class="number">5.</span> Find the median of each <span class="number">5</span>-element group by rote.</span><br><span class="line">    // Θ(n)</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span> Recursively SELECT the median x of the n/<span class="number">5</span> group medians to be the pivot.</span><br><span class="line">    // T(n/<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span> Partition around the pivot x. Let k = rank(x).</span><br><span class="line">    // Θ(n)</span><br><span class="line"></span><br><span class="line">    <span class="number">4.</span> <span class="keyword">if</span> i = k</span><br><span class="line">            then <span class="keyword">return</span> x</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> i &lt; k</span><br><span class="line">            then recursively SELECT the i-th smallest element <span class="keyword">in</span> the lower part</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            recursively SELECT the (i–k)th smallest element <span class="keyword">in</span> the upper part</span><br></pre></td></tr></table></figure><p><img src="/2019/08/03/median-and-order-statistics/最坏情况为线性时间的选择算法.png" alt></p><ul><li>Minor simplification: For $n \geq 50$, we have $\lfloor 3n/10 \rfloor \geq n/4$.</li><li>Therefore, for $n \geq 50$ the recursive call to SELECT in Step 4 is executed recursively on $\leq 3n/4$ elements.</li><li>Thus, the recurrence for running time can assume that Step 4 takes time $T(3n/4)$ in the worst case.</li><li>For $n &lt; 50$, we know that the worst-case time is $T(n) = \Theta(1)$.</li><li>$T(n) \leq \begin{cases}<br>  O(1) &amp; n &lt; 50 \\<br>  T(n/5) + T(3n/4) + O(n) &amp; n \geq 50<br>  \end{cases}$</li><li>Use substitution to confirm $T(n) = O(n)$</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; \leq {1 \over 5} cn + {3 \over 4} cn + O(n) \\<br>  &amp; = cn - ({1 \over 20} cn - O(n)) \\<br>  &amp; \leq cn \quad \text{(if $c$ is chosen large enough to handle both $O(n)$ and initial conditions)}<br>  \end{split}\end{equation}$</li></ul><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul><li>Since the work at each level of recursion is a constant fraction (19/20) smaller, the work per level is a geometric series dominated by the linear work at the root.</li><li>In practice, this algorithm runs slowly, because the constant in front of n is large.</li><li>The randomized algorithm is far more practical.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 顺序统计量 </tag>
            
            <tag> 选择问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（5）线性时间排序</title>
      <link href="/2019/08/03/linear-time-sorting.html"/>
      <url>/2019/08/03/linear-time-sorting.html</url>
      
        <content type="html"><![CDATA[<ul><li>How fast can we sort ? <ul><li>All the sorting algorithms we have seen so far are <strong>comparison sorts</strong> (比较排序): only use comparisons to determine the relative order of elements. <ul><li>E.x. insertion sort, merge sort, quick-sort, heap-sort. </li></ul></li><li>The best worst-case running time that we’ve seen for comparison sorting is O(nlgn). </li></ul></li><li>Is <code>O(nlgn)</code> the best we can do ? <ul><li><strong>Decision trees</strong> (决策树) can help us answer this question. </li></ul></li></ul><h1 id="Decision-tree-model-决策树模型"><a href="#Decision-tree-model-决策树模型" class="headerlink" title="Decision-tree model (决策树模型)"></a>Decision-tree model (决策树模型)</h1><h2 id="Sort-langle-a-1-a-2-a-3-rangle"><a href="#Sort-langle-a-1-a-2-a-3-rangle" class="headerlink" title="Sort $\langle a_1, a_2, a_3 \rangle$"></a>Sort $\langle a_1, a_2, a_3 \rangle$</h2><p><img src="/2019/08/03/linear-time-sorting/decision-tree-model.jpg" alt></p><h2 id="Sort-langle-a-1-a-2-cdots-a-n-rangle"><a href="#Sort-langle-a-1-a-2-cdots-a-n-rangle" class="headerlink" title="Sort $\langle a_1, a_2, \cdots, a_n \rangle$"></a>Sort $\langle a_1, a_2, \cdots, a_n \rangle$</h2><ul><li>Each internal node is labeled <code>i : j</code> for $i, j \in \{1, 2, \cdots, n\}$. <ul><li>The left sub-tree shows subsequent comparisons if $a_i \leq a_j$. </li><li>The right sub-tree shows subsequent comparisons if $a_i &gt; a_j$. </li></ul></li><li>Each leaf contains a permutation (排列) $\langle π(1), π(2), \cdots , π(n)\rangle$. <ul><li>Indicate that the ordering $a_{π(1)} \leq a_{π(2)} \leq \cdots \leq a_{π(n)}$ has been established.</li></ul></li></ul><h2 id="Execution-of-any-comparison-sort"><a href="#Execution-of-any-comparison-sort" class="headerlink" title="Execution of any comparison sort"></a>Execution of any comparison sort</h2><ul><li>Build one tree for each input size n. </li><li>View the algorithm as splitting into two forks (the left sub-tree and the right sub-tree) whenever it make a comparison. </li><li>The tree contains the comparisons along all possible instruction traces. </li><li>The running time of the algorithm = the length of the root to leaf path. <ul><li>Worst-case running time = height of tree. </li></ul></li></ul><h2 id="Lower-bound-on-decision-tree-sorting-comparison-sorting"><a href="#Lower-bound-on-decision-tree-sorting-comparison-sorting" class="headerlink" title="Lower bound on decision-tree sorting (comparison sorting)"></a><strong>Lower bound</strong> on decision-tree sorting (comparison sorting)</h2><ul><li>The tree must contain $\geq n!$ leaves, since there are n! possible permutations. A height-h binary tree has $\leq 2^h$ leaves. Thus, $n! \leq 2^h$. </li><li>$\begin{equation}\begin{split} \therefore h &amp; \geq \log_2 n! \\<br>  &amp; \geq \log_2 \left({n \over e}\right)^n \\<br>  &amp; = n \lg n - n \lg e \\<br>  &amp; = \Omega(n \lg n)<br>  \end{split}\end{equation}$</li><li>Theorem: Any decision tree that can sort n elements must have height Ω(nlgn). </li><li>Corollary: Heap-sort and merge sort are asymptotically optimal comparison sorting algorithms. Randomized quick-sort is also asymptotically optimal in expectation. </li></ul><h1 id="Counting-sort-计数排序"><a href="#Counting-sort-计数排序" class="headerlink" title="Counting sort (计数排序)"></a>Counting sort (计数排序)</h1><ul><li><strong>No comparisons</strong> between elements. </li><li>Input: A[1 . . n], where A[i]∈{0, 1, 2, …, k}. </li><li>Output: B[1 . . n], sorted. </li><li><p>Auxiliary storage (辅助存储器): C[0 . . k]. </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Counting-Sort(A, B, k)</span><br><span class="line">    let C[<span class="number">1.</span>.k] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k</span><br><span class="line">        C[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">        C[A[j]] = C[A[j]] + <span class="number">1</span></span><br><span class="line">    // C[i] = |&#123;key = i&#125;|</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k</span><br><span class="line">        C[i] = C[i] + C[i<span class="number">-1</span>]</span><br><span class="line">    // C[i] = |&#123;key &lt;= i&#125;|</span><br><span class="line">    <span class="keyword">for</span> j = n down to <span class="number">1</span></span><br><span class="line">        B[C[A[j]]] = A[j]</span><br><span class="line">        C[A[j]] = C[A[j] - <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><img src="/2019/08/03/linear-time-sorting/counting-sort-1.png" alt></p></li><li><img src="/2019/08/03/linear-time-sorting/counting-sort-2.png" alt></li></ul><ul><li>$T(n) = \Theta(n + k)$ <ul><li>If $k = O(n)$, then counting sort takes $\Theta(n)$ time. </li></ul></li><li>But, sorting takes $\Omega(n \lg n)$ time! Where’s the fallacy? <ul><li>Comparison sorting takes $\Omega(n \lg n)$ time. </li><li>Counting sort is not a comparison sort. </li><li>In fact, not a single comparison between elements occurs! </li></ul></li></ul><h1 id="Stable-sort-algorithm-稳定性排序算法"><a href="#Stable-sort-algorithm-稳定性排序算法" class="headerlink" title="Stable sort algorithm (稳定性排序算法)"></a>Stable sort algorithm (稳定性排序算法)</h1><ul><li>A stable sorting algorithm preserves the relative order of equal elements (具有相同值的元素的相对次序相同). </li><li>Counting sort is a stable sort. </li><li><img src="/2019/08/03/linear-time-sorting/stable-sort.png" alt></li><li>Insertion sort and merge sort are stable sorts. </li><li>Quick-sort and heap-sort are not stable sorts. </li></ul><h1 id="Radix-sort-基数排序"><a href="#Radix-sort-基数排序" class="headerlink" title="Radix sort (基数排序)"></a>Radix sort (基数排序)</h1><ul><li>Origin: Herman Hollerith’s card-sorting machine for the 1890 U.S. Census. </li><li><strong>Digit-by-digit sort (按位排序)</strong>. </li><li>Hollerith’s original (bad) idea: sort on most-significant digit first. </li><li>Good idea: Sort on <strong>least-significant digit first (最低有效位)</strong> with auxiliary stable sort. </li></ul><p><img src="/2019/08/03/linear-time-sorting/radix-sort.png" alt></p><h2 id="Correctness-of-radix-sort"><a href="#Correctness-of-radix-sort" class="headerlink" title="Correctness of radix sort"></a>Correctness of radix sort</h2><ul><li>induction on digit position that we are currently sorting. </li><li>Assume that the numbers are sorted by their low-order $t-1$ digit. </li><li>Sort on digit. <ul><li>If two elements have the same t-th digit <ul><li>Stability ⇒ put in the same order as the input </li><li>By induction hypothesis ⇒ keep in sorted order </li></ul></li><li>If two elements have different t-th digit <ul><li>Sorting ⇒ put them in the right (sorted) order </li></ul></li></ul></li></ul><h2 id="Analysis-of-radix-sort"><a href="#Analysis-of-radix-sort" class="headerlink" title="Analysis of radix sort"></a>Analysis of radix sort</h2><ul><li>Assume counting sort is the auxiliary stable sort. </li><li>Suppose we have $n$ integers of $b$ bits each. </li><li>Split each integer into $b/r$ digits of $r$ bits long (base $2^r$). </li><li>$T(n, b) = \Theta \left( {b \over r} (n + 2^r) \right)$ </li><li>Choose $r$ to minimize $T(n, b)$ <ul><li>Differentiate with respect to $r$ and set to 0. (对 r 求导，求导数等于 0 时的解) </li><li>Increasing r means fewer passes, but as $r &gt;&gt; \lg n$, the time grows exponentially. </li><li>Choosing $r = \lg n$ implies $T(n, b) = \Theta \left({b n \over \lg n}\right)$. </li><li>For numbers in the range from 0 to $n^d – 1$, we have $b = d \lg n$ ⇒ radix sort runs in $\Theta(dn)$ time. </li></ul></li></ul><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><ul><li>In practice, <strong>radix sort is fast for large inputs</strong>, as well as simple to code and maintain.</li><li>Example (32-bit numbers):<ul><li>At most 3 passes when sorting ≥ 2000 numbers.</li><li>Merge sort and quick-sort do at least lg 2000 = 11 passes. </li></ul></li><li>Downside: Unlike quick-sort, radix sort displays little locality of reference, and thus a well-tuned quick-sort fares better on modern processors, which feature steep memory hierarchies. (缺点：不像快速排序，基数排序不呈现时空局限性，所以快速排序在以过高的内存结构为特征的现代处理器中性能更好) </li></ul><h1 id="Bucket-sort-桶排序"><a href="#Bucket-sort-桶排序" class="headerlink" title="Bucket sort (桶排序)"></a>Bucket sort (桶排序)</h1><ul><li>Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. </li><li>It is a distribution sort (分配排序), a generalization of pigeonhole sort (鸽巢排序), and is a cousin of radix sort in the most-to-least significant digit flavor. </li><li>The computational complexity (计算复杂度) depends on the algorithm used to sort each bucket, the number of buckets to use, and whether the input is uniformly distributed (服从均匀分布，输入的元素均匀分布在区间 [0, 1) 上). </li><li><p>Bucket sort works as follows: </p><ol><li>Set up an array of initially empty “buckets”. </li><li>Scatter: Go over the original array, putting each object in its bucket. </li><li>Sort each non-empty bucket. </li><li><p>Gather: Visit the buckets in order and put all elements back into the original array. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Bucket-sort(A)</span><br><span class="line">    n = A.length</span><br><span class="line">    let B[<span class="number">0.</span>.n<span class="number">-1</span>] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n<span class="number">-1</span></span><br><span class="line">       make B[i] an empty list</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">       insert A[i] into list B[nA[i]]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n<span class="number">-1</span></span><br><span class="line">       sort list B[i]</span><br><span class="line">    concatenate the lists B[<span class="number">0</span>], B[<span class="number">1</span>], ... , B[n<span class="number">-1</span>] together <span class="keyword">in</span> order</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="Worst-case-analysis-of-bucket-sort"><a href="#Worst-case-analysis-of-bucket-sort" class="headerlink" title="Worst-case analysis of bucket-sort"></a>Worst-case analysis of bucket-sort</h2><ul><li>The worst-case scenario occurs when all the elements are placed in a single bucket. </li><li>The overall performance would then be dominated by the algorithm used to sort each bucket, which is typically $O(n^2)$ insertion sort, making bucket sort less optimal than $O(n \lg n)$ comparison sort algorithms like quick-sort. </li></ul><h2 id="Average-case-analysis-of-bucket-sort"><a href="#Average-case-analysis-of-bucket-sort" class="headerlink" title="Average-case analysis of bucket-sort"></a>Average-case analysis of bucket-sort</h2><ul><li>Consider the case that the input is uniformly distributed. </li><li>Assume insertion sort is used to sort each bucket, then the third step costs $O(\sum_{i=1}^k n_i^2)$, where $n_i$ is the length of the bucket indexed $i$. </li><li>Let  $X_{ij}$ be the random variable of element $j$ being placed in bucket $i$. We have $n_i = \sum_{j = 1}^n X_{ij}$. </li><li>$\begin{equation}\begin{split} E(n_i^2) &amp; = E(\sum_{j=1}^n X_{ij} \sum_{k=1}^n X_{ik}) \\<br>  &amp; = E(\sum_{j=1}^n \sum_{k=1}^n X_{ij} X_{ik}) \\<br>  &amp; = E(\sum_{j=1}^n X_{ij}^2) + E(\sum_{1 \leq j, k \leq n}^n \sum_{j \not= k}^n X_{ij} X_{ik}) \\<br>  \end{split}\end{equation}$</li><li>$E(X_{ij}^2) = 1^2 \cdot ({1 \over k}) + 0^2 \cdot (1 - {1 \over k}) = {1\over k}$</li><li>$E(X_{ij} X_{ik}) = 1 \cdot ({1 \over k})({1 \over k}) = {1 \over k^2}$</li><li>$\begin{equation}\begin{split} E(n_i^2) &amp; = E(\sum_{j=1}^n X_{ij}^2) + E(\sum_{1 \leq j, k \leq n}^n \sum_{j \not= k}^n X_{ij} X_{ik}) \\<br>  &amp; = n \cdot {1 \over k} + n(n-1) \cdot {1 \over k^2} \\<br>  &amp; = {n^2 + nk - n \over k^2} \\<br>  \end{split}\end{equation}$</li><li>$O(\sum_{i=1}^k E(n_i^2)) = O(\sum_{i=1}^k {n^2 + nk - n \over k^2}) = O({n^2 \over k} + n)$</li><li>If $k$ is chosen to be $k = \Theta(n)$, then bucket-sort runs in $O(n)$ average time.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 线性时间排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（4）堆与堆排序</title>
      <link href="/2019/08/02/heap-and-heapsort.html"/>
      <url>/2019/08/02/heap-and-heapsort.html</url>
      
        <content type="html"><![CDATA[<h1 id="Priority-Queue-（优先队列）"><a href="#Priority-Queue-（优先队列）" class="headerlink" title="Priority Queue （优先队列）"></a>Priority Queue （优先队列）</h1><ul><li>A data structure that implements a set S of elements, each associated with a key, supporting the following operations:<ul><li><code>insert(S, x)</code>: insert element x into set S.</li><li><code>max(S)</code>: return element of S with largest key.</li><li><code>extract_max(S)</code>: return the element of S with largest key and remove it from S.</li><li><code>increase_key(S, x, k)</code>: increase the value of element x’s key to new value k.</li></ul></li></ul><h1 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h1><ul><li>Implementation of a priority queue</li><li>An array, visualized as a nearly complete binary tree（完全二叉树）</li><li><img src="/2019/08/02/heap-and-heapsort/array.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/heap.png" alt></li></ul><h2 id="Heap-as-a-tree"><a href="#Heap-as-a-tree" class="headerlink" title="Heap as a tree"></a>Heap as a tree</h2><ul><li><strong>root of the tree</strong>: first element in the array, corresponding to i = 1.</li><li><strong>parent(i) = i/2</strong>, return index of node’s parent.</li><li><strong>left(i) = 2i</strong>, return index of node’s left child.</li><li><strong>right(i) = 2i+1</strong>, return the index of node’s right child.</li></ul><h2 id="Max-Heap-Property（最大堆性质）"><a href="#Max-Heap-Property（最大堆性质）" class="headerlink" title="Max Heap Property（最大堆性质）"></a>Max Heap Property（最大堆性质）</h2><ul><li>The key of a node is <strong>no less than</strong> the keys of its children. </li><li>Min Heap defined analogously.</li></ul><h1 id="Heap-operations"><a href="#Heap-operations" class="headerlink" title="Heap operations"></a>Heap operations</h1><ul><li><code>max_heapify</code>:  correct a single violation of the heap property in a subtree’s root</li><li><code>build_max_heap</code>: produce a max-heap from an unordered array</li><li><code>insert</code></li><li><code>extract_max</code></li><li><code>heapsort</code></li></ul><h2 id="Max-Heapify"><a href="#Max-Heapify" class="headerlink" title="Max_Heapify"></a>Max_Heapify</h2><ul><li>Assume that the trees rooted at left(i) and right(i) are max-heaps.</li><li>If element A[i] violates the max-heap property, correct violation by “trickling”（滴下） element A[i] down the tree, making the subtree rooted at index i a max-heap.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Max_Heapify(A, i)</span><br><span class="line">    l = left(i)</span><br><span class="line">    r = right(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= heap_size(A) <span class="keyword">and</span> A[l] &gt; A[i]</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt;= heap_size(A) <span class="keyword">and</span> A[r] &gt; A[largest]</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i</span><br><span class="line">        exchange A[i] <span class="keyword">and</span> A[largest]</span><br><span class="line">        Max_Heapify(A, largest)</span><br></pre></td></tr></table></figure></li><li><img src="/2019/08/02/heap-and-heapsort/max-heapify-1.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/max-heapify-2.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/max-heapify-3.png" alt></li><li>For a size n tree, the size of its sub-tree is <strong>at most 2n/3</strong></li><li>$T(n) \leq T(2n/3) + \Theta(1)$</li><li>$T(n) = O(\lg n)$</li><li>In other words, the running time of max_heapify operation for a <code>height h</code> node is O(h).</li></ul><h2 id="Build-Max-Heap"><a href="#Build-Max-Heap" class="headerlink" title="Build_Max_Heap"></a>Build_Max_Heap</h2><ul><li>Convert A[1..n] to a max-heap.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Build_Max_Heap(A)</span><br><span class="line"><span class="keyword">for</span> i = n/<span class="number">2</span> down to <span class="number">1</span></span><br><span class="line">Max_Heapify(A, i)</span><br></pre></td></tr></table></figure></li><li><p>Why start at n/2 ?</p><ul><li>Because elements A[n/2+1 … n] are all leaves of the tree.</li></ul></li><li>T(n) = O(nlgn) via simple analysis.</li><li><img src="/2019/08/02/heap-and-heapsort/build-max-heap-1.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/build-max-heap-2.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/build-max-heap-3.png" alt></li></ul><h3 id="Build-Max-Heap-analysis"><a href="#Build-Max-Heap-analysis" class="headerlink" title="Build_Max_Heap analysis"></a>Build_Max_Heap analysis</h3><ul><li>Observe that Max_Heapify takes <strong>O(1)</strong> time for nodes that are one level above the leaves, and in general, <strong>O(L)</strong> time for the nodes that are <em>L</em> levels above the leaves.</li><li>We have n/4 nodes with level 1, n/8 with level 2, and so on till we have one root node that is <strong>lgn</strong> levels above the leaves.</li><li>Total amount of work in the for loop can be summed as:</li><li>$T(n) = {n \over 4} (1c) + {n \over 8} (2c) + {n \over 16} (3c) + \cdots + 1 (\lg n c)$</li><li>Setting ${n \over 4} = 2^k$ and simplifying we get:</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; = c 2^k \left( {1 \over 2^0} + {2 \over 2^1} + {3 \over 2^2} + \cdots + {k+1 \over 2^k} \right) \\<br>  &amp; = c 2^k \left( 4 - {k+3 \over 2^k} \right) \\<br>  &amp; = c (n - \log_2 n -1) \\<br>  &amp; = O(n)<br>  \end{split}\end{equation}$</li></ul><h1 id="Heap-sort（堆排序）"><a href="#Heap-sort（堆排序）" class="headerlink" title="Heap-sort（堆排序）"></a>Heap-sort（堆排序）</h1><ul><li>Sorting strategy<ol><li>Build Max Heap from unordered array</li><li>Find maximum element A[1]</li><li>Swap elements A[n] and A[1]: now max element is at the end of the array!</li><li>Discard node n from heap (by decrementing heap-size variable)</li><li>New root may violate max heap property, but its children are max heaps. Run max_heapify to fix this.</li><li>Go to Step 2 unless heap is empty.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Heapsort(A)</span><br><span class="line">    Build_Max_Heap(A, n)</span><br><span class="line">    <span class="keyword">for</span> i = n down to <span class="number">2</span></span><br><span class="line">        exchange A[<span class="number">1</span>] <span class="keyword">with</span> A[i]</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        Max_Heapify(A, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><img src="/2019/08/02/heap-and-heapsort/heapsort-1.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/heapsort-2.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/heapsort-3.png" alt></li><li><img src="/2019/08/02/heap-and-heapsort/heapsort-4.png" alt></li><li>Running time<ul><li>After n iterations（循环，重复）, the Heap is empty.</li><li>Every iteration involves a swap and a max_heapify operation, hence it takes O(lgn) time.</li><li>$T(n) = O(n \lg n)$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（3）快速排序与随机算法</title>
      <link href="/2019/08/02/quick-sort-and-randomized-algorithm.html"/>
      <url>/2019/08/02/quick-sort-and-randomized-algorithm.html</url>
      
        <content type="html"><![CDATA[<h1 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h1><ul><li>Proposed by C.A.R. Hoare in 1962.</li><li>Divide-and-conquer algorithm.</li><li>Sorts “in place” (like insertion sort, but not like merge sort).</li><li>Very practical (with tuning).</li></ul><h2 id="Quick-sort-an-n-element-array"><a href="#Quick-sort-an-n-element-array" class="headerlink" title="Quick sort an n-element array"></a>Quick sort an n-element array</h2><ol><li>Divide: Partition (划分) the array into two sub-arrays around a <strong>pivot x</strong> such that <strong>elements in lower sub-array ≤ x ≤ elements in upper sub-array</strong>.</li><li>Conquer: Recursively sort the two sub-arrays.</li><li>Combine: Trivial.</li></ol><ul><li><p>Key: Linear-time partitioning subroutine.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Partition(A, p, q)</span><br><span class="line">    x = A[p]</span><br><span class="line">    i = p</span><br><span class="line">    <span class="keyword">for</span> j = p+<span class="number">1</span> to q</span><br><span class="line">        <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">    exchange A[p] <span class="keyword">with</span> A[i]</span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></li><li><p><img src="/2019/08/02/quick-sort-and-randomized-algorithm/快排划分示例.png" alt></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quicksort(A, p, q)</span><br><span class="line">    <span class="keyword">if</span> p &lt; q</span><br><span class="line">        r = Partition(A, p, q)</span><br><span class="line">        Quicksort(A, p, r<span class="number">-1</span>)</span><br><span class="line">        Quicksort(A, r+<span class="number">1</span>, q)</span><br></pre></td></tr></table></figure></li><li><p>Initial call: Quick-sort(A, 0, n-1).</p></li><li>One of the tricks to making quick-sort go fast is to look for a special purpose sorting routine for small numbers of elements. Beyond what kind of optimization is used, the core of it is this partitioning routine.</li></ul><h2 id="Analysis-of-quick-sort"><a href="#Analysis-of-quick-sort" class="headerlink" title="Analysis of quick-sort"></a><strong>Analysis of quick-sort</strong></h2><ul><li>Assume all input elements are distinct.</li><li><p>In practice, there are better partitioning algorithms when duplicate input elements may exist.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Hoare-Partition(A, p, q)</span><br><span class="line">    x = A[p]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    j = q + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> TRUE</span><br><span class="line">        repeat</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        until A[j] &lt;= x</span><br><span class="line">        repeat</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        until A[i] &gt;= x</span><br><span class="line">        <span class="keyword">if</span> i &lt; j</span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure></li></ul><h3 id="Worst-case-analysis"><a href="#Worst-case-analysis" class="headerlink" title="Worst-case analysis"></a>Worst-case analysis</h3><ul><li>Input sorted or reverse sorted.</li><li>Partition around min or max element.</li><li>One side of partition always has no elements.</li><li>$\begin{equation}\begin{split} T(n) &amp; = T(0) + T(n-1) + \Theta(n) \\<br>  &amp; = \Theta(1) + T(n-1) + \Theta(n) \\<br>  &amp; = T(n-1) + \Theta(n) \\<br>  &amp; = \Theta(n^2) \\<br>  \end{split}\end{equation}$</li><li><img src="/2019/08/02/quick-sort-and-randomized-algorithm/worst-case recursion tree.png" alt></li></ul><h3 id="Best-case-analysis-for-intuition-only"><a href="#Best-case-analysis-for-intuition-only" class="headerlink" title="Best-case analysis (for intuition only !)"></a>Best-case analysis (for intuition only !)</h3><ul><li>If we’re lucky, partition splits the array evenly.（均匀地划分数组）</li><li>$T(n) = 2T(n/2) + \Theta(n) = \Theta(n \lg n)$</li></ul><h3 id="“Almost-best”-case-analysis"><a href="#“Almost-best”-case-analysis" class="headerlink" title="“Almost-best” case analysis"></a>“Almost-best” case analysis</h3><ul><li>What if the split is always 1/10 : 9/10 ?</li><li>$T(n) = T(n/10) + T(9n/10) + \Theta(n) = \Theta(n \lg n)$</li><li><img src="/2019/08/02/quick-sort-and-randomized-algorithm/almost best case recursion tree.png" alt></li></ul><h3 id="More-intuition"><a href="#More-intuition" class="headerlink" title="More intuition"></a>More intuition</h3><ul><li>Suppose we alternative lucky, unlucky, lucky, unlucky, lucky, …</li><li>lucky step: $L(n) = 2U(n/2) + \Theta(n)$</li><li>unlucky step: $U(n) = L(n-1) + \Theta(n)$</li><li>Solving: $L(n) = 2L(n/2-1) + \Theta(n) = \Theta(n \lg n)$, lucky!</li><li>How can we make sure we are usually lucky?</li></ul><h1 id="Randomized-quick-sort-analysis"><a href="#Randomized-quick-sort-analysis" class="headerlink" title="Randomized quick-sort analysis"></a>Randomized quick-sort analysis</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Randomized-Partition(A, p, r)</span><br><span class="line">i = random(p, r)</span><br><span class="line">exchange A[p] <span class="keyword">with</span> A[i]</span><br><span class="line">    <span class="keyword">return</span> Partition(A, p, r)</span><br><span class="line"></span><br><span class="line">Randomized-Quicksort(A, p, r)</span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">    q = Randomized-Partition(A, p, r)</span><br><span class="line">        Randomized-Quicksort(A, p, q<span class="number">-1</span>)</span><br><span class="line">        Randomized-Quicksort(A, q+<span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><ul><li><strong>Let <code>T(n)</code> be the random variable</strong> for the running time of randomized quick-sort on an input of size n, assuming random numbers are independent.</li><li>For k = 0, 1, … , n–1, define the <strong>indicator random variable</strong>（指示器随机变量）</li><li>$X_k = \begin{cases}<br>  1 &amp; \text{if partition generates a $k : n-k-1$ split} \\<br>  0 &amp; \text{otherwise} \\<br>  \end{cases}$</li><li>$E(X_k) = 0 \times P\{X_k = 0\} + 1 \times P\{X_k = 1\} = P\{X_k = 1\} = 1/n$</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; = \begin{cases}<br>  T(0) + T(n-1) + \Theta(n) &amp; \text{if $0 : n-1$ split} \\<br>  T(1) + T(n-2) + \Theta(n) &amp; \text{if $1 : n-2$ split} \\<br>  \cdots \\<br>  T(n-1) + T(0) + \Theta(n) &amp; \text{if $n-1 : 0$ split} \\<br>  \end{cases} \\<br>  &amp; = \sum_{k = 0} ^{n-1} X_k [T(k) + T(n-k-1) + \Theta(n)] \\<br>  \end{split}\end{equation}$</li><li>$\begin{equation}\begin{split}<br>  E[T(n)] &amp; = E\{\sum_{k = 0}^{n-1} X_k [T(k) + T(n-k-1) + \Theta(n)]\} \\<br>  &amp; = \sum_{k = 0}^{n-1} E\{X_k [T(k) + T(n-k-1) + \Theta(n)]\} \\<br>  &amp; = \sum_{k = 0}^{n-1} E[X_k]E[T(k) + T(n-k-1) + \Theta(n)] \\<br>  &amp; = {1 \over n}  \sum_{k = 0}^{n-1} E[T(k)] + {1 \over n}  \sum_{k = 0}^{n-1} E[T(n-k-1)] + {1 \over n} \sum_{k = 0}^{n-1} \Theta(n) \\<br>  &amp; = {2 \over n} \sum_{k = 0}^{n-1} E[T(n)] + \Theta(n) \\<br>  &amp; = {2 \over n} \sum_{k = 2}^{n-1} E[T(n)] + \Theta(n) \quad \quad \text{k = 0, 1 terms are absorbed in $\Theta(n)$} \\<br>  \end{split}\end{equation}$</li><li>$\text{For the fact}\sum_{k = 2}^{n-1} k \lg k \leq {1 \over 2} n^2 \lg n - {1 \over 8} n^2$</li><li>$\begin{equation}\begin{split}<br>  E[T(n)] &amp; \leq {2 \over n} \sum_{k = 2}^{n-1} ak \lg k + \Theta(n) \\<br>  &amp; = {2a \over n} \left( {1 \over 2} n^2 \lg n - {1 \over 8} n^2 \right) + \Theta(n) \\<br>  &amp; = an \lg n - \left( {an \over 4} - \Theta(n)\right) \\<br>  &amp; \leq an \lg n \quad \quad \text{if a is chosen large enough so that an/4 dominates the $\Theta(n)$}<br>  \end{split}\end{equation}$</li></ul><h1 id="Quick-sort-in-practice"><a href="#Quick-sort-in-practice" class="headerlink" title="Quick-sort in practice"></a>Quick-sort in practice</h1><ul><li>Quick-sort is a great general-purpose sorting algorithm.</li><li>Quick-sort is typically three or more times faster than merge sort.</li><li>Quick-sort can benefit substantially from code tuning.</li><li>Quick-sort behaves well even with caching and virtual memory.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 随机算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（2）分治法</title>
      <link href="/2019/08/02/divide-and-conquer.html"/>
      <url>/2019/08/02/divide-and-conquer.html</url>
      
        <content type="html"><![CDATA[<h1 id="Divide-and-conquer（分治法）"><a href="#Divide-and-conquer（分治法）" class="headerlink" title="Divide and conquer（分治法）"></a>Divide and conquer（分治法）</h1><ul><li>Divide and conquer is the most well-known <strong><em>algorithm design</em></strong>（算法设计）strategy<ol><li><strong>Divide</strong> the problem (instance) into one or more smaller sub-problems.</li><li><strong>Conquer</strong> each sub-problems recursively.</li><li><strong>Combine</strong> the solutions to the sub-problems into the solution for the original problem.</li></ol></li></ul><h1 id="Merge-sort（归并排序）"><a href="#Merge-sort（归并排序）" class="headerlink" title="Merge sort（归并排序）"></a>Merge sort（归并排序）</h1><ol><li>Divide: Trivial.</li><li>Conquer: Recursively sort 2 sub-arrays.</li><li>Combine: Linear-time merge.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Merge-Sort(A, p, r)</span><br><span class="line">    <span class="keyword">if</span> p &lt; r</span><br><span class="line">        q = (p + r) / <span class="number">2</span></span><br><span class="line">        Merge-Sort(A, p, q)</span><br><span class="line">        Merge-Sort(A, q, r)</span><br><span class="line">        Merge(A, p, q, r)</span><br><span class="line"></span><br><span class="line">Merge(A, p, q, r)</span><br><span class="line">    n1 = q - p + <span class="number">1</span></span><br><span class="line">    n2 = r - q</span><br><span class="line">    let L[<span class="number">1.</span>.n1+<span class="number">1</span>] <span class="keyword">and</span> R[<span class="number">1.</span>.n2+<span class="number">1</span>] be new arrays</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n1</span><br><span class="line">        L[i] = A[p + i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n2</span><br><span class="line">        R[j] = A[q + j]</span><br><span class="line">    L[n1 + <span class="number">1</span>] = ∞</span><br><span class="line">    R[n2 + <span class="number">1</span>] = ∞</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k = p to r</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>$T(n) = 2T(n/2) + \Theta(n) = \Theta(n \lg n)$</li></ul><h1 id="Binary-search（二分查找）"><a href="#Binary-search（二分查找）" class="headerlink" title="Binary search（二分查找）"></a>Binary search（二分查找）</h1><ul><li>find x in a sorted array.<ol><li>Divide: compare x with the middle element in the array.</li><li>Conquer: recurs in one sub-array.</li><li>Combine:  Trivial, nothing to do.</li></ol></li><li>$T(n) = T(n/2) + \Theta(1) = \Theta(\lg n)$</li></ul><h1 id="Powering-a-number（乘方）"><a href="#Powering-a-number（乘方）" class="headerlink" title="Powering a number（乘方）"></a>Powering a number（乘方）</h1><ul><li>given a number x and an integer n ≥ 0, compute xⁿ.<ul><li>Naive algorithm: Θ(n)</li><li>Divide-and-conquer Algorithm<ul><li>$a^n = \begin{cases}<br>  a^{n/2} \times a^{n/2} &amp; \text{if $n$ is even} \\<br>  a^{(n-1)/2} \times a^{(n-1)/2} \times a &amp; \text{if $n$ is odd} \\<br>  \end{cases}$</li><li>$T(n) = T(n/2) + \Theta(1) = \Theta(\lg n)$</li></ul></li></ul></li></ul><h1 id="Fibonacci-numbers（斐波那契数）"><a href="#Fibonacci-numbers（斐波那契数）" class="headerlink" title="Fibonacci numbers（斐波那契数）"></a>Fibonacci numbers（斐波那契数）</h1><ul><li>$F_n = \begin{cases}<br>  0 &amp; \text{if $n = 0$} \\<br>  1 &amp; \text{if $n = 1$} \\<br>  F_{n-1} + F_{n-2} &amp; \text{if $n \geq 2$} \\<br>  \end{cases}$</li><li>Naive recursive algorithm（朴素递归算法）<ul><li>$T(n) = \Omega(\varphi^n)$, where $\varphi = (1 + \sqrt 5) / 2$</li><li><strong>Exponential time</strong>（指数级时间）algorithm is bad.</li><li><strong>Polynomial time</strong>（多项式时间）algorithm is good.</li></ul></li><li>Bottom-top algorithm（自底向上算法）<ul><li>Compute the Fibonacci numbers in order, forming each number by summing the two previous.</li><li>Running time is linear, $T(n) = \Theta(n)$.</li></ul></li><li>Naive recursive squaring algorithm（朴素递归平方算法）<ul><li>$F_n = \varphi^n / \sqrt 5$ rounded to the nearest integer.（$\varphi^n / \sqrt 5$ 距离最近的那个整数，就是第n个斐波那契数）</li><li>$T(n) = \Theta(\lg n)$</li><li>This method is unreliable（不可靠）, since floating-point arithmetic（浮点运算）is prone to round-off errors.</li></ul></li><li>Recursive squaring algorithm（递归平方算法）<ul><li>$\begin{bmatrix} F_2 &amp; F_1 \\ F_1 &amp; F_0 \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}^1$</li><li>$\begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n-1} \end{bmatrix} = \begin{bmatrix} F_n &amp; F_{n-1} \\ F_{n-1} &amp; F_{n-2} \end{bmatrix}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} = \cdots = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}^n$</li><li>$T(n) = \Theta(\lg n)$</li></ul></li></ul><h1 id="Matrix-multiplication（矩阵乘法）"><a href="#Matrix-multiplication（矩阵乘法）" class="headerlink" title="Matrix multiplication（矩阵乘法）"></a>Matrix multiplication（矩阵乘法）</h1><ul><li>Standard algorithm</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Matrix-Multiply(A, B)</span><br><span class="line">    n = A.rows</span><br><span class="line">    let C be a new n×n matrix</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">            C[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k = <span class="number">1</span> to n</span><br><span class="line">                C[i][j] = C[i][j] + A[i][k] × B[k][j]</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure><ul><li>$T(n) = \Theta(n^3)$</li><li><strong>Divide-and-conquer algorithm</strong><ul><li>n x n matrix = 2 x 2 matrix of (n/2) x (n/2) sub-matrices</li><li><img src="/2019/08/02/divide-and-conquer/矩阵乘法的分治法.png" alt></li><li>$\left.\begin{array}{l}r = ae + bg\\s = af + bh\\t = ce + dg\\u = cf + dh\\\end{array}\right\} \quad \left.\begin{array}{l}\text{8 mults of $(n/2)\times(n/2)$ sub-matrices}\\\text{4 adds of $(n/2)\times(n/2)$ sub-matrices}\\\end{array}\right.$</li><li>$T(n) = 8T(n/2) + \Theta(n^2) = \Theta(n^3)$, no better than the ordinary algorithm.</li></ul></li><li><strong>Strassen algorithm</strong><ul><li>Multiply 2 x 2 matrices with only 7 recursive mults<ol><li>Divide: Partition A and B into (n/2)×(n/2) submatrices. Form terms to be multiplied using + and –</li><li>Conquer: Perform 7 multiplications of (n/2)×(n/2) submatrices recursively.</li><li>Combine: Form C using + and – on (n/2)×(n/2) submatrices.</li></ol><ul><li>$\left.\begin{array}{l}P_1 = a \cdot (f-h)\\ P_2 = (a+b) \cdot h\\ P_3 = (c+d) \cdot e\\ P_4 = d \cdot (g-e)\\ P_5 = (a+d) \cdot (e+h)\\ P_6 = (b-d) \cdot (g+h)\\ P_7 = (a-c) \cdot (e+f)\\ \end{array}\right\} \quad \left.\begin{array}{l}r = P_5 + P_4 - P_2 + P_6\\ s = P_1 + P_2\\ t = P_3 + P_4\\ u = P_5 + P_1 - P_3 - P_7\\ \end{array}\right.$</li><li>7 mult, 18 adds/subs (no reliance on commutativity of mult)</li><li>$T(n) = 7T(n/2) + \Theta(n^2) = \Theta(n^{\log_2 7}) = O(n^{2.81})$</li></ul></li></ul></li></ul><h1 id="VLSI-layout（Very-large-scale-integration-layout-超大规模集成电路布局）"><a href="#VLSI-layout（Very-large-scale-integration-layout-超大规模集成电路布局）" class="headerlink" title="VLSI layout（Very large-scale integration layout, 超大规模集成电路布局）"></a>VLSI layout（Very large-scale integration layout, 超大规模集成电路布局）</h1><ul><li>Problem: Embed a complete binary tree with n leaves in a grid using minimal area</li><li><img src="/2019/08/02/divide-and-conquer/VLSI1.png" alt></li><li><img src="/2019/08/02/divide-and-conquer/VLSI2.png" alt></li></ul><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul><li>Divide and conquer is just one of several powerful techniques for algorithm design.</li><li>Divide-and-conquer algorithms can be analyzed using recurrences and the master method (so practice this math).</li><li>Can lead to more efficient algorithms.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（1）算法分析</title>
      <link href="/2019/08/01/analysis-of-algorithm.html"/>
      <url>/2019/08/01/analysis-of-algorithm.html</url>
      
        <content type="html"><![CDATA[<h1 id="Analysis-of-algorithm"><a href="#Analysis-of-algorithm" class="headerlink" title="Analysis of algorithm"></a>Analysis of algorithm</h1><ul><li>The analysis of algorithm is the <strong>theoretical study</strong>（理论研究）of computer program <strong>performance</strong>（性能）and <strong>resource usage</strong>（资源利用）.</li><li>Why do we study algorithms and performance if it’s at the bottom of heap?<ol><li>Performance measures the line between the feasible（可行）and the infeasible, algorithms are on the cutting edge of entrepreneurship（解决问题的最前沿）.</li><li>Algorithm give you a language for talking about program behavior, and that turns out to be a language that has been pervasive through computer science. Performance is like currency（货币）, it the universal thing that you quantity.</li><li>Algorithm is tons of fun, speed if always fun.</li></ol></li></ul><h1 id="Running-time"><a href="#Running-time" class="headerlink" title="Running time"></a>Running time</h1><ul><li>Depends on <strong>input</strong> itself（输入本身）. ( Ex. already sorted )</li><li>Depends on <strong>input size</strong>（输入规模）. ( Ex. 6 vs 6×10ⁿ ）<ul><li>Parameterize  things in the input size.（依输入规模将其参数化）</li><li>Talk about time as a function of the size of the things that we are sorting.</li></ul></li><li>We want <strong>upper bounds</strong>.（运行时间的上界）<ul><li>It represents a guarantee to the user.</li></ul></li></ul><h1 id="Kinds-of-analysis"><a href="#Kinds-of-analysis" class="headerlink" title="Kinds of analysis"></a>Kinds of analysis</h1><ul><li><strong>Worst-case analysis</strong>（最坏情况分析）（usually）<ul><li>T(n) = the maximum time on any input of size n. </li><li>Worst-case time depends on computer.</li><li>Compare algorithms typically for <strong>relative speed</strong>（相对速度）(on same machine).</li><li><strong>absolute speed</strong> （绝对速度）(on different machine).</li></ul></li><li><strong>Average-case analysis</strong>（平均情况分析）（sometimes）<ul><li>T(n) = the expect time over all inputs of size n.</li><li>Need an assumption of the statistical distribution of inputs.</li></ul></li><li>Best-case analysis（最好情况分析）（bogus假象）</li></ul><h1 id="Problem-Sorting"><a href="#Problem-Sorting" class="headerlink" title="Problem: Sorting"></a>Problem: Sorting</h1><ul><li>Input: sequence &lt; a1, a2, … , an &gt; of numbers.</li><li>Output:permutation &lt; a1′, a2′, … , an′ &gt; such that a1′ ≤ a2′ ≤ … ≤ an′.</li></ul><h2 id="Insertion-Sort（插入排序）"><a href="#Insertion-Sort（插入排序）" class="headerlink" title="Insertion Sort（插入排序）"></a>Insertion Sort（插入排序）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Insertion-Sort(A, n) <span class="comment">//Sorts A[1...n]</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">2</span> to n</span><br><span class="line">        key = A[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><h2 id="Insertion-sort-analysis"><a href="#Insertion-sort-analysis" class="headerlink" title="Insertion sort analysis"></a>Insertion sort analysis</h2><ul><li>Worst-case: input reverse sorted.</li><li>$T(n)  = \sum_{j=2}^n \Theta(j) = \Theta(n^2)$</li><li>Is insertion sort fast?<ul><li>moderately fast for small n</li><li>not at all for lager n</li></ul></li></ul><h2 id="Merge-Sort（归并排序）"><a href="#Merge-Sort（归并排序）" class="headerlink" title="Merge Sort（归并排序）"></a>Merge Sort（归并排序）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Merge sort A[<span class="number">1.</span>..n]</span><br><span class="line"><span class="comment">//T(n)</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> If n=<span class="number">1</span>, done.</span><br><span class="line"><span class="comment">//Θ(1), constant time</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Recursively sort A[<span class="number">1.</span>..n/<span class="number">2</span>] <span class="keyword">and</span> A[n/<span class="number">2</span>+<span class="number">1.</span>..n].</span><br><span class="line"><span class="comment">//2T(n/2)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="string">"Merge"</span> <span class="number">2</span> sorted lists.</span><br><span class="line"><span class="comment">//key subroutine, Θ(n)</span></span><br></pre></td></tr></table></figure><ul><li><strong>Recurrence</strong>（递归表达式）for the performance of merge sort</li><li>$T(n) = \begin{cases}<br>  \Theta(1) &amp; n=1 \\<br>  2T(n/2)+\Theta(n) &amp; n &gt; 1<br>  \end{cases}$</li></ul><h2 id="Recursion-tree-method（递归树法）"><a href="#Recursion-tree-method（递归树法）" class="headerlink" title="Recursion-tree method（递归树法）"></a>Recursion-tree method（递归树法）</h2><ul><li><img src="/2019/08/01/analysis-of-algorithm/递归树法示例1.jpg" alt></li><li>Θ(nlgn) is asymptotically faster than Θ(n²).</li><li>Merge sort, on a large enough input size (more than 30), is going to beat insertion sort.</li></ul><h1 id="Asymptotic-analysis"><a href="#Asymptotic-analysis" class="headerlink" title="Asymptotic analysis"></a>Asymptotic analysis</h1><ol><li>Ignore machine-dependent constants（忽略依赖于机器的常量）, look at the <strong>growth of the running time</strong> instead of the actual running time（关注运行时间的增长）.</li><li>Asymptotic analysis satisfies our issue of being able to compare both relative and absolute speed.</li><li>Some of the slower algorithms, even though may asymptotically be slower（从渐进的观点来看低速）, they may still be faster on reasonable sizes of things（在合理的输入规模下运行得更快）.</li><li>We have to balance our mathematical understanding（数学理解）with our engineering common sense（工程直觉）in order to do good programming.</li></ol><h1 id="Asymptotic-notation"><a href="#Asymptotic-notation" class="headerlink" title="Asymptotic notation"></a>Asymptotic notation</h1><ul><li><strong>Ο notation</strong> — asymptotically upper bounds（渐进上界，≤）<ul><li>f(n) = Ο(g(n)) means there are consts c &gt; 0, n0 &gt; 0, such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0.<ul><li>Ex. 2n² = Ο(n³).</li></ul></li><li>Set definition: Ο(g(n)) = { f(n): there are consts c &gt; 0, n0 &gt; 0, such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0 }</li><li>Macro convention（宏用法）: A set in a formula represents an anonymous function in that set.<ul><li>f(n) = n³ + Ο(n²) means there is a function h(n)∈Ο(n²), such that f(n) = n³ + h(n).</li><li>n² + Ο(n) = Ο(n²) means for any f(n)∈Ο(n), there is an h(n)∈Ο(n²), such that n² + f(n) = h(n).</li></ul></li></ul></li><li><strong>Ω notation</strong> — asymptotically lower bounds（渐进下界，≥）<ul><li>Ω(g(n)) = { f(n): there exist consts c &gt; 0, n0 &gt; 0, such that 0 ≤ cg(n) ≤ f(n) for all n ≥ n0 }<ul><li>sqrt(n) = Ω(lgn) means up to constant factors root n is at least lgn for sufficiently large n.</li></ul></li></ul></li><li><strong>Θ notation</strong> — asymptotically tight bounds（渐进紧确界，=）<ul><li>Θ(g(n)) = Ο(g(n)) ∩ Ω(g(n)) = { f(n): there exist consts c1 &gt; 0, c2 &gt; 0, n0 &gt; 0, such that 0 ≤ c1g(n) ≤ f(n) ≤ c2g(n) for all n ≥ n0 } </li><li>From a formula, drop low order terms（弃掉低阶项）and ignore leading constants（忽略前面的常数因子）<ul><li>Ex. 3n³ + 90n² - 5n + 1024 = Θ(n³)</li></ul></li><li>As n→∞, Θ(n²) algorithm always beats a Θ(n³) algorithm.</li></ul></li><li><strong>ο notation</strong> — non-asymptotically tight upper bounds（非渐进紧确上界， &lt; ）<ul><li>ο(g(n)) = { f(n): for any constant c &gt; 0, there is const n0 &gt; 0, such that 0 ≤ f(n) &lt; cg(n) for all n ≥ n0 }</li><li>$\lim_{n \to \infty} {f(n) \over g(n)} = 0$<ul><li>Ex. 2n = ο(n²), but 2n² ≠ ο(n²).</li></ul></li></ul></li><li><strong>ω</strong> <strong>notation</strong> — non-asymptotically tight lower bounds（非渐进紧确下界， &gt; ）<ul><li>ο(g(n)) = { f(n): for any constant c &gt; 0, there is const n0 &gt; 0, such that 0 ≤ cg(n) &lt; f(n) for all n ≥ n0 }</li><li>$\lim_{n \to \infty} {f(n) \over g(n)} = \infty$</li><li>Ex. n²/2 = ω(n), but n²/2 ≠ ω(n²).</li></ul></li></ul><h1 id="Solving-recurrences"><a href="#Solving-recurrences" class="headerlink" title="Solving recurrences"></a>Solving recurrences</h1><h2 id="Substitution-method（代换法）"><a href="#Substitution-method（代换法）" class="headerlink" title="Substitution method（代换法）"></a>Substitution method（代换法）</h2><ol><li>Guess the form of the solution</li><li>Verify whether the recurrence satisfy this bound by induction（数学归纳法验证）</li><li>Solve for constants</li></ol><ul><li>Ex. T(n) = 4T(n/2)+n</li><li>Guess T(n)=Ο(n³), assume T(k)≤ck³ for k＜n, T(n) = 4T(n/2)+n ≤ 4(n/2)³+n = ½cn³+n = cn³-(½cn³-n) ≤ cn³, if (½cn³-n) ≥ 0, e.g. c≥2, n≥1.（<strong>desired - residual</strong>  期望 - 余项）</li><li>We must also handle the initial conditions/the boundary conditions, that is, ground the induction with base cases.</li><li>Base：T(n)=Θ(1) for all n&lt;n0, where n0 is a suitable constant. For 1 ≤ n＜n0, we have “Θ(1)”≤cn³, if we pick c big enough.</li><li>Guess T(n)=Ο(n²), assume T(k)≤ck² is useless, IDEA：Strengthen the induction hypothesis, <strong>subtract a low-order term</strong>.</li><li>Assume T(k)≤c₁k²-c₂k for k&lt;n, T(n) ≤ c₁n²-c₂n-(c₂-1)n ≤ c₁n²-c₂n, if c₂≥1. Pick c₁ big enough to handle the initial conditions.</li></ul><h2 id="Recursion-tree-method（递归树法）-1"><a href="#Recursion-tree-method（递归树法）-1" class="headerlink" title="Recursion-tree method（递归树法）"></a>Recursion-tree method（递归树法）</h2><ul><li>A recursion-tree models the costs (time) of a recursive execution of an algorithm.</li><li>The recursion-tree method is good for generating guesses for the substitution method.</li><li>The recursion-tree method can be unreliable（不可靠）, just like any method that uses ellipses (…).</li><li>The recursion-tree method promotes intuition（直观）, however.</li><li><img src="/2019/08/01/analysis-of-algorithm/递归树法示例2.jpg" alt></li></ul><h2 id="Master-method（主方法）"><a href="#Master-method（主方法）" class="headerlink" title="Master method（主方法）"></a>Master method（主方法）</h2><ul><li>Applies to recurrence of the form：<strong>T(n) = aT(n/b) + f(n).</strong></li><li>Where <strong>a ≥ 1</strong>（至少递归一次）and <strong>b &gt; 1</strong>（子问题规模减小）are constants and <strong>f(n) is an asymptotically positive function</strong>（渐进正函数，存在某特定n0，当n≥n0时，f(n)＞0）.</li><li><img src="/2019/08/01/analysis-of-algorithm/主方法比较示意图.png" alt></li><li>Compare $f(n)$ with $n^{\log_b a}$</li><li>Case 1:<ul><li>$f(n) = O(n^{ {\log_b}^a - \varepsilon})$ for some constant $\varepsilon &gt; 0$</li><li>Solution: $T(n) = \Theta(n^{\log_b a})$</li><li>The weight increases geometrically from the root to the leaves. The leaves hold a constant fraction of the total weight.</li></ul></li><li>Case 2:<ul><li>$f(n) = \Theta(n^{\log_b a} \lg^k n)$ for some constant $k \geq 0$</li><li>Solution: $T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$</li><li>(k = 0) The weight is approximately the same on each of the $\log_b n$ levels.</li></ul></li><li>Case 3:<ul><li>$f(n) = \Omega(n^{ {\log_b}^a + \varepsilon})$ for some constant $\varepsilon &gt; 0$</li><li>Solution: $T(n) = \Theta(f(n))$</li><li>The weight decreases geometrically from the root to the leaves. The root holds a constant fraction of the total weight.</li></ul></li><li>Ex. $T(n) = 4T(n/2) + f(n), a=4, b=2, n^{\log_b a} = n^2$.<ol><li>$f(n) = n = O(n^{2-\varepsilon})$, Case 1, T(n)=Θ(n²).</li><li>$f(n) = n^2 = \Theta(n^2 lg^0 n)$, Case 2, T(n)=Θ(n²lgn).</li><li>$f(n) = n^3 = Ω(n^{2+\varepsilon})$, Case 3, T(n)=Θ(n³).</li><li>$f(n)=n^2 / \lg n$, master method doesn’t apply, in particular, for every constant $\varepsilon&gt;0$, we have $n^\varepsilon = \omega(\lg n)$.</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 算法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu问题汇总</title>
      <link href="/2019/07/31/ubuntu-question.html"/>
      <url>/2019/07/31/ubuntu-question.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-终端基本语法"><a href="#Ubuntu-终端基本语法" class="headerlink" title="Ubuntu 终端基本语法"></a>Ubuntu 终端基本语法</h1><h2 id="设置-grub2-启动引导"><a href="#设置-grub2-启动引导" class="headerlink" title="设置 grub2 启动引导"></a>设置 grub2 启动引导</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;default&#x2F;grub</span><br><span class="line"># 删除或注释 GRUB_TIMEOUT_STYLE&#x3D;hidden</span><br><span class="line"># 将 GRUB_TIMEOUT 由 0 修改为 10</span><br><span class="line"># 将 GRUB_DEFAULT 由 0 改为 saved, 并在文件末尾加上 GRUB_SAVEDEFAULT&#x3D;true, 自由切换默认程序</span><br><span class="line"></span><br><span class="line"># 更新 grub</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><h2 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install xxxx</span><br></pre></td></tr></table></figure><h2 id="卸载移除应用"><a href="#卸载移除应用" class="headerlink" title="卸载移除应用"></a>卸载移除应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove xxxx</span><br></pre></td></tr></table></figure><h2 id="root-模式"><a href="#root-模式" class="headerlink" title="root 模式"></a>root 模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入root</span><br><span class="line">sudo su</span><br><span class="line"># 退出root</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="强制删除文件或目录"><a href="#强制删除文件或目录" class="headerlink" title="强制删除文件或目录"></a>强制删除文件或目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf xxx</span><br></pre></td></tr></table></figure><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"># 全部子目录及文件权限修改为每个人都有读和写以及执行的权限</span><br><span class="line">sudo chmod 777 * -R</span><br></pre></td></tr></table></figure><h2 id="添加和删除-PPA-源"><a href="#添加和删除-PPA-源" class="headerlink" title="添加和删除 PPA 源"></a>添加和删除 PPA 源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加 PPA 源</span><br><span class="line">sudo add-apt-repository ppa:user&#x2F;ppa-name</span><br><span class="line">sudo apt-get update</span><br><span class="line"># 删除 PPA 源</span><br><span class="line">sudo add-apt-repository -r ppa:&#x2F;user&#x2F;ppa-name</span><br><span class="line"># 删除后进入 &#x2F;etc&#x2F;apt&#x2F;source.list.d 目录将相应 PPA 源的保存文件删除</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h1 id="应用安装"><a href="#应用安装" class="headerlink" title="应用安装"></a>应用安装</h1><h2 id="安装-typora"><a href="#安装-typora" class="headerlink" title="安装 typora"></a>安装 typora</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https:&#x2F;&#x2F;typora.io&#x2F;linux&#x2F;public-key.asc | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &#39;deb https:&#x2F;&#x2F;typora.io&#x2F;linux .&#x2F;&#39;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure><h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 配置 git 库</span><br><span class="line">sudo add-apt-repository ppa:git-core&#x2F;ppa</span><br><span class="line"># 安装 git</span><br><span class="line">sudo apt-get install git</span><br><span class="line"># 配置git config</span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;email&quot;</span><br><span class="line"># 避免频繁输入 github 账号密码</span><br><span class="line">sudo apt-get install vim</span><br><span class="line">touch .git-credentials</span><br><span class="line">sudo gedit .git-credentials # 在主目录输入</span><br><span class="line">https:&#x2F;&#x2F;Username:Password@github.com # 输入相应文字后保存</span><br></pre></td></tr></table></figure><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install curl</span><br><span class="line">curl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_10.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><h2 id="安装-sublime-text"><a href="#安装-sublime-text" class="headerlink" title="安装 sublime text"></a>安装 sublime text</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https:&#x2F;&#x2F;download.sublimetext.com&#x2F;sublimehq-pub.gpg | sudo apt-key add -</span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line">echo &quot;deb https:&#x2F;&#x2F;download.sublimetext.com&#x2F; apt&#x2F;stable&#x2F;&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;sublime-text.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text</span><br></pre></td></tr></table></figure><h2 id="安装-gThumb"><a href="#安装-gThumb" class="headerlink" title="安装 gThumb"></a>安装 gThumb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gthumb</span><br></pre></td></tr></table></figure><h2 id="安装-XMind"><a href="#安装-XMind" class="headerlink" title="安装 XMind"></a>安装 XMind</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 在官网 https://www.xmind.cn/xmind8-pro/ 下载文件 (如 xmind-8-update8-linux.zip)</span></span><br><span class="line"><span class="comment"># 2. 解压文件到 /opt/ 目录</span></span><br><span class="line">sudo unzip xmind<span class="number">-8</span>-update8-linux.zip -d /opt/xmind8</span><br><span class="line">sudo chmod -R <span class="number">777</span> /opt/xmind8/*</span><br><span class="line"><span class="comment"># 3. 在解压文件夹中打开终端安装相关依赖</span></span><br><span class="line">sudo ./setup.sh</span><br><span class="line"><span class="comment"># 4. 安装完成后进入 /opt/xmind8/XMind_amd64 双击 XMind 确认是否可以运行</span></span><br><span class="line"><span class="comment"># 5. 下载破解补丁 (链接: https://pan.baidu.com/s/1iLZ8OBuckGrRLlBJrgDCFA 提取码: 8s6y) 放到 /opt/xmind8/XMind_amd64 目录下, 并添加到 XMind.ini 中</span></span><br><span class="line">sudo echo -javaagent:/opt/xmind8/XMind_amd64/XMindCrack.jar &gt;&gt; /opt/xmind8/XMind_amd64/XMind.ini</span><br><span class="line"><span class="comment"># 6. 修改 hosts 文件, 在最后加上一列 "127.0.0.1 www.xmind.net"</span></span><br><span class="line">sudo gedit /etc/hosts</span><br><span class="line"><span class="comment"># 7. 运行 xmind 输入序列号即可完成破解 </span></span><br><span class="line">XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345</span><br><span class="line"><span class="comment"># 8. 在 /opt/xmind8/XMind_amd64/ 添加运行脚本</span></span><br><span class="line">sudo gedit run.sh</span><br><span class="line">在文件中添加两行</span><br><span class="line">cd /opt/xmind8/XMind_amd64/</span><br><span class="line">/opt/xmind8/XMind_amd64/XMind</span><br><span class="line"><span class="comment"># 9. 修改 run.sh 文件的权限</span></span><br><span class="line">sudo chmod a+x ./run.sh</span><br><span class="line"><span class="comment"># 10. 在 /usr/share/applications 中建立 xmind.desktop 文件</span></span><br><span class="line">cd /usr/share/applications</span><br><span class="line">sudo gedit xmind.desktop</span><br><span class="line">在文件中输入</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Name=Xmind8</span><br><span class="line">Exec=/opt/xmind8/XMind_amd64/run.sh</span><br><span class="line">Icon=/opt/xmind8/xmind_logo.png</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application</span><br></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="Ubuntu-18-04-和-Windows-10-时间不同步"><a href="#Ubuntu-18-04-和-Windows-10-时间不同步" class="headerlink" title="Ubuntu 18.04 和 Windows 10 时间不同步"></a>Ubuntu 18.04 和 Windows 10 时间不同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line">sudo hwclock --localtime --systohc</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《图像处理》空域图像增强</title>
      <link href="/2019/07/20/spatial-domain-enhancement-by-book-image-processing.html"/>
      <url>/2019/07/20/spatial-domain-enhancement-by-book-image-processing.html</url>
      
        <content type="html"><![CDATA[<h1 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h1><ul><li>图像增强技术是最基本和最常用的一种图像处理技术，也常作为其他图像处理技术之前的预处理手段</li><li>图像增强的目的是通过对图像的特定加工，以将被处理的图像转化为对具体应用来说视觉质量和效果更好或更有用的图像</li><li>目前常用的图像增强技术根据根据其处理所进行的空间不同，可分为基于空域（图像域）的方法和基于变换域的方法两类</li></ul><h1 id="空域增强：点操作"><a href="#空域增强：点操作" class="headerlink" title="空域增强：点操作"></a>空域增强：点操作</h1><ul><li>空域：像素位置所在的空间，也称图像空间</li><li>空域图像增强：直接作用于像素，在图像空间进行的增强</li><li>点操作<ul><li>增强操作仅定义在每个像素点的位置上（增强操作仅利用了单个像素的信息）</li><li>种类<ul><li>几何点操作：改变像素的坐标位置 (x,y)</li><li>灰度点操作：改变像素的灰度 f</li></ul></li></ul></li></ul><h2 id="图像坐标变换"><a href="#图像坐标变换" class="headerlink" title="图像坐标变换"></a>图像坐标变换</h2><ul><li>图像（空间/几何）坐标变换是一种位置映射操作，涉及的是图像空间里各个坐标位置间的转换及方式</li></ul><h3 id="基本坐标变换"><a href="#基本坐标变换" class="headerlink" title="基本坐标变换"></a>基本坐标变换</h3><ul><li>变换的表示<ul><li>$\begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}\begin{bmatrix}{a}&amp;{b}&amp;{c}\end{bmatrix}^T\ =\ 0\ \Leftrightarrow\ {点} (x,y) {在直线} ax\ +\ by\ +\ c\ =\ 0 {上}$，这样点矢量 $\begin{bmatrix}{x}&amp;{y}\end{bmatrix}^T$ 就用一个 3-D 矢量 $\begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}^T$ 来表示了</li><li><strong>齐次坐标</strong>：<ul><li>如果空间中的点用矢量形式表示为 $\boldsymbol \omega = \begin{bmatrix}{x}&amp;{y}&amp;{z}\end{bmatrix}^T$，则对应的齐次坐标可表示为 ${\boldsymbol \omega}_h = \begin{bmatrix}{kx}&amp;{ky}&amp;{kz}&amp;{k}\end{bmatrix}^T,k$ 为非零常数</li></ul></li><li><strong>坐标变换</strong>：<ul><li>设原坐标的矢量为 $\boldsymbol v = \begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}^T$，变换后坐标的矢量为 $\boldsymbol v’ = \begin{bmatrix}{x’}&amp;{y’}&amp;{1}\end{bmatrix}^T$，则坐标变换可借助矩阵写为 $\boldsymbol v’ = A_{3{\times}3}\boldsymbol v$</li><li>令 $\boldsymbol v_{1}, \boldsymbol v_{2}, \cdots, \boldsymbol v_{m}$ 代表 m 个点的坐标矢量，则对一个其列由这些列矢量组成的 3 × m 矩阵 $\boldsymbol V$，可用一个  3 × 3 矩阵 $A$ 同时变换所有的点，即 $\boldsymbol V’ = A\boldsymbol V$</li></ul></li></ul></li><li><strong>平移变换</strong><ul><li>平移变换矩阵 $T = \begin{bmatrix}<br>  {1}&amp;{0}&amp;{T_{x}}\\<br>  {0}&amp;{1}&amp;{T_{y}}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li><strong>放缩变换</strong>（尺寸变换）<ul><li>放缩变换矩阵 $S = \begin{bmatrix}<br>  {S_{x}}&amp;{0}&amp;{0}\\<br>  {0}&amp;{S_{y}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li><strong>旋转变换</strong><ul><li>旋转轴垂直于图像平面，旋转角 $\gamma$ 按从旋转轴正向看原点而<strong>顺时针</strong>（从 Y 轴向 X 轴旋转）定义</li><li>旋转轴位于坐标原点时，旋转变换矩阵 $R_{\gamma} = \begin{bmatrix}<br>  {\cos{\gamma}}&amp;{\sin{\gamma}}&amp;{0}\\<br>  {-\sin{\gamma}}&amp;{\cos{\gamma}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>旋转轴不在坐标原点时，<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/旋转变换轴不在原点的情况.png" alt></li></ul></li></ul><h3 id="坐标变换扩展"><a href="#坐标变换扩展" class="headerlink" title="坐标变换扩展"></a>坐标变换扩展</h3><ul><li><strong>反变换</strong><ul><li>基本坐标变换反向进行</li><li>平移变换逆矩阵 $T^{-1} = \begin{bmatrix}<br>  {1}&amp;{0}&amp;{-T_{x}}\\<br>  {0}&amp;{1}&amp;{-T_{y}}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>放缩变换逆矩阵 $S^{-1} = \begin{bmatrix}<br>  {\frac{1}{S_{x}}}&amp;{0}&amp;{0}\\<br>  {0}&amp;{\frac{1}{S_{y}}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>绕在原点的旋转轴顺时针旋转 $\gamma$ 角度的逆矩阵 ${R_{\gamma}}^{-1} = \begin{bmatrix}<br>  {\cos{\gamma}}&amp;{-\sin{\gamma}}&amp;{0}\\<br>  {\sin{\gamma}}&amp;{\cos{\gamma}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix} = {R_{\gamma}}^T$</li></ul></li><li><p><strong>变换级联</strong></p><ul><li>多个不同变换接续进行，如旋转变换的旋转轴不在原点时的旋转</li></ul></li><li><strong>3-点映射变换</strong><ul><li>将矩形映射为平行四边形，而将三角形映射为另一个三角形的变换</li><li>除平移、放缩、旋转变换外还有拉伸变换和剪切变换</li><li><strong>拉伸变换</strong><ul><li>在一个方向上放大，而在其正交方向上缩小的变换</li><li>放缩变换的一种特例，放缩系数互为倒数</li><li>设拉伸系数为 L，则拉伸变换矩阵 $\boldsymbol L = \begin{bmatrix}<br>  {L}&amp;{0}&amp;{0}\\<br>  {0}&amp;{1/L}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li><strong>剪切变换</strong><ul><li>仅像素的水平坐标或垂直坐标之一发生（与像素的垂直或水平坐标数值相关的）平移变化</li><li>水平剪切变换矩阵 $\boldsymbol J_{h} = \begin{bmatrix}<br>  {1}&amp;{J_{x}}&amp;{0}\\<br>  {0}&amp;{1}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>垂直剪切变换矩阵 $\boldsymbol J_{v} = \begin{bmatrix}<br>  {1}&amp;{0}&amp;{0}\\<br>  {J_{y}}&amp;{1}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li>五种典型的坐标变换示意<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/五种典型的坐标变换示意.png" alt></li></ul></li><li><strong>旋转变换的分解</strong><ul><li>通过结合剪以及水平和垂直方向的放缩来实现快速旋转，但是放缩操作需额外的计算，还可能导致分辨率减小<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/旋转变换的分解1.png" alt></li><li>为避免放缩操作，可将图像旋转分解为 3 个 1-D 剪切变换的级联以加速<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/旋转变换的分解2.png" alt></li></ul></li></ul><h2 id="图像间运算"><a href="#图像间运算" class="headerlink" title="图像间运算"></a>图像间运算</h2><ul><li>图像间的运算指以图像为单位进行的操作（按数组方式进行），运算的结果是一幅新图像</li></ul><h3 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h3><ul><li>算术运算<ul><li>一般用于<strong>灰度图像</strong></li><li>设有分别属于两幅图像对应位置的两个像素 p 和 q</li><li>加法：p + q</li><li>减法：p - q</li><li>乘法：p × q（也可写为 pq）</li><li>除法：p ÷ q</li><li>将两个像素的灰度值通过相应运算得到一个新的灰度值作为对应输出图像中同一位置处像素的灰度值</li></ul></li><li>逻辑运算<ul><li>只用于<strong>二值图像</strong>（0 和 1）</li><li>补（COMPLEMENT）：NOT q（也可写为 $\bar{q}$）</li><li>与（AND）：p AND q（也可写为 p ▪ q）</li><li>或（OR）：p OR q（也可写为 p + q）</li><li>异或（XOR）：p XOR q（也可写为 p ⊕ q）</li></ul></li></ul><h3 id="图像间算术运算的应用"><a href="#图像间算术运算的应用" class="headerlink" title="图像间算术运算的应用"></a>图像间算术运算的应用</h3><ul><li>图像间加法的应用<ul><li>用于图像平均以减少和去除图像采集中混入的噪声</li><li>实际采集到的图像 g(x,y) 可看作是由原始场景图像 f(x,y) 和噪声图像 e(x,y) 叠加而成的，即 g(x,y) = f(x,y) + e(x,y)，假设图像在各点的噪声是互不相关的，且噪声具有零均值的统计特性</li><li>将 M 个图像相加再求平均得到一幅新的图像，即 $\bar{g}(x,y)={\frac{1}{M}}\sum_{i=1}^{M}g_{i}(x,y)$</li><li>可以证明新图像的期望值为原始场景图像 $E\{\bar{g}(x,y)\}=f(x,y)$</li><li>如果考虑新图像和噪声图像各自的均方差之间的关系，则有 $\sigma_{\bar{g}(x,y)} = \sqrt{\frac{1}{M}} \times \sigma_{e(x,y)}$</li><li>可见随着平均图数量增加，噪声在每个像素位置的影响将越来越小</li></ul></li><li>图像间减法的应用<ul><li>两图相减可把差异凸显出来</li><li>医学图像处理：消除背景，医学成像的基本工具之一</li><li>运动检测：对时间上相邻的两幅图像求差可以将图像中目标的位置和形状变化凸显出来</li></ul></li><li>图像间乘法和除法的应用<ul><li>校正由于照明或传感器的非均匀性所造成的图像明暗变化</li><li>模板运算</li><li>彩色空间中的转换</li></ul></li></ul><h2 id="图像灰度映射"><a href="#图像灰度映射" class="headerlink" title="图像灰度映射"></a>图像灰度映射</h2><h3 id="灰度映射原理"><a href="#灰度映射原理" class="headerlink" title="灰度映射原理"></a>灰度映射原理</h3><ul><li>图像灰度映射要根据原始图像中的每个像素的灰度值，按照某种映射规则，直接将其变换或转化为另一灰度值，从而达到增强图像视觉效果的目的</li><li>灰度映射函数 $t=E_{H}(s)$，t 为增强灰度值，s 为原始灰度值</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/灰度映射原理.png" alt></li></ul><h3 id="典型灰度映射"><a href="#典型灰度映射" class="headerlink" title="典型灰度映射"></a>典型灰度映射</h3><ul><li><strong>图像求反</strong><ul><li>将原图灰度值翻转，使白变黑，使黑变白</li><li>照片和底片关系就是这样</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/图像求反灰度映射.png" alt></li></ul></li><li><strong>增强对比度</strong><ul><li>增加图像各相邻部分的灰度差别，具体通过增加图像中某两个灰度值之间的动态范围来进行</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/增强对比度灰度映射.png" alt></li></ul></li><li><strong>动态范围压缩</strong><ul><li>如果原图动态范围太大，超出显示设备允许的动态范围，会导致细节丢失，此时需要对原图进行一定的灰度范围压缩，常用压缩方式是借助对数形式的灰度映射函数 $t=Clog(1+|s|)$</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/动态范围压缩灰度映射.png" alt></li></ul></li><li><strong>伽马校正</strong><ul><li>借助<strong>指数变换</strong>映射的增强技术 $t=Cs^{\gamma}$</li><li>当 $\gamma &lt; 1$ 时，变换的结果是输入中较窄的低灰度范围被映射到输出中较宽的灰度范围，而同时输入中较宽的高灰度范围被映射到输出中较窄的灰度范围</li><li>许多图像获取、显示、打印设备的输出响应与输入激励满足对数变换的规律，为校正其响应为线性的，需进行指数变换，如常见的 CRT 显示器的亮度-电压响应满足指数变换规律，直接显示的效果会暗许多，校正后显示结果基本与原图一致</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/伽马校正示例.png" alt></li></ul></li></ul><h2 id="直方图变换"><a href="#直方图变换" class="headerlink" title="直方图变换"></a>直方图变换</h2><ul><li>直方图变换（也叫直方图修正）是以概率论为基础，通过改变图像的直方图来改变图像中各像素的灰度，以达到图像增强的目的</li></ul><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><ul><li>直方图均衡化借助图像的直方图表达来进行，目标是<strong>平衡不同灰度级像素的数量</strong></li><li>灰度统计<strong>直方图</strong><ul><li>提供了图像像素的灰度值分布情况</li><li>是一个以灰度值为自变量的 <strong>1-D的离散函数</strong> $h(k) = n_{k} \quad k=0,1,\cdots,L-1$</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/灰度统计直方图.png" alt></li><li>直方图的均值和方差也是图像灰度的均值和方差</li><li>图像的视觉效果和其直方图有对应关系</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/不同类型图像及其直方图示例.png" alt></li></ul></li><li>灰度统计<strong>累积直方图</strong><ul><li>也是一个 1-D 离散函数</li><li>可以表示成 $H(k) = \sum_{i=0}^{k}n_{i} \quad k=0,1,\cdots,L-1$</li><li>累积直方图中列 k 的高度给出图像中灰度值小于和等于 k 的像素的总个数</li></ul></li><li>直方图均衡化原理<ul><li>直方图均衡化主要用于<strong>增强动态范围偏小的图像的对比度</strong></li><li>基本思想：把原始图像的<strong>直方图变换为均匀分布的形式</strong>，增加像素之间灰度值差别的动态范围，从而达到增强图像整体对比度的结果</li><li>归一化直方图<ul><li>将直方图以<strong>归一化的概率形式表达</strong>给出了对各灰度值在图像中所占的数量比例</li><li>$p_{s}(s_{k}) = \frac{n_{k}}{N} \quad 0 \leq s_{k} \leq 1 \quad k = 0,1,\cdots,L-1$</li><li>$s_{k}$ 为图像 f(x,y) 的第 k 级灰度值，N是图像中像素的总个数，L 是灰度级的数量</li></ul></li><li>增强函数 $E_{H}(s)$<ul><li>两个条件<ul><li>$E_{H}(s)$ 在 $0 \leq s \leq 1$ 范围内是单值单增函数 $\Longrightarrow$ 各灰度级在变换后仍<strong>保持排列次序</strong></li><li>对 $0 \leq s \leq 1$ 有 $0 \leq E_{H}(s) \leq 1$ $\Longrightarrow$ 变换前后图像的<strong>灰度值动态范围保持一致性</strong></li></ul></li><li><strong>累积分布函数</strong><ul><li>$t_{k} = E_{H}(s_{k}) = \sum_{i=0}^k\frac{n_{i}}{N} = \sum_{i=0}^k{p_{s}(s_{i})} \quad 0 \leq s_{k} \leq 1 \quad k = 0,1,\cdots,L-1$</li><li>提供了图像像素灰度值得累积分布情况</li><li>$t_{k}$ 是 k 的单值单增函数</li><li>灰度值取值范围一致，$0 \leq t_{k} \leq 1$</li><li>将 s 的分布转换为 t 的均匀分布</li></ul></li></ul></li><li>取整扩展<ul><li>$t_{k} = int[t_{k} \times (L-1) + 0.5]$</li></ul></li><li>确定映射对应关系<ul><li>$s_{k} \rightarrow t_{k}$</li></ul></li><li>根据映射关系计算均衡化直方图</li></ul></li><li>直方图均衡化的列表计算<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/直方图均衡化计算列表.jpg" alt></li><li>直方图均衡化效果<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/直方图均衡化效果.png" alt></li></ul><h3 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h3><ul><li>直方图均衡化：能自动增强图像整体对比度，但实际增强效果不易控制，结果总是得到全局均衡化的直方图</li><li>直方图规定化：有选择地增强某个特定灰度值范围内的对比度，使图像灰度值的分布满足特定的要求</li><li>直方图规定化原理<ul><li>要调整原始图像的直方图去逼近所规定的目标直方图</li><li>三个步骤<ul><li>对原始直方图进行灰度均衡化</li><li>$t_{k} = E_{H_{s}}(s_{i}) = \sum_{i=0}^k{p_{s}(s_{i})} \quad k = 0,1,\cdots,L-1$</li><li>规定需要的直方图，并计算能使规定的直方图均衡化的变换</li><li>$v_{l} = E_{H_{u}}(u_{j}) = \sum_{j=0}^l{p_{u}(u_{j})} \quad l = 0,1,\cdots,L-1$</li><li>将步骤 1 得到的变换反转过来，即将原始直方图（灰度级数 M）对应映射到规定直方图（灰度级数 N）<ul><li>单映射规则（SML）</li><li>从大到小依次找到使 $| \sum_{i=0}^k{p_{s}(s_{i})} - \sum_{j=0}^l{p_{u}(u_{j})} |$ 最小的 k 和 l，然后将 $p_{s}(s_{i})$ 分别对应到 $p_{u}(u_{j})$ 去</li><li><strong>组映射规则（GML）</strong></li><li>设有一个整数函数 $I(l), 0 \leq l \leq N-1$，满足 $0 \leq I(0) \leq \cdots \leq I(l) \leq \cdots \leq I(N-1) \leq M-1$。现在要确定能使 $| \sum_{i=0}^{I(l)}{p_{s}(s_{i})} - \sum_{j=0}^l{p_{u}(u_{j})} |$达到最小的 $I(l)$，然后分组对应</li></ul></li></ul></li></ul></li><li>直方图规定化的列表计算<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/直方图规定化计算列表.jpg" alt></li><li>直方图规定化的绘图计算<ul><li>将直方图画成一长条，每一段对应直方图的一项</li><li>单映射规则是从原始累积直方图的各项依次向规定累计直方图进行映射，每次选择最接近的数值，即遵循最短（最垂直）的连线<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/单映射规则绘图示例.png" alt></li><li>组映射规则是<strong>从规定累积直方图</strong>的各项依次向原始累积直方图进行，遵循最短（最垂直）的连线<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/组映射规则绘图示例.png" alt></li></ul></li><li>两种映射规则的比较<ul><li>单映射规则：有偏的映射规则，最大误差为 $p_{u}(u_{j})/2$</li><li>组映射规则：统计无偏的映射规则，最大误差为 $p_{s}(s_{i})/2$</li><li>$\because N \leq M \quad \therefore p_{s}(s_{i})/2 \leq p_{u}(u_{j})/2$</li></ul></li><li>直方图均衡化和直方图规定化<ul><li>直方图规定化是直方图变换或直方图修正的一般形式</li><li>直方图均衡化可看作使用完全水平的直方图作为规定直方图的直方图规定化</li></ul></li></ul><h1 id="空域增强：模板操作"><a href="#空域增强：模板操作" class="headerlink" title="空域增强：模板操作"></a>空域增强：模板操作</h1><ul><li>像素在图像空间是按某种规律排列的，相互之间有一定的联系，而相邻或接近的像素之间有更密切的联系，常可结合在一起考虑</li><li>在图像处理中，常用模板来组合相邻或接近的像素，根据这些像素的统计特性或局部运算来进行操作，称为模板操作或模板运算</li><li>利用模板操作来进行图像增强常称为滤波，可以是线性的也可以是非线性的</li><li>由于模板操作涉图像中的局部区域，所以也可方便地进行局部增强</li></ul><h2 id="像素间联系"><a href="#像素间联系" class="headerlink" title="像素间联系"></a>像素间联系</h2><h3 id="像素的邻域和邻接"><a href="#像素的邻域和邻接" class="headerlink" title="像素的邻域和邻接"></a>像素的邻域和邻接</h3><ul><li>邻域：由一个像素周围与其关系最密切的近邻像素组成的集合<ul><li>4-邻域 $N_{4}(p)$：由像素 p 的垂直（上、下）和水平（左、右）共 4 个近邻像素组成</li><li>对角邻域 $N_{D}(p)$：由像素 P 的 对角（左上、右上、左下、右下）共 4 个近邻像素组成</li><li>8-邻域 $N_{8}(P)$：由像素 p 的 4 个 4-邻域像素和 4 个对角邻域像素合起来构成</li></ul></li><li>邻接：一种像素间的空间接近关系<ul><li>4-邻接</li><li>对角邻接</li><li>8-邻接</li></ul></li></ul><h3 id="像素间的连接和连通"><a href="#像素间的连接和连通" class="headerlink" title="像素间的连接和连通"></a>像素间的连接和连通</h3><ul><li>连接：两个像素间的一种空间和属性关系<ul><li>连接与否<ol><li>空间上邻接</li><li>灰度值满足某个特定的相似准则（灰度值相等或同在一个灰度值集合中取值）</li></ol></li><li>两种常用的连接（设 V 是定义连接的灰度值集合）<ul><li>4-连接：2 个像素 p 和 r 在 V 中取值，且 r 在 $N_{4}(p)$ 中</li><li>8-连接：2 个像素 p 和 r 在 V 中取值，且 r 在 $N_{8}(p)$ 中</li></ul></li><li>两个连接的像素一定是邻接的，反之则不一定</li></ul></li><li>连通：连通是连接的推广<ul><li>通路<ul><li>从具有坐标 $(x, y)$ 的像素 p 到具有坐标 $(s, t)$ 的像素 q 的一条通路由一系列具有坐标 $(x_{0}, y_{0}), (x_{1}, y_{1}), \cdots, (x_{n}, y_{n})$ 的独立像素组成，这里 $(x_{0}, y_{0}) = (x, y), (x_{n}, y_{n}) = (s, t)$，且 $(x_{i}, y_{i})$ 与 $(x_{i-1}, y_{i-1})$ 邻接，其中 1 ≤ i ≤ n，n为通路长度</li><li>根据所采用的邻接定义不同，可得到不同的通路<ul><li>4-通路</li><li>8-通路</li></ul></li><li>这里对通路的定义仅考虑了像素坐标空间上的联系，没有考虑像素属性空间上的联系</li></ul></li><li>连通<ul><li>通路建立了两个像素 p 和 q 之间的空间联系，如果这条通路上的所有像素的灰度值均满足某个特定的相似准则，即两两邻接的像素也是连接的，则可以说像素 p 和 q 是连通的</li><li>根据所采用的连接定义的不同，可得到不同的连通<ul><li>4-连通</li><li>8-连通</li></ul></li><li>当 n = 1 时，连通转化为其特例 —— 连接</li></ul></li></ul></li><li>邻接、连接、通路、连通之间的关系<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/邻接、连接、通路、连通之间的关系.png" alt></li></ul><h3 id="像素集合的邻接、连接和连通"><a href="#像素集合的邻接、连接和连通" class="headerlink" title="像素集合的邻接、连接和连通"></a>像素集合的邻接、连接和连通</h3><ul><li>子集：图像中（部分）像素的集合，是图像的一部分</li><li>图像子集邻接：S 的一个或一些像素与 T 的一个或一些像素邻接</li><li>图像子集连接：图像子集邻接且邻接像素的灰度值满足特定的相似准则，即 S 的一个或一些像素与 T 的一个或一些像素连接</li><li>连通组元：由在同一个图像子集中的与同一个像素相连通的所有像素构成</li><li>连通集：只有一个连通组元（即所有像素都互相连通）的图像子集</li><li>区域：一幅图像里的每个连通集构成该图像的一个区域<ul><li>简单连通：区域没有孔</li><li>多重连通：区域有孔</li></ul></li><li>轮廓：即区域的边界，是该区域的一个子集，将该区域与其他区域分离开<ul><li>组成一个区域的边界像素本身属于该区域而在其邻域中有不属于该区域的像素</li></ul></li></ul><h3 id="像素间的距离"><a href="#像素间的距离" class="headerlink" title="像素间的距离"></a>像素间的距离</h3><ul><li>距离量度函数 <code>D(p,q)</code><ul><li>D(p,q) ≥ 0 (D(p,q) = 0 当且仅当 p = q) → 距离恒正</li><li>D(p,q) = D(q,p) → 距离是相对的，与起终点无关</li><li>D(p,q) ≤ D(p,r) + D(r,q) → 沿直线距离最短</li></ul></li><li>测度空间 <code>(A,d)</code><ul><li>A 为抽象集合</li><li>d 为从集合 A 向实数集 R 映射的距离度量函数（d: A × A → R）</li></ul></li><li>2-D 图像中的 3 种距离<ul><li>欧氏距离（范数为 2） $D_{E}(p,q) = \sqrt{(x-s)^2 + (y-t)^2}$</li><li>城区距离（曼哈顿距离，范数为 1） $D_{4}(p,q) = |x-s|+|y-t|$</li><li>棋盘距离（切比雪夫距离，范数为 ∞） $D_{8}(p,q) = \max(|x-s|,|y-t|)$</li></ul></li><li>用距离定义邻域<ul><li>$N_{4}(p) = \{r|D_{4}(p,r) = 1\}$</li><li>$N_{8}(p) = \{r|D_{8}(p,r) = 1\}$</li></ul></li><li><a href="https://blog.csdn.net/alinawly/article/details/80804727" target="_blank" rel="noopener">范数和距离</a><ul><li>函数的范数可表示为 ${\Vert f \Vert}_{m} = [\int|f(x)|^m dx]^{1/m}$</li><li><strong>闵可夫斯基（Minkowski）距离</strong>度量为 $D_{m}(p,q) = [|x-s|^m + |y-t|^m ]^{1/m}$，对应范数为参数 m</li><li>考虑与原点为单位距离的点的集合<ul><li>m = 1 → 菱形</li><li>m = 2 → 圆</li><li>m = ∞ → 正方形</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/3种范数和3种距离.png" alt></li></ul></li></ul></li></ul><h2 id="模板运算"><a href="#模板运算" class="headerlink" title="模板运算"></a>模板运算</h2><ul><li>模板：一般可看作尺寸为 n × n (n 为较小的奇数) 的小图像，在其各位置上的值常称为系数值，系数值由功能确定</li><li>模板运算：将赋予某个像素的值作为它本身灰度值和其相邻像素灰度值的函数</li><li>滤波：利用像素本身以及其邻域像素的灰度关系进行图像增强的方法</li><li>滤波器：实现滤波功能的模板</li></ul><h3 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h3><ul><li>模板卷积：用模板与需处理图像在图像空间进行卷积的运算过程</li><li>模板卷积过程不能原地完成，所以输出结果要是用另一幅图像</li><li>模板卷积步骤<ol><li>将模板在输入图像中漫游，并将模板中心与图像中某个像素位置重合</li><li>将模板上的各个系数与模板下各对应像素的灰度值相乘</li><li>将所有乘积相加（为保持灰度范围，常将结果再除以模板系数之和）</li><li>将上述结果（模板的输出响应）赋给输出图像中对应模板中心位置的像素</li></ol></li><li>用 3 × 3 的模板进行模板操作的示意图<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/用3×3的模板进行模板操作的示意图.jpg" alt></li></ul><h3 id="模板排序"><a href="#模板排序" class="headerlink" title="模板排序"></a>模板排序</h3><ul><li>模板排序：用模板来提取需处理图像中与模板同尺寸的图像子集并将其中像素根据其幅度值排序的运算过程</li><li>模板排序过程也不能原地完成</li><li>模板排序步骤<ol><li>将模板在输入图象中漫游，并将模板中心与图象中某个象素位置重合</li><li>读取模板下输入图象中各对应象素的灰度值</li><li>将这些灰度值进行排序，一般将它们从小到大排成一列（单增）</li><li>根据运算目的从排序结果中选一个序，取出该序象素的灰度值</li><li>将取出的灰度值赋给输出图象中对应模板中心位置的象素</li></ol></li><li>模板排序中<ul><li>模板只划定像素范围，系数均看作 1 且不影响赋值</li><li>赋给输出图像的值必定是输入图像中与模板对应的像素值中的一个</li><li>模板只是为了选取像素，因而不一定是方形的，或者说，虽然用方形模板，但其中有些系数取 0</li></ul></li></ul><h3 id="图像边界处的模板运算"><a href="#图像边界处的模板运算" class="headerlink" title="图像边界处的模板运算"></a>图像边界处的模板运算</h3><ul><li>当模板中心对应输入图像的边界像素时，其邻域范围有可能扩展到输入图像的边界之外</li><li>解决方法<ul><li>忽略边界处的像素<ul><li>仅处理图像内部与边界距离大于等于模板半径 r 的像素</li></ul></li><li>将输入图像进行扩展<ul><li>在图像的 4 条边界外各增加/扩展一个 r 行或 r 列的带</li><li>新增行列中的像素的幅度值<ul><li>取为 0</li><li>取为原图像中 4-邻接像素的值（4 个角上的取为 8-邻接像素的值）</li><li>将图像在水平和垂直方向上均看作周期循环的（最后一行后是第一行，最后一列后是第一列）</li><li>利用外插技术，根据接近边界处行列像素的幅度值以一定的规则进行外推</li></ul></li><li>上述确定幅度值的方法都对边界像素给予了特殊的权重，并会使图像的平均灰度发生小的改变</li></ul></li></ul></li></ul><h3 id="空域滤波分类"><a href="#空域滤波分类" class="headerlink" title="空域滤波分类"></a>空域滤波分类</h3><ul><li>将模板运算用于图像空域增强一般称为<strong>空域滤波</strong></li><li>根据滤波功能分类<ul><li>平滑滤波<ul><li>减弱或消除图像中的高频率分量（高频分量对应图像中区域边缘等灰度值具有较大较快变化的部分，滤去后可减少局部灰度起伏，使图像变得比较平滑）</li><li>消除噪声（噪声的空间相关性较弱，对应较高的空间频率）</li></ul></li><li>锐化滤波<ul><li>减弱或消除图像中的低频率分量（低频分量对应图像中灰度值缓慢变化的区域，与图像的整体特性有关，滤去可使图像反差增加，边缘明显）</li><li>增强被模糊的细节或目标的边缘</li></ul></li></ul></li><li>根据滤波运算特点分类<ul><li>从统计的角度看，滤波是一种估计，它基于一组观察结果来估计未观察的量</li><li>线性滤波：对观察结果进行线性组合，理论基础比较成熟</li><li>非线性滤波：对观察结果的逻辑组合，理论基础较弱</li></ul></li><li>空域滤波增强技术分类<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/空域滤波增强技术分类.png" alt></li></ul><h2 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h2><ul><li>线性滤波既可以得到平滑的效果（图像反差减少），也可以得到锐化的效果（图像反差增加），主要取决于所用模板的系数值</li><li>线性滤波基于<strong>模板卷积</strong>进行</li></ul><h3 id="线性平滑滤波"><a href="#线性平滑滤波" class="headerlink" title="线性平滑滤波"></a>线性平滑滤波</h3><ul><li><strong>邻域平均</strong><ul><li>用一个像素邻域的平均值作为滤波结果</li><li>滤波模板的所有系数都取为 1</li><li>为保持灰度值范围，卷积结果要除以系数总个数再行赋值</li><li>$g(x,y) = {1 \over n^2} \sum_{(s,t) \in N(x,y)}f(s,t)$</li><li>N(x,y) 对应 f(x,y) 中 (x,y) 的 n × n 邻域</li></ul></li><li><strong>加权平均</strong><ul><li>离中心近的像素应对滤波结果有较大的贡献</li><li>将接近模板中心的系数取得比模板周边的系数大</li><li>$g(x,y) = \frac{\sum_{(s,t) \in N(x,y)}\; w(s,t)f(s,t)}{\sum_{(s,t) \in N(x,y)}\; w(s,t)}$</li></ul></li><li><strong>高斯平均</strong><ul><li>加权平均的一种特例</li><li>根据高斯分布（标准正态分布）来确定模板系数</li><li>${1 \over 273}\begin{bmatrix}<br>  1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\<br>  4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\<br>  7 &amp; 26 &amp; 41 &amp; 26 &amp; 7 \\<br>  4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\<br>  1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\<br>  \end{bmatrix}$</li><li>模板分解<ul><li>一个 2-D 高斯卷积可分解为顺序执行的两个 1-D 高斯卷积，即一个 2-D 高斯平均模板可拆分成两个 1-D 高斯平均模板</li><li>${1 \over 16}\begin{bmatrix}<br>  1 &amp; 2 &amp; 1 \\<br>  2 &amp; 4 &amp; 2 \\<br>  1 &amp; 2 &amp; 1 \\<br>  \end{bmatrix} = {1 \over 4}\begin{bmatrix}<br>  1 \\<br>  2 \\<br>  1 \\<br>  \end{bmatrix}{1 \over 4}\begin{bmatrix}<br>  1 &amp; 2 &amp; 1 \\<br>  \end{bmatrix}$</li><li>计算量为 <code>O(n²)</code> 的单个 n × n 模板被计算量为 <code>O(n)</code> 的两个 1 × n 模板所替换</li><li>对 n &gt; 3，总可以借助模板分解减少计算量</li></ul></li><li>1-D 离散模板<ul><li>可对高斯函数在整数位置 <code>-n,…,0,…,+n</code> 采样，具体可取 n = 2σ + 1（σ 为高斯方差），而模板尺寸为 s = 2n + 1</li><li>对高斯函数的简单近似可借助杨辉三角进行<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/1-D高斯模板系数.png" alt></li></ul></li><li>高斯滤波器<ul><li>特点<ul><li>线性的</li><li>与位置无关的</li><li>旋转对称的（各向同性的）</li><li>可以控制效果的（有一个控制参数）</li><li>可以连续多次使用的</li><li>可分离的（2-D 可用 1-D 的来计算）</li><li>不能递归执行</li></ul></li><li>线性滤波器都会改变图像中的噪声方差<ul><li>一个线性滤波器 $h(x,y)$ 会使噪声方差乘以因子 $\sum\sum h(x,y)$</li><li>对于高斯滤波器，这个因子是 $1 \over 4\pi\sigma^2$</li><li>取 $\sigma = {n \over 2\sqrt{\pi}}$，可使高斯滤波器与一个 n × n 的邻域平均滤波器具有相同的效果</li></ul></li></ul></li></ul></li><li><strong>边缘保持平滑</strong><ul><li>为了避免局部平均会模糊不同区域之间的边缘，考虑选择只在不包含边缘的邻域中进行平均</li><li>取中心像素的8个不同邻域，对每个邻域都统计其像素的灰度方差，并将灰度方差最小（方差小的邻域中像素灰度级的变化小，包含边缘的概率也小）的那个邻域中的像素均值赋给中心像素<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/8个边缘保持平滑模板.png" alt></li></ul></li></ul><h3 id="线性锐化滤波"><a href="#线性锐化滤波" class="headerlink" title="线性锐化滤波"></a>线性锐化滤波</h3><ul><li><strong>拉普拉斯算子</strong><ul><li>线性锐化滤波可借助模板卷积实现<ul><li>对应积分运算的模板卷积可以平滑图像，对应微分运算的模板卷积可以锐化图像</li><li>锐化模板系数的取值在中心为正而周围原理中心处为负</li></ul></li><li>拉普拉斯算子是一个<strong>各向同性</strong>的二阶微分算子<ul><li>$\nabla^2 f = {\partial^2 f \over \partial x^2} + {\partial^2 f \over \partial y^2}$</li><li>两个二阶偏导数可借助差分来计算</li><li>$\begin{cases}<br>  {\partial^2 f \over \partial x^2} = 2f(x,y) - f(x+1,y) - f(x-1,y)\\<br>  {\partial^2 f \over \partial y^2} = 2f(x,y) - f(x,y+1) - f(x,y-1)\\<br>  \end{cases}$</li><li>可得到</li><li>$\nabla^2 f(x,y) = 4(x,y) - f(x+1,y) - f(x-1,y) - f(x,y+1) - f(x,y-1)$</li><li>据此得到的模板仅考虑了中心像素的 4-邻域，类似地也可以考虑 8-邻域</li></ul></li><li>两种拉普拉斯算子模板<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/两种拉普拉斯算子模板.png" alt><ul><li>两种模板系数之和均为 0<ul><li>灰度值为常数或变化很小的区域的卷积输出为 0 或很小</li><li>输出图的平均灰度值为 0，图中一部分像素灰度值小于 0</li></ul></li><li>通过变换将输出灰度值范围变回 [0, L-1]<ul><li>图像处理中只考虑大于或等于 0 的灰度值</li><li>变换后才能正常显示</li></ul></li></ul></li><li>拉普拉斯算子可增强图像中的灰度不连续边缘，减弱灰度值缓慢变化区域的对比度，将结果叠加到原始图像上，就可以得到锐化后的图像</li></ul></li><li><strong>高频提升滤波</strong><ul><li>图像锐化的效果可以通过叠加图像微分结果取得，也可通过减除图像积分结果取得</li><li>用原始图像 f(x,y) 减去平滑或模糊图像 g(x,y) 就得到<strong>非锐化掩模</strong> h(x,y)，如将非锐化掩模加到原始图像上就能锐化图像</li><li>进一步，把原始图像乘以一个放大倍数 A 再减去平滑图像就可实现<strong>高频提升滤波</strong></li><li>$h_{b}(x,y) = Af(x,y) - g(x,y) = (A-1)f(x,y) + h(x,y)$<ul><li>A = 1 → 非锐化掩模（平滑时丢失的锐化分量）</li><li>A &gt; 1 → 加权的原始图像与非锐化掩模相加（使原始图像锐化）</li><li>A = 2 → 非锐化掩模化<ol><li>平滑原始图像</li><li>从原始图像中减去平滑后的效果</li><li>将上述结果加到原始图像上</li></ol></li></ul></li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/拉普拉斯算子与高频提升滤波的比较.png" alt></li></ul></li></ul><h2 id="非线性滤波"><a href="#非线性滤波" class="headerlink" title="非线性滤波"></a>非线性滤波</h2><ul><li>线性滤波常不能区分图像中有用的内容和无用的噪声<ul><li>在 1-D 傅里叶空间对原始图像加上白噪声，两者的频谱直接叠加。线性滤波将两者的傅里叶变换相乘，结果在每个频率处信号和噪声的强度都由相同的因子所消弱。图像信噪比保持原值，并不增加<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/线性滤波不能区分图像中有用的特征和噪声.png" alt></li></ul></li><li>非线性滤波可区分图像中有用的内容和无用的噪声<ul><li>三个方向发展：逻辑、几何、代数</li><li>分为三种：基于集合的、基于形状的、基于排序的<ul><li>基于形状的非线性滤波围绕数学形态学进行，而基于形状的形态操作建立在集合论的基础上，并可在一定条件下简化成传统的逻辑表达</li></ul></li></ul></li></ul><h3 id="非线性平滑滤波"><a href="#非线性平滑滤波" class="headerlink" title="非线性平滑滤波"></a>非线性平滑滤波</h3><ul><li><strong>中值滤波原理</strong><ul><li>中值滤波依靠<strong>模板排序</strong>来实现</li><li>考虑 1-D 信号，设模板尺寸为 M = 2r+1，r 为模板半径，给定 1-D 信号序列 {fi}, i = 1, 2, … , N.</li><li>则中值滤波输出为 $g_{j} = median [f_{j-r}, f_{j-r+1}, \cdots, f_{j}, \cdots, f_{j+r}]$</li><li>上述定义的操作常称为游程中值，可以通过滑动奇数长度的模板来实现</li><li>中值滤波适合用于对脉冲噪声的消除<ul><li>脉冲噪声会导致受影响的像素值发生明显变化成为野点</li><li>平均滤波不加区别地平均对应模板的所有像素值，而中值滤波则忽略野点，所以不会模糊图像</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/1-D中值滤波示例.png" alt></li></ul></li><li>考虑一个长度为 L 的信号 $f(i) =<br>  \begin{cases}<br>  = 0  &amp; {i &lt; 0} \\<br>  \neq 0 &amp; {i = 0}\\<br>  \neq 0 &amp; {i = L - 1}\\<br>  = 0 &amp; {i \geq L - 1}\\<br>  \end{cases}$<ul><li>L ≤ r → 输出完全是 0，脉冲全被消除 </li><li>如果信号仅包含长度至少为 r+1 的常数段 → 长度小于等于 2r+1 的中值滤波模板对信号滤波并不会使信号发生任何变化</li></ul></li><li>根信号<ul><li>不受中值滤波影响的信号</li><li>一个信号使用一个长度为 2r+1 的中值滤波的根信号的充分条件是该信号局部单调变化且阶数为 r+1（该信号的长度为 r+1 的段均为单调的）</li></ul></li><li>中值滤波的一些特性<ul><li>可以很好地消除孤立尖峰</li><li>有可能导致尖峰附近的边缘偏移，且元素多的更易偏移</li><li>中值滤波趋向于产生为常数的片段</li></ul></li></ul></li><li>2-D 中值滤波<ul><li>$g_{median}(x,y) = median_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>输出值大于等于模板中一半像素的值，又小于等于模板中另一半像素的值</li><li>一般情况下，图像中尺寸小于模板尺寸一半的过亮或过暗区域将会在滤波后被消除掉</li><li>中值滤波既能消除噪声又能较好地保持图像的细节<ul><li>中值滤波的主要功能就是让与周围像素灰度值的差比较大的像素改取与周围像素值接近的值，这样它对孤立的噪声像素的消除能力是很强的</li><li>又由于它不是简单的取均值，所以产生的模糊比较少</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/邻域平均和中值滤波的比较.png" alt> </li></ul></li></ul></li><li>中值滤波的模板<ul><li>中值滤波的效果与所用模板的尺寸有关，也与模板中参与运算的像素个数有关<ul><li>有实验表明，当使用超过包含 9 — 13 个像素的模板来消除图像中的噪声时，计算量的增加比消噪效果的改善更为明显，所以常可使用稀疏的模板来减少运算量<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/一些用于中值滤波的模板.png" alt></li></ul></li><li>中值滤波的效果还与所用模板的形状或模板中参与计算的像素所构成的图案的形状有关<ul><li>方形：对图像细节不敏感，会滤除细线并消除边缘上的角点，也常在常数灰度区域产生条纹</li><li>十字交叉：能保留较细的水平线和垂直线，但有可能将对角线滤除</li><li>X 形：仅保留对角线</li></ul></li></ul></li><li>2-D 中值计算<ul><li>为提高计算速度，常试图顺序使用两个 1-D 中值滤波模板以实现类似于 2-D 中值滤波模板的效果，但他们并不严格相等</li><li>3 种方法<ol><li>直接使用 2-D 模板</li><li>先使用第 1 个 1-D 模板，再使用第 2 个 1-D 模板</li><li>先使用第 2 个 1-D 模板，再使用第 1 个 1-D 模板</li></ol></li><li>中值计算是非线性的，因而计算结果有可能相同，也有可能不同</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/实现2-D中值滤波的3种方法的结果.png" alt></li><li>不严格分解<ul><li>这并不只是非线性滤波模板的特性，有些线性滤波模板也不能准确分解</li><li>究其原因是在一个 n × n 模板中的独立系数个数是 n²，这比在 n × 1 或 1 × n 分量模板中的独立系数个数要多得多</li></ul></li><li>中值滤波器<ul><li>不可分离，但使用优化算法可使它的运行时间与可分离滤波器基本相同</li><li>不能预测图像边缘是否会变化，也不能确定变化程度，还很难估计噪声消除的效果</li></ul></li></ul></li><li><strong>序统计滤波</strong><ul><li>百分比滤波均基于模板排序来工作，所以是一种序统计滤波</li><li>中值滤波：选取灰度序列中位于 50% 位置的像素作为滤波结果<ul><li>$g_{median}(x,y) = median_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可以消除椒盐噪声</li><li>趋向于在图像中产生具有常数灰度的区域</li></ul></li><li>最大值滤波：选取灰度序列中位于 100% 位置的像素作为滤波结果<ul><li>$g_{max}(x,y) = \max_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可用来检测图像中最亮的点，并可减弱暗（低取值）的椒噪声</li><li>趋向于在图像中产生具有（高）常数灰度的区域</li></ul></li><li>最小值滤波：选取灰度序列中位于 0% 位置的像素作为滤波结果<ul><li>$g_{min}(x,y) = \min_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可用来检测图像中最暗的点，并可减弱亮（高取值）的盐噪声</li><li>趋向于在图像中产生具有（低）常数灰度的区域</li></ul></li><li>中点滤波：取最大值和最小值中点的那个值作为滤波的输出<ul><li>$g_{mid}(x,y) = {1 \over 2}\{ g_{max}(x,y) + g_{min}(x,y) \}$</li><li>结合了排序滤波和平均滤波两种方式的优点</li><li>对多种随机分布的噪声（如高斯噪声、均匀噪声）都比较有效</li></ul></li></ul></li><li><strong>最频值滤波</strong><ul><li>最频值：代表一个分布中最有可能出现的值</li><li>最频值滤波：用最频值作为滤波的输出<ul><li>可以消除噪声（尤其是脉冲噪声）</li><li>可以锐化目标边缘<ul><li>在接近边缘的邻域中，最频值滤波会将最频值移动到更靠近边缘中心的位置，从而使边缘更加尖锐</li><li>这与会模糊边缘的平均滤波不同</li></ul></li></ul></li><li>一个区域灰度分布的均值、中值、最频值都与直方图密切相关<ul><li>均值：直方图均值</li><li>中值：直方图中值</li><li>最频值：统计值最大的灰度值</li><li>直方图对称且仅有一个峰 → 均值、中值、最频值都为该峰</li><li>直方图仅有一个峰但左右不对称 → 最频值对应该峰，中值比均值更接近最频值</li></ul></li></ul></li></ul><h3 id="非线性锐化滤波"><a href="#非线性锐化滤波" class="headerlink" title="非线性锐化滤波"></a>非线性锐化滤波</h3><ul><li><strong>基于梯度的锐化滤波</strong><ul><li>利用微分可以锐化图像（积分平滑图像），最常用的微分方法是利用梯度</li><li>一个连续函数 f(x,y) 的梯度是一个矢量 $\nabla f = \begin{bmatrix} {\partial f \over \partial x} &amp; {\partial f \over \partial y}\\ \end{bmatrix}^T = \begin{bmatrix} G_{x} &amp; G_{y} \end{bmatrix}^T$</li><li>在离散空间，微分用差分实现，下面是两个常用的差分卷积模板，分别计算沿 X 和 Y 方向的差分<img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/两个差分模板.png" alt></li><li>实际锐化滤波中常只使用梯度矢量的幅度（模）</li><li>非线性组合模板的输出值（矢量转化为标量）<ul><li>以 2 为范数计算（对应欧氏距离）：$\vert \nabla f_{(2)} \vert = mag(\nabla f) = [ G_{x}^2 + G_{y}^2 ] ^ {1/2}$</li><li>以 1 为范数计算（对应城区距离）：$\vert \nabla f_{(1)} \vert = \vert G_{x} \vert + \vert G_{y} \vert$</li><li>以 ∞ 为范数计算（对应棋盘距离）：$\vert \nabla f_{(∞)} \vert = max\{ {\vert G_{x} \vert}, {\vert G_{y} \vert} \}$</li></ul></li></ul></li><li><strong>最大-最小锐化变换</strong><ul><li>一种将最大值滤波和最小值滤波结合使用的图像增强技术，可以锐化模糊的边缘并让模糊的目标清晰起来</li><li>这种方法可迭代进行，在每次迭代中将一个模板覆盖区域里的中心像素值与该区域里的最大值和最小值进行比较，然后将中心像素值用与其较接近的极值（最大值或最小值）替换</li><li>最大-最小锐化变换 $S[f(x,y)] = \begin{cases}<br>  g_{max}(x,y)  &amp; {如果 g_{max}(x,y) - f(x,y) \leq f(x,y) - g_{min}(x,y)} \\<br>  g_{min}(x,y) &amp; {其它} \\<br>  \end{cases}$</li><li>迭代进行 $S^{n+1}[f(x,y)] = S \{ S^n[f(x,y)] \}$</li></ul></li><li>锐化滤波模板的通用性质<ol><li>零位移：通过检测和加强图像中对应边缘的部分来增强图像的视觉效果，但不应该改变图像中边缘的位置，一阶微分滤波模板应是反对称的</li><li>消除均值：任意阶的微分滤波模板都不应该对常数值有响应，也即所有系数和为 0</li><li>对称性质：零位移暗示一阶微分算子一般有奇数个反对称的系数，则沿一个方向的卷积计算可简化，对 2r+1 个系数只需要 r 次乘法，2r-1 次加法</li></ol></li></ul><h3 id="线性和非线性混合滤波"><a href="#线性和非线性混合滤波" class="headerlink" title="线性和非线性混合滤波"></a>线性和非线性混合滤波</h3><ul><li>将线性滤波运算和中值滤波运算混合串联起来，先对较大的区域进行计算量较小的线性滤波操作，然后再计算线性滤波输出的中值，作为混合滤波的最终输出<ul><li>1-D 信号 f(i)</li><li>$g(i) = MED[H_{1}(f(i)), H_{2}(f(i)), \cdots, H_{M}(f(i))]$</li><li>2-D 图像 f(x,y)</li><li>$g(x,y) = MED \{ {1 \over 2}[f(x,y-2) + f(x,y-1)], {1 \over 2}[f(x,y+1) + f(x,y+2)], \\<br>  f(x,y), {1 \over 2}[f(x+2,y) + f(x+1,y)], {1 \over 2}[f(x-1,y) + f(x-2,y)]\}$</li></ul></li></ul><h2 id="局部增强"><a href="#局部增强" class="headerlink" title="局部增强"></a>局部增强</h2><ul><li>全局增强：把一幅图像作为一个整体</li><li>局部增强：对图像某些局部区域的细节进行增强</li><li>用全局增强不能保证在所关心区域的局部区域得到所需要的增强效果</li><li>局部增强多了一个选择确定局部区域的步骤，直接利用局部信息以达到局部增强的目的</li><li><strong>直方图变换局部增强</strong><ul><li>直方图变换是空域增强中最常采用的方法，也很容易用于图像的局部增强</li><li>先将图像分成一系列小区域（子图像），对各小区域进行直方图变换，从而使各个小区域得到不同的增强效果</li><li>由于增强是对局部区域分别进行的，增强效果在小区域的边界上有可能不协调，所以实际中常将图像划分为有些互相重叠的小区域以减小这种影响</li><li><img src="/2019/07/20/spatial-domain-enhancement-by-book-image-processing/局部增强效果示例.png" alt></li><li>点操作中的直方图变换虽然可以使动态范围增加，但增强图像中的灰度级数并不会较原始图像变得更多，只是灰度级数间的距离增加</li><li>直方图变换局部增强在增加动态范围的同时也可以增加全图中的灰度级数，避免了像素间的生硬过渡，视觉效果较柔和</li></ul></li><li><strong>基于均值和方差的局部增强</strong><ul><li>局部增强也可在对图像增强时直接利用局部信息以实现对不同的局部或不同的像素进行不同的增强</li><li>常用的局部信息主要是每个像素的邻域内所有像素的灰度均值和灰度方差<ul><li>灰度均值：平均亮度的测度</li><li>灰度方差：亮度反差（对比度）的测度</li></ul></li><li>利用灰度均值和灰度方差来选择需要增强的像素<ul><li>例如需要增强图像中灰度比较大但方差比较小的区域</li><li>$g(x,y) = \begin{cases}<br>  Ef(x,y)  &amp; {M \leq km(x,y) 且 \sigma(x,y) \leq lS} \\<br>  f(x,y) &amp; {其它} \\<br>  \end{cases}$</li><li>$m(x,y), \sigma(x,y)$ 分别是以像素 $(x,y)$ 为中心的邻域像素的灰度均值和均方差值</li><li>$M, S$ 是 $f(x,y)$ 的灰度均值和均方差值</li><li>$k, l$ 是比例常数（可都取 &lt; 0.5）</li><li>$E$ 是增强系数（&gt; 2）</li></ul></li><li>利用每个像素的邻域内所有像素的均值和方差这两个特性进行<ul><li>如要把输入图 f(x,y) 根据各个像素的邻域特性增强成输出图 g(x,y)，需要在每个像素位置 (x,y) 进行如下变换</li><li>$g(x,y) = A(x,y)[f(x,y) - m(x,y)] + m(x,y)$</li><li>其中 $A(x,y) = k {M \over \sigma(x,y)} \; 0 &lt; k &lt; 1$ 称为局部增益函数</li><li>A 与 f - m 相乘能放大图像的局部变化。由于 A(x,y) 反比于均方差，所以在图像对比度较小的区域得到较大的增益，局部对比度增强。最后加上 m 是为了恢复平均灰度值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图像处理》章毓晋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《图像处理》绪论</title>
      <link href="/2019/07/16/introduction-by-book-image-processing.html"/>
      <url>/2019/07/16/introduction-by-book-image-processing.html</url>
      
        <content type="html"><![CDATA[<h1 id="图像及其表示"><a href="#图像及其表示" class="headerlink" title="图像及其表示"></a>图像及其表示</h1><h2 id="图像和信息"><a href="#图像和信息" class="headerlink" title="图像和信息"></a>图像和信息</h2><ul><li>图像：用各种观测系统以不同形式和手段观测客观世界而获得的，可以直接或间接作用于人眼并进而产生视知觉的实体</li><li>信息：人类从外界获得的信息约有 75% 来自视觉系统</li></ul><h2 id="图像类型"><a href="#图像类型" class="headerlink" title="图像类型"></a>图像类型</h2><ul><li>广义：照片、动画、绘图、视像、文档等</li><li>狭义<ul><li>单幅图像 → 序列图像</li><li>静止图像 → 运动图像（视频）</li><li>2-D 图像 → 3-D、立体对、时空体、多光谱、多视场图像</li><li>灰度图像 → 彩色、深度、纹理图像</li></ul></li><li>基本<ul><li>单幅、静止、2-D、灰度图像均可由 <strong>2-D 数组 $f(x,y)$</strong> 表示</li><li><strong><em>f</em></strong> 表示图像在点 (x,y) 处的某种性质</li></ul></li><li>一般的图像表达函数<ul><li><strong>5-D 有限函数 $T(x,y,z,t,λ)$</strong></li><li>x、y、z 是空间变量，t 代表时间变量，λ 代表波长（对应频谱变量）</li></ul></li></ul><h2 id="图像元素"><a href="#图像元素" class="headerlink" title="图像元素"></a>图像元素</h2><ul><li>图像中的每个基本单元称为图像元素<ul><li>2-D 图像：像素（pixel）</li><li>3-D 图像：体素（voxel）</li></ul></li></ul><h2 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h2><ul><li><strong>2-D 数组 f(x,y)</strong><ul><li>x, y : 2-D 空间 XY 中坐标点的位置</li><li>f : 代表图像在 (x,y) 的性质 F 的数值</li><li>性质 F 可对应不同物理量<ul><li>灰度图像：灰度</li><li>二值图像：文字和空白</li></ul></li></ul></li><li><strong>2-D 矩阵</strong><ul><li>$F = \begin{bmatrix}{f_{11}} &amp; {f_{12}} &amp; {\cdots} &amp; {f_{1N}}\\{f_{21}}&amp;{f_{22}}&amp;{\cdots}&amp;{f_{2N}}\\{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\{f_{M1}}&amp;{f_{M2}}&amp;{\cdots}&amp;{f_{MN}}\\\end{bmatrix}$</li></ul></li><li><strong>矢量</strong><ul><li>$\boldsymbol F = \begin{bmatrix}{\boldsymbol f_{1}}&amp;{\boldsymbol f_{2}}&amp;{\cdots}&amp;{\boldsymbol f_{N}}\\\end{bmatrix}$</li><li>其中 ${\boldsymbol f_{i}} = \begin{bmatrix}{\boldsymbol f_{1i}}&amp;{\boldsymbol f_{2i}}&amp;{\cdots}&amp;{\boldsymbol f_{Mi}}\\\end{bmatrix}^T{\quad}i = 1, 2, ···, N$</li></ul></li></ul><h2 id="图像显示"><a href="#图像显示" class="headerlink" title="图像显示"></a>图像显示</h2><ul><li>2-D 图像：看作在 2-D 空间位置上的一种幅度分布</li><li><img src="/2019/07/16/introduction-by-book-image-processing/灰度图像显示方式.png" alt></li><li>上图中是两种灰度图像的显示<ul><li>左图采用的坐标系统在图像计算中采用</li><li>右图采用的坐标系统在屏幕显示中采用</li></ul></li><li><img src="/2019/07/16/introduction-by-book-image-processing/二值图像显示方式.png" alt></li><li>上图是同一个二值图像的 3 种可视表达方式<ul><li>图(a)：像素区域用其中心表示</li><li>图(b)：像素区域仍用区域表示</li><li>图(c)：幅度值标在图像对应位置</li></ul></li></ul><h1 id="图像分辨率"><a href="#图像分辨率" class="headerlink" title="图像分辨率"></a>图像分辨率</h1><h2 id="空间分辨率和幅度分辨率"><a href="#空间分辨率和幅度分辨率" class="headerlink" title="空间分辨率和幅度分辨率"></a>空间分辨率和幅度分辨率</h2><ul><li>图像所对应的空间视场由几何成像模型所确定<ul><li>空间视场中的精度对应其空间分辨率</li><li>空间分辨率对应<strong>数字化的空间采样点数</strong></li></ul></li><li>图像的幅度范围由亮度成像模型所确定<ul><li>幅度范围中的精度对应其幅度分辨率</li><li>幅度分辨率对应<strong>采样点值的量化级数</strong></li></ul></li></ul><h2 id="采样与量化"><a href="#采样与量化" class="headerlink" title="采样与量化"></a>采样与量化</h2><ul><li>空间<strong>采样</strong>：空间坐标的离散化</li><li>灰度<strong>量化</strong>：灰度值的离散化</li><li><img src="/2019/07/16/introduction-by-book-image-processing/空间分辨率和幅度分辨率.png" alt></li><li>采样过程可看作将图像平面划分成规则网格，每个网格中心点位置由笛卡尔坐标 (x,y) 决定</li><li>量化过程可看作给点对 (x,y) 通过函数 f(▪) 赋予灰度值</li></ul><h2 id="分辨率与数据量"><a href="#分辨率与数据量" class="headerlink" title="分辨率与数据量"></a>分辨率与数据量</h2><ul><li>图像水平尺寸为 $M = 2^m$，图像垂直尺寸为 $N = 2^n$，像素灰度级数为 $G = 2^k$</li><li>则图像存储所需位数为 $b = M \times N \times k$</li></ul><h1 id="图像质量"><a href="#图像质量" class="headerlink" title="图像质量"></a>图像质量</h1><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><ul><li>保持灰度级数不变，降低空间分辨率，会出现像素粒子变粗的现象</li><li>保持空间分辨率不变，降低灰度级数，在灰度缓慢变化区域会出现山脊结构（虚假轮廓）</li></ul><h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><ul><li>图像的亮度本身是一个客观量，人们对它的感知是一个主观量</li><li>图像的亮度常对应图像的灰度，较大的灰度对应较高的亮度</li></ul><h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><ul><li>对比度描述图像局部范围内相邻两部分之间的亮度差别，也可以用相邻两部分亮度平均值的比值来描述</li><li>相对亮度对比度 RBC = $\frac{I_{max}\;\; -\; I_{min}}{I_{max}\;\; +\; I_{min}}$</li></ul><h1 id="图像处理系统"><a href="#图像处理系统" class="headerlink" title="图像处理系统"></a>图像处理系统</h1><h2 id="系统构成框图"><a href="#系统构成框图" class="headerlink" title="系统构成框图"></a>系统构成框图</h2><p><img src="/2019/07/16/introduction-by-book-image-processing/图像处理系统的构成.png" alt></p><h2 id="图像采集"><a href="#图像采集" class="headerlink" title="图像采集"></a>图像采集</h2><ul><li>图像采集装置<ul><li><strong>物理器件（传感器）</strong>：对某个电磁能量谱波段（如X射线、紫外线、可见光、红外线等）敏感，能产生与所接收到的电磁能量成正比的（模拟）电信号</li><li><strong>数字化器</strong>：能将上述（模拟）电信号转化为数字（离散）的形式</li></ul></li><li>固态采集器件<ul><li>构成<ul><li>固态阵：感光基元产生正比于光强的输出电压，空间分辨率取决于基元排列</li><li>数字化器：幅度分辨率取决于量化级数</li></ul></li><li>器件种类<ul><li>电荷耦合器件 CCD</li><li>互补金属氧化物半导体 CMOS</li><li>电荷注射器件 CID</li></ul></li></ul></li></ul><h2 id="图像显示和打印"><a href="#图像显示和打印" class="headerlink" title="图像显示和打印"></a>图像显示和打印</h2><ul><li>图像显示<ul><li>图像处理结果多是供观察的</li><li>图像数据转换成亮度模式显示</li></ul></li><li>显示设备<ul><li>阴极射线管</li><li>电视显示器</li><li>液晶显示器</li><li>打印设备</li></ul></li><li><strong>半调输出技术</strong><ul><li>多数打印设备仅能直接输出二值图像</li><li>半调输出技术是一种<strong>将灰度图像转化为二值图像</strong>的技术</li><li>半调输出技术利用人眼的集成特性，通过控制输出二值点模式的形式（包括数量，尺寸，形状等）来让人获得视觉上多个灰度的感觉</li><li>半调输出技术仅在<strong>输出设备的灰度值有限</strong>的情况下使用，是<strong>以空间分辨率的减少换取幅度分辨率的增加</strong>（牺牲图像的空间点数来增加图像的灰度级数）</li><li>幅度调制（AM）半调输出<ul><li>通过调整输出黑点的尺寸来显示不同的灰度</li><li>二值点规则排列，墨点的尺寸反比于灰度值，点的形状不是决定性因素</li></ul></li><li>频率调制（FM）半调输出<ul><li>输出黑点的尺寸固定，但其在空间的分布（点间隔或一定区域内点出现频率）取决于灰度值</li><li>缺点：点增益（打印单元尺寸相对于原始单元尺寸的增加量）导致打印图灰度范围的减少或压缩</li></ul></li><li>半调输出模板<ul><li>每个模板对应一个输出单元</li><li>将模板划分为规则网格，每个网格对应一个基本二值点，通过调整各个网格为黑或白，让模板输出不同的灰度，从而达到输出灰度图像的目的</li><li>如果将一个模板分成 n×n 网格， 则可以输出 n² + 1 种不同的灰度</li></ul></li></ul></li><li>抖动技术<ul><li>通过半调输出技术可以看出若要保留细节则灰度级数不能太多，但是一幅图像的灰度级数比较少时图像的视觉质量会比较差</li><li>抖动技术通过调节或变动图像的幅度值来改善量化过粗图像的显示质量</li><li>抖动可通过对原始图像 f(x,y) 加一个随机的小噪声 d(x,y) 来实现，设 b 为图像显示的比特数，则 d(x,y) 的值可以从 $-2^{6-b}, -2^{5-b}, 0, 2^{5-b}, 2^{6-b}$ 五个数中以均匀概率取得，将 f(x,y) 加这样一个随机的小噪声 d(x,y) 的 b 个最高有效比特作为最终输出像素的值</li></ul></li></ul><h2 id="图像存储"><a href="#图像存储" class="headerlink" title="图像存储"></a>图像存储</h2><ul><li>图像存储器<ul><li>处理过程中使用的快速存储器（计算机内存，帧缓存）</li><li>较快重新调用的在线或联机存储器（磁盘，磁光盘）</li><li>不经常使用的数据库（档案库）存储器（磁带，光盘，光盘塔）</li></ul></li><li>图像文件格式<ul><li>BMP 格式：Windows 环境下的一种标准，全称 Microsoft 独立位图</li><li>GIF 格式：公用图像文件格式标准，一般为 8 位文件格式</li><li>TIFF 格式：独立于操作系统和文件系统的格式，便于软件之间进行图像数据交换</li><li>JPEG 格式：静止灰度或彩色图像的一种压缩标准</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图像处理》章毓晋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt基础知识</title>
      <link href="/2019/07/13/qt-knowledge.html"/>
      <url>/2019/07/13/qt-knowledge.html</url>
      
        <content type="html"><![CDATA[<h1 id="Qt简介"><a href="#Qt简介" class="headerlink" title="Qt简介"></a>Qt简介</h1><ul><li>Qt 是一个著名的 C++ 应用程序框架。你并不能说它只是一个 GUI 库，因为 Qt 十分庞大，并不仅仅是 GUI 组件。使用 Qt，在一定程度上你获得的是一个“一站式”的解决方案：不再需要研究 STL，不再需要 C++ 的<code>&lt;string&gt;</code>，不再需要到处去找解析 XML、连接数据库、访问网络的各种第三方库，因为Qt自己内置了这些技术。</li><li>后续Qt相关文章均参考 <a href="https://www.devbean.net/2012/08/qt-study-road-2-catelog/" target="_blank" rel="noopener">Qt学习之路2</a> 。</li></ul><h1 id="Qt5-VS2017开发环境搭建"><a href="#Qt5-VS2017开发环境搭建" class="headerlink" title="Qt5+VS2017开发环境搭建"></a>Qt5+VS2017开发环境搭建</h1><ul><li><p><a href="https://blog.csdn.net/gaojixu/article/details/82185694#QtVS2017_60" target="_blank" rel="noopener">Qt5+VS2017环境搭建</a></p><blockquote><p>1.Qt 组件的选取根据需要来选择即可<br>2.为配合 VS2017 的使用需要勾选 MSVC 2017 64-bit 和 MinGW 7.3.0 64-bit</p></blockquote></li></ul><h1 id="信号槽"><a href="#信号槽" class="headerlink" title="信号槽"></a>信号槽</h1><h2 id="什么是信号与槽"><a href="#什么是信号与槽" class="headerlink" title="什么是信号与槽"></a>什么是信号与槽</h2><ul><li><p>所谓信号槽，实际类似<strong>观察者模式</strong>。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个<strong>信号（signal）</strong>。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用<strong>连接（connect）函数</strong>，也就是用自己的一个函数（称为<strong>槽（slot）</strong>）来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** main.cpp ***/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtWidgets/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"Quit"</span>)</span></span>;</span><br><span class="line">QObject::connect(&amp;button, SIGNAL(clicked()), &amp;a, SLOT(quit()));</span><br><span class="line">button.show();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序运行时，会出现一个带有“Quit”字样按钮的窗口，点击按钮程序退出</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect()函数"></a>connect()函数</h2><ul><li>使用<code>connect()</code>可以连接系统提供或者自定义的信号和槽。</li><li><p>Qt5 中 <code>QObject::connect()</code> 有 6 个重载：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> <span class="keyword">char</span> *member,</span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> QMetaMethod &amp;signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> QMetaMethod &amp;method, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *member, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    Functor functor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *context, Functor functor, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>connect()</code>函数一般使用 4 个参数：sender、signal、receiver、slot。绑定信号与槽以后，sender 发出 signal 会自动调用 receiver 的 slot 函数</p><ul><li>sender 与 receiver 都是 <code>QObject *</code> 类型的<strong>指针</strong></li><li><code>SIGNAL</code> 和 <code>SLOT</code> 这两个宏可以将两个<strong>除去返回值的函数声明</strong>转换成 <code>const char *</code> 类型</li><li><p>任何成员函数、static 函数、全局函数以及 Lambda 表达式都可作为槽函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line"></span><br><span class="line">    QPushButton button(&quot;Quit&quot;);</span><br><span class="line">    QObject::connect(&amp;button, &amp;QPushButton::clicked, [](bool) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;You clicked me!&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    button.show();</span><br><span class="line"></span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;程序运行时点击Quit按钮会在终端输出&quot;You clicked me!&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="自定义信号槽"><a href="#自定义信号槽" class="headerlink" title="自定义信号槽"></a>自定义信号槽</h2><ul><li><p>信号槽不是 GUI 模块提供的，而是 Qt 核心特性之一。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** newspaper.h ***/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Newspaper(<span class="keyword">const</span> QString &amp; name) :</span><br><span class="line">        m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的信号</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** reader.h ***/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Reader() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的槽函数</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveNewspaper</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Receives Newspaper: "</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** main.cpp ***/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"newspaper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Newspaper <span class="title">newspaper</span><span class="params">(<span class="string">"Newspaper A"</span>)</span></span>;</span><br><span class="line">    Reader reader;</span><br><span class="line">    QObject::connect(&amp;newspaper, &amp;Newspaper::newPaper, </span><br><span class="line">                     &amp;reader, &amp;Reader::receiveNewspaper);</span><br><span class="line">    newspaper.send();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的程序运行时会看到终端输出"Receives Newspaper: Newspaper A"</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Q_OBJECT</code> 宏</strong></p><ul><li><strong>只有继承了 <code>QObject</code> 类的类才具有信号槽能力。</strong></li><li>凡是<code>QObject</code>类（不管是直接子类还是间接子类），都应该在<strong>头文件</strong>的第一行代码写上<code>Q_OBJECT</code>。<strong>不管是不是使用信号槽，都应该添加这个宏。</strong>这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。这个宏由 moc 做特殊处理，生成以 <code>moc_</code> 为前缀的文件。</li></ul></li><li><strong>signals 块</strong><ul><li>signals 块中列出该类需要的信号。</li><li>信号是一个个函数声明，返回值类型为 void（无法获得信号的返回值，也就不需要任何返回值），参数是该类需要让外界知道的数据。</li><li>信号无需在 cpp 文件中进行实现（moc 处理会实现信号函数所需要的函数体）</li><li><code>emit</code> 关键字是 Qt 对 C++ 的扩展，含义是“发出“，也即发出信号。</li></ul></li><li><strong>槽函数（slot 块）</strong><ul><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数。</li><li>与信号函数不同，槽函数必须自己完成实现代码。</li><li>槽函数就是普通的成员函数，因此作为成员函数，也会受到 public、private 等访问控制符的影响。</li><li>sender 和 receiver 都需要是 <code>QObject</code> 的子类。（槽函数是全局函数和 Lambda 表达式等无需接收者的情况除外。）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Qt基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
