<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面向对象（1）</title>
      <link href="/2020/01/java-object-oriented-1/"/>
      <url>/2020/01/java-object-oriented-1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，<br>使用 Java 语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。</p><p>面向对象思想就是在计算机程序设计过程中，参照现实中事物，<strong>将属性特征、行为特征抽象出来，描述成计算机事件</strong>的设计思想。 它区别于面向过程思想，<strong>强调的是通过调用对象的行为来实现功能</strong>，而不是自己一步一步的去操作实现。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。<br>面向对象的语言中，包含了<strong>三大基本特征，即封装、继承和多态。</strong></p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="什么是类和对象"><a href="#什么是类和对象" class="headerlink" title="什么是类和对象"></a>什么是类和对象</h2><p><strong>类</strong>：是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该<br>类事物。</p><ul><li><strong>属性</strong>：就是该事物的状态信息。</li><li><strong>行为</strong>：就是该事物能够做什么。</li></ul><p><strong>对象</strong>：是一类事物的具体体现。对象是<strong>类的一个实例</strong>，必然具备该类事物的属性和行为。</p><p>类和对象的关系：</p><ul><li>类是对一类事物的描述，是<strong>抽象</strong>的。</li><li>对象是一类事物的实例，是<strong>具体</strong>的。</li><li><strong>类是对象的模板，对象是类的实例。</strong></li></ul><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>Java 中用类（<code>class</code>） 来描述事物：</p><ul><li><strong>成员变量</strong>（属性）</li><li><strong>成员方法</strong>（行为）</li></ul><p>类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>成员变量直接定义在<strong>类中、方法外</strong>；</li><li>成员方法<strong>不加 static 关键字</strong>。</li></ol><h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><p>通常情况下，一个类不能直接使用，需要根据类创建一个对象才能使用。</p><p>创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName objectName  = <span class="keyword">new</span> ClassName();</span><br></pre></td></tr></table></figure><p>使用对象访问类中的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectName.成员变量名</span><br><span class="line">objectName.成员方法名(参数)</span><br></pre></td></tr></table></figure><p>成员变量的默认值：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>整数（byte、short、int、long）</td><td>0</td></tr><tr><td>浮点数（float、double）</td><td>0.0</td></tr><tr><td>字符（char）</td><td>\u0000</td></tr><tr><td>布尔（boolean）</td><td>false</td></tr><tr><td>引用（数组、类、接口）</td><td>null</td></tr></tbody></table></div><h2 id="对象内存原理"><a href="#对象内存原理" class="headerlink" title="对象内存原理"></a>对象内存原理</h2><ul><li>创建的对象存储在堆内存中<ul><li>成员变量</li><li>成员方法标记值（成员方法的地址值）</li></ul></li><li>类的信息存储在方法区中<ul><li>成员方法的信息</li></ul></li><li>程序运行在栈内存中<ul><li>main 方法首先入栈，最后出栈<ul><li>局部变量</li><li>引用变量（对象地址值）</li></ul></li><li>成员方法不断压栈和出栈<ul><li>局部变量</li></ul></li></ul></li></ul><h2 id="使用对象类型作为方法的参数和返回值"><a href="#使用对象类型作为方法的参数和返回值" class="headerlink" title="使用对象类型作为方法的参数和返回值"></a>使用对象类型作为方法的参数和返回值</h2><p>引用类型作为参数和返回值时，传递的都是地址值。</p><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>变量根据<strong>定义位置的不同</strong>分成成员变量和局部变量两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    数据类型 成员变量名;<span class="comment">// 成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        数据类型 局部变量名;<span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在类中的位置不同<ul><li>成员变量：类中、方法外</li><li>局部变量：方法中或者方法声明中（形式参数）</li></ul></li><li>作用范围不同<ul><li>成员变量：类中</li><li>局部变量：方法中</li></ul></li><li>初始化值不同<ul><li>成员变量：有默认值</li><li>局部变量：没有默认值，必须定义后赋值才能使用</li></ul></li><li>在内存中的位置不同<ul><li>成员变量：堆内存</li><li>局部变量：栈内存</li></ul></li><li>生命周期不同<ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li></ul></li></ul><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><p>封装就是将一些细节信息隐藏起来，对于外界不可见。封装性在 Java 当中的体现：</p><ol><li><code>方法</code> 就是一种封装：调用者只知道方法会完成什么功能，并不知道功能具体是如何实现的。</li><li>关键字 <code>private</code> 也是一种封装：将类的属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</li></ol><h2 id="private-关键字"><a href="#private-关键字" class="headerlink" title="private 关键字"></a><code>private</code> 关键字</h2><p> <code>private</code> 的含义：</p><ul><li>private 是一个<strong>权限修饰符</strong>，代表最小权限，可以修饰成员变量和成员方法。</li><li>被 private 修饰后的成员变量和成员方法，<strong>在本类当中仍可以随意访问</strong>，但是超出了本类范围之外就不能再直接访问了。</li></ul><p>间接访问 private 成员变量：定义 <code>getXxx</code> 方法和 <code>setXxx</code> 方法</p><ul><li>Getter 方法：不能有参数，返回值类型和成员变量对应</li><li>Setter 方法：不能有返回值，参数类型和成员变量对应</li><li>对于基本类型当中的 boolean 值，Getter 方法一定要写成 <code>isXxx</code> 的形式，而 setXxx 规则不变</li></ul><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a><code>this</code> 关键字</h2><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，会优先使用局部变量，导致成员变量被隐藏，无法访问成员变量。</p><p>如果需要访问本类当中的成员变量，需要使用 <code>this</code> 关键字。使用格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名</span><br></pre></td></tr></table></figure><p>使用 this 关键字代表所在类的当前对象的引用（地址值），即对象自己的引用。<strong>谁在调用，谁就是this。</strong> </p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当我们<strong>通过关键字 new 来创建对象时，其实就是在调用构造方法。</strong>构造方法专门用来初始化对象，给对象的成员变量赋初始值。</p><p>构造方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassName</span><span class="params">(参数类型 参数名称, ...)</span> </span>&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法的名称必须与所在类的类名完全一致</li><li>构造方法<strong>没有返回值类型</strong>，也不能返回一个值</li><li>如果没有自定义构造方法，编译器会默认提供一个<strong>无参构造方法</strong> <code>public ClassName() {}</code> </li><li>一旦自定义构造方法，编译器不再提供默认的无参构造方法</li><li>构造方法可以重载</li></ul><h2 id="标准的类（JavaBean）"><a href="#标准的类（JavaBean）" class="headerlink" title="标准的类（JavaBean）"></a>标准的类（JavaBean）</h2><p>一个标准的类通常要满足下面的条件：</p><ol><li>类是具体的和公共的；</li><li>所有的成员变量都使用 private 关键字修饰；</li><li>为每一个成员变量都提供一对 Getter/Setter 方法；</li><li>必须具有一个无参数的构造方法；</li><li>建议具有一个全参数的构造方法；</li></ol><p>这样的标准规范也叫做 <code>Java Bean</code> ，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//构造方法，无参构造方法【必须】，有参构造方法【建议】</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="comment">//getXxx()</span></span><br><span class="line"><span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java面向对象 </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 成员变量 </tag>
            
            <tag> 局部变量 </tag>
            
            <tag> 封装 </tag>
            
            <tag> private关键字 </tag>
            
            <tag> this关键字 </tag>
            
            <tag> 构造方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（4）</title>
      <link href="/2020/01/java-fundamentals-4/"/>
      <url>/2020/01/java-fundamentals-4/</url>
      
        <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法（Method）就是若干语句的功能集合。</p><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><p>定义方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名, ...) &#123;</span><br><span class="line">    方法体;</span><br><span class="line">    [<span class="keyword">return</span> 返回值;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当一个方法需要一些数据条件，才能完成任务的时候，就有参数。</li><li>一个方法不需要任何数据条件，自己就能独立完成任务，就无参数。</li><li>返回值类型：必须要和 return 语句返回值的类型相同，否则编译失败 。</li><li>不能在 return 后面写代码，return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。</li></ul><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>方法的三种调用格式：</p><ol><li>单独调用： <code>方法名(参数);</code> </li><li>打印调用： <code>System.out.println(方法名(参数));</code></li><li>赋值调用： <code>数据类型 变量名 = 方法名(参数);</code> </li></ol><p>注意：返回值类型为 void 的方法只能单独调用，不能进行打印调用和赋值调用</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>方法应该定义在类当中，但是不能在方法当中再定义方法。</li><li>方法定义的前后顺序无所谓。</li><li>方法定义之后不会执行，如果希望执行，一定要调用。</li><li>如果方法有返回值，那么必须写上 <code>return 返回值;</code> ，不能没有。</li><li>return 后面的返回值数据，必须和方法的返回值类型，对应起来。</li><li>对于一个 void 方法，不能写 return 后面的返回值，只能写 <code>return;</code> 。</li><li>对于 void 方法当中最后一行的 return 可以省略不写。</li><li>一个方法当中可以有多个 return 语句，但是必须保证同时只有一个会被执行到，两个 return 不能连写。</li></ol><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p><strong>方法重载（Overload）</strong>：指在同一个类中，允许存在一个以上的<strong>同名方法</strong>，只要它们的<strong>参数列表不同</strong>即可，<strong>与参数名称、修饰符和返回值类型无关</strong>。</p><ul><li>好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。</li><li>参数列表：<strong>个数</strong>不同，<strong>数据类型</strong>不同，<strong>多类型顺序</strong>不同。</li><li>重载方法调用：JVM 通过方法的参数列表，调用不同的方法。</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组的概念：是一种容器，可以同时存放多个数据值。</p><p>数组的特点：</p><ol><li>数组是一种引用数据类型</li><li>数组当中的多个数据，类型必须统一</li><li><strong>定长</strong>特性：数组的长度在程序运行期间不可改变</li></ol><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。</p><p>两种常见的初始化方式：</p><ol><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ol><h3 id="动态初始化数组"><a href="#动态初始化数组" class="headerlink" title="动态初始化数组"></a>动态初始化数组</h3><p>动态初始化数组的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><p>使用动态初始化数组时，其中的元素将在自动拥有一个默认值。规则如下：</p><ul><li>如果是整数类型，默认值为 <code>0</code> </li><li>如果是浮点数类型，默认值为 <code>0.0</code> </li><li>如果是字符类型，默认值为 <code>\u0000</code> （不可见字符）</li><li>如果是布尔类型，默认值为 <code>false</code> </li><li>如果是引用类型，默认值为 <code>null</code> </li></ul><h3 id="静态初始化数组"><a href="#静态初始化数组" class="headerlink" title="静态初始化数组"></a>静态初始化数组</h3><p>静态初始化数组的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[] &#123;元素<span class="number">1</span>,元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;;<span class="comment">// 标准格式</span></span><br><span class="line"></span><br><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;;<span class="comment">// 省略格式</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>静态初始化没有直接指定长度，但是仍然会自动推算得到长度。</li><li>动态初始化和静态初始化标准格式可以拆分成为 <code>声明数组</code> 和 <code>创建数组</code> 两个步骤。</li><li>静态初始化一旦使用省略格式，就不能拆分成为两个步骤来写了，但依然隐含了 new 操作。</li></ol><h2 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h2><p><strong>数组索引</strong>： 每一个存储到数组的元素，都会自动的拥有一个编号， <code>从 0 开始，一直到数组长度减 1 为止</code> ，这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素。</p><p>访问数组元素的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure><p>索引访问数组中的元素：</p><ul><li><code>数组名[索引] = 数据值</code> ，为数组中的元素赋值</li><li><code>变量名 = 数组名[索引]</code> ，获取出数组中的元素</li></ul><h2 id="数组的内存原理"><a href="#数组的内存原理" class="headerlink" title="数组的内存原理"></a>数组的内存原理</h2><p>内存是用于程序运行的临时存储区域，程序运行完毕后会清空内存。</p><p>Java 虚拟机为了提高运算效率，对内存空间进行了不同区域的划分：</p><div class="table-container"><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器（PC Register）</td><td>与 CPU 相关</td></tr><tr><td>本地方法栈（Native Method Stack）</td><td>JVM 在使用操作系统功能的时候使用</td></tr><tr><td>方法区（Method Area）</td><td>存储 .class 文件，包含方法的信息</td></tr><tr><td>堆（Heap）</td><td>存储对象或数组，凡是 new 创建的都存储在堆中</td></tr><tr><td>栈（Stack）</td><td>存储方法中的局部变量，方法一定在栈中运行</td></tr></tbody></table></div><p>数组名称：存储数组<strong>内存地址哈希值</strong>。</p><p> <code>数组A = 数组B</code> 将数组 A 的引用赋值给数组 B，结果数组 A 和 B 将会指向同一片内存空间。</p><h2 id="数组操作的常见异常"><a href="#数组操作的常见异常" class="headerlink" title="数组操作的常见异常"></a>数组操作的常见异常</h2><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><p>如果访问数组元素的时候，索引编号并不存在，程序运行后，将会抛出 <code>ArrayIndexOutOfBoundsException</code> 数组越界异常。</p><h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><p>所有的引用类型变量，都可以赋值为一个 null 值，但是代表其中什么都没有。</p><p>数组必须进行 new 初始化才能使用其中的元素。如果只是赋值了一个 null，没有进行 new 创建，那么将会发生 <code>NullPointerException</code> 空指针异常。</p><h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>每个数组都具有长度，而且是固定的。</p><p>Java 中赋予了数组的一个属性，可以获取到数组的长度，语句为： <code>数组名.length</code> ，属性 length 的执行结果是数组的长度，int 类型结果。</p><p>数组一旦创建，程序运行期间，长度不可改变。</p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>数组遍历： 将数组中的每个元素分别获取出来，就是遍历。</p><p>遍历也是数组操作中的基石。</p><p>数组的索引是 <code>0</code> 到 <code>lenght-1</code> ，可以作为循环的条件出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.println(array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组作为方法参数和返回值"><a href="#数组作为方法参数和返回值" class="headerlink" title="数组作为方法参数和返回值"></a>数组作为方法参数和返回值</h2><p>一个方法<strong>可以有0、1 或多个参数</strong>；但是只能有0或者1个返回值，<strong>不能有多个返回值</strong>。</p><p>任何数据类型都能作为方法的参数类型或返回值类型。</p><ul><li>数组作为方法参数传递，传递的参数是数组内存的地址。</li><li>数组作为方法的返回值，返回的其实也是数组的地址值。</li></ul><h2 id="方法的参数类型区别"><a href="#方法的参数类型区别" class="headerlink" title="方法的参数类型区别"></a>方法的参数类型区别</h2><ul><li><strong>方法的参数为基本类型时，传递的是数据值。</strong></li><li><strong>方法的参数为引用类型时，传递的是地址值。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java基础 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（3）</title>
      <link href="/2020/01/java-fundamentals-3/"/>
      <url>/2020/01/java-fundamentals-3/</url>
      
        <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。</p><h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>顺序结构：按照编写的顺序，依次运行。</p><div id="flowchart-0" class="flow-chart"></div><h1 id="分支（选择）结构"><a href="#分支（选择）结构" class="headerlink" title="分支（选择）结构"></a>分支（选择）结构</h1><h2 id="判断语句（if）"><a href="#判断语句（if）" class="headerlink" title="判断语句（if）"></a>判断语句（<code>if</code>）</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-1" class="flow-chart"></div><h3 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a><code>if-else</code> 语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-2" class="flow-chart"></div><h3 id="if-else-if-else-语句"><a href="#if-else-if-else-语句" class="headerlink" title="if-else if-else 语句"></a><code>if-else if-else</code> 语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">    语句体n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-3" class="flow-chart"></div><h2 id="选择语句（switch）"><a href="#选择语句（switch）" class="headerlink" title="选择语句（switch）"></a>选择语句（<code>switch</code>）</h2><p> <code>switch</code> 语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-4" class="flow-chart"></div><p>注意事项：</p><ol><li>多个 case 后面的数值不可以重复。</li><li>switch 后面小括号当中只能是下列数据类型：<ul><li>基本数据类型：<code>byte</code> 、 <code>short</code> 、 <code>char</code> 、 <code>int</code></li><li>引用数据类型：<code>String</code> 、 <code>enum</code> </li></ul></li><li>switch 语句格式可以很灵活：前后顺序可以颠倒，而且 break 语句还可以省略。<strong>匹配哪一个 case 就从哪一个位置向下执行，直到遇到了 break 或者整体结束为止。</strong></li></ol><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为 false，从而结束循环，否则循环将一直执行下去，形成死循环。</p><p>循环结构的基本组成部分，一般可以分成四部分：</p><ol><li><strong>初始化语句</strong>：在循环开始最初执行，而且只做唯一一次。</li><li><strong>条件判断</strong>：如果成立，则循环继续；如果不成立，则循环退出。</li><li><strong>循环体</strong>：重复要做的事情内容，若干行语句。</li><li><strong>步进语句</strong>：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次。</li></ol><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h2><p> <code>for</code> 循环语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式; 布尔表达式; 步进表达式) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-5" class="flow-chart"></div><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h2><p> <code>while</code> 循环语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(布尔表达式) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-6" class="flow-chart"></div><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a><code>do-while</code> 循环</h2><p> <code>do while</code> 循环语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><div id="flowchart-7" class="flow-chart"></div><p> <code>do-while</code> 循环的特点：<strong>无条件执行一次循环体</strong>，即使我们将循环条件直接写成 false，也依然会循环一次。这样的循环具有一定的风险性。</p><h2 id="三种循环的区别"><a href="#三种循环的区别" class="headerlink" title="三种循环的区别"></a>三种循环的区别</h2><ol><li>如果条件判断从来没有满足过，那么 for 循环和 while 循环将会执行 0 次，但是 do-while 循环会执行至少一次。</li><li>for 循环的变量在小括号当中定义，只有循环内部才可以使用。while 循环和 do-while 循环初始化语句本来就在循环外定义变量，所以出来循环结束后还可以继续使用。</li></ol><h2 id="跳出语句"><a href="#跳出语句" class="headerlink" title="跳出语句"></a>跳出语句</h2><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a><code>break</code> 语句</h3><p>使用场景：终止 <code>switch</code> 或循环</p><ol><li>可以用在 switch 语句当中，一旦执行，整个 switch 语句立刻结束。</li><li>还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。</li></ol><h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a><code>continue</code> 语句</h3><p>使用场景：结束本次循环，继续下一次循环</p><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><p>永远停不下来的循环，叫做死循环。</p><p>死循环的标准格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>所谓嵌套循环，是指一个循环的循环体内包含另一个循环。比如 for 循环里面还有一个 for 循环，就是嵌套循环。</p><p> <code>总共的循环次数 = 外循环次数 * 内循环次数</code> 。</p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始e=>end: 结束op1=>operation: 步骤1op2=>operation: 步骤2opdots=>operation: ...opn=>operation: 步骤nst->op1->op2->opdots->opn->e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>operation: 其他语句cond=>condition: 关系表达式op2=>operation: 语句体op3=>operation: 其他语句op1->condcond(yes)->op2->op3cond(no)->op3</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: 其他语句op2=>operation: 其他语句cond=>condition: 关系表达式op3=>operation: 语句体1op4=>operation: 语句体2op1->condcond(yes)->op3->op2cond(no)->op4->op2</textarea><textarea id="flowchart-2-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句cond1=>condition: 判断条件1cond2=>condition: 判断条件2conddots=>condition: ……condn=>condition: 判断条件nop1=>operation: 语句体1op2=>operation: 语句体2opdots=>operation: ……opn=>operation: 语句体nopn+1=>operation: 语句体n+1st->cond1cond1(yes)->op1->econd1(no)->cond2cond2(yes)->op2->econd2(no)->conddotsconddots(yes)->opdots->econddots(no)->condncondn(yes)->opn->econdn(no)->opn+1->e</textarea><textarea id="flowchart-3-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句cond1=>condition: 表达式=常量值1cond2=>condition: 表达式=常量值2conddots=>condition: ......op1=>operation: 语句体1op2=>operation: 语句体2opdots=>operation: ......opn+1=>operation: 语句体n+1st->cond1cond1(yes)->op1->econd1(no)->cond2cond2(yes)->op2->econd2(no)->conddotsconddots(yes)->opdots->econddots(no)->opn+1->e</textarea><textarea id="flowchart-4-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script><textarea id="flowchart-5-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句op1=>operation: 初始化语句cond=>condition: 条件判断语句op2=>operation: 循环体语句op3=>operation: 步进语句st->op1->condcond(yes)->op2->op3(left)->condcond(no)->e</textarea><textarea id="flowchart-5-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-5-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-5-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-5", options);</script><textarea id="flowchart-6-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句op1=>operation: 初始化语句cond=>condition: 条件判断语句op2=>operation: 循环体语句op3=>operation: 步进语句st->op1->condcond(yes)->op2->op3(left)->condcond(no)->e</textarea><textarea id="flowchart-6-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-6-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-6-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-6", options);</script><textarea id="flowchart-7-code" style="display: none">st=>operation: 其他语句e=>operation: 其他语句op1=>operation: 初始化语句cond=>condition: 条件判断语句op2=>operation: 循环体语句op3=>operation: 步进语句st->op1->op2->op3->condcond(yes)->op2cond(no)->e</textarea><textarea id="flowchart-7-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-7-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-7-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-7", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java基础 </tag>
            
            <tag> 流程控制 </tag>
            
            <tag> 顺序结构 </tag>
            
            <tag> 分支结构 </tag>
            
            <tag> 判断语句 </tag>
            
            <tag> 选择语句 </tag>
            
            <tag> 循环结构 </tag>
            
            <tag> 跳出语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（2）</title>
      <link href="/2020/01/java-fundamentals-2/"/>
      <url>/2020/01/java-fundamentals-2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>Java 程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果<strong>数据类型不一致将发生类型转换</strong>。</p><h2 id="自动类型转换（隐式）"><a href="#自动类型转换（隐式）" class="headerlink" title="自动类型转换（隐式）"></a>自动类型转换（隐式）</h2><ul><li>特点：代码不需要进行特殊处理，自动完成。</li><li>规则： <code>数据范围小的类型</code> 向 <code>数据范围大的类型</code> 提升。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>/<span class="keyword">short</span>/<span class="keyword">char</span> --&gt; <span class="keyword">int</span> --&gt; <span class="keyword">long</span> --&gt; <span class="keyword">float</span> --&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><h2 id="强制类型转换（显式）"><a href="#强制类型转换（显式）" class="headerlink" title="强制类型转换（显式）"></a>强制类型转换（显式）</h2><ul><li>特点：代码需要进行特殊的格式处理，不能自动完成。</li><li>规则：将 <code>数据范围大的类型</code> 强制转换成 <code>数据范围小的类型</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范围小的类型 范围小的变量名 = (范围小的类型) 原本的范围大的数据值</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>强制类型转换一般不推荐使用，因为有可能发生<strong>精度损失、数据溢出</strong>。</li><li>byte/short/char 这三种类型都可以发生数学运算，例如加法 “+”。在运算的时候，都会被<strong>首先提升成为 int 类型</strong>，然后再计算。</li><li>boolean 类型不能发生数据类型转换。</li></ol><h2 id="ASCII-amp-Unicode-编码表"><a href="#ASCII-amp-Unicode-编码表" class="headerlink" title="ASCII &amp; Unicode 编码表"></a>ASCII &amp; Unicode 编码表</h2><p><strong>编码表</strong> ：数字和字符的对照关系表，就是将人类的文字和一个十进制数进行对应起来组成的一张表格。</p><ul><li>ASCII 码表：American Standard Code for Information Interchange，美国信息交换标准代码。</li><li>Unicode 码表：万国码，开头 0-127 部分和 ASCII 完全一样，但是从 128 开始包含有更多字符。</li></ul><h1 id="运算符-amp-表达式"><a href="#运算符-amp-表达式" class="headerlink" title="运算符 &amp; 表达式"></a>运算符 &amp; 表达式</h1><p>运算符：进行特定操作的符号。</p><p>表达式：用运算符连起来的式子。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><div class="table-container"><table><thead><tr><th>算术运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法运算，字符串连接运算</td></tr><tr><td><code>-</code></td><td>减法运算</td></tr><tr><td><code>*</code></td><td>乘法运算</td></tr><tr><td><code>/</code></td><td>除法运算（整数相除只看商）</td></tr><tr><td><code>%</code></td><td>取模运算（整数相除取余数）</td></tr><tr><td><code>++</code> <code>--</code></td><td>自增和自减运算</td></tr></tbody></table></div><p>注意事项：</p><ol><li>整数使用上述运算符的结果只会是整数。</li><li>一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。</li></ol><p>运算符 <code>+</code> 的用法：</p><ul><li>对数值来说，就是加法；</li><li>对字符 <code>char</code> 类型来说，计算之前先被提升为 <code>int</code> ；</li><li>对字符串 <code>String</code> 来说，加号代表<strong>字符串连接</strong>操作，任何数据类型与字符串进行连接的结果都是字符串。</li></ul><p>运算符 <code>++</code> 的用法：</p><ul><li>基本含义：变量自己增长 1 </li><li>使用格式：写在变量名称之前，或写在变量名称之后</li><li>使用方式：<ol><li>单独使用：不和其他任何操作混合，自己独立成为一个步骤。此时 <code>前++</code> 和 <code>后++</code> 没有区别。</li><li>混合使用：与其他操作混合。如果是前++，那么变量马上加 1，然后拿着结果进行使用；如果是后++，那么首先使用变量本来的值，然后再加 1。</li></ol></li><li>注意：只有变量才能使用自增和自减运算，常量不可发生改变。</li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><div class="table-container"><table><thead><tr><th>赋值运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>=</code></td><td>基本赋值运算</td></tr><tr><td><code>+=</code></td><td>加等于</td></tr><tr><td><code>-=</code></td><td>减等于</td></tr><tr><td><code>*=</code></td><td>乘等于</td></tr><tr><td><code>/=</code></td><td>除等于</td></tr><tr><td><code>%=</code></td><td>取模等</td></tr></tbody></table></div><p>基本赋值运算：是将等号右边的值，赋值给等号左边的变量</p><p>复合赋值运算：将等号右边的值进行复合操作后，赋值给等号左边的变量</p><p>注意事项：</p><ol><li>只有变量才能使用赋值运算符，常量不能进行赋值。</li><li><strong>复合赋值运算符其中隐含了一个强制类型转换。</strong></li></ol><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><div class="table-container"><table><thead><tr><th>比较运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>!=</code></td><td>不等于</td></tr></tbody></table></div><p>比较运算：是两个数据之间进行比较的运算，运算结果都是布尔值 <code>true</code> 和 <code>false</code> 。</p><p>注意事项：如果进行多次判断，不能像数学中一样连着写。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><div class="table-container"><table><thead><tr><th>逻辑运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code> （与）</td><td>全都是 true 才是 true，否则就是 false</td></tr><tr><td>&#124; &#124; （或）</td><td>至少一个是 true 就是 true，全都是 false 才是 false</td></tr><tr><td><code>!</code> （非）</td><td>本来是 true 变成 false，本来是 false 变成 true</td></tr></tbody></table></div><p>注意事项：</p><ol><li>逻辑运算符只能用于 boolean 值。</li><li>与、或需要左右各自有一个 boolean 值，但是取反只要有唯一的一个 boolean 值即可。</li><li>与、或两种运算符，如果有多个条件，可以连续写 <code>条件A &amp;&amp; 条件B &amp;&amp; 条件C</code> 。</li><li>与“&amp;&amp;”，或“||”，具有<strong>短路</strong>效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。</li></ol><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名称 = 布尔类型表达式 ? 表达式A : 表达式B</span><br></pre></td></tr></table></figure><p>流程：</p><ul><li>如果布尔表达式成立（为 true），那么将表达式 A 的值赋值给左侧的变量；</li><li>如果布尔表达式不成立（为 false），那么将表达式 B 的值赋值给左侧的变量。</li></ul><p>注意事项：</p><ol><li>必须同时保证表达式 A 和表达式 B 都符合左侧数据类型的要求。</li><li><strong>三元运算符的结果必须被使用</strong>。</li></ol><h1 id="方法入门"><a href="#方法入门" class="headerlink" title="方法入门"></a>方法入门</h1><h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p><strong>方法</strong>：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了<strong>代码的复用性</strong>，也<strong>解决了代码冗余的现象</strong>。</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>方法定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法名：方法名称的命名规则和变量一样，使用小驼峰。</li><li>方法体：也就是大括号当中可以包含任意条语句。</li></ul><p>注意事项：</p><ul><li>方法定义的先后顺序无所谓</li><li>方法的定义不能产生嵌套关系</li></ul><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法 main 中来调用我们自己定义好的方法。</p><p>在主方法中，直接写要调用的方法名字就可以调用了，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名(实参);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java基础 </tag>
            
            <tag> 自动类型转换 </tag>
            
            <tag> 运算符 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（1）</title>
      <link href="/2020/01/java-fundamentals-1/"/>
      <url>/2020/01/java-fundamentals-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="Java-语言"><a href="#Java-语言" class="headerlink" title="Java 语言"></a>Java 语言</h2><p>Java 语言是美国 Sun 公司（Stanford University Network），在 1995 年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><h2 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h2><p><strong>JVM（Java Virtual Machine）</strong>：Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 代码，都运行在 JVM 之上。</p><p><strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用 Java 编写的软件可以运行在任何的操作系统上，这个特性称为 Java 语言的跨平台特性。该特性是由 JVM 实现的，我们编写的<strong>程序运行在 JVM 上，而  JVM 运行在操作系统上</strong>。</p><h2 id="JRE-和-JDK"><a href="#JRE-和-JDK" class="headerlink" title="JRE 和 JDK"></a>JRE 和 JDK</h2><p><strong>JRE (Java Runtime Environment)</strong>：是 Java 程序的运行时环境，包含 JVM 和运行时所需要的核心类库。</p><p><strong>JDK (Java Development Kit)</strong>：是 Java 程序开发工具包，包含 JRE 和开发人员使用的工具。</p><h1 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h1><h2 id="Java-程序开发"><a href="#Java-程序开发" class="headerlink" title="Java 程序开发"></a>Java 程序开发</h2><p>Java程序开发三步骤：<strong>编写、编译、运行</strong></p><ol><li>编写 Java 源程序（后缀名 <code>.java</code>）</li><li>编译 Java 源文件（使用 <code>javac</code> 命令编译源程序为<strong>字节码文件</strong>，文件后缀 <code>.class</code>）</li><li>运行（使用 <code>java</code> 命令在 JVM 上运行字节码文件）</li></ol><p>编译和运行的区别</p><ul><li><strong>编译</strong>：是指将我们编写的 Java 源文件翻译成 JVM 认识的 class 文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。</li><li><strong>运行</strong>：是指将 class 文件交给 JVM 去运行，此时 JVM 就会去执行我们编写的程序了。</li></ul><p>关于 <strong><code>main</code> 方法</strong></p><ul><li>main 方法，也称为主方法，是程序的入口或起点。</li><li>JVM 在运行的时候，都会从 main 方法开始执行。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>注释</strong>：就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须要的，它不影响程序的编译和运行。</p><ul><li>单行注释：<code>//开头，换行结束</code> </li><li>多行注释：<code>/*开头，*/结束</code> </li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>关键字</strong>：是指在 Java 程序中事先定义好的单词，具有特殊意义。</p><ul><li>完全小写的字母</li><li>在增强版的记事本中（如 notepad++）具有特殊颜色</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><strong>标识符</strong>：是指在程序中，我们自己定义的内容，比如类的名字、方法的名字和变量的名字等等。</p><p><strong>命名规则：<code>硬性要求</code></strong> </p><ul><li>标识符可以包含 <code>英文字母26个（区分大小写）</code> 、 <code>0-9数字</code> 、 <code>$（美元符号）</code> 和 <code>_（下划线）</code> </li><li>标识符不能以数字开头</li><li>标识符不能是关键字</li></ul><p><strong>命名规范：<code>软性建议</code></strong> </p><ul><li>首字母大写，后面每个单词首字母大写（大驼峰式）。</li><li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</li><li>变量名规范：全部小写。</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>常量</strong>：Java 程序中固定不变的量</p><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th><th>数据举例</th></tr></thead><tbody><tr><td>整型常量</td><td>所有的整数</td><td>0，1，100，-250</td></tr><tr><td>小数常量</td><td>所有的小数</td><td>0.0，2.5，-3.14</td></tr><tr><td>字符常量</td><td>单引号引起来，只能写一个字符，必须有内容</td><td>‘A’，’b’，’9’，’好’，’ ‘</td></tr><tr><td>字符串常量</td><td>双引号引起来，可以写多个字符，也可以不写</td><td>“A”， “Hello”，”123”，””</td></tr><tr><td>布尔常量</td><td>只有两个值</td><td>true，false</td></tr><tr><td>空常量</td><td>只有一个值</td><td>null</td></tr></tbody></table></div><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java 的数据类型分为两大类：</p><ul><li><strong>基本数据类型</strong>：包括 <code>整数</code> 、 <code>浮点数</code> 、 <code>字符</code> 、 <code>布尔</code>  </li><li><strong>引用数据类型</strong>：包括 <code>字符串</code> 、 <code>数组</code> 、 <code>类</code> 、 <code>接口</code> 、 <code>Lambda</code> </li></ul><p>基本数据类型（4 类 8 种）</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1 个字节</td><td>-128 ~ 127</td></tr><tr><td>短整型</td><td>short</td><td>2 个字节</td><td>-32768 ~ 32767</td></tr><tr><td>整型</td><td>int（默认）</td><td>4 个字节</td><td>-2^31^ ~ 2^31^-1</td></tr><tr><td>长整型</td><td>long</td><td>8 个字节</td><td>-2^63^ ~ 2^63^-1</td></tr><tr><td>单精度浮点型</td><td>float</td><td>4 个字节</td><td>1.4013E-45 ~ 3.4028E+38</td></tr><tr><td>双精度浮点型</td><td>double（默认）</td><td>8 个字节</td><td>4.9E-324 ~ 1.7977E+308</td></tr><tr><td>字符型</td><td>char</td><td>2 个字节</td><td>0 ~ 65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>1 个字节</td><td>true，false</td></tr></tbody></table></div><p>注意事项：</p><ol><li>字符串不是基本类型，而是引用类型。</li><li>浮点型可能只是一个近似值，并非精确的值。</li><li><strong>数据范围与字节数不一定相关</strong>，例如 float 数据范围比 long 更加广泛，但是 float 是4字节，long 是 8 字节。</li><li>浮点数当中默认类型是 double。如果一定要使用 float 类型，需要加上一个<strong>后缀 F</strong>。如果是整数，默认为 int 类型，如果一定要使用 long 类型，需要加上一个<strong>后缀 L</strong>。推荐使用大写字母后缀。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量</strong>：程序运行期间，内容可以发生改变产生的量。<br>Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。<br>创建和使用变量的格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.数据类型 变量名称;<span class="comment">// 创建了一个变量</span></span><br><span class="line">变量名称 = 数据值;<span class="comment">// 赋值，将右边的数据值赋值给左边的变量</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.数据类型 变量名称 = 数据值;<span class="comment">// 在创建变量的同时，立刻放入指定的数据值</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.变量<span class="number">1</span> = 变量<span class="number">2</span>;<span class="comment">// 将一个变量2的数据内容，赋值交给变量1</span></span><br></pre></td></tr></table></figure></p><p>注意事项：</p><ol><li>如果创建多个变量，那么变量之间的名称不可以重复。</li><li>对于 float 和 long 类型来说，字母后缀 F 和 L 不要丢掉。</li><li>如果使用 byte 或者 short 类型的变量，那么右侧的数据值不能超过左侧类型的范围。</li><li><strong>没有进行赋值的变量，不能直接使用</strong>；一定要赋值之后，才能使用。</li><li>变量使用不能超过作用域的范围。<br><strong>作用域</strong>：从定义变量的一行开始，一直到直接所属的大括号结束为止。</li><li>可以通过一个语句来创建多个变量，但是一般情况不推荐这么写。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JVM </tag>
            
            <tag> JDK </tag>
            
            <tag> JRE </tag>
            
            <tag> 关键字 </tag>
            
            <tag> 标识符 </tag>
            
            <tag> 常量 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代计算机网络考试复习整理</title>
      <link href="/2020/01/computer-networks-systems-approach/"/>
      <url>/2020/01/computer-networks-systems-approach/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><h2 id="Ch1-网络体系结构"><a href="#Ch1-网络体系结构" class="headerlink" title="Ch1 网络体系结构"></a>Ch1 网络体系结构</h2><h3 id="什么是网络"><a href="#什么是网络" class="headerlink" title="什么是网络"></a>什么是网络</h3><h4 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h4><p>计算机网络最大的特点是<strong>通用性</strong>，传输的是通用数据，连接的通用的计算机。</p><p>计算机网络是<strong>互联的通用计算机的集合</strong>。</p><ul><li>互联：经传输媒质交换数据</li><li>自治：面向用户自管理</li><li>作为一个通用的网络，需要满足不同的网络需求</li></ul><h4 id="计算机网络的需求与约束"><a href="#计算机网络的需求与约束" class="headerlink" title="计算机网络的需求与约束"></a>计算机网络的需求与约束</h4><p>需求总结起来最重要的是三个点：</p><ol><li>互联（Connectivity）</li><li>为用户提供高效的资源共享（Cost Effective Resource Sharing）</li><li>为开发者支持常用服务（Support for Common Services）</li></ol><h4 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h4><h4 id="网络性能测量与评价"><a href="#网络性能测量与评价" class="headerlink" title="网络性能测量与评价"></a>网络性能测量与评价</h4><ul><li><strong>带宽</strong>（Bandwidth）<ul><li>习惯把带宽作为数字信道的数据率或比特率</li><li><strong>比特率</strong>：某时段内网络上可能传输的比特数，或传输每比特数据所需的时间</li><li><strong>吞吐率</strong>（Throughput）：链路上实际每秒传输的比特数</li></ul></li><li><strong>延迟</strong>（delay）<ul><li>delay：把一个报文从网络一端传输到另一端所需的时间</li><li>Round Trip Time（<strong>RTT</strong>）：发收来回时间（2 次时延）</li><li>定义：<strong>延迟 = 处理＋排队 + 传输 + 传播</strong>， 主要考虑后两个<ul><li>处理时延：检查包首部、决定导向何处；比特差错检测，高速Router一般在微秒或更低数量级，接收完整的一个分组的时间＝包容量/链路速率</li><li>排队时延：等待输出链路空闲，与当时流量和排队规则有关</li><li>传输时延：数据量/带宽，微秒到毫秒级</li><li>传播时延：距离/光速（光缆中1000km传播延迟约5ms)），广域网在毫秒级</li><li><strong>传输时延和传播时延的比较</strong>：<ul><li>传输时延是路由器把分组发送出去所需时间，由<strong>数据量和链路实际带宽决定</strong>，与两个路由器间距离无关</li><li>传播时延是一个比特从发送路由器到接收路由器传播所需的时间，是<strong>距离的函数</strong>，ms级</li></ul></li></ul></li></ul></li><li><strong>延迟带宽积</strong><ul><li>一对进程通道间的延迟（总体延迟）带宽积：信道管道的体积 = 链路上所容纳的比特数</li></ul></li></ul><h4 id="互联网的管理"><a href="#互联网的管理" class="headerlink" title="互联网的管理"></a>互联网的管理</h4><h3 id="Direct-Link-Networks-的基本理论与技术"><a href="#Direct-Link-Networks-的基本理论与技术" class="headerlink" title="Direct Link Networks 的基本理论与技术"></a>Direct Link Networks 的基本理论与技术</h3><h4 id="Hardware-Building-Blocks"><a href="#Hardware-Building-Blocks" class="headerlink" title="Hardware Building Blocks"></a>Hardware Building Blocks</h4><p>结点（Node）&amp; 链路（Links）</p><p><strong>香农定理</strong>决定了一个链路传输能力上限</p><ul><li>这个传输能力 C 用 bps 为单位，跟链路上信号的信噪比相关（S/N，decibels or dB）</li><li>$C=B\cdot\log_2(1+S/N)$</li></ul><h4 id="编码技术"><a href="#编码技术" class="headerlink" title="编码技术"></a>编码技术</h4><p>信号：表示信息的物理量</p><ul><li><p>模拟信号：一组特别的数据点之间及所有可能点之间都是连续的信号</p></li><li><p>数字信号：离散点构成的信号</p></li></ul><p><strong>信号调制</strong>：修改信号的幅度、频率和相位及其组合形式来标示和携带数据信息的过程</p><p>调制的一个原因：我们知道链路上信噪比的重要性，影响信号的噪声在不同频率上的强度并非完全一样。如果能把原始信号移动到噪声频率谱上噪声强度最低的频率上去，就可以避开本底噪声很高的区域，和其他没有被彻底屏蔽掉的干扰信号。信号调制时，需要选择一个「载波」——这个载波就可以选择系统噪声强度最低区域的频率。</p><p><strong>信号的物理层处理</strong></p><ul><li>模拟 → 模拟（调制）</li><li>模拟 → 数字（编码）</li><li>数字 → 数字（编码）</li><li>数字 → 模拟（调制）<ul><li>比特率（Bit Rate）：bps = bit/s，每秒内传输的比特数</li><li><strong>波特率</strong>（Baud Rate）：每秒内为表示某些比特而需要的信号单元数（或码元数）</li><li>当仅当一个信号单元表示一比特时，比特率才等于波特率</li><li>$Bit Rate = log_2Bit Unit× Baud Rate$</li></ul></li></ul><p><strong>信号的逻辑层编码</strong></p><ul><li><strong>NRZ 编码</strong><ul><li>这是一种不归零（Non-Return Zero）的编码方案，<strong>将数值 1 映射为高电平，数值 0 映射为低电平</strong>。</li><li>连续的 1 或 0 易导致<strong>基线漂移</strong>，即接收方保持它所接收的信号平均值用来区分高低电平受到干扰。</li><li>编解码需要双方的<strong>时钟同步</strong>，这依赖于信号内有许多跳变，只有信号跳变才能进行时钟同步。</li></ul></li><li><strong>NRZI 编码</strong><ul><li>不归零反转（Non-Return Zero Inverted），<strong>1 表示信号跳变，0 表示信号保持</strong></li><li><strong>解决了连续 1 的问题</strong></li></ul></li><li><strong>曼彻斯特编码</strong><ul><li>把本地时钟看作一个从低到高变化的内部信号，一对低/高变化的电平看作一个时钟周期</li><li><strong>0 表示从低到高的跳变，1 表示从高到低的跳变</strong></li><li>使链路上的信号跳变速率加倍，比特率是波特率的一半</li><li><strong>差分曼彻斯特编码</strong>：信号前一半与前一比特信号后一半相等则编码为 1，相反则编码为 0</li></ul></li><li><strong>4B/5B 编码</strong><ul><li>用 5 个比特编码 4 个比特的数据</li><li>在比特流中插入额外的比特以打破一连串的 0 或 1</li><li>5 比特代码的选择方式为：<strong>每个代码最多有 1 个前导 0，并且末端最多有 2 个 0</strong></li><li>因此当连续传送时，任何一个 5 比特代码连续 0 的个数最多为 3，<strong>解决了连续 0 的问题</strong></li><li><strong>将得到的 5 比特代码使用 NRZI 编码传输</strong></li></ul></li></ul><h4 id="成帧技术"><a href="#成帧技术" class="headerlink" title="成帧技术"></a>成帧技术</h4><p>Frame 是一个在具体网络（与类型和厂家有关）第二层上实现的、与硬件有关的特殊分组。是网上传输的最小数据单元。</p><p>Frame＝数据部分＋发送和接收站点的物理地址＋处理控制部分。</p><p><strong>面向字节的协议</strong></p><ul><li><strong>BISYN</strong><ul><li>用起止标记法组帧</li><li>帧的开始由发送一个特定的 <strong><code>SYN</code></strong> 字符表示</li><li>帧的数据部分包含在两个起止字符 <strong><code>STX</code></strong>（正文开始符）和 <strong><code>ETX</code></strong>（正文结束符）之间</li><li><code>ETX</code> 有可能出现在帧的数据部分，通过对 <code>ETX</code> 字符转义来解决这个问题，在其前加上 <strong><code>DLE</code></strong>（数据链路转义字符）（字符填充法）</li></ul></li><li>DDCMP</li><li>PPP / SLIP</li></ul><p><strong>面向比特的协议</strong></p><ul><li>不关心字符的边界，把帧看作比特的集合</li><li>SDLC（Synchronous Data Link Control Protocol）</li><li><strong>HDLC</strong>（High-level Data Link Control Protocol）<ul><li>用特定的比特序列 <strong><code>01111110</code></strong> 表示帧的开始和结束</li><li>使用类似 <code>DLE</code> 字符的方法，称为比特填充法</li><li>发送方任意时刻在消息体中发出连续的 5 个 1 后（试图发送特定序列 <code>01111110</code> 除外），在发送下一比特前插入一个 0</li><li>接收方接收连续的 5 个 1 后，如果下一比特是 0，则一定是填充的，丢掉它；如果下一比特是 1，再查看下一比特，如果为 0，则是帧结束消息，如果为 1，则是出错了，丢弃整个帧</li></ul></li></ul><p><strong>基于时钟的组帧</strong></p><ul><li><strong>SONET</strong>（Synchronous Optical Network）<ul><li>使用字节交叉的多路复用</li><li>基本 SONET 帧（STS-1 帧）每 125 us 产生 810 字节，有无数据都同步发送，故每秒 8000 帧</li><li>9 x 90 = 810 Bytes/s x 8000＝51.84 Mbps，构成基本 SONET 信道</li><li>一帧包含 9 行，每行 90 Bytes，每行的前 3 bit 留作系统管理信息</li><li>STS-N 帧可认为是由 N 个 STS-1 帧构成（多路复用），这些帧中的字节是交叉的</li></ul></li></ul><h4 id="信道共享技术"><a href="#信道共享技术" class="headerlink" title="信道共享技术"></a>信道共享技术</h4><p>信道（Channel）是通信中传递信息的通道，它由发送与接收信息的设备及传输介质组成。</p><p>信道有独占或共享两种使用方式。</p><p>复用：把共享信道划分成多个子信道，每个子信道传输一路数据。</p><ul><li>时分复用TDM（Time Division Multiplexing），统计时分复用STDM。按时间划分不同的信道，目前应用最广泛</li><li>频分复用FDM（Frequency Division Multiplexing）按频率划分不同的信道，如CATV系统</li><li>波分复用WDM（Wave Division Multiplexing：DWDM/CWDM）按波长划分不同的信道，用于光纤传输</li><li>码分复用CDM（Code Division Multiplexing）按地址码划分不同的信道，如手机</li></ul><h4 id="差错控制技术"><a href="#差错控制技术" class="headerlink" title="差错控制技术"></a>差错控制技术</h4><p>什么是差错控制？<br>在通信过程中，发现、检测差错并进行纠正</p><p>为何要进行差错控制？<br>不存在理想的信道 → 传输总会出错 与语音、图像传输不同，计算机通信要求极低的差错率。</p><p>基本思想：发方编码、收方检错，能纠则纠，不能则重传</p><p>基本方法：收方进行差错检测，并向发送方应答，告知是否正确接收。</p><p>差错控制技术：<strong>自动请求重传 ARQ</strong>（Automatic Repeat Request）</p><ul><li>停等 ARQ<ul><li>每发送一帧就需要一个应答帧</li><li>只重传刚才出错的帧</li></ul></li><li>Go-back-N ARQ<ul><li>每发送N帧需要一个应答帧</li><li>需重传前面（N-i+1）帧（0≤i≤N）</li></ul></li><li>选择重传 ARQ<ul><li>每发送N帧需要一个应答帧</li><li>只重传出错的帧</li></ul></li></ul><p>任何检验纠错技术的基本思想</p><ul><li>加入冗余信息到帧中去（极端：两份拷贝）</li><li>一般为 n 位信息加入 k&lt;&lt;n 比特冗余，例如 12000bits (1500bytes) 的报文仅需要 32 比特 CRC 码</li></ul><p>纠错码主要的编码方法：</p><ul><li>奇偶校验（Parity Checking）</li><li>循环冗余校验（CRC, Cyclic Redundancy Check）</li><li>校验和：Check sum</li></ul><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>直连网络存在两个问题：</p><ol><li>由于共享链路，所以仅仅允许少量的节点连接到网络，例如早期的以太网最多不超过 1024 个节点</li><li>仅仅能分布在很小的范围，早期以太网距离不超过 2500m</li></ol><p>所以出现 Packet Switch 这样的设备，将多个直连网络连接起来，组建更大范围的网络。</p><h4 id="以太网及其发展"><a href="#以太网及其发展" class="headerlink" title="以太网及其发展"></a>以太网及其发展</h4><p>以太网优势</p><ul><li>可扩展（10M-10G），灵活（多种媒介、全/半双工、共享/交换），便宜、易于安装使用、稳健性好</li></ul><p>网卡功能</p><ul><li>数据的封装与解封</li><li>链路管理：<strong>CSMA/CD</strong>（带冲突检测的载波侦听多路访问）</li><li>bit 的编码与解码</li></ul><p>MAC地址</p><ul><li>Unicast：单播帧地址,仅对某个网卡</li><li>Broadcast：广播帧地址,仅对某个子网</li><li>Multicast：多播帧地址,组地址</li><li>杂收模式（Promiscuous mode）：接收总线上所有的可能接收的帧</li></ul><h4 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h4><p>以太网</p><ul><li>可以是一组直连的主机</li><li>也可以通过连接设备进行扩展<ul><li>集线器（HUB）：物理层互联设备</li><li>交换机（Switch）：链路层互联设备</li></ul></li></ul><p>广播域和冲突域</p><ul><li><strong>广播域</strong>：广播报文可以达到的范围</li><li><strong>冲突域</strong>：可以发生报文冲突的范围</li></ul><ol><li>HUB 的所有端口都在一个冲突域和一个广播域</li><li>Switch 的所有端口都在一个广播域，每个端口是一个冲突域，只有在划分 VLAN 之后才能分割广播域</li><li>Router 的每个端口是一个冲突域，也是一个广播域</li></ol><p><strong>虚拟局域网（VLAN）</strong></p><ul><li>虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网</li><li>不依赖三层交换，通过虚拟局域网 VLAN，可以将同一交换机或者多个交换机的广播域划分多个广播域（每个虚拟局域网一个广播域）</li></ul><p>交换机的自学习功能</p><ul><li>转发表可由交换机学习自动得到</li></ul><h4 id="交换机生成树协议-STP-Spanning-Tree-Protocol"><a href="#交换机生成树协议-STP-Spanning-Tree-Protocol" class="headerlink" title="交换机生成树协议 STP (Spanning Tree Protocol )"></a>交换机生成树协议 STP (Spanning Tree Protocol )</h4><p>交换机的自学习机制可以工作良好，但是一旦交换机连接存在环路，会造成严重后果。</p><p>当交换机之间存在多条活动链路时，容易形成环路，导致转发表的不正确与不稳定，并且还会导致重复的数据包在网络中传递，引起广播风暴，使网络不稳定。</p><p>为了防止交换机之间由于多条活动链路而导致的网络故障，必须将多余的链路置于非活动状态，即不转发用户数据包，而只留下单条链路作为网络通信。</p><p><strong>生成树协议</strong>（Spanning Tree Protocol）</p><ul><li>STP 将交换网络中任何两个点之间的多余链路置于 Blocking（关闭）状态，而只留一条活动链路，当使用中的活动链路失效时，立即启用被Block的链路，以此来提供网络的冗余效果。</li><li>需要所有交换机支持。</li><li>每个交换机实际上需要 disable 掉自己的某些端口，不转发 frame。极端情况下，可能一个交换机完全不参与任何 frame 的转发。</li></ul><p>去掉环路的方法： <strong>所有交换机按照树的方式进行连通</strong></p><ul><li>STP 的核心思想是网络中<strong>选出一台交换机做为核心交换机</strong>， STP 称其为 Root，也就是根，功能相当于 hub spoke 网络中的 Hub。</li><li>其它不是 Root 的交换机则需要留出一条活动链路去往根交换机，因为只要普通交换机到根是通的，到其它交换机也就是通的。</li><li>一个广播域内独立选举 STP<ul><li>交换机之间选举根交换机（Root）<ul><li>一 个广播域 内只能 选举一台根交换机。 Bridge ID 中优先级最高（即数字最小）的为根交换机，优先级范围为 0 65535 ，如果优先级相同，则 MAC 地址小的为根交换机。</li></ul></li><li>交换机端口之间选举根端口（Root Port）<ul><li>所有非根交换机都要选举根端口，选举规则为到根交换机的 Path Cost 值最小的链路。</li></ul></li><li>非根交换机选择指定端口（Designated Port）<ul><li>简单地理解为每条连接交换机的 link 有两个端口（属于不同交换机）中，有一个要被选举为指定端口。</li><li>选举规则和选举根端口一样，即：到根交换机的 Path Cost 值最小的端口，如果多条链路到达根交换机的 Path Cost 值相同，则选举上一跳交换机 Bridge ID 最小的链路。</li></ul></li><li>剩余端口状态为 Blocking<ul><li>在 STP 选出根交换机，根端口以及指定端口后，其它所有端口全部为 Blocking 状态，为了防止环路，所有 Blocking 端口只有在根端口或指定端口失效、拓扑改变的时候才会被启用 。</li><li>一个端口，在 STP 中只能处于一种角色，不可能是两种角色</li></ul></li></ul></li></ul><p><strong>选举</strong></p><ul><li><p>使用 BPDU（Bridge Protocol Data Unit）</p><ol><li>当交换机打开的时候，所有的端口都处于 Listening 状态，每个交换机都会认为自己是根交换机（Root ID 为自己），然后都每隔两秒就向外发送一次自己的 BPDU。</li><li>如果收到的 BPDU 的 Bridge ID 比自己的小，则停止转发自己的 BPDU，开始转发更优的 BPDU，如果比自己的 Bridge ID 大或者和自己的 Bridge ID 相等，则丢弃该 BPDU。</li><li>持续 15s（转发延迟）等到 BPDU 扩散完毕之后，开始各种端口的选举，这时候每个 BID 最小的交换机成了根交换机，各个交换机通过收到的 BPDU 来确定根端口和指定端口。剩下的成为非指定端口，转到 blocking 状态。然后进入 learning 状态</li><li>进入 Learning 状态之后，填写 MAC 地址表，经过 15s（转发延迟）之后进入 Forwarding 状态。</li><li>进入 Forwarding 状态之后，开始转发数据，并且同时接受转发来自于根的 BPDU（Root ID为根交换机），维护拓扑。这时只有根交换机发 BPDU，其他交换机都只是转发 BPDU。</li><li>当一个新的交换机加入的时候，端口状态是 Learning，新的交换机认为自己是根交换机开始发送 BPDU，也接收对端的 BPDU，然后进行进一步的竞选。</li><li>若竞选成功，则网络拓扑就重新变化了，若竞选失败则计算根端口指定端口和非指定端口。（30s 可以完成）</li></ol></li><li><p>第二种类型的 BPDU 包：TCN（Topology Change Notification）BPDU</p><ol><li>当一台交换机检测到拓扑变化后,它就可以发送 TCN 给 root 交换机，注意 TCN 是通过 root port 向 root  交换机方向发出的.</li><li>当交换机从它的 designate port 接收到 TCN 类 BPDU 时,它必须为其做转发，从它自已的 root port 上发送出去 TCN 类型的 BPDU 包，这样一级一级地传到 root bridge 后，TCN 的任务才算完成.</li><li>在以上的过程中,无论是哪台交换机从它的designate port上收到了TCN类型的BPDU包，它都必须给一个回复，必须从 designate port 上发出 TCA 位被置 1 的 normal configuration BPDU 包</li><li>那么当 TCN 传遍全网,直至到达 ROOT BRIDGE 后，root bridge 也要做出一种回应,它会发出一个正常的 configuration BPDU 包,当然会有一些不同,就是包内的 TC 字段会被置 1，TC 即 topology change，表示发现拓扑变化。</li><li>这个包会被所有交换机转发,同样的 TC 位会置 1，直至传遍全网，所有交换机都得知拓扑变化为止，原来转发表作废，重新开始选举。</li></ol></li></ul><h3 id="TCP-IP-技术"><a href="#TCP-IP-技术" class="headerlink" title="TCP/IP 技术"></a>TCP/IP 技术</h3><p>报文交换网络无法组成一个大范围网络</p><ol><li>报文交换网络默认在一个广播域（VLAN 是手工分割广播域）</li><li>Forwarding table 无法扩展</li><li>以太网地址是厂商生产序号，无法更改，也无法聚合</li></ol><p>需要更好的方案组成大范围的网络</p><h4 id="命名与定位-Naming-amp-Locating"><a href="#命名与定位-Naming-amp-Locating" class="headerlink" title="命名与定位 (Naming &amp; Locating)"></a>命名与定位 (Naming &amp; Locating)</h4><p>因特网的三地址</p><ul><li>用户识别地址：公司/机关/团体/个人注册的因特网可访问的 ID：<strong>域名</strong></li><li>网络地址：同一体系结构中的可访问的计算机ID：<strong>IP 地址</strong></li><li>物理地址：物理媒体可访问的计算机某端口的唯一 ID：<strong>MAC 地址</strong></li></ul><h4 id="IP-互连与分组交换"><a href="#IP-互连与分组交换" class="headerlink" title="IP 互连与分组交换"></a>IP 互连与分组交换</h4><p><strong>ICMP</strong>（Internet Control Message Protocol）</p><h4 id="路由与寻址-Routing-amp-Addressing"><a href="#路由与寻址-Routing-amp-Addressing" class="headerlink" title="路由与寻址 (Routing &amp; Addressing)"></a>路由与寻址 (Routing &amp; Addressing)</h4><p><strong>距离向量算法（RIP）</strong></p><p><strong>链路状态算法（OSPF）</strong></p><ul><li>OSPF 一个 Domain 中的路由器会交换链路状态，LSP（Link-State Packet）采用洪泛的方法传给所有 Domain 中的路由器</li></ul><h4 id="传输层技术"><a href="#传输层技术" class="headerlink" title="传输层技术"></a>传输层技术</h4><h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>IP 组播是介于单播和广播之间的一种分组传送形式 ，它既不指定明确的接收者，也不是将数据分发给网络上的所有主机。</p><p>发送者不关心接收者所处 的位置 ，只要将数据发送到约定的目的地址，剩下的工作就交给网络去完成 。</p><p>这样做的好处在于， 发送者只产生一份数据，而不用为每个接收者分别复制一份，而且发送者不必维护接收者的信息 。</p><p>网络中的路由器 设备必须收集接收者的信息，并按照正确的路径实现组播报文的转发和复制。</p><h4 id="IGMP-协议"><a href="#IGMP-协议" class="headerlink" title="IGMP 协议"></a>IGMP 协议</h4><p>组成员机制</p><ul><li>查询 ，就是一台路由器向网络中发出查询消息，查询是否要主机要加入组如果有主机应答，那么路由器就可以请求上游路由器把组播流量前转到这个子网中，如果没有主机应答，则请求上游路由器停止向其前转组播流量。</li><li>报告 ，主机也可以不必等待路由器的查询，可以主动向路由器请求加入某个组，退出时也要向路由器发送退出消息，让路由器停止向 其转发组播流量。</li><li>IGMP 实现的功能是双向的：一方面，主机通过 IGMP 协议通知本地路由器希望加入并接收某个特定组播组的信息；另一方面，路由器通过 IGMP 协议周期性地查询局域网内某个已知组的成员是否处于活动状态（即该网段是否仍有属于某个组播组的成员），实现对所连网络组成员关系的收集与维护。</li><li>至于数据报文在路由器之间如何转发 则由组播路由协议决定， IGMP 协议并不负责 。</li></ul><h4 id="组播路由协议"><a href="#组播路由协议" class="headerlink" title="组播路由协议"></a>组播路由协议</h4><p>PIM 协议（Protocol Independent Multicast）</p><ul><li>可以让组播源和目的之间的路由表生成单播表一样地生成组播表，最后路由器根据这张组播路由表来完成组播的转发 。</li><li>组播发送者到接收者之间的转发线路，被称为<strong>组播转发树</strong> 。</li><li>防止组播反向路径转发（RPF）<ul><li>组播路由器上朝发送者方向的接口被称为 RPF 接口， 只有从 RPF 接口发来的数据才能被转发，从其它接口过来的数据被认为是无效的。</li></ul></li></ul><p>PIM-DM</p><ul><li>组播源会向所有 PIM邻居发出查询，查询数据包中包含组的地址，下一跳 PIM 邻居路由器还会继续向它的邻居发出查询数据包，这些查询数据包会在所有 PIM 邻居之间传递。</li><li>如果查询数据包到一个连接了组成员的网络，这时路由器收到组成员的报告之后，就会向自己上一跳邻居（ RPF 接口方向的邻居）发送加入组的消息，以宣布自己要接收组播，从而将组播转发到组成员。</li><li>组播路由记录 (S,G)，G)，其中 S 就是组播源地址， G 就是组地址，而出口则会被标为 forwarding 。</li><li>对于不需要接收组播的 PIM 接口， PIM-DM 模式照样会将其记录在路由表中，但被标为 pruning 。</li><li>（S,G）记录的组播树被称为最短路径树 Shortest Path Tree ( SPT)</li></ul><p>PIM-SM</p><ul><li>在建立组播树时， PIM-SM 并不会让路由器发送查询数据包去查询组成员，而组成员的发现是靠组成员自己主动向路由器发送报告。</li><li>当一台路由器从接口上收到组成员的报告之后，就会向自己的上一跳邻居发送加入消息，以通告自己需要接收组播，如果上一跳邻居还不是组播发送者，那么上一跳邻居会继续再向上一跳邻居发送加入消息，直到组播源收到加入消息为止。</li><li>(<em>，G) ，其中 </em> 就是组播源地址， G 就是组地址。</li><li>PIM-SM 模式只记录连接着接收者的接口，其它没有接收者，不需要接收组播的接口是不会被记录的 。</li><li>Rendezvous Point ( RP)：RP 就是组播网络的核心，发送者统一将组播数据发送到 RP ，然后 RP 再将数据发到接收者，也就是说接收者收到的数据，都是由 RP 转发过来 的。</li><li>(*，G)  形式的树被称为共享树（RPT）</li><li>真正 的源向 RP 发出第一个组播包时，DR 将此包封装在单播中发向 RP。发送的注册消息会从 DR 到 RP 之间建立一条源树 ，也就是 （S，G ）的记录，这样，在源到 RP 之间创建的源树就可以帮助避免 RPF 检测失败。</li></ul><h2 id="Ch2-IPv6"><a href="#Ch2-IPv6" class="headerlink" title="Ch2 IPv6"></a>Ch2 IPv6</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="IPv4-的问题"><a href="#IPv4-的问题" class="headerlink" title="IPv4 的问题"></a>IPv4 的问题</h4><h4 id="IPv6-设计目标和主要特征"><a href="#IPv6-设计目标和主要特征" class="headerlink" title="IPv6 设计目标和主要特征"></a>IPv6 设计目标和主要特征</h4><ul><li>扩大地址空间、路由更结构层次化<ul><li>32bits →128 bits</li><li>全局 unicast 地址等价于 IPv4 公开地址</li><li>直接使用 CIDR，网络前缀取代掩码，前缀表示子网号</li></ul></li><li>报头格式大简化，方便硬件处理<ul><li>基本报头固定 40 bytes</li><li>简化路由器的操作</li><li>引入结构化扩展报头，取消可选项长度限制</li></ul></li><li>网络管理 更加简单<ul><li>建立一系列自动发现和自动配置功能</li><li>最大单元发现（MTU discovery）</li><li>邻接节点发现（neighbor discovery ）</li><li>路由器通告（router advertisement ）</li><li>路由器请求（router solicitation）</li><li>节点自动配置（auto-configuration）</li></ul></li><li>安全性支持<ul><li>IP security ,提供IP层的安全 IPSec</li><li>实现认证头（Authentication Header）</li><li>安全载荷封装（Encapsulated Security Payload）</li></ul></li><li>QoS 能力<ul><li>流标号（flow label），20比特,发送者可以要求路由器对此流进行特殊处理，路由器可以鉴别特殊流的所有报文</li></ul></li><li>多播寻址<ul><li>在 multicast 地址中增加了 范围“scope”字段，允许将多播路由限定在正确的范围内</li><li>设置flog允许区分永久性多播地址和临时性多播地址</li></ul></li><li>可移动性<ul><li>信宿选项报头、路由选项报头、自动配置、安全机制、以及 anycast 技术，将 QoS 同移动节点结合，从而强化对移动的支持</li></ul></li></ul><h3 id="IPv6-的报文结构"><a href="#IPv6-的报文结构" class="headerlink" title="IPv6 的报文结构"></a>IPv6 的报文结构</h3><p>主要改变</p><ul><li>对齐（alignment）已经从32bit的整数倍改为64bit整数倍（5×64 bits = 40×8B=320 bits ）</li><li>取消了报头长度字段，基本报头长度固定40Bytes</li><li>Total Length长度字段被Payload Length字段取代</li><li>源目地址字段增加到每个字段16个bytes</li><li>分片信息已经从基本报头的固定字段移到一个扩展报头中生存时间TTL改为跳数极限hop limit字段</li><li>业务类型改为数据流标号flow label 字段</li><li>协议字段改为下一个报头字段，以指明下一个报头类型</li></ul><h3 id="IPv6-的地址空间"><a href="#IPv6-的地址空间" class="headerlink" title="IPv6 的地址空间"></a>IPv6 的地址空间</h3><p>地址的三种文本表示</p><ul><li><strong>点分十进制</strong><ul><li>104.230.140.100.255.255.255.255.0.0.17.128.150.10.255.255</li></ul></li><li><strong>冒分 16 进制</strong><ul><li>共8个，相同字间距</li><li>上面地址为 68E6:8C64:FFFF:FFFF:0:1180:96A:FFFF</li></ul></li><li><strong>0 压缩 :: 表示</strong><ul><li>对连续长串0用::代替，一个地址中仅出现一次</li><li>2080:0:0:0:8:800:200C:417A → 2080::8: … ；unicast address</li><li>FF01:0:0:0:0:0:0:101→ FF01::101 ; multicast address</li><li>0:0:0:0:0:0:0:1 → ::1 ; loopback address</li><li>0:0:0:0:0:0:0:0 →:: ; undefined address</li></ul></li><li><strong>混合表示</strong><ul><li>x: x: x: x: x: x: d.d.d.d， x :表示16进制(16 Bits)， d.表示10进制(8 Bits )</li><li>0:0:0:0:0:0:13.1.168.3 或 ::13.1.168.3</li><li>0:0:0:0:0:FFFF:129.144.52.38或 :: FFFF:129.144.52.38</li></ul></li></ul><p><strong>CIDR形式</strong></p><ul><li>IPv6 地址/前缀长度，长度是 10 进制，表明地址最左端连续比特个数</li><li>正确表示 12AB00000000CD3 的 60 bits 前缀是：<ul><li>12AB:0000:0000:CD30:0000:0000:0000:0000/60</li><li>12AB::CD30:0:0:0:0/60</li><li>12AB:0:0:CD30::/60</li></ul></li><li>不正确的表示为（没有准确体现前缀=60个bit后面为0）：<ul><li>12AB:0:0:CD3/60 ；可理解为0CD3</li><li>12AB::CD30/60 ；可理解为12AB:0:0:0:0:0:0:CD30</li></ul></li><li>HUST的IPV6地址=2^81 = 2^80 ×2<ul><li>2001:0250:4000::/48</li><li>2001:0DA8:3000::/48</li></ul></li></ul><p>地址类型</p><ul><li>Unicast：One to One (Global，Link local，Site local，Compatible)</li><li>Anycast：One to Nearest (Allocated from Unicast)</li><li>Multicast：One to Many</li><li>Reserved</li></ul><p><strong>可聚类全局Unicast地址</strong></p><ul><li>共分3级，6个部分</li><li>前缀 <code>001</code>：全球可聚合Unicast地址</li><li>TLA ID（13 bits）（Top Level Aggregator）：顶级聚合标识符，分配给大型 ISP，从 IANA 直接获得。</li><li>RES（8 bits）：留做将来使用－Reserved for future use</li><li>NLA ID（24 bits）（Next Level Aggregator）：次级聚合标识符，中型 ISP 从 TLA 获取。</li><li>SLA ID（16bits）（Site Level Aggregator）：站点级聚合标识符，小型 ISP 从 NLA 获得</li><li>接口ID（64bits）：接口标识符Interface Identifier</li></ul><h3 id="IPv6-邻居发现协议"><a href="#IPv6-邻居发现协议" class="headerlink" title="IPv6 邻居发现协议"></a>IPv6 邻居发现协议</h3><p>基于 ICMPv6 报文实现其功能</p><ul><li><p>路由器请求（Router Solicitation）</p></li><li><p>路由器通告（Router Advertisement）</p></li><li><p>邻居请求（Neighbor Solicitation）</p></li><li><p>邻居通告（Neighbor Advertisement）</p></li></ul><p><strong>地址自动配置</strong></p><ul><li>当一台 IPV6 的主机第一次连接到链路上时，它能够自动配置接口的链路地址。在接口的 48 位的 MAC 地址中间插入一个保留的 16 位数值 <code>0xFFFE</code>，并把它的 U/L 位（第七位）翻转，这样就得到了一个 64 位接口 ID。在接口 ID 前面加上链路本地前缀 <code>FE80::/10</code>，就得到了链路本地地址</li><li>Stateless：在主机和路由器之间，利用 ICMPv6 协议中的 RA 和 RS 消息完成无状态自动配置过程。主机通过 RS 发现链路上的路由器，而路由器通过 RA 向主机通告 IPv6 地址前缀信息，主机在收到 IPv6 前缀信息后，与自己的网卡接口 ID 组合构成 128 位 IPv6 单播地址。</li><li>Stateful：主机通过配置协议（如 DHCPv6）获取 IPv6 地址以及其他信息（如 DNS），相比 Stateless 更加可控，但需要额外的应用服务器（如 DHCPv6 服务器）。</li></ul><p><strong>地址解析</strong></p><ul><li>地址解析在三层完成，不同的二层介质可以采用相同的地址解析协议</li><li>使用组播方式发送请求报文，减少了二层网络的性能压力</li><li>使用两种 ICMPv6 报文完成交互过程<ul><li>邻居请求（NS）<ul><li>IPv6 报头目的地址：请求节点多播地址</li></ul></li><li>邻居通告（NA）</li></ul></li></ul><p><strong>DAD（Duplicate Address Detection）</strong></p><ul><li>确保网络中无两个相同的单播地址</li><li>每次系统默认一个主机在应用新的 IP 地址之前会<strong>发送 3 次 DAD</strong>, 如果三次以后均没有收到任何回应，那么该地址被认为是可以配置在接口上的</li><li>若发现有地址重复（存在 NA 报文，目的地址为 FF02::1）<ul><li>全局单播地址：不安排给接口</li><li>链路本地地址 ：将接口置于不可用状态</li></ul></li></ul><h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3><p>IPSec 定义了在网际层使用的安全服务，其功能包括数据加密、对网络单元的访问控制、数据源地址验证、数据完整性检查和防止重放攻击。</p><h3 id="IPv4-到-IPv6-过渡"><a href="#IPv4-到-IPv6-过渡" class="headerlink" title="IPv4 到 IPv6 过渡"></a>IPv4 到 IPv6 过渡</h3><h2 id="Ch3-拥塞控制"><a href="#Ch3-拥塞控制" class="headerlink" title="Ch3 拥塞控制"></a>Ch3 拥塞控制</h2><h3 id="拥塞控制相关基础"><a href="#拥塞控制相关基础" class="headerlink" title="拥塞控制相关基础"></a>拥塞控制相关基础</h3><h4 id="拥塞控制的基本原理"><a href="#拥塞控制的基本原理" class="headerlink" title="拥塞控制的基本原理"></a>拥塞控制的基本原理</h4><p>拥塞产生的原因（需求大于供给，无准入控制）</p><ul><li>宏观原因：网络资源分布不均匀，流量分布不均匀，</li><li>微观原因：报文聚合到达率大于路由器输出链路的带宽</li></ul><p>拥控：</p><ul><li><p>问题：某些点上存在资源瓶颈</p></li><li><p>防止发送者把太多的数据发送到网路中，适应瓶颈链路和路由器有限 buffer ，保护网络</p></li></ul><p>流控：</p><ul><li><p>问题：接收方可能存在缓存不足、进程等待</p></li><li><p>防止发送方的发送速度比接收方的接收速度快，适应收发双方的 buffer + cpu 能力，保护端点。</p></li></ul><h4 id="拥塞控制方法分类"><a href="#拥塞控制方法分类" class="headerlink" title="拥塞控制方法分类"></a>拥塞控制方法分类</h4><p>解决拥塞本质上是<strong>更合理的资源分配</strong></p><ul><li>以路由器为中心与以主机为中心<ul><li>链路算法：在网络设备中执行，作用是检测网络拥塞的发生，产生拥塞反馈信息（主要集中在主动队列管理 AQM 算法方面）</li><li>源算法：在主机和网络边缘设备中执行，作用是根据反馈信息调整发送速率（使用最广泛的是 TCP 协议中的拥塞控制算法）</li></ul></li><li>基于预留与基于反馈<ul><li>基于预留：建立流时，端主机请求网络给予一定的容量，每个 R 分配足够的资源（缓冲区或链路带宽的比例）来满足这一请求。如果由于资源的过量则 R 不能满足该请求而拒绝该流。</li><li>基于反馈：端主机首先没有预留任何容量，而按照它们接收到的反馈来调整其发送。调整或者是显式的，如拥塞 R 发送一个“请慢下来”消息到主机，或隐式的，如端主机根据外部可观察的网络行为，如包丢失率，来调整其发送率</li></ul></li><li>基于窗口与基于速率<ul><li>用窗口大小来描述：如 TCP ：流控也可用窗口通告机制来预留缓冲空间，来支持资源分配</li><li>用速率大小来描述：用速率控制发送者行为，如接收方可说它可处理 1Mbps 的视频，而发送方则坚持这一速率</li></ul></li></ul><h4 id="资源分配评价标准"><a href="#资源分配评价标准" class="headerlink" title="资源分配评价标准"></a>资源分配评价标准</h4><p>有效性</p><ul><li>用<strong>吞吐率和延迟之比</strong>来描述资源分配模式的有效性，该比称为<strong>网络能力</strong></li><li>power = 吞吐率 / 延迟</li><li>目标是最大化吞吐/延迟比</li></ul><p>公平性</p><ul><li>赋予 0-1 公平性指数的函数（<strong>n 数和的平方 / n 数平方和的 n 倍</strong>）</li><li>当 n 个流都获得 1 个单位吞吐量时，公平指数为 1</li><li>当 1 个流获得 1 + delta 的吞吐量时，公平指数小于 1</li><li>当 n 个流中只有 k 个接收相等吞吐量，其余为 0 时，公平指数为 k/n</li></ul><h3 id="排队规则与流量整形"><a href="#排队规则与流量整形" class="headerlink" title="排队规则与流量整形"></a>排队规则与流量整形</h3><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p><strong>首先到达的包首先发送</strong></p><p>当 R 的缓冲空间满时，尾部的包就丢弃（tail drop）不考虑包是否重要，</p><p>FIFO 和 tail drop 是不同的概念，前者是发送调度策略，后者是丢弃策略，但二者常捆绑在一起叫做 FIFO。</p><h4 id="优先排队"><a href="#优先排队" class="headerlink" title="优先排队"></a>优先排队</h4><p>对基本 FIFO 的简单变化是优先排队策略</p><p>给每个包打上可携带的<strong>优先权标记</strong> ，如 IP 服务类型 TOS（DiffServ）</p><p>R 先发送其优先权高的包</p><p>这一方式离 Best effort delivery 并不远</p><h4 id="公平排队-FQ"><a href="#公平排队-FQ" class="headerlink" title="公平排队 FQ"></a>公平排队 FQ</h4><p>为每个正在被路由器处理的流分别维护一个队列，路由器以轮循方式服务每个队列。</p><p>当一个流发送包太快，则其队列填满；当一个队列到达一个特定的长度，属于该队列的后继包就被丢掉，这样，任何源就不可能多占用其他流的网络容量。</p><p>FQ 并不告诉源端任何有关路由器的状态，或并不限制源端发送怎样快。</p><p>主要的复杂性是路由器中处理的包长度不相同，公平须考虑包的长度。</p><p>先判断如果该包按位轮流方式发送何时可发完，然后根据完成时间对要发送的包排序。</p><p>$F_i = \max(F_{i-1},A_i) + P_i$</p><h4 id="加权公平排队-WFQ"><a href="#加权公平排队-WFQ" class="headerlink" title="加权公平排队 WFQ"></a>加权公平排队 WFQ</h4><p>给排队流加权，R 服务每个队列时每次发送多少比特，它直接控制每个流将得到多少链路带宽</p><p>$F_i = \max(F_{i-1},A_i) + P_i/W$</p><h4 id="流量整形-Traffic-Shaping"><a href="#流量整形-Traffic-Shaping" class="headerlink" title="流量整形 (Traffic Shaping)"></a>流量整形 (Traffic Shaping)</h4><p>造成拥塞的主要原因是网络流量通常是突发性的</p><p>强迫包以一种可预测的速率发送</p><p>漏桶算法强迫输出按平均速率进行，不灵活，溢出时要丢包。</p><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>基本思想：漏桶存放令牌，每 $\Delta T$ 秒产生一个 令牌，令牌累积到超过漏桶上界时就不再增加。包传输之前必须<br>获得一个令牌，传输之后删除该令牌.</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>智端 + 傻网，端端拥塞控制</p><p>无预约，先渐增发，后观察事件反应</p><p>TCP假设网络中R仅用 FIFO 排队，但也可能使用 FQ 规则</p><p>拥塞包在 R 中丢弃后，由端来重传解决</p><p>TCP又叫自定时（self clocking）</p><ul><li>重传定时器</li><li>坚持定时器（接收窗口为0，期性地向接收方查询，发一个字节）</li><li>保活定时器（默认是2小时）</li><li>2MSL（报文段最大生存时间）定时器</li><li>……</li></ul><p>分组不能被传送和导致超时的主要原因是拥塞造成分组丢弃，<strong>发生拥塞的标志</strong>：</p><ul><li><strong>duplicate ACK（接收方发现包到达失序，不能确认，因此对已确认的字节再次确认）</strong></li><li><strong>超时</strong></li></ul><h4 id="加乘式-AIMD"><a href="#加乘式-AIMD" class="headerlink" title="加乘式 (AIMD)"></a>加乘式 (AIMD)</h4><p>TCP 根据网络中存在的拥塞级别来设定 Congestion Window 值</p><ul><li>拥塞级别上升，则减少 CW<ul><li>每发生一次超时，CW 减半</li></ul></li><li>拥塞级别下降，则增加 CW<ul><li>每成功确认一个分组，CW 加 1</li><li>当前 CW 对应的分组数全部确认后，CW 将翻倍</li></ul></li></ul><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>源最开始将 CW 设定为 1，每收到一个 ACK 线性增加 CW，最终 TCP 在每个 RTT 内将传送的分组数加倍</p><p>慢启动只发生在<strong>刚开始和发生超时</strong>的时候。</p><h4 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h4><p>发送方TCP等到 3 个 Duplicate ACK 后就重发丢失的包；即快速重传，比等待报文超时要快。（合理性：既然ACK报文可以通过网络，证明网络是通畅的，应该加快发送速度）</p><p>当快速重传同时快速恢复</p><ol><li>把 ssthresh 设置为 cwnd 的一半</li><li>把 cwnd 再设置为等于 ssthresh 的值，不再从 1 开始 (具体实现有些为 ssthresh + 3，因为三个重复的 ACK，表示有三个报文离开网络了，可以新增三个)</li><li>重新进入拥塞避免阶段，再收到重复 ACK，拥塞窗口+1（不会加剧拥塞，因为有 ACK 报文，说明可以增加发送）</li><li>收到新的报文 ACK 时候，ssthresh 变为第一步的大小（说明所有丢失的报文都收到了，可以快速恢复）</li></ol><h3 id="TCP-拥塞避免"><a href="#TCP-拥塞避免" class="headerlink" title="TCP 拥塞避免"></a>TCP 拥塞避免</h3><p>拥塞避免策略：拥塞将要发生时进行预测，在包将被丢弃之前减少主机发送数据的速率</p><h4 id="DECbit"><a href="#DECbit" class="headerlink" title="DECbit"></a>DECbit</h4><p>把拥塞任务更均匀分担在路由器和端节点之间，每个路由器监视它正在经历的负载，在拥塞将要发生时明确地通告端节点，通过设置流过路由器包中的二进制拥塞位来实现。目端把这拥塞位拷贝进 ACK 报文并返送回源端，源端调整自己的发送速率以避免拥塞，设置标志位告诉接收方，已经处理了拥塞。</p><p>测量平均队列长度的时间间隔是：最近的忙期 + 空闲期 + 当前忙期（R传输时为忙，不传输时为闲）。</p><p>用队列长度 1 作为设置拥塞位的触发器，是在有效排队(维持高吞吐率)和增加闲期(较低延迟)之间的折中，即队长1是网络能力（吞吐率/延迟）函数的优化。</p><p>源主机的工作，记录有多少包导致其在路由器中记下拥塞位，维护一个拥塞窗口，并观察最近等价窗口值导致设置拥塞的比例，若比例 $&lt;$ 50%，源增加拥塞窗口1个包，若比例 $\geq$ 50%，源减拥塞窗口至原值0.875倍。</p><h4 id="ECN-显式拥塞控制"><a href="#ECN-显式拥塞控制" class="headerlink" title="ECN 显式拥塞控制"></a>ECN 显式拥塞控制</h4><p>标记包而不是丢弃包，减少超时长度和重传次数</p><h4 id="基于源的拥塞避免"><a href="#基于源的拥塞避免" class="headerlink" title="基于源的拥塞避免"></a>基于源的拥塞避免</h4><h4 id="路由器主动队列管理-AQM"><a href="#路由器主动队列管理-AQM" class="headerlink" title="路由器主动队列管理 AQM"></a>路由器主动队列管理 AQM</h4><p>随机早期检测 RED</p><ul><li>R 在其缓冲被完全填满前就丢少量包，使源方减慢发率</li><li>RED 不明确发送拥塞通知到源，而是<strong>通过丢弃一个包来隐含已发生拥塞</strong>。源会被随后的超时或重复ACK所提示，这可与 TCP 配合使用</li><li>当队列超过某阈值时按某概率丢弃到达包</li><li>动态加权平均队长<ul><li>Avglen = (1 - Weight) × Avglen + Weight × SampleLen</li></ul></li><li>丢包函数<ul><li>TempP = MaxP * (Avglen - MinThreshold) / (MaxThreshold - MinThreshold)</li><li>P = TempP / (1 - count × TempP)，count 记录从上一次丢包开始到现在有多少刚到的包已加入队列</li></ul></li></ul><h2 id="Ch4-对等网络-P2P"><a href="#Ch4-对等网络-P2P" class="headerlink" title="Ch4 对等网络 P2P"></a>Ch4 对等网络 P2P</h2><h3 id="P2P-网络基本概念"><a href="#P2P-网络基本概念" class="headerlink" title="P2P 网络基本概念"></a>P2P 网络基本概念</h3><p>对等网络，计算 端到端</p><p>经系统间直接交换来共享计算资源和服务的应用模式</p><p>以非集中方式使用分布式资源来完成关键任务的一类系统和应用</p><p>既是客户端 consumer 也是服务器端</p><p>任何时候都有加入或离开的自由</p><p>无限的 peer diversity: 服务能力、存储空间 、网络带宽和服务需求</p><p>开放的广域无中心分布系统</p><h3 id="混合式-P2P-网络（第一代）"><a href="#混合式-P2P-网络（第一代）" class="headerlink" title="混合式 P2P 网络（第一代）"></a>混合式 P2P 网络（第一代）</h3><p>拓扑结构： 服务器仍然是网络的核心</p><p>底层协议： 全部使用 TCP ，限制了链接的 Peer 数量</p><p>查询与路由简单高效：</p><ul><li><p>Napster 和 BT 的用户访问服务器；服务器返回文件索引或种子文件；用户再直接同另一 Peer 连接</p></li><li><p>故路由跳数为 O(1) 1)，即常数跳</p></li></ul><p>容错、自适应和匿名性</p><ul><li><p>服务器单点失效率高</p></li><li><p>自组织和自适应主要依靠服务器</p></li><li><p>服务器的存在使匿名性实际不可能</p></li></ul><p>用户接入无安全认证机制</p><h3 id="无结构-P2P-网络（第二代）"><a href="#无结构-P2P-网络（第二代）" class="headerlink" title="无结构 P2P 网络（第二代）"></a>无结构 P2P 网络（第二代）</h3><p>容错性与自适应</p><ul><li>幂率特性对随机节点失效有高容错性</li><li>自适应：检测邻居在线否</li><li>超级节点列表定期更新</li></ul><p>可扩展性</p><ul><li>改造洪泛提高可扩展性</li></ul><p>安全性与匿名性</p><ul><li>无结构不易追踪</li></ul><p>增强机制 复制</p><ul><li>查询分布：均匀、 Zipf</li><li>复制份数：均匀、依查询概率比例、方根复制</li></ul><p>优势和缺陷</p><ul><li>高容错性和良好自适应性，较高安全性和匿名性</li><li>路由效率低 可扩展差 准确定位差</li></ul><h3 id="结构化-P2P-网络（第三代）"><a href="#结构化-P2P-网络（第三代）" class="headerlink" title="结构化 P2P 网络（第三代）"></a>结构化 P2P 网络（第三代）</h3><p>目标相同</p><ul><li>减少路由到指定文件的 P2P 跳数</li><li>减少每个 Peer 必须保持的路由状态</li></ul><p>算法异同</p><ul><li>节点与对象 Hash 映射到 同一空间 ，走 最接近 路由</li><li>都保证算法的跳数与 Peer 群组的大小相关</li><li>方法上的差别很小</li></ul><h3 id="BitCoin-和区块链"><a href="#BitCoin-和区块链" class="headerlink" title="BitCoin 和区块链"></a>BitCoin 和区块链</h3><p>区块奖励</p><ul><li>新产生的比特币奖励</li><li>交易费</li></ul><p>防止双花交易</p><ul><li>区块链是一个分布式数据库，每个区块拥有一段时间内的交易信息和上一个区块的摘要</li><li>同时可能出现两个合法的区块，但是只有最长链是最大算力保证的</li><li>如果有人想一个币使用两次，就会出现同一个交易输出被打包到两个新的交易中，非常容易检测，只有最长链才是被所有节点认可的，这样就防止了双花交易</li></ul><h1 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h1><ul><li><strong>OSI</strong>：Open Systems Interconnection，开放式系统互联</li><li><strong>TCP</strong>：Transmission Control Protocol，传输控制协议</li><li><strong>UDP</strong>：User Datagram Protocol，用户数据报协议</li><li><strong>IP</strong>：Internet Protocol，网际协议</li><li><strong>API</strong>：Application Programming Interface，应用程序接口</li><li><strong>RTT</strong>：Round Trip Time，往返时延</li><li><strong>QoS</strong>：Quality of Service，服务质量</li><li><strong>EoS</strong>：Experience of Service，服务体验（Ethernet over SDH，基于SDH的以太网）</li><li><strong>RFC</strong>：Request For Comment，请求评议</li><li><strong>DDoS</strong>：Distributed Denial of Service，分布式拒绝服务</li><li><strong>AS</strong>：Autonomous System，自治域</li><li><strong>S/N（SNR）</strong>：signal to noise ratio，信噪比</li><li><strong>GSM</strong>：Global System for Mobile Communications ，全球移动通信</li><li><strong>EIRP</strong>：Equivalent Isotropically Radiated Power，等效全向辐射频率</li><li><strong>OC</strong>：Optical Carrier，光载波</li><li><strong>SONET</strong>：Synchronous Optical Network，同步光纤网络</li><li><strong>STS</strong>：Synchronous Transport Signal，同步传输信号</li><li><strong>SDH</strong>：Synchronous Digital Hierarchy，同步数字体系</li><li><strong>STM</strong>：Synchronous Transport Module，同步传输模块</li><li><strong>PAM</strong>：Pulse Amplitude Modulation，脉冲幅度调制</li><li><strong>PCM</strong>：Pulse Code Modulation，脉冲码调制</li><li><strong>ASK</strong>：Amplitude Shift Keying，幅移键控</li><li><strong>FSK</strong>：Frequency Shift Keying，频移键控</li><li><strong>PSK</strong>：Phase Shift Keying，相移键控</li><li><strong>QAM</strong>：Quadrature Amplitude Modulation，正交幅度编码</li><li><strong>NRZ</strong>：Non-Return Zero，不归零编码</li><li><strong>NRZI</strong>：Non-Return Zero Inverted，不归零反转编码</li><li><strong>BISYN</strong>：Binary Synchronous Communication Message Protocol，二进制同步通信协议</li><li><strong>DDCMP</strong>：Digital Data Communication Message Protocol，数字数据通信消息协议</li><li><strong>PPP</strong>：Point to Point Protocol，点到点协议</li><li><strong>SDLC</strong>：Synchronous Data Link Control Protocol，同步数据链路控制协议</li><li><strong>HDLC</strong>：High-level Data Link Control Protocol，高级数据链路控制协议</li><li><strong>TDM</strong>：Time Division Multiplexing，时分复用</li><li><strong>STDM</strong>：Statistical Time Division Multiplexing，统计时分复用</li><li><strong>FDM</strong>：Frequency Division Multiplexing，频分复用</li><li><strong>WDM</strong>：Wavelength Division Multiplexing，波分复用</li><li><strong>CWDM</strong>：Coarse Wavelength Division Multiplexing，稀疏波分复用</li><li><strong>DWDM</strong>：Dence Wavelength Division Multiplexing，密集波分复用</li><li><strong>CDM</strong>：Code Division Multiplexing，码分复用</li><li><strong>ARQ</strong>：Automatic Repeat Request，自动请求重传</li><li><strong>CRC</strong>：Cyclic Redundency Check，循环冗余校验</li><li><strong>ATM</strong>：Asynchronous Transfer Mode，异步传输模式</li><li><strong>CSMA/CD</strong>：Carrier Sense Multiple Access with Collision Detection，带冲突检测的载波侦听多路访问</li><li><strong>VLAN</strong>：Virtual Local Area Network，虚拟局域网</li><li><strong>STP</strong>：Spanning Tree Protocol，生成树协议</li><li><strong>CST</strong>：Common Spanning Tree，公共生成树</li><li><strong>BPDU</strong>：Bridge Protocol Data Unit，网桥协议数据单元</li><li><strong>TCN</strong>：Topology Change Notification，拓扑更改通知</li><li><strong>URL</strong>：Uniform Resource Locater，统一资源定位器</li><li><strong>DNS</strong>：Domain Name System，域名系统</li><li><strong>MAC 地址</strong>：Media Access Control Address，媒介存取控制地址</li><li><strong>ARP</strong>：Address Resolution Protocol，地址解析协议</li><li><strong>NAT</strong>：Network Address Translation，网络地址转换</li><li><strong>TTL</strong>：Time To Live，生存期</li><li><strong>MTU</strong>：Maximum Transmission Unit，最大传输单元</li><li><strong>FDDI</strong>：Fiber Distributed Data Interface，光纤分布式数据接口</li><li><strong>ICMP</strong>：Internet Control Message Protocol ，网际控制报文协议</li><li><strong>IGP</strong>：Interior Gateway Protocol，内部网关协议</li><li><strong>RIP</strong>：Routing Information Protocol，路由信息协议</li><li><strong>OSPF</strong>：Open Shortest Path First，开放最短路径优先</li><li><strong>EGP</strong>：Exterior Gateway Protocol，外部网关协议</li><li><strong>BGP</strong>：Border Gateway Protocol，边界网关协议</li><li><strong>LSP</strong>：Link-State Packet，链路状态分组</li><li><strong>LSA</strong>：Link-State Advertisement，链路状态通知</li><li><strong>CIDR</strong>：Classless Inter-Domain Routing，无类别域间路由</li><li><strong>DHCP</strong>：Dynamic Host Configuration Protocol，动态主机配置协议</li><li><strong>IPSec</strong>：Internet Protocol Security，网际协议安全</li><li><strong>EUI</strong>：Extended Unique Identifier，扩展唯一标识符</li><li><strong>DAD</strong>：Dupicate Address Detection，重复地址检测</li><li><strong>NDP</strong>：Neighbor Discovery Protocol，邻居发现协议</li><li><strong>AQM</strong>：Active Queue Management，主动队列管理</li><li><strong>FIFO</strong>：First In First Out，先进先出</li><li><strong>ToS</strong>：Type of Service，服务类型</li><li><strong>DSCP</strong>：Differentiated Services Code Point，差分服务代码点</li><li><strong>ECN</strong>：Explict Congestion Notification，显示拥塞通知</li><li><strong>FQ</strong>：Fair Queuing，公平排队</li><li><strong>WFQ</strong>：Weighted Fair Queuing，加权公平排队</li><li><strong>ssthresh</strong>：slow start threshold，慢启动阈值</li><li><strong>AIMD</strong>：Additive Increase Multiplicative Decrease，加性增乘性减（加法式增加乘法式减少）</li><li><strong>RED</strong>：Random Early Detection，随机早期检测</li><li><strong>IGMP</strong>：Internet Group Management Protocol，因特网组管理协议</li><li><strong>CGMP</strong>：Cisco Group Management Protocol，思科组管理协议</li><li><strong>PIM</strong>：Protocol Independent Multicast，协议独立组播</li><li><strong>PIM-DM</strong>：Protocol Independent Multicast-Dense Mode，协议独立组播密集模式</li><li><strong>PIM-SM</strong>：Protocol Independent Multicast-Sparse Mode，协议独立组播稀疏模式</li><li><strong>RPF</strong>：Reverse Protocol Forwarding，逆向路径转发</li><li><strong>SPT</strong>：Shortest-Path Tree，最短路径树</li><li><strong>RPT</strong>: Rendezvous Point Tree，PIM-SM 协议共享树</li><li><strong>MBGP</strong>：Multi-protocol Border Gateway Protocol，多协议边界网关协议</li><li><strong>MSDP</strong>：Multicast Source Discovery Protocol，组播源发现协议</li><li><strong>RTP</strong>：Real-time Transport Protocol，实时传输协议</li><li><strong>RTCP</strong>：Real-time Transport Control Protocol，实时传输控制协议</li><li><strong>RSVP</strong>：Resource Reservation Protocol，资源预留协议</li><li><strong>P2P</strong>：Peer to Peer，端到端，对等</li><li><strong>CDN</strong>：Content Delivery Network，内容分发网络</li><li><strong>ALM</strong>：Application Level Multicast，应用层组播</li><li><strong>DHT</strong>：Distributed Hash Table，分布式哈希表</li><li><strong>CFS</strong>：Cooperative File System，协同文件系统</li><li><strong>UTXO</strong>：Unspent Transaction Output，没有花出去的输出</li><li><strong>SDN</strong>：Software Defined Networking，软件定义网络</li><li><strong>SIP</strong>：Session Initiation Protocol，会话初始化协议</li><li><strong>NDN</strong>：Named Data Networking，命名数据网络</li><li><strong>NFV</strong>：Network Function Virtualization，网络功能虚拟化</li><li><strong>LTE</strong>：Long Term Evolution，长期演进技术</li><li><strong>OTN</strong>：Optical Transport Network，光传输网络</li><li><strong>IOT</strong>：the Internet of Things，物联网</li><li><strong>RTS</strong>：Request to Send，请求发送</li><li><strong>CTS</strong>：Clear to Send，允许发送</li></ul>]]></content>
      
      
      <categories>
          
          <category> 现代计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《图像处理》频域图像增强</title>
      <link href="/2019/10/frequency-domain-enhancement-by-book-image-processing/"/>
      <url>/2019/10/frequency-domain-enhancement-by-book-image-processing/</url>
      
        <content type="html"><![CDATA[<h1 id="频域图像增强"><a href="#频域图像增强" class="headerlink" title="频域图像增强"></a>频域图像增强</h1><ul><li>前面对图像的加工都是在图像空间进行的，也可以考虑将图像变换到其他空间里再进行加工，这些利用变换以后空间的方法称为基于变换域的方法<ol><li>将图像从图像空间转换到变换域空间</li><li>在变换域空间中对图像进行增强</li><li>将增强后的图像再从变换域空间转换到图像空间</li></ol></li><li>最常用的变换空间是<strong>频域空间</strong>，所采用的变换是<strong>傅里叶变换</strong></li><li>频域空间里的图像信息表现为不同频率分量的组合，如果能让不同频率范围内的分量受到不同的抑制，即进行不同的滤波，就可以改变输出图的频率分布，达到不同的增强目的</li></ul><h1 id="频域技术原理"><a href="#频域技术原理" class="headerlink" title="频域技术原理"></a>频域技术原理</h1><h2 id="频域增强步骤"><a href="#频域增强步骤" class="headerlink" title="频域增强步骤"></a>频域增强步骤</h2><ul><li>如果将图像从图像空间转换到频域空间所需的变换用 $T$ 表示（反变换用 $T^{-1}$ 表示），将在频域空间对图像进行增强加工的操作仍用 $E_H$ 表示，则要将 $f(x,y)$ 增强成 $g(x,y)$ 可表示为 $g(x,y) = T^{-1} \{E_H[T[f(x,y)]] \}$ . </li><li>卷积理论是频域技术的基础<ul><li>设函数 $f(x,y)$ 与线性位不变算子 $h(x,y)$ 的卷积结果是 $g(x,y)$，即 $g(x,y)=h(x,y)*f(x,y)$，那么根据卷积定理在频域有 $G(u,v)=H(u,v)F(u,v)$，其中 $G(u,v)$，$H(u,v)$，$F(u,v)$ 分别是 $g(x,y)$，$h(x,y)$，$f(x,y)$ 的傅里叶变换。根据线性系统理论，$H(x,y)$ 是转移函数。</li><li>在具体增强应用中，$f(x,y)$ 是给定的输入图像，需要确定的是 $H(u,v)$，具有所需特性的 $g(x,y)$ 就可以通过算出 $G(x,y)$ 后得到：$g(x,y)=T^{-1}[H(u,v)F(u,v)]$。</li></ul></li><li>频域增强的步骤<ol><li>计算需增强图像的傅里叶变换</li><li>将其与一个根据需要设计的转移函数相乘</li><li>再将结果进行傅里叶反变换以得到增强的图像</li></ol></li><li>转移函数<ul><li>根据增强目的进行设计</li><li>基本思路<ul><li>要允许一定频率通过（保留某些频率分量），限制或阻止另外一些频率通过（消除某些频率分量）</li></ul></li><li>类型<ul><li>低通滤波</li><li>高通滤波</li><li>带阻滤波</li><li>带通滤波</li><li>同态滤波</li></ul></li></ul></li></ul><h2 id="频域技术与空域技术"><a href="#频域技术与空域技术" class="headerlink" title="频域技术与空域技术"></a>频域技术与空域技术</h2><ul><li>空域和频域技术基本可实现相同功能<ul><li>频域中滤波器的转移函数和空域中的脉冲响应函数或点扩散函数构成傅里叶变换对</li></ul></li><li>在频域中设计滤波器比较方便<ul><li>在频域中分析，在空域中实现</li></ul></li><li>空域技术基于（部分象素）局部性质，频域技术利用（所有象素）全局性质</li></ul><h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><ul><li><a href="https://blog.csdn.net/u013921430/article/details/79683853" target="_blank" rel="noopener">傅里叶变换</a><ul><li>是可分离和正交变换的一个特例</li><li>对图像的傅里叶变换将图像从图像空间变换到频率空间，从而可利用傅里叶频谱特性进行图像处理</li></ul></li></ul><h2 id="2-D-傅里叶变换"><a href="#2-D-傅里叶变换" class="headerlink" title="2-D 傅里叶变换"></a>2-D 傅里叶变换</h2><ul><li><p>变换定义</p><ul><li>2-D 图像 $f(x,y)$ 的 <code>正反傅里叶变换</code> 分别定义如下（其中 $u$ 和 $v$ 均为频率分量）<ul><li>$F(u,v)=\cfrac{1}{N}\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi(ux+vy)/N} \quad u,v=0,1,\cdots,N-1$ </li><li>$f(x,y)=\cfrac{1}{N}\sum_{u=0}^{N-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi(ux+vy)/N} \quad x,y=0,1,\cdots,N-1$ </li></ul></li><li>可得<ul><li>$\bar{f}(x,y)=\cfrac{1}{N^2}\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}f(x,y)=\cfrac{1}{N}F(0,0)$<ul><li>一个 2-D 离散函数的傅里叶变换在原点的值（<strong>零频率分量</strong>）与该函数的均值成正比</li></ul></li></ul></li><li>2-D 傅里叶变换的 <code>频谱</code>（幅度函数）、<code>相位角</code> 和 <code>功率谱</code>（频谱的平方）定义如下<ul><li>$|F(u,v)|=\sqrt{R^2(u,v)+I^2(u,v)}$ </li><li>$\phi(u,v)=\arctan\cfrac{I(u,v)}{R(u,v)}$ </li><li>$P(u,v)=|F(u,v)|^2=R^2(u,v)+I^2(u,v)$ </li></ul></li></ul></li><li><p><strong>变换核</strong></p><ul><li>正向变换 $f(x,y) \Rightarrow F(u,v)$ <ul><li>正向变换核 $\cfrac{1}{N} e^{-j2\pi(ux+vy)/N}$ </li></ul></li><li>反向变化 $F(u,v) \Rightarrow f(x,y)$ <ul><li>反向变换核 $\cfrac{1}{N}e^{j2\pi(ux+vy)/N}$ </li></ul></li><li>可分离性<ul><li>$ux$ 和 $vy$ 可分开<ul><li>$\cfrac{1}{N} e^{-j2\pi(ux+vy)/N} = \cfrac{1}{\sqrt{N}} e^{-j 2\pi ux/N} \times \cfrac{1}{\sqrt{N}} e^{-j 2\pi vy/N}$ </li><li>$\cfrac{1}{N} e^{j2\pi(ux+vy)/N} = \cfrac{1}{\sqrt{N}} e^{j 2\pi ux/N} \times \cfrac{1}{\sqrt{N}} e^{j 2\pi vy/N}$ </li></ul></li><li>1 个 2-D 变换核可分解成 2 个 1-D 变换核</li></ul></li><li>对称性<ul><li>分离后的两部分函数形式一样</li></ul></li><li>具有可分离且对称变换核的 2-D 傅里叶变换可分解成两个步骤计算，每个步骤用一个 1-D 变换<ul><li>正变换分解<ol><li>列变换 $F(x,v)=\cfrac{1}{\sqrt{N}}\sum_{y=0}^{N-1} f(x,y) e^{-j 2\pi vy/N} \quad x,v=0,1,\cdots,N-1$ </li><li>行变换 $F(u,v)=\cfrac{1}{\sqrt{N}}\sum_{x=0}^{N-1} F(x,v) e^{-j 2\pi ux/N} \quad u,v=0,1,\cdots,N-1$ </li></ol></li><li><img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/由2步1-D变换计算2-D变换.jpg" alt></li></ul></li></ul></li></ul><h2 id="傅里叶变换定理"><a href="#傅里叶变换定理" class="headerlink" title="傅里叶变换定理"></a>傅里叶变换定理</h2><ul><li>设图像空间的 f(x,y) 与频域空间的 F(u,v) 构成一对变换，即 $f(x,y) \Leftrightarrow F(u,v)$，则有一下基本定理成立</li><li><strong>平移定理</strong><ul><li>$f(x-a,y-b) \Leftrightarrow F(u,v) e^{-j2\pi(au+bv)/N}$ </li><li>$F(u-c,v-d) \Leftrightarrow f(x,y) e^{j2\pi(cx+dy)/N}$ </li><li>将 f(x,y) 在空间平移相当于把其变换在频域与一个指数项相乘</li><li>将 f(x,y) 在图像空间与一个指数项相乘相当于把其在变换在频域平移</li><li>平移不影响正反变换的幅值</li><li>平移定理证明<img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/平移定理证明.png" alt></li><li>傅里叶变换频域平移示例<img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/频域平移.png" alt></li></ul></li><li><strong>旋转定理</strong><ul><li>反映傅里叶变换的旋转性质</li><li>首先借助极坐标变换</li><li>$\begin{cases}<br>  x=r\cos\theta \\<br>  y=r\sin\theta \\<br>  u=\omega\cos\phi \\<br>  v=\omega\sin\phi \\<br>  \end{cases}$ </li><li>将 $f(x,y)$ 和 $F(u,v)$ 转换为 $f(r,\theta)$ 和 $F(\omega,\phi)$ </li><li>直接将它们带入傅里叶变换对得到</li><li>$f(r,\theta+\theta_0) \Leftrightarrow F(\omega,\phi+\theta_0)$ </li><li>其中 $\theta_0$ 为旋转角度</li><li>傅里叶变换旋转性质示例<img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/傅里叶变换旋转示例.png" alt></li></ul></li><li><strong>尺度定理（相似定理）</strong><ul><li>给出傅里叶变换在尺度（放缩）变化时的性质</li><li>$af(x,y) \Leftrightarrow aF(u,v)$ </li><li>$f(ax,by) \Leftrightarrow \cfrac 1 {|ab|}F \left(\cfrac u a,\cfrac v b \right)$ </li><li>对 f(x,y) 在<strong>幅度方面的尺度变化</strong>导致对其傅里叶变换 F(u,v) 在<strong>幅度方面的对应尺度变化 </strong></li><li>对 f(x,y) 在<strong>空间尺度方面的放缩</strong>导致对其傅里叶变换 F(u,v) 在<strong>频域尺度方面的相反放缩</strong> </li><li>对 f(x,y) 的收缩 (a&gt;1, b&gt;1) 不仅导致 F(u,v) 的膨胀，而且会使 F(u,v) 的幅度减小</li><li>傅里叶变换尺度性质示例<img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/傅里叶变换尺度性质示例.png" alt></li></ul></li><li><strong>剪切定理</strong><ul><li>描述傅里叶变换在剪切变化时的性质</li><li>对 f(x,y) 的纯剪切会导致 F(x,y) 在<strong>正交方向</strong>的纯剪切</li><li>水平剪切 $f(x+by,y) \Leftrightarrow F(u,v-bu)$ </li><li>垂直剪切 $f(x,y+dx) \Leftrightarrow F(u-dv,v)$ </li><li>傅里叶变换剪切性质示例<img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/傅里叶变换剪切性质示例.png" alt></li><li>组合剪切 $f(x+by,y+dx) \Leftrightarrow \cfrac{1}{|1-bd|}F \left( \cfrac{u-dv}{1-bd},\cfrac{-bu+v}{1-bd} \right)$ </li><li>矩阵表达<ul><li>用矢量 $\boldsymbol{x}$ 表示 $(x,y)$，用矢量 $\boldsymbol{x’}$ 表示 $(x’,y’)$ </li><li>$\boldsymbol{x’}=\begin{bmatrix}1&amp;b\\d&amp;1\end{bmatrix}\boldsymbol{x}$ </li><li>对水平剪切，变换矩阵为 <script type="math/tex">\begin{bmatrix}1&b\\0&1\end{bmatrix}</script> 或 $\begin{bmatrix} 1 &amp; \tan s \\ 0 &amp; 1 \end{bmatrix}$</li><li>对垂直剪切，变换矩阵为 $\begin{bmatrix}1&amp;0\\d&amp;1\end{bmatrix}$ 或 $\begin{bmatrix} 1 &amp; 0 \\ \tan t &amp; 1\end{bmatrix}$ </li><li>先水平剪切后垂直剪切可表示为 $\begin{bmatrix}1&amp;0\\d&amp;1\end{bmatrix} \begin{bmatrix}1&amp;b\\0&amp;1\end{bmatrix} = \begin{bmatrix} 1 &amp; b \\ d &amp; 1+bd \end{bmatrix}$ </li><li>先垂直剪切后水平剪切可表示为 $\begin{bmatrix}1&amp;b\\0&amp;1\end{bmatrix} \begin{bmatrix}1&amp;0\\d&amp;1\end{bmatrix} = \begin{bmatrix} 1+bd &amp; b \\ d &amp; 1 \end{bmatrix}$ </li><li>其中角度 s 和 t 如图所示 <img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/单位正方形受到剪切后的效果.jpg" alt><ul><li>(a) 水平剪切</li><li>(b) 垂直剪切</li><li>(c) 组合剪切</li><li>(d) 先水平剪切后垂直剪切</li><li>(e) 先垂直剪切后水平剪切</li></ul></li><li>简单的剪切操作依次使用会产生不同的结果<ul><li>矩阵相乘的次序是不能交换的</li><li><strong>组合剪切</strong>的结果具有与<strong>简单剪切</strong>相同的倾斜角 s 和 t<ul><li>$\tan s = b$ </li><li>$\tan t = d$</li></ul></li><li><strong>先水平剪切后垂直剪切</strong>保持了 t，但产生了一个新角 p<ul><li>$\tan p = \cfrac{b}{1+bd}$ </li></ul></li><li><strong>先垂直剪切后水平剪切</strong>保持了 s，但产生了一个新角 q<ul><li>$\tan q = \cfrac{d}{1+bd}$ </li></ul></li></ul></li></ul></li></ul></li><li><strong>卷积定理</strong><ul><li>指出两个函数<strong>在空间的卷积</strong>与它们的傅里叶变换<strong>在频域的乘积</strong>构成一对变换，而两个函数<strong>在空间的乘积</strong>与它们的傅里叶变换<strong>在频域的卷积</strong>构成一对变换</li><li>$f(x,y) \ast g(x,y) \Leftrightarrow F(u,v)G(u,v)$ </li><li>$f(x,y)g(x,y) \Leftrightarrow F(u,v) \ast G(u,v)$ </li></ul></li><li><strong>相关定理</strong><ul><li>指出两个函数在空间的相关与它们的傅里叶变换（其中一个为其复共轭）在频域的乘积构成一对变换，而两个函数（其中一个为其复共轭）在空间的乘积与它们的傅里叶变换在频域的相关构成一对变换</li><li>$f(x,y) \circ g(x,y) \Leftrightarrow F^{\ast}(u,v)G(u,v)$ </li><li>$f^{*}(x,y)g(x,y) \Leftrightarrow F(u,v) \circ G(u,v)$ </li><li>如果 $f(x,y) = g(x,y)$，称为自相关</li><li>如果 $f(x,y) \neq g(x,y)$，称为互相关</li></ul></li></ul><h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><ul><li>直接进行一个 $N \times N$ 的 2-D 傅里叶变换需要 $N^4$ 次<strong>复数乘法</strong>运算和 $N^2(N^2–1)$ 次<strong>复数加法</strong>运算<ul><li>对 $N^2$ 个点中的每个点都需要进行 $N^2$ 次复数乘法运算和 $N^2–1$ 次复数加法运算</li></ul></li><li>2-D 傅里叶变化可由连续两次 1-D 傅里叶变换得到<ul><li>$\mathcal{F}\{f(x)\}=F(u)=\cfrac{1}{N}\sum_{x=0}^{N-1}f(x)e^{-j 2\pi ux/N} \quad u=0,1,\cdots,N-1$ </li><li>1-D 傅里叶变换对 $u$ 的 $N$ 个值中的每一个都需要进行 $N$ 次复数乘法和 $N-1$ 次复数加法，即复数乘法和加法的次数都正比于 $N^2$ </li></ul></li><li><a href="https://blog.csdn.net/enjoy_pascal/article/details/81478582" target="_blank" rel="noopener">快速傅里叶变换</a><ul><li>注意到 $e^{-j 2\pi ux/N}$ 可只计算一次后存到一个表中以备查用，正确地分解 1-D 傅里叶变换可以将复数乘法和加法的次数减少为正比于 $N\log_2N$ </li></ul></li></ul><h1 id="低通滤波和高通滤波"><a href="#低通滤波和高通滤波" class="headerlink" title="低通滤波和高通滤波"></a>低通滤波和高通滤波</h1><ul><li>低通滤波和高通滤波的<strong>目的或功能相反</strong>，但低通滤波器和高通滤波器又<strong>具有对偶性</strong></li><li>下述讨论中仅考虑对 F(u,v) 的实部和虚部影响完全相同的滤波函数（称为<strong>零相移滤波器</strong>）</li></ul><h2 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h2><ul><li>低通滤波是要保留图像中的低频分量而除去高频分量</li><li>图像中的边缘和噪声都对应图像傅里叶频谱中的高频部分，所以通过在频域中的低通滤波可以除去或削弱噪声中的影响并模糊边缘轮廓，与空域中的平滑方法类似</li><li><p>要实现低通滤波需要设计一个合适的滤波转移函数 H(u,v)</p><h3 id="理想低通滤波"><a href="#理想低通滤波" class="headerlink" title="理想低通滤波"></a>理想低通滤波</h3></li><li><p>一个理想的低通滤波器的转移函数满足以下条件</p></li><li>$H(u,v)=\begin{cases} 1 &amp; D(u,v) \leq D_0 \\<br>  0 &amp; D(u,v) \gt D_0 \end{cases}$</li><li>其中 $D_0$ 是一个非负整数，也叫<strong>截断频率</strong> </li><li>$D(u,v)=\sqrt{u^2+v^2}$ 是从点 $(u,v)$ 到频率平面原点的距离</li><li><img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/理想低通滤波器转移函数的剖面图.png" alt></li><li>理想是指小于截断频率的频率可以完全不受影响地通过滤波器，而大于截断频率的频率则完全通不过</li><li>在数学上定义得很清楚，在计算机模拟中也可实现，但是在截断频率处直上直下的理想低筒滤波器是不能勇士级的电子器件实现的</li></ul><h3 id="理想低通滤波的模糊"><a href="#理想低通滤波的模糊" class="headerlink" title="理想低通滤波的模糊"></a>理想低通滤波的模糊</h3><ul><li>理想低通滤波器是“非物理”的滤波器，使用它来对图像进行滤波，其<strong>输出图像会变得模糊并有“振铃”现象出现</strong> </li><li><img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/理想低通滤波的空间模糊示意图.png" alt></li><li>理想低通滤波所产生的“振铃”现象在 2-D 图象上表现为<strong>一系列同心圆环</strong> <ul><li>圆环半径反比于截断频率</li><li>如果截断频率较小，就会使 h(x,y) 产生数量较少但较宽的同心圆环，并使得 g(x,y) 模糊得更比较厉害</li><li>当增加截断频率时，圆环就会变得数量较多但较窄，且 g(x,y) 的模糊减小</li><li>如果截断频率超过 F(u,v) 的定义域，则 h(x,y) 在其对应的空间区域值为 1，h(x,y) 与 f(x,y) 的卷积仍是 f(x,y)，这相当于没有滤波</li></ul></li></ul><h3 id="巴特沃斯低通滤波"><a href="#巴特沃斯低通滤波" class="headerlink" title="巴特沃斯低通滤波"></a>巴特沃斯低通滤波</h3><ul><li>物理上可以实现的一种低通滤波器</li><li>一个阶为 $n$、截断频率为 $D_0$ 的巴特沃斯低通滤波器的转移函数为 $H(u,v)=\cfrac{1}{1+[D(u,v)/D_0]^{2n}}$ </li><li>阶为 1 的巴特沃斯低通滤波器转移函数的剖面图如下<img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/巴特沃斯低通滤波器转移函数的剖面示意图.png" alt><ul><li>在高低频率间的过渡比较光滑</li><li>可减少振铃效应</li></ul></li><li>常取<strong>使 H 最大值降到某个百分比的频率</strong>为截断频率<ul><li>当 $D(u,v)=D_0$ 时，$H(u,v)=1/2$ （即降到 50%）</li><li>另一个常用的截断频率值是使 $H(u,v)=\sqrt{1/2}$ 的频率</li></ul></li></ul><h2 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h2><ul><li>要保留图像中的高频分量而除去低频分量</li><li>图像中的边缘对应高频分量，所以要锐化图像可使用高通滤波器</li></ul><h3 id="理想高通滤波"><a href="#理想高通滤波" class="headerlink" title="理想高通滤波"></a>理想高通滤波</h3><ul><li>一个理想的高通滤波器的转移函数满足以下条件</li><li>$H(u,v)=\begin{cases} 0 &amp; D(u,v) \leq D_0 \\<br>  1 &amp; D(u,v) \gt D_0 \end{cases}$</li><li><img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/理想高通滤波器转移函数的剖面图.png" alt></li></ul><h3 id="巴特沃斯高通滤波"><a href="#巴特沃斯高通滤波" class="headerlink" title="巴特沃斯高通滤波"></a>巴特沃斯高通滤波</h3><ul><li>一个阶为 $n$、截断频率为 $D_0$ 的巴特沃斯高通滤波器的转移函数为 $H(u,v)=\cfrac{1}{1+[D_0/D(u,v)]^{2n}}$ </li><li>阶为 1 的巴特沃斯高通滤波器的转移函数的剖面图如下<img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/巴特沃斯高通滤波器转移函数的剖面示意图.png" alt></li><li>常取<strong>使 H 最大值降到某个百分比的频率</strong>为截断频率</li></ul><h3 id="高频增强滤波"><a href="#高频增强滤波" class="headerlink" title="高频增强滤波"></a>高频增强滤波</h3><ul><li>一般图像中<strong>大部分能量集中在低频分量中</strong>，高通滤波会将很多低频分量（特别是直流分量）滤除，导致曾庆图中边缘得到增强但光滑区域灰度减弱变暗甚至接近黑色</li><li>为解决这个问题，可<strong>对频域里的高通滤波器的转移函数加一个常数以将一些低频分量加回去</strong>，获得既保持光滑区域灰度又改善边缘区域对比度的效果，这样得到的滤波器称为<strong>高频增强滤波器</strong> <ul><li>设原始模糊图的傅里叶变换为 $F(u,v)$，高通滤波所用的转移函数为 $H(u,v)$，则输出图的傅里叶变换为 $G(u,v) = H(u,v)F(u,v)$ </li><li>现对转移函数加一个常数 $c$ 得到高频增强转移函数 $H_e(u,v)=H(u,v)+c$ ，其中 $c$ 为 [0,1] 间常数</li><li>这样高频增强输出图的傅里叶变换为 $G_e(u,v)=G(u,v)+cF(u,v)$，即在高通的基础上又保留了一定的低频分量 $cF(u,v)$ </li><li>如果将高频增强输出图的傅里叶变换再反变换回去，则可得 $g_e(x,y)=g(x,y)+cf(x,y)$，可见增强图中既包含了高通滤波的结果，也包含了一部分原始的图像。或者说，在原始图的基础上叠加了一些高频成分，因而增强图中高频分量更多了</li></ul></li><li>实际中，还可以给高频增强滤波所用转移函数乘以一个常数 k（k为大于 1 的常数）以进一步加强高频成分<ul><li>$H_e(u,v)=kH(u,v)+c$ </li><li>$G_e(u,v)=kG(u,v)+cF(u,v)$ </li></ul></li></ul><h3 id="高频提升滤波"><a href="#高频提升滤波" class="headerlink" title="高频提升滤波"></a>高频提升滤波</h3><ul><li>用原始图减去低通图可以得到高通滤波效果</li><li>高频提升滤波<strong>先将原始图乘以一个放大系数 A 再减去低通图</strong><ul><li>设原始图的傅里叶变换为 $F(u,v)$，原始图被低通滤波后的傅里叶变换为 $F_L(u,v)$，原始图高通滤波后的傅里叶变换为 $F_H(u,v)$ </li><li>则高频提升滤波结果 $G_{HB}(u,v)=AF(u,v)-F_L(u,v)=(A-1)F(u,v)+F_H(u,v)$ <ul><li>当 A=1 时，就是普通的高通滤波</li><li>当 A&gt;1 时，原始图的一部分与高通图相加，恢复了部分高通滤波时丢失的低频分量，使得最终结果与原图更接近</li></ul></li><li>因为低通滤波常使图像模糊，所以一般从原始图中减去模糊图也称为（非锐化）掩模</li></ul></li></ul><h1 id="带通和带阻滤波"><a href="#带通和带阻滤波" class="headerlink" title="带通和带阻滤波"></a>带通和带阻滤波</h1><ul><li>带通滤波和带阻滤波都属于选择性滤波</li></ul><h2 id="带阻滤波"><a href="#带阻滤波" class="headerlink" title="带阻滤波"></a>带阻滤波</h2><ul><li>阻止一定频率范围内的信号通过而允许其他频率范围内的信号通过<ul><li>如果下限是 0 (上限不为 $\infty$) $\rightarrow$ 高通滤波</li><li>如果上限是 $\infty$ (下限不为 0) $\rightarrow$ 低通滤波</li></ul></li><li>带阻滤波器设计成能除去以原点为中心的一定频率范围内的信号<ul><li>$H(u,v)=\begin{cases} 1 &amp; D(u,v) \lt D_d-W/2 \\<br>  0 &amp; D_d-W/2 \leq D(u,v) \leq D_d+W/2 \\<br>  1 &amp; D(u,v) \gt D_d+W/2 \end{cases}$ </li><li>其中 $W$ 为带的宽度，$D_d$ 为带中心到频率平面原点的距离</li><li><img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/带阻滤波转移函数剖面图.png" alt></li><li><img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/放射对称的带阻滤波透视图.png" alt></li></ul></li><li>巴特沃斯带阻滤波器的转移函数为 $H(u,v)=\cfrac{1}{1+\left[\cfrac{D(u,v)W}{D^2(u,v)-D_d^2}\right]^{2n}}$ <ul><li>在 $D_d-W/2$ 处的上升沿比较陡而在 $D_d+W/2$ 处的上升沿要缓一些</li></ul></li></ul><h2 id="带通滤波"><a href="#带通滤波" class="headerlink" title="带通滤波"></a>带通滤波</h2><ul><li>允许一定频率范围内的信号通过而阻止其他频率范围内的信号通过<ul><li>如果下限是 0 (上限不为 $\infty$) $\rightarrow$ 低通滤波</li><li>如果上限是 $\infty$ (下限不为 0) $\rightarrow$ 高通滤波</li></ul></li><li>带通滤波器和带阻滤波器是互补的<ul><li>设 $H_R(u,v)$ 为带阻滤波器的转移函数</li><li>则对应的带通滤波器 $H_P(u,v)$ 只需将 $H_R(u,v)$ 翻转即可</li><li>$H_P(u,v)=-[H_R(u,v)-1]=1-H_R(u,v)$ </li></ul></li></ul><h2 id="陷波滤波"><a href="#陷波滤波" class="headerlink" title="陷波滤波"></a>陷波滤波</h2><ul><li>能通过或阻断在频率域上某点周围预先确定的邻域中的频率</li><li>零相移的滤波器相对于原点是对称的<ul><li>中心在 $(u_0,v_0)$ 的陷波有一个对应的中心在 $(-u_0,-v_0)$ 的陷波</li><li>陷波器必须两两对称地工作</li></ul></li><li>带阻陷波器由其中心转到陷波中心的高通滤波器的乘积来获得<ul><li>通用形式 $H_{NR}(u,v)=\prod_{k=1}^Q H_k(u,v)H_{-k}(u,v)$ </li><li>其中 $H_k(u,v)$ 和 $H_{-k}(u,v)$ 分别是中心在 $(u_0,v_0)$ 和 $(-u_0,-v_0)$ 的高通滤波器</li></ul></li><li>如果频域中心为 $(M/2,N/2)$，则距离函数<ul><li>$D_k(u,v)=\sqrt{(u-M/2-u_k)^2+(v-N/2-v_k)^2}$ </li><li>$D_{-k}(u,v)=\sqrt{(u-M/2+u_k)^2+(v-N/2+v_k)^2}$ </li></ul></li><li>一个用于消除以 $(u_0,v_0)$ 为中心、$D_0$ 为半径的区域内所有频率的理想阻断陷波器的转移函数为 $H(u,v)=\begin{cases} 0 &amp; D_k(u,v) \leq D_0 或 D_{-k}(u,v) \leq D_0 \\<br>  1 &amp; \text{其他} \end{cases}$ </li><li><img src="/2019/10/frequency-domain-enhancement-by-book-image-processing/理想带阻陷波器和带通陷波器透视图.png" alt></li></ul><h1 id="同态滤波"><a href="#同态滤波" class="headerlink" title="同态滤波"></a>同态滤波</h1>]]></content>
      
      
      <categories>
          
          <category> 《图像处理》章毓晋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像增强 </tag>
            
            <tag> 频域增强 </tag>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习模型基本结构</title>
      <link href="/2019/09/basic-structures-for-deep-learning-models/"/>
      <url>/2019/09/basic-structures-for-deep-learning-models/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习的三个步骤"><a href="#深度学习的三个步骤" class="headerlink" title="深度学习的三个步骤"></a>深度学习的三个步骤</h1><ol><li>构造一个<strong>神经网络</strong> (neural network)<ul><li>神经网络是由很多个简单的函数 (function) 组成的函数集合 (function set)，这些简单的函数就是<strong>神经元</strong> (neuron)。</li><li>通常我们需要自己决定使用什么样的神经网络，并且让机器能够从数据中获取参数。</li></ul></li><li>定义一个<strong>损失函数</strong> (cost function)<ul><li>损失函数根据训练数据来判断性能较好的函数和参数</li><li>基于问题来定义损失函数</li></ul></li><li>找到最好的函数</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github搭建个人博客</title>
      <link href="/2019/08/hexo-github-blog/"/>
      <url>/2019/08/hexo-github-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="博客初始搭建"><a href="#博客初始搭建" class="headerlink" title="博客初始搭建"></a>博客初始搭建</h1><h1 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h1><h2 id="博客图标制作"><a href="#博客图标制作" class="headerlink" title="博客图标制作"></a>博客图标制作</h2><ul><li><a href="https://realfavicongenerator.net/" target="_blank" rel="noopener">博客图标制作</a></li></ul><h1 id="博客功能添加"><a href="#博客功能添加" class="headerlink" title="博客功能添加"></a>博客功能添加</h1><h2 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h2><ul><li><p>安装 <code>hexo-blog-encrypt</code> 插件</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-blog-encrypt --save</span><br></pre></td></tr></table></figure></li><li><p>在<code>站点配置文件</code> 中启用该插件</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line">encrypt: <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  enable: true</span><br><span class="line">  default_abstract: 这是一篇加密文章，内容可能涉及项目隐私、个人情感宣泄或者收费技术。如果你确实想看，请与我联系。</span><br><span class="line">  default_message: 输入密码，查看文章。</span><br></pre></td></tr></table></figure></li><li><p>在文章头部添加对应字段</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">title: 文章加密</span><br><span class="line">date: <span class="number">2019</span><span class="number">-09</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span></span><br><span class="line">id: article-security</span><br><span class="line">categories: 文章加密</span><br><span class="line">tags:</span><br><span class="line">keywords:</span><br><span class="line">mathjax:</span><br><span class="line">password: <span class="comment"># 该博客加密使用的密码</span></span><br><span class="line">abstract: <span class="comment"># 该博客的摘要，会显示在博客的列表页</span></span><br><span class="line">message: <span class="comment"># 这个是博客查看时，密码输入框上面的描述性文字</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="hexo报错解决办法"><a href="#hexo报错解决办法" class="headerlink" title="hexo报错解决办法"></a>hexo报错解决办法</h1><h2 id="fs-SyncWriteStream-is-deprecated"><a href="#fs-SyncWriteStream-is-deprecated" class="headerlink" title="fs.SyncWriteStream is deprecated"></a>fs.SyncWriteStream is deprecated</h2><ul><li>报错内容：<ul><li><code>[DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</code></li></ul></li><li>解决办法：<ul><li>注释掉 <code>./node_modules/hexo-admin/node_modules/hexo-fs/lib</code> 目录下 <code>fs.js</code> 文件的第 <code>718</code> 行内容.</li></ul></li></ul><h2 id="primordials-is-not-defined"><a href="#primordials-is-not-defined" class="headerlink" title="primordials is not defined"></a>primordials is not defined</h2><ul><li><p>报错内容：</p><ul><li><code>const { Math, Object } = primordials; ReferenceError: primordials is not defined</code></li></ul></li><li>解决办法：<ul><li><a href="https://www.sitepoint.com/how-to-migrate-to-gulp-4/" target="_blank" rel="noopener">如何迁移到Gulp.js 4.0</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo-blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（10）红黑树</title>
      <link href="/2019/08/red-black-tree/"/>
      <url>/2019/08/red-black-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Balanced-search-tree-平衡搜索树"><a href="#Balanced-search-tree-平衡搜索树" class="headerlink" title="Balanced search tree (平衡搜索树)"></a>Balanced search tree (平衡搜索树)</h1><ul><li>A search-tree data structure maintaining dynamic set of n elements using tree of height O(lgn).</li><li>Examples:<ul><li>AVL trees (AVL树)</li><li>2-3 trees</li><li>2-3-4 trees</li><li>B-trees (B树)</li><li>Red-black trees (红黑树)</li><li>Skip lists (跳跃表)</li><li>Treaps (treap树)</li></ul></li></ul><h1 id="Red-black-tree-红黑树"><a href="#Red-black-tree-红黑树" class="headerlink" title="Red-black tree (红黑树)"></a>Red-black tree (红黑树)</h1><ul><li>内容参考<ul><li><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a></li></ul></li></ul><h2 id="Red-black-properties-红黑性质"><a href="#Red-black-properties-红黑性质" class="headerlink" title="Red-black properties (红黑性质)"></a>Red-black properties (红黑性质)</h2><ul><li>Red-black tree is a BST data structure with <strong>extra color field</strong> for each node, satisfying <code>red-black properties</code>:<ol><li>Every node is either red or black.</li><li>The root is black.</li><li>Every leaf (NIL) is black.</li><li>Every red node has two black children. (红色节点的孩子和父亲都不能是红色, 不能有两个连续的红色结点)</li><li>Every simple path from a node x to a descendant leaf contains the same number of black nodes [= <strong>black-height(x)</strong> (不包含出发结点)].</li></ol></li><li><img src="/2019/08/red-black-tree/red-black-properties.png" alt></li></ul><h2 id="Height-of-a-red-black-tree"><a href="#Height-of-a-red-black-tree" class="headerlink" title="Height of a red-black tree"></a>Height of a red-black tree</h2><ul><li>Theorem<ul><li>A red-black tree with $n$ keys has height $h ≤ 2 \lg (n+1)$.</li></ul></li><li>Intuition<ul><li>Merge red nodes into their black parents.<ul><li><img src="/2019/08/red-black-tree/height-of-red-black-tree.png" alt></li></ul></li><li>This process produces a <code>2-3-4 tree</code>.<ul><li>Every internal node has 2, 3, or 4 children.</li><li>Every leaf has the same depth namely black-height(root).</li></ul></li><li>The number of leaves in each tree is $n+1$.<ul><li>⇒ $2^{h’} ≤ n+1$</li><li>⇒ $h’ ≤ \lg (n+1)$</li></ul></li><li>At most 1/2 of nodes on any root to leaf path are red.<ul><li>⇒ $h ≤ 2h’$</li><li>⇒ $h ≤ 2 \lg (n+1)$</li></ul></li></ul></li><li>Corollary<ul><li>Red-black trees ensure that no such path from the root to a leaf is more than twice as long as any other, so that the tree is approximately balanced. (最长路径不超过最短路径的 2 倍，达到近似平衡的状态)</li><li>The queries (查询操作) <code>SEARCH</code>, <code>MINIMUM</code>, <code>MAXIMUM</code>, <code>SUCCESSOR</code> and <code>PREDECESSOR</code> all run in O(lgn) time on a red-black tree with n nodes.</li></ul></li></ul><h1 id="Modifying-operations-修改操作"><a href="#Modifying-operations-修改操作" class="headerlink" title="Modifying operations (修改操作)"></a>Modifying operations (修改操作)</h1><ul><li>The operations <code>INSERT</code> and <code>DELETE</code> cause modifications to the red-black tree.</li><li>How to restore red-black properties:<ul><li>BST operation</li><li>Color changes (变色)</li><li>Restructuring the links of the tree via <code>rotations</code> (旋转)<ul><li>Left rotations (左旋)</li><li>Right rotations (右旋)</li></ul></li></ul></li></ul><h2 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h2><ul><li><img src="/2019/08/red-black-tree/rotations.png" alt></li><li>Rotations preserves the inorder ordering of keys.<ul><li>$a ∈ α, b ∈ β, c ∈ γ \quad\Rightarrow\quad a ≤ A ≤ b ≤ B ≤ c$</li></ul></li><li>A rotation can be performed in $O(1)$ time.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Left-Rotate(T, x)</span><br><span class="line">    y = x.right</span><br><span class="line">    x.right = y.left</span><br><span class="line">    <span class="keyword">if</span> y.left != T.nil</span><br><span class="line">        y.left.parent = x</span><br><span class="line">    y.parent = x.parent</span><br><span class="line">    <span class="keyword">if</span> x.parent == T.nil</span><br><span class="line">        T.root = y</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">        x.parent.left = y</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x.parent.right = y</span><br><span class="line">    y.left = x</span><br><span class="line">    x.parent = y</span><br></pre></td></tr></table></figure><h1 id="Insertion-into-a-red-black-tree"><a href="#Insertion-into-a-red-black-tree" class="headerlink" title="Insertion into a red-black tree"></a>Insertion into a red-black tree</h1><ul><li>IDEA<ul><li>Insert x in tree. (BST serach, 查找插入的位置)</li><li>Color x red. (插入红色结点，在父结点(如果存在)为黑色时不会破坏黑平衡，但如果插入结点是黑色，插入位置所在的子树黑色结点总是多 1，必须做自平衡)</li><li>Only red-black property 4 might be violated.</li><li>Move the violation up the tree by recoloring until it can be fixed with rotations and recoloring.</li></ul></li><li>Example<ul><li><img src="/2019/08/red-black-tree/rb-insertion-1.png" alt></li><li>Insert x = 15.</li><li><img src="/2019/08/red-black-tree/rb-insertion-2.png" alt></li><li>Recolor, moving the violation up the tree.</li><li><img src="/2019/08/red-black-tree/rb-insertion-3.png" alt></li><li>Right-Rotate(18).</li><li><img src="/2019/08/red-black-tree/rb-insertion-4.png" alt></li><li>Left-Rotate(7) and recolor.</li><li><img src="/2019/08/red-black-tree/rb-insertion-5.png" alt></li></ul></li></ul><h2 id="Insertion-cases"><a href="#Insertion-cases" class="headerlink" title="Insertion cases"></a>Insertion cases</h2><ul><li><img src="/2019/08/red-black-tree/rb-insertion-cases.png" alt></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RB_Insert(T, z)</span><br><span class="line">    y = T.nil</span><br><span class="line">    x = T.root</span><br><span class="line">    <span class="keyword">while</span> x != T.nil</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right</span><br><span class="line">    z.parent = y</span><br><span class="line">    <span class="keyword">if</span> y == T.nil</span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y.right = z</span><br><span class="line">    z.left = T.nil</span><br><span class="line">    z.right = T.nil</span><br><span class="line">    z.color = RED  //新插入结点标记为红色</span><br><span class="line">    RB_Insert_Fixup(T, z)  //进行调整，使得满足红黑树性质</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB_Insert_Fixup(T, z)</span><br><span class="line">    <span class="keyword">while</span> z.parent.color == RED</span><br><span class="line">        <span class="keyword">if</span> z.parent == z.parent.parent.left</span><br><span class="line">            y = z.parent.parent.right</span><br><span class="line">            <span class="keyword">if</span> y.color == RED                 // Case <span class="number">4.1</span></span><br><span class="line">                z.parent.color = BLACK</span><br><span class="line">                y.color = BLACK</span><br><span class="line">                z.parent.parent.color = RED</span><br><span class="line">                z = z.parent.parent</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> z == z.parent.right   // Case <span class="number">4.2</span><span class="number">.2</span></span><br><span class="line">                    z = z.parent</span><br><span class="line">                    Left-Rotate(T, z)</span><br><span class="line">                z.parent.color = BLACK        // Case <span class="number">4.2</span><span class="number">.1</span></span><br><span class="line">                z.parent.parent.color = RED</span><br><span class="line">                Right-Rotate(T, z.parent.parent)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    T.root.color = BLACK</span><br></pre></td></tr></table></figure><ul><li><strong>Case 4.1</strong>: the uncle of z is red<ul><li><img src="/2019/08/red-black-tree/rb-insertion-case4.1.png" alt></li><li>Push C’s black onto A and D, and recurs, since C’s parent may be red.</li></ul></li><li><strong>Case 4.2.2</strong>: the uncle of z is black and z is a right child<ul><li><img src="/2019/08/red-black-tree/rb-insertion-case4.2.2.png" alt></li><li>Transform to Case 4.2.1.</li></ul></li><li><strong>Case 4.2.1</strong>: the uncle of z is black and z is a left child<ul><li><img src="/2019/08/red-black-tree/rb-insertion-case4.2.1.png" alt></li></ul></li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><ul><li>Insert the node<ul><li>takes $O(\lg n)$ time.</li></ul></li><li>RB_Insert_Fixup<ul><li>Going up the tree performing Case 4.1 for the <code>while</code>, which only recolors nodes, takes $O(\lg n)$ time.</li><li>If Case 4.2.1 or Case 4.2.2 occurs, perform 1 or 2 rotations, and terminate the processing, taking $O(1)$ time.</li></ul></li><li><strong>RB_Insert Running time</strong><ul><li>$O(\lg n)$ with $O(1)$ rotations.</li></ul></li></ul><h1 id="Delete-a-red-black-tree-node"><a href="#Delete-a-red-black-tree-node" class="headerlink" title="Delete a red-black tree node"></a>Delete a red-black tree node</h1><ul><li>IDEA：<ul><li>Perform standard BST delete. <ol><li>Delete a leaf node: <ul><li>Reset its parent link to NIL.</li></ul></li><li>Delete a degree-1 node: <ul><li>Replace the node by its single child.</li></ul></li><li>Delete a degree-2 node: <ul><li>Replace the node by the largest one in its left subtree or the smallest one in its right subtree (choose the successor).</li><li>Delete the replacing node from the subtree.</li></ul></li></ol><ul><li>The <strong>replacing node</strong>, which is formally deleted, is leaf node or degree-1 node. </li><li>The final replacing node is must leaf node.</li></ul></li><li>Red-black properties 2, 4, 5 might be violated.<ol><li>If the deleted node is red, red-black properties is still satisfied.</li><li>If the deleted node id black, red-black property 5 must be violated.<ul><li>If the deleted black node is root and the replacing node is red, red-property 2 is violated.</li><li>If the deleted black node’s parent and non-empty child both are red, red-black property 4 is violated.</li></ul></li></ol></li><li>Like insertion, recoloring and rotations are used to maintain the red-black properties. <ul><li>In insert operation, we check color of <code>uncle</code> to decide the appropriate case, which maintains the <code>color</code> (bottom-up). </li><li>In delete operation, we check color of <code>sibling</code> (兄弟) to decide the appropriate case, which maintains the <code>black height</code> (top-down). </li></ul></li></ul></li></ul><h2 id="Deletion-cases"><a href="#Deletion-cases" class="headerlink" title="Deletion cases"></a>Deletion cases</h2><ul><li><img src="/2019/08/red-black-tree/rb-deletion-cases.png" alt></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RE-TRANSPLANT(T, u, v)</span><br><span class="line">    <span class="keyword">if</span> u.p == T.nil</span><br><span class="line">        T.root = v</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">        u.p.left = v</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u.p.right = v</span><br><span class="line">    v.p = u.p// v.p的赋值无条件执行，因为u是root时v.p是T.nil该赋值依然成立</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z)</span><br><span class="line">    y=z</span><br><span class="line">    y-original-color = y.color</span><br><span class="line">    <span class="keyword">if</span> z.left == T.nil</span><br><span class="line">        x = z.right</span><br><span class="line">        RB-TRANSPLANT(T, z, z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil</span><br><span class="line">        x = z.left</span><br><span class="line">        RB-TRANSPLANT(T, z, z.left)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = TREE-MINIMUM(z.right)</span><br><span class="line">        x = y.right</span><br><span class="line">        <span class="keyword">if</span> y.p == z</span><br><span class="line">            x.p = y</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            RB-TRANSPLANT(T, y, y.right)</span><br><span class="line">            y.right.p = y</span><br><span class="line">        RB-TRANSPLANT(T, z, y)</span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.p = y</span><br><span class="line">        y.color = z.color</span><br><span class="line">    <span class="keyword">if</span> y-original-color == BLACK</span><br><span class="line">        RE-DELETE-FIXUP(T, x)// 若y原本是黑色则移走y后原本包含y路径的黑高会改变导致破坏红黑树性质</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x)</span><br><span class="line">    <span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK</span><br><span class="line">        <span class="keyword">if</span> x == x.p.left</span><br><span class="line">            w = x.p.right</span><br><span class="line">            <span class="keyword">if</span> w.color == RED</span><br><span class="line">                w.color = BLACK             // case <span class="number">2.1</span><span class="number">.1</span></span><br><span class="line">                x.p.color = RED</span><br><span class="line">                LEFT-ROTATE(T, x, p)</span><br><span class="line">                w = x.p.right</span><br><span class="line">            <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK</span><br><span class="line">                w.color = RED               // case <span class="number">2.1</span><span class="number">.2</span><span class="number">.3</span></span><br><span class="line">                x = x.p</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK</span><br><span class="line">                    w.left.color = BLACK        // case <span class="number">2.1</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">                    w.color = RED</span><br><span class="line">                    RIGHT-ROTATE(T, w)</span><br><span class="line">                    w = x.p.right</span><br><span class="line">                w.color = x.p.color             // case <span class="number">2.1</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">                x.p.color = BLACK</span><br><span class="line">                w.right.color = BLACK</span><br><span class="line">                LEFT-ROTATE(T, x, p)</span><br><span class="line">                x = T.root</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    x.color = BLACK// case <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>Case 2.1.1: the sibling of replacing node is red<ul><li><img src="/2019/08/red-black-tree/rb-deletion-case-2.1.1.png" alt></li><li>Transform to case 2.1.2.3.</li></ul></li><li>Case 2.1.2.3: the sibling is black and its child both are black<ul><li><img src="/2019/08/red-black-tree/rb-deletion-case-2.1.2.3.png" alt></li></ul></li><li>Case 2.1.2.2: the sibling is black, its left child is red and its right child is black<ul><li><img src="/2019/08/red-black-tree/rb-deletion-case-2.1.2.2.png" alt></li></ul></li><li>Case 2.1.2.1: the sibling is black and its right child is red<ul><li><img src="/2019/08/red-black-tree/rb-deletion-case-2.1.2.1.png" alt></li></ul></li></ul><h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><ul><li>delete the node<ul><li>takes $O(\lg n)$ time.</li></ul></li><li>RB_Delete_Fixup<ul><li>Going up the tree performing Case 2.1.2.3 for the <code>while</code> takes $O(\lg n)$ time.</li><li>Constant times recoloring and at most 3 times rotations takes $O(1)$ time.</li></ul></li><li><strong>RB_Delete Running time</strong><ul><li>Always $O(\lg n)$.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 平衡搜索树 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（9）二叉搜索树</title>
      <link href="/2019/08/binary-search-tree/"/>
      <url>/2019/08/binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-binary-search-tree-BST"><a href="#What-is-binary-search-tree-BST" class="headerlink" title="What is binary search tree (BST)?"></a>What is binary search tree (BST)?</h1><ul><li>Properties:<ul><li>Each node x in the binary tree has a key key(x).</li><li>Nodes other than the root have a parent p(x).</li><li>Nodes may have a left child left(x) and/or a right child right(x). These are pointers unlike in a heap.</li><li>The invariant is: For any node x, for all nodes y in the left subtree of x, key(y) ≤ key(x). For all nodes y in the right subtree of x, key(y) ≥ key(x).</li></ul></li><li>BST can output the key in particular order recursively.<ul><li>Inorder tree walk (中序遍历)</li><li>Preorder tree walk (先序遍历)</li><li>Postorder tree walk (后序遍历)</li><li>Traversing a binary tree with n nodes takes  Θ(n) time.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Inorder-Tree-Walk(x)</span><br><span class="line">    <span class="keyword">if</span> x != NIL</span><br><span class="line">        Inorder-tree-walk(x.left)</span><br><span class="line">        <span class="keyword">print</span> x.key</span><br><span class="line">        Inorder-tree-walk(x.right)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="BST-operations"><a href="#BST-operations" class="headerlink" title="BST operations"></a>BST operations</h1><h2 id="Insertion-into-BST"><a href="#Insertion-into-BST" class="headerlink" title="Insertion into BST"></a>Insertion into BST</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Tree-Insert(T, val)</span><br><span class="line">    y = NIL</span><br><span class="line">    x = T.root</span><br><span class="line">    <span class="keyword">while</span> x != NIL</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> val.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right</span><br><span class="line">    val.parent = y</span><br><span class="line">    <span class="keyword">if</span> y == NIL</span><br><span class="line">        T.root = val</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> val.key &lt; y.key</span><br><span class="line">        y.left = val</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y.right = val</span><br></pre></td></tr></table></figure><ul><li><img src="/2019/08/binary-search-tree/insertion.png" alt></li></ul><h2 id="Query-BST"><a href="#Query-BST" class="headerlink" title="Query BST"></a>Query BST</h2><h3 id="Finding-a-value-in-the-BST-if-it-exist"><a href="#Finding-a-value-in-the-BST-if-it-exist" class="headerlink" title="Finding a value in the BST if it exist"></a>Finding a value in the BST if it exist</h3><ul><li>Follow left and right pointers until you find it or hit NIL.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tree-Search(x, k) <span class="comment"># recursion</span></span><br><span class="line">    <span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">        <span class="keyword">return</span> Tree-Search(x.left, k)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Tree-Search(x.right, k)</span><br><span class="line">    </span><br><span class="line">Iterative-Tree-Search(x, k) <span class="comment"># iterative</span></span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> k != x.key</span><br><span class="line">        <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="Finding-the-minimum-maximum-element"><a href="#Finding-the-minimum-maximum-element" class="headerlink" title="Finding the minimum/maximum element"></a>Finding the minimum/maximum element</h3><ul><li>Go left/right till leaf.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tree-Minimum()</span><br><span class="line">    <span class="keyword">while</span> x.left != NIL</span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">Tree-Maximum()</span><br><span class="line">    <span class="keyword">while</span> x.right != NIL</span><br><span class="line">        x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="Finding-the-predecessor-前驱-and-successor-后继"><a href="#Finding-the-predecessor-前驱-and-successor-后继" class="headerlink" title="Finding the predecessor (前驱) and successor (后继)"></a>Finding the predecessor (前驱) and successor (后继)</h3><ul><li>If the right subtree of node x is nonempty, then the successor of x is just the left-most node in the right subtree.</li><li>if the right subtree of node x is empty and x has a successor y, then y is the lowest ancestor of x whose left child is also an ancestor of x.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Successor(x)</span><br><span class="line">    <span class="keyword">if</span> x.right != NIL</span><br><span class="line">        <span class="keyword">return</span> Tree-Minimum(x.right)</span><br><span class="line">    y = x.parent</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.right</span><br><span class="line">        x = y</span><br><span class="line">        y = y.parent</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><ul><li>If the left subtree of node x is nonempty, then the predecessor of x is just the right-most node in the left subtree.</li><li>if the left subtree of node x is empty and x has a predecessor y, then y is the lowest ancestor of x whose right child is also an ancestor of x.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tree-Predecessor(x)</span><br><span class="line">    <span class="keyword">if</span> x.left != NIL</span><br><span class="line">        <span class="keyword">return</span> Tree-Maximum(x.left)</span><br><span class="line">    y = x.parent</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.left</span><br><span class="line">        x = y</span><br><span class="line">        y = y.parent</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="Delete-one-element"><a href="#Delete-one-element" class="headerlink" title="Delete one element"></a>Delete one element</h2><ul><li>If node z has no children, simply modify the field of its parent with NIL.</li><li>If node z has only a single child, delete z by making a new link between its child and its parent.</li><li>If node z has two children, find z’s successor y to replace z.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Transplant(T, u, v)</span><br><span class="line">    <span class="keyword">if</span> u.parent == NIL</span><br><span class="line">        T.root = v</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> u == u.parent.left</span><br><span class="line">        u.parent.left = v</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u.parent.right = v</span><br><span class="line">    <span class="keyword">if</span> v != NIL</span><br><span class="line">        v.parent = u.parent</span><br><span class="line"></span><br><span class="line">Tree-Delete(T, z)</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL</span><br><span class="line">        Transplant(T, z, z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == NIL</span><br><span class="line">        Transplant(T, z, z.left)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = Tree-Minimum(z.right)</span><br><span class="line">        <span class="keyword">if</span> y.parent != z</span><br><span class="line">            Transplant(T, y, y.right)</span><br><span class="line">            y.right = z.right</span><br><span class="line">            y.right.parent = y</span><br><span class="line">        Transplant(T, z, y)</span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.parent = y</span><br></pre></td></tr></table></figure><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><ul><li>All operations on dynamic sets are O(h)​ where h is height of the BST.</li></ul><h1 id="BST-sort"><a href="#BST-sort" class="headerlink" title="BST sort"></a>BST sort</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Binary-search-tree Sort(T)</span><br><span class="line">    T ← ∅        //Create an empty BST</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        do Tree-Insert(T, A[i])</span><br><span class="line">    Perform an inorder tree walk of T.</span><br></pre></td></tr></table></figure><ul><li><img src="/2019/08/binary-search-tree/BST-sort.png" alt></li><li>BST sort performs the same comparisons as quicksort, but in a different order!</li><li>The expected time to build the tree is asymptotically the same as the running time of quicksort.</li><li>Randomized BST sort<ol><li>Randomly permute the array A.</li><li>BST sort(A).</li></ol></li><li>E[running time(randomized BST sort)]<br>  = E[running time(randomized quicksort)]<br>  = Θ(nlgn)</li></ul><h2 id="Node-depth-节点深度"><a href="#Node-depth-节点深度" class="headerlink" title="Node depth (节点深度)"></a>Node depth (节点深度)</h2><ul><li>The depth of a node = the number of comparisons made during Tree-Insert.</li><li>Running time of BST sort = the sum of all node depths.</li><li>E[average node depth]<br>  = E[(1/n)sum(all node depths)]<br>  = (1/n)E[running time of BST sort]<br>  = Θ(nlgn)/n<br>  = Θ(lgn)</li></ul><h2 id="Expected-tree-height-树的期望高度"><a href="#Expected-tree-height-树的期望高度" class="headerlink" title="Expected tree height (树的期望高度)"></a>Expected tree height (树的期望高度)</h2><ul><li>Average node depth of a randomly built BST = O(lg n) <strong>does not necessarily mean</strong> that its expected height is also O(lgn).</li><li>although it is, proof below.</li><li><img src="/2019/08/binary-search-tree/expected-tree-height.png" alt></li></ul><h1 id="Randomly-build-BST"><a href="#Randomly-build-BST" class="headerlink" title="Randomly build BST"></a>Randomly build BST</h1><ul><li>Define a <strong>randomly built binary search tree</strong> on n distinct keys as one that arises from inserting the keys in random order into an initially empty tree.<ul><li>Each of the n! permutations of the input keys is equally likely.</li><li>Randomly built BST = tree resulting from randomized BST sort. (BST排序的结果树)</li></ul></li><li><strong>Theorem</strong><ul><li>The expected height of a randomly built binary tree on n keys is O(lgn).</li></ul></li></ul><h2 id="Outline-of-the-analysis"><a href="#Outline-of-the-analysis" class="headerlink" title="Outline of the analysis"></a>Outline of the analysis</h2><ul><li>Firstly, prove <code>Jensen&#39;s inequality</code>, which says that $f(E[X]) ≤ E[f(X)]$ for any convex function (下凸函数) $f$ and random variable $X$.</li><li>Secondly, analyze <code>the exponential height</code> of a randomly built BST on n nodes, which is the random variable $Y_n = 2^{X_n}$, where $X_n$ is the random variable denoting the height of the BST.</li><li>Thirdly, prove that $E[Y_n] = O(n^3)$.</li><li>At last, conclude that $2^{E[X_n]} ≤ E[2^{X_n}] = E[Y_n] = O(n^3)$, and hence that $E[X_n] = O(\lg n)$.</li></ul><h2 id="Jensen’s-inequality"><a href="#Jensen’s-inequality" class="headerlink" title="Jensen’s inequality"></a>Jensen’s inequality</h2><ul><li>Lemma<ul><li>Let $f$ be a convex function, and let $X$ be a random variable. Then, $f(E[X]) ≤ E[f(X)]$.</li></ul></li><li>Proof<ul><li>$\begin{equation}\begin{split}<br>  f(E[X]) &amp; = f \left( \sum_{k=-\infty}^\infty k \cdot Pr \{ X=k \} \right) \\<br>  &amp; \leq \sum_{k=-\infty}^\infty f(k) \cdot Pr \{ X=k \} \\<br>  &amp; = E(f(X))<br>  \end{split}\end{equation}$</li></ul></li></ul><h2 id="Analysis-of-BST-height"><a href="#Analysis-of-BST-height" class="headerlink" title="Analysis of BST height"></a>Analysis of BST height</h2><ul><li>Let $X_n$ be the random variable denoting the height of a randomly built BST on n nodes.</li><li>Let $Y_n = 2^{X_n}$ be its exponential height.</li><li>If the root of the tree has rank $k$, then $X_n = 1 + \max \{ X_{k-1}, X_{n-k} \}$, since each of the left and right subtrees of the root are randomly built. Hence, we have $Y_n = 2 \cdot \max \{ Y_{k-1}, Y_{n-k} \}$.</li><li>Define the indicator random variable $Z_{nk} = I \{ \text{root has the rank k} \}$, thus, $Pr \{ Z_{nk}=1 \} = E[Z_{nk}] = 1/n$.</li><li>$\begin{equation}\begin{split}<br>  E[Y_n] &amp; = E[\sum_{k=1}^n Z_{nk} (2 \cdot \max \{ Y_{k-1}, Y_{n-k} \})] \\<br>  &amp; = \sum_{k=1}^n E[Z_{nk} (2 \cdot \max \{ Y_{k-1}, Y_{n-k} \})] \\<br>  &amp; = 2 \sum_{k=1}^n E[Z_{nk}] \cdot E[\max \{ Y_{k-1}, Y_{n-k} \}] \\<br>  &amp; \leq {2 \over n} \sum_{k=1}^n E[Y_{k-1} + Y_{n-k}] \\<br>  &amp; = {4 \over n} \sum_{k=0}^{n-1} E[Y_k]<br>  \end{split}\end{equation}$</li><li>Use substitution to show that $E[Y_n] ≤ cn^3$ for some positive constant $c$, which we can pick sufficiently large to handle the initial conditions (base case).</li><li>$\begin{equation}\begin{split}<br>  E[Y_n] &amp; = {4 \over n} \sum_{k=0}^{n-1} E[Y_k] \\<br>  &amp; \leq {4 \over n} \sum_{k=0}^{n-1} ck^3 \\<br>  &amp; \leq {4c \over n} \int_0^n x^3 dx \\<br>  &amp; = {4c \over n} \cdot {n^4 \over 4} \\<br>  &amp; = cn^3<br>  \end{split}\end{equation}$</li><li>Putting it all together, we have $2^{E[X_n]} ≤ E[2^{X_n}] = E[Y_n] ≤ cn^3$.</li><li>Taking the $\lg$ of both sides yields, $E[X_n] ≤ 3 \lg n + c = 3 \lg n + O(1)$.</li></ul><h2 id="Some-words-at-last"><a href="#Some-words-at-last" class="headerlink" title="Some words at last"></a>Some words at last</h2><ul><li>Why bother with analyzing exponential height? Why not just develop the recurrence on $X_n = 1 + \max \{ X_{k-1}, X_{n-k} \}$ directly?<ul><li>The inequality $\max \{ a, b \} ≤ a + b$ provides a poor upper bound, since the RHS approaches the LHS slowly as |a – b| increases.</li><li>The bound $\max \{ 2^a, 2^b \} ≤ 2^a + 2^b$ allows the RHS to approach the LHS far more quickly as |a – b| increases.</li><li>By using the convexity of $f(x) = 2^x$ via Jensen’s inequality, we can manipulate the sum of exponential, resulting in a tight analysis.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 二叉搜索树排序 </tag>
            
            <tag> 随机构建二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（8）散列表</title>
      <link href="/2019/08/hash-table/"/>
      <url>/2019/08/hash-table/</url>
      
        <content type="html"><![CDATA[<h1 id="Symbol-table-problem-符号表问题"><a href="#Symbol-table-problem-符号表问题" class="headerlink" title="Symbol-table problem (符号表问题)"></a>Symbol-table problem (符号表问题)</h1><ul><li>Table S holding n records</li><li><img src="/2019/08/hash-table/symbol-table-problem.png" alt></li><li>Operations on S:<ul><li><code>INSERT(S, x)</code>: S ← S ∪ {x}</li><li><code>DELETE(S, x)</code>: S ← S - {x}</li><li><code>SEARCH(S, k)</code>: return x such that key[x] = k, or return nil (无)  if no such x.</li></ul></li></ul><h1 id="Direct-access-table-直接寻址表"><a href="#Direct-access-table-直接寻址表" class="headerlink" title="Direct-access table (直接寻址表)"></a>Direct-access table (直接寻址表)</h1><ul><li>Suppose that keys are drawn from universe (全域) <code>U = {0, 1, 2, ... , m-1}</code>.</li><li>Assume that keys are distinct.</li><li>Set up an array <code>T[0..m-1]</code> to represent the dynamic set <code>S</code></li><li>$T(k) = \begin{cases}<br>  x &amp; \text{if $x \in S$ and $key[x] = k$} \\<br>  \text{NIL} &amp; \text{otherwise}<br>  \end{cases}$</li><li>Operations takes $\Theta(1)$ time.</li><li>Problem: The range of keys can be large.<ul><li>64-bit numbers (which represent 18,446,744,073,709,551,616 different keys)</li><li>character strings (even larger!)</li></ul></li></ul><h1 id="Hash-table-散列表-哈希表"><a href="#Hash-table-散列表-哈希表" class="headerlink" title="Hash table (散列表/哈希表)"></a>Hash table (散列表/哈希表)</h1><ul><li>Use a <strong>hash function</strong> (哈希函数) <code>h</code> to map keys “randomly” into slots (槽) of table T.</li><li><img src="/2019/08/hash-table/hash-function-example.jpg" alt></li><li>When a record to be inserted maps to an already occupied slot in T, a <strong>collision</strong> (冲突) occurs.</li></ul><h2 id="Resolving-collisions-by-chaining-通过链接法解决冲突"><a href="#Resolving-collisions-by-chaining-通过链接法解决冲突" class="headerlink" title="Resolving collisions by chaining (通过链接法解决冲突)"></a>Resolving collisions by chaining (通过链接法解决冲突)</h2><ul><li>IDEA: link records in same slot into a list.</li><li><img src="/2019/08/hash-table/chaining.png" alt></li></ul><h2 id="Analysis-of-chaining"><a href="#Analysis-of-chaining" class="headerlink" title="Analysis of chaining"></a>Analysis of chaining</h2><ul><li>Worst-case<ul><li>Every key hashes to same slot. </li><li>Access takes $\Theta(n)$ time if $|S|  = n$.</li></ul></li><li>Average-case<ul><li>Assumption of simple <strong>uniform hashing</strong> (简单均匀哈希). </li><li>Each key $k \in S$ is equally likely to be hashed to any slot of table T, independent of where other keys are hashed.</li><li>Define the <strong>load factor</strong> (装载因子) of a hash table with $n$ keys and $m$ slots is $\alpha = n/m$ = average numbers of keys per slot.</li><li>Expected unsuccessful search time = $\Theta(1 + \alpha)$.</li><li><img src="/2019/08/hash-table/chaining-unsuccessful-search.png" alt></li><li>Actually, expected successful search time = $\Theta(1 + \alpha)$.</li><li><img src="/2019/08/hash-table/chaining-successful-search.png" alt></li><li>Expected search time = $\Theta(1)$ if $\alpha = O(1)$, or equivalently, if $n = O(m)$.</li></ul></li></ul><h1 id="Choosing-a-hash-function"><a href="#Choosing-a-hash-function" class="headerlink" title="Choosing a hash function"></a>Choosing a hash function</h1><ul><li>The assumption of simple uniform hashing is hard to guarantee, but several common techniques tend to work well in practice as long as their deficiencies can be avoided.</li><li>A good hash function should distribute the keys uniformly into the slots of the table.</li><li>Regularity in the key distribution should not affect this uniformity.</li></ul><h2 id="Division-method-除法散列法"><a href="#Division-method-除法散列法" class="headerlink" title="Division method (除法散列法)"></a>Division method (除法散列法)</h2><ul><li>$h(k) = k \mod m$</li><li><strong>Don’t pick m with small divisor d.</strong> A preponderance of keys that are congruent modulo d (同余模 d) can adversely affect uniformity.</li><li>If $m = 2^r$, then the hash doesn’t depend on all the bits of $k$.</li><li><img src="/2019/08/hash-table/division-method.png" alt></li><li>Pick m to be a prime (质数) but not too close to a power of 2 or 10.</li><li>But it is inconvenient to find a prime number, and division is slow.</li></ul><h2 id="Multiplication-method-乘法散列法"><a href="#Multiplication-method-乘法散列法" class="headerlink" title="Multiplication method (乘法散列法)"></a>Multiplication method (乘法散列法)</h2><ul><li>Assume that all keys are integers, $m = 2^r$, and our computer has <strong>w-bit words</strong>.</li><li>$h(k) = [(A \cdot k) \mod 2^w] &gt;&gt; (w − r)$</li><li>$A$ is odd (奇数), $2^{w-1} &lt; a &lt; 2^w$, $A$ is not too close to $2^{w-1}$ or $2^w$.</li><li><img src="/2019/08/hash-table/multiplication-method-1.png" alt></li><li><img src="/2019/08/hash-table/multiplication-method-2.png" alt></li><li>Multiplication and bit extraction are faster than division.</li></ul><h1 id="Resolving-collisions-by-open-addressing-开放寻址法"><a href="#Resolving-collisions-by-open-addressing-开放寻址法" class="headerlink" title="Resolving collisions by open addressing (开放寻址法)"></a>Resolving collisions by open addressing (开放寻址法)</h1><ul><li>No storage for links. (没有链表) </li><li>Probe table systematically until an empty slot is found.</li><li>The hash function depends on both the key (关键字) and probe number (探查号) .</li><li>$h: U \times \{0, 1, \cdots, m-1 \}  \rightarrow \{ 0, 1, \cdots, m-1 \}$</li><li>The probe sequence $\langle h(k,0), h(k,1), \cdots, h(k,m-1) \rangle$ should be a permutation of $\{ 0, 1, \cdots, m-1 \}$.</li><li>The table may fill up (溢出) , and deletion is difficult (but not impossible).</li><li><img src="/2019/08/hash-table/open-addressing.jpg" alt></li><li>Search uses the same probe sequence.<ul><li>Terminating successfully if it finds the key.</li><li>Terminating unsuccessfully if it encounters an empty slot.</li></ul></li></ul><h2 id="Probing-strategies"><a href="#Probing-strategies" class="headerlink" title="Probing strategies"></a>Probing strategies</h2><ul><li><strong>Linear probing 线性探查)</strong><ul><li>$h(k, i) = [h’(k) + i] \mod m$</li><li>This method, though simple, suffers from <strong>primary clustering (一次群集)</strong>, where long runs of filled slots build up, increasing the average search time.</li></ul></li><li><strong>Quadratic probing (二次探查)</strong><ul><li>$h(k, i) = [h’(k) + c_1 i + c_2 i^2] \mod m$</li><li>This method suffers from <strong>secondary clustering</strong> (二次群集，初始探测位置相同的关键字的探查序列也是相同的).</li></ul></li><li><strong>Double hashing (双重散列)</strong><ul><li>$h(k, i) = [h_1(k) + i \cdot h_2(k)] \mod m$</li><li>This method generally produces excellent results, but $h_2(k)$ must be relatively prime to $m$.</li><li>One way is to make  $m = 2^r$ and design $h_2(k)$ to produce only odd numbers (奇数).</li><li>The other way is to make $m$ prime number and design $h_2(k)$ to produce integers smaller than $m$.</li></ul></li></ul><h2 id="Analysis-of-open-addressing"><a href="#Analysis-of-open-addressing" class="headerlink" title="Analysis of open addressing"></a>Analysis of open addressing</h2><ul><li>Make the assumption of uniform hashing<ul><li>Each key is equally likely to have any one of the m! permutations as its probe sequence, independent of other keys.</li></ul></li><li><strong>Theorem</strong><ul><li>Given an open-addressed hash table with load factor $\alpha = n/m &lt; 1$, the expected number of probes in an unsuccessful search is at most $1/(1–\alpha)$.</li></ul></li><li>Proof<ul><li>At least one probe is always necessary.</li><li>With probability $n/m$, collision makes a second probe.</li><li>With probability $(n-1)/(m-1)$, collision makes a third probe.</li><li>Observe that $(n-i)/(m-i) &lt; n/m = \alpha$ for $i = 1, 2, \cdots, n-1$.</li><li>Therefore, the expected number of probes is</li><li>$\begin{equation}\begin{split}<br>  E[\text{probe number}] &amp; = 1 + {n \over m} \left( 1 + {n-1 \over m-1} \left( 1 + {n-2 \over m-2} \left( \cdots \left( 1 + {1 \over m-n+1} \right) \cdots \right) \right) \right) \\<br>  &amp; \leq 1 + \alpha \left( 1 + \alpha \left( 1 + \alpha \left( \cdots \left( 1 + \alpha \right) \cdots \right) \right) \right) \\<br>  &amp; = 1 + \alpha + \alpha^2 + \alpha^3 + \cdots \\<br>  &amp; = \sum_{i=0}^\infty \alpha^i \\<br>  &amp; = {1 \over 1-\alpha}<br>  \end{split}\end{equation}$</li></ul></li><li><strong>Implication of the theorem</strong><ul><li>If $\alpha$ is constant, accessing an open-addressed hash table takes $O(1)$ time.</li></ul></li></ul><h1 id="Universal-hashing-全域哈希"><a href="#Universal-hashing-全域哈希" class="headerlink" title="Universal hashing (全域哈希)"></a>Universal hashing (全域哈希)</h1><ul><li><strong>Definition</strong><ul><li>Let $U$ be a universe of keys, and let $\mathcal{H}$ be a finite collection (有限集) of hash functions mapping $U$ to $\{0, 1, \cdots, m-1\}$. We say $\mathcal{H}$ is universal if for all $x, y \in U$, where $x \not= y$, we have $|\{h: h \in \mathcal{H}, h(x) = h(y)\}| \leq |\mathcal{H}|/m$. That is, if $h$ is chosen randomly from $\mathcal{H}$, the probability of collision between x and y is no more than $1/m$.</li></ul></li><li>Universality id good.<ul><li><strong>Theorem</strong><ul><li>Choose hash function h randomly from universal set $\mathcal{H}$. Suppose hashing n keys into m slots in table T. Then, for a given key x, $E[\text{collision with x}] &lt; n/m$.</li></ul></li><li><strong>Proof</strong><ul><li>Let $C_x$ be the random variable denoting the total number of collisions of keys in T with x, and let $c_{xy} = I \{ h(x)=h(y) \}$.</li><li>$\begin{equation}\begin{split}<br>  E[C_x] &amp; = E[\sum_{y \in T - \{ x \}} c_{xy}] \\<br>  &amp; = \sum_{y \in T - \{ x \}} E[c_{xy}] \\<br>  &amp; \leq \sum_{y \in T - \{ x \}} {1 \over m} \\<br>  &amp; = {n-1 \over m}<br>  \end{split}\end{equation}$</li></ul></li></ul></li></ul><h2 id="Constructing-a-set-of-universal-hash-functions"><a href="#Constructing-a-set-of-universal-hash-functions" class="headerlink" title="Constructing a set of universal hash functions"></a>Constructing a set of universal hash functions</h2><ul><li>Let $m$ be prime. Decompose key $k$ into $r+1$ digits: $k = \langle k_0, k_1, \cdots, k_r \rangle$, where $0 \leq k_i \leq m-1$.</li><li>Randomized strategy<ul><li>Pick $a = \langle a_0, a_1, \cdots, a_r \rangle$, each $a_i$ is chosen randomly from $\{ 0, 1, \cdots, m-1 \}$.</li><li>Define $h_a(k) = \sum_{i=0}^r a_i k_i \mod m, \quad |\mathcal{H}| = m^{r+1}$</li><li>Theorem: $\mathcal{H}$ is universal.</li></ul></li><li>Proof<ul><li>Suppose that $x = \langle x_0, x_1, \cdots, x_r \rangle$ and $y = \langle y_0, y_1, \cdots, y_r \rangle$ are distinct keys. Thus, they differ in at least one digit, without loss of generality position 0.（不失一般性，选择第0位不同）For how many $h_a \in H$ do x and y collide?</li><li>We must have $h_a(x) = h_a(y)$</li><li>$\Longrightarrow \quad \sum_{i=0}^r a_i x_i \equiv \sum_{i=0}^r a_i y_i \quad (\text{mod $m$})$</li><li>$\Longrightarrow \quad a_0(x_0 - y_0) + \sum_{i=1}^r a_i(x_i - y_i) \equiv 0 \quad (\text{mod $m$})$</li><li>$\Longrightarrow \quad a_0(x_0 - y_0) \equiv -\sum_{i=1}^r a_i(x_i - y_i) \quad (\text{mod $m$})$</li><li>since $x_0 \not= y_0$, an inverse $(x_0 - y_0)^{-1}$ must exist</li><li>$\Longrightarrow \quad a_0 \equiv [ - \sum_{i=1}^r a_i (x_i - y_i) ] (x_0 - y_0)^{-1} \quad (\text{mod $m$})$</li><li>Thus, for any choice of $a_1, a_2, \cdots, a_r$, exactly one choice of $a_0$ cause x and y to collide, and no collision for other $m-1$ choice for $a_0$.</li><li>Thus, the number of $h_a$’s that cause x and y to collide is $m^r = |\mathcal{H}|/m$.</li></ul></li></ul><h2 id="Construct-another-set-of-universal-hash-functions"><a href="#Construct-another-set-of-universal-hash-functions" class="headerlink" title="Construct another set of universal hash functions"></a>Construct another set of universal hash functions</h2><ul><li><img src="/2019/08/hash-table/universal-hashing-1.png" alt></li><li><img src="/2019/08/hash-table/universal-hashing-2.png" alt></li></ul><h1 id="Perfect-hashing-完全哈希"><a href="#Perfect-hashing-完全哈希" class="headerlink" title="Perfect hashing (完全哈希)"></a>Perfect hashing (完全哈希)</h1><ul><li>Problem<ul><li>Given n keys, construct a static hash table of size $m = O(n)$, such that search takes $O(1)$ time in the worst case.</li></ul></li><li>IDEA<ul><li>Use <strong>2-level scheme</strong> (双级结构) with universal hashing at both levels.</li></ul></li><li>No collisions at level-2 (secondary hash table, 二次散列表).</li><li><img src="/2019/08/hash-table/perfect-hashing.png" alt></li><li>If $n_i$ items hash to a level-1 slot i, then use $m_i = n_i^2$ slots in level-2 hash table $S_i$.</li></ul><h2 id="Level-2-analysis"><a href="#Level-2-analysis" class="headerlink" title="Level-2 analysis"></a>Level-2 analysis</h2><ul><li><strong>Theorem</strong><ul><li>Hash n keys into $m = n^2$ slots using random $h$ in universal $\mathcal{H}$, the expected number of collisions is less than 1/2​.</li></ul></li><li><strong>Proof</strong> <ul><li>By the definition of universality, the probability that 2 given keys in the table collide under h is $1/m = 1/n^2$.</li><li>Since there are $\mathrm{C}_n^2$ pairs of keys that can possibly collide, the expected number of collisions is $\mathrm{C}_2^n \cdot {1 \over n^2} = {n(n-1) \over 2} \cdot {1 \over n^2} &lt; {1 \over 2}$.</li></ul></li><li><strong>Corollary</strong><ul><li>The probabilty of no collision ia at least 1/2.</li></ul></li><li><strong>Proof</strong><ul><li>Markov’s inequality (马尔可夫不等式)<ul><li>For any non-negative random variable $X$, we have $Pr \{ X \geq t \} \leq E(X) /t$.</li><li>$Pr \{ \text{collision} \geq 1 \} \leq E[\text{collision}]/1 &lt; 1/2$</li></ul></li></ul></li><li>Thus, to find a good level-2 hash function, just test a few at random. We will quickly find one that works since at least 1/2 will work.</li></ul><h2 id="Analysis-of-storage"><a href="#Analysis-of-storage" class="headerlink" title="Analysis of storage"></a>Analysis of storage</h2><ul><li>For the level-1 hash table T, choose $m = n$, and let $n_i$ be random variable for the number of keys that hash to slot $i$ in T. Use $m_i = n_i^2$ slots for the level-2 hash table $S_i$.</li><li>$\begin{equation}\begin{split}<br>  E[\text{total storage}] &amp; = n + E[\sum_{i=0}^{m-1} n_i^2] \\<br>  &amp; = n + E[\sum_{i=0}^{m-1} (n_i + 2 \mathrm{C}_{n_i}^2)] \\<br>  &amp; = n + E[\sum_{i=0}^{m-1} n_i] + 2 E[\sum_{i=0}^{m-1} \mathrm{C}_{n_i}^2] \quad\text{和式正是散列表中发生冲突的关键字的总对数} \\<br>  &amp; \leq 2n + 2 \mathrm{C}_n^2 {1 \over m} \\<br>  &amp; = 2n + 2 {n(n-1) \over 2m} \\<br>  &amp; = 3n-1 \\<br>  &amp; = \Theta(n)<br>  \end{split}\end{equation}$</li><li>The analysis is identical to the analysis from recitation of the expected running time of bucket sort.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 直接寻址表 </tag>
            
            <tag> 散列表 </tag>
            
            <tag> 链接法 </tag>
            
            <tag> 散列函数 </tag>
            
            <tag> 除法散列法 </tag>
            
            <tag> 乘法散列法 </tag>
            
            <tag> 全域散列法 </tag>
            
            <tag> 开放寻址法 </tag>
            
            <tag> 完全散列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（7）动态集合与基本数据结构</title>
      <link href="/2019/08/dynamic-set-and-elementary-data-structure/"/>
      <url>/2019/08/dynamic-set-and-elementary-data-structure/</url>
      
        <content type="html"><![CDATA[<h1 id="Dynamic-Sets-动态集合"><a href="#Dynamic-Sets-动态集合" class="headerlink" title="Dynamic Sets (动态集合)"></a>Dynamic Sets (动态集合)</h1><ul><li>Dynamic sets are data structures that support some or all the following operations: </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Operation</th><th style="text-align:center">Effect</th></tr></thead><tbody><tr><td style="text-align:center">Search(S, k)</td><td style="text-align:center">return x with x.key = k</td></tr><tr><td style="text-align:center">Insert(S, x)</td><td style="text-align:center">insert x into S</td></tr><tr><td style="text-align:center">Delete(S, x)</td><td style="text-align:center">delete x from S</td></tr><tr><td style="text-align:center">Minimum(S)</td><td style="text-align:center">return y with the smallest key</td></tr><tr><td style="text-align:center">Maximum(S)</td><td style="text-align:center">return y with the largest key</td></tr><tr><td style="text-align:center">Successor(S, x)</td><td style="text-align:center">return y with the next key lager than x.key</td></tr><tr><td style="text-align:center">Predecessor(S, x)</td><td style="text-align:center">return y with the next key smaller than x.key</td></tr></tbody></table></div><blockquote><p>S is a set, x and y are elements, k is a key<br>NIL is returned if operations can’t be performed</p></blockquote><h1 id="Elementary-Data-Structures-基本数据结构"><a href="#Elementary-Data-Structures-基本数据结构" class="headerlink" title="Elementary Data Structures (基本数据结构)"></a>Elementary Data Structures (基本数据结构)</h1><h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack (栈)"></a>Stack (栈)</h2><ul><li>LIFO (Last-In-First-Out)</li><li>Operations:<ul><li><code>Push</code> (压栈)</li><li><code>Pop</code> (出栈)</li></ul></li><li>Array implementation S[1..S.top]<ul><li>1 → the bottom of Stack</li><li><code>S.top</code> → the top of Stack</li><li>if <code>S.top == 0</code>, Stack is <code>empty</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stack-Empty(S)</span><br><span class="line">    <span class="keyword">if</span> S.top == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> true</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> false</span><br><span class="line"></span><br><span class="line">Push(S, x)</span><br><span class="line">    S.top = S.top + <span class="number">1</span></span><br><span class="line">    S[S.top] = x</span><br><span class="line"></span><br><span class="line">Pop(S)</span><br><span class="line">    <span class="keyword">if</span> Stack-Empty(S)</span><br><span class="line">        error <span class="string">"underflow"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        S.top = S.top - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> S[S.top + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue (队列)"></a>Queue (队列)</h2><ul><li>FIFO (First-In-First-Out)</li><li>Operations:<ul><li><code>Enqueue</code> (入队)</li><li><code>Dequeue</code> (出队)</li></ul></li><li>Array implementation  Q[1..n]<ul><li><code>Q.head</code> → the head element of Queue</li><li><code>Q.tail</code> → the tail element of Queue</li><li>If <code>Q.head == Q.tail</code>, Queue is <code>empty</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Enqueue(Q, x)</span><br><span class="line">    Q[Q.tail] = x</span><br><span class="line">    <span class="keyword">if</span> Q.tail == Q.length</span><br><span class="line">        Q.tail = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q.tail = Q.tail + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Dequeue(Q)</span><br><span class="line">    x = Q[Q.head]</span><br><span class="line">    <span class="keyword">if</span> Q.head == Q.length</span><br><span class="line">        Q.head = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q.head = Q.head + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List (链表)"></a>Linked List (链表)</h2><ul><li>A linked list is a data structure in which the objects are arranged in a linear order.</li><li>Unlike an array, though, in which the linear order is determined by the array indices (数组下标), the order in a linked list is determined by a pointer in each object.</li><li>Doubly linked list (双向链表)<ul><li>Each element is an object with a <code>key</code> field and two other pointer fields: <code>next</code> and <code>prev</code>.</li><li><img src="/2019/08/dynamic-set-and-elementary-data-structure/doubly-linked-list.png" alt></li><li>If <code>x.prev == NIL</code>, the element x has no predecessor (前驱) and is therefore the first element, or <code>head</code></li><li>If <code>x.next == NIL</code>, the element <em>x</em> has no successor (后继) and is therefore the last element, or <code>tail</code></li><li>If <code>L.head == NIL</code>, the list is empty</li></ul></li><li>Singly linked list (单向链表)<ul><li>omit (省略) the <code>prev</code> pointer in each element</li></ul></li><li>Circular linked list (循环链表)<ul><li>The prev pointer of the head of the list points to the tail</li><li>The next pointer of the tail of the list points to the head</li><li><img src="/2019/08/dynamic-set-and-elementary-data-structure/circular-linked-list.png" alt></li></ul></li></ul><h3 id="Searching-a-linked-list"><a href="#Searching-a-linked-list" class="headerlink" title="Searching a linked list"></a>Searching a linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List-Search(L, k) <span class="comment"># worst case: Θ(n)</span></span><br><span class="line">    x = L.head</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> x.key != k</span><br><span class="line">        x = x.next</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="Inserting-into-a-linked-list"><a href="#Inserting-into-a-linked-list" class="headerlink" title="Inserting into a linked list"></a>Inserting into a linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List-Insert(L, x, i) <span class="comment"># average: Θ(n)</span></span><br><span class="line">    p = L.head</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span></span><br><span class="line">        L.head = x</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span></span><br><span class="line">        p = p.next</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    x.next = p</span><br><span class="line">    <span class="keyword">if</span> p.prev != NIL</span><br><span class="line">        p.prev.next = x</span><br><span class="line">    x.prev = p.prev</span><br><span class="line">    p.prev = x</span><br></pre></td></tr></table></figure><h3 id="Deleting-from-a-linked-list"><a href="#Deleting-from-a-linked-list" class="headerlink" title="Deleting from a linked list"></a>Deleting from a linked list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List-Delete(L, k) <span class="comment"># worst case: Θ(n)</span></span><br><span class="line">    x = List-Search(L, k)</span><br><span class="line">    <span class="keyword">if</span> x.prev != NIL</span><br><span class="line">        x.prev.next = x.next</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L.head = x.next</span><br><span class="line">    <span class="keyword">if</span> x.next != NIL</span><br><span class="line">        x.next.prev = x.prev</span><br></pre></td></tr></table></figure><h3 id="Sentinel-哨兵"><a href="#Sentinel-哨兵" class="headerlink" title="Sentinel (哨兵)"></a>Sentinel (哨兵)</h3><ul><li>A sentinel is a dummy object (哑对象) that allows us to simplify boundary conditions (简化边界).</li><li>Object <code>L.nil</code> represents <code>NIL</code> but has all the fields of the other list elements.<ul><li>Wherever we have a reference to <code>NIL</code> in list code, we replace it by a reference to the sentinel <code>L.nil</code>, this turns a regular doubly linked list into a circular list<ul><li><code>L.nil</code> placed between the head and tail<ul><li>L.nil.next → L.head</li><li>L.nil.prev → L.tail</li></ul></li><li><code>L.tail.next</code> and <code>L.head.prev</code> point to <code>L.nil</code><ul><li>L.head.prev → L.nil</li><li>L.tail.next → L.nil</li></ul></li></ul></li><li><img src="/2019/08/dynamic-set-and-elementary-data-structure/sentinel.png" alt></li></ul></li></ul><h2 id="Rooted-Trees-有根树"><a href="#Rooted-Trees-有根树" class="headerlink" title="Rooted Trees (有根树)"></a>Rooted Trees (有根树)</h2><h3 id="Binary-trees-二叉树"><a href="#Binary-trees-二叉树" class="headerlink" title="Binary trees (二叉树)"></a>Binary trees (二叉树)</h3><ul><li>Use the fields <code>p</code>, <code>left</code>, and <code>right</code> to store pointers to the parent, left child, and right child of each node in a binary tree</li><li><img src="/2019/08/dynamic-set-and-elementary-data-structure/binary-tree.png" alt></li><li>If <code>x.p == NIL</code>, x is the root</li><li>If <code>x.left == NIL</code>, x has no left child</li><li>If <code>T.root == NIL</code>, T is empty</li></ul><h3 id="Rooted-trees-with-unbounded-branching-分支无限制的有根树"><a href="#Rooted-trees-with-unbounded-branching-分支无限制的有根树" class="headerlink" title="Rooted trees with unbounded branching (分支无限制的有根树)"></a>Rooted trees with unbounded branching (分支无限制的有根树)</h3><ul><li>The scheme for representing a binary tree can be extended to any class of trees in which the number of children of each node is at most some constant $k$. <ul><li>We replace the $left$ and $right$ fields by $child_1, child_2, \cdots, child_k$.</li><li>This scheme no longer works when the number of children of a node is unbounded.<ul><li>Don’t know how many fields to allocate in advance.</li><li>Even if the number of children k is bounded by a large constant but most nodes have a small number of children, we may waste a lot of memory.</li></ul></li></ul></li><li><strong>left-child, right-sibling representation (左孩子右兄弟表示法)</strong><ul><li>Using only $O(n)$ space for any n-node rooted tree</li><li>Node x<ul><li>parent pointer <code>x.p</code> and <code>T.root</code> points to the root of tree</li><li><code>x.left-child</code> points to the leftmost child of node x<ul><li>If node x has no children, x.left-child = NIL</li></ul></li><li><code>x.right-sibling</code> points to the sibling of x immediately to the right<ul><li>If node x is the rightmost child of its parent, x.right-sibling = NIL</li></ul></li></ul></li><li><img src="/2019/08/dynamic-set-and-elementary-data-structure/left-child-right-sibling-representation.png" alt></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 动态集合 </tag>
            
            <tag> 基本数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 有根树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（6）中位数与顺序统计量</title>
      <link href="/2019/08/median-and-order-statistics/"/>
      <url>/2019/08/median-and-order-statistics/</url>
      
        <content type="html"><![CDATA[<h1 id="Selection-选择问题"><a href="#Selection-选择问题" class="headerlink" title="Selection (选择问题)"></a>Selection (选择问题)</h1><ul><li>Given $n$ elements in array, find the $k^{th}$ smallest element (the element with rank $k$)<ul><li>Naive algorithm<ul><li>Sort and index $k^{th}$ element.</li><li>Worst-case running time $= \Theta(n \lg n) + \Theta(1) = \Theta(n \lg n)$, using merge sort or heap sort (not quick sort).</li></ul></li><li>k = 1: <strong>minimum</strong></li><li>k = n: <strong>maximum</strong></li><li>k = (n+1)/2: <strong>median</strong></li></ul></li></ul><h1 id="Randomized-selection-algorithm-随机选择算法"><a href="#Randomized-selection-algorithm-随机选择算法" class="headerlink" title="Randomized selection algorithm (随机选择算法)"></a>Randomized selection algorithm (随机选择算法)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Randomized-Select(A, p, q, i)</span><br><span class="line">    <span class="keyword">if</span> p == q</span><br><span class="line">        <span class="keyword">return</span> A[p]</span><br><span class="line">    r = Randomized-Partition(A, p, q)</span><br><span class="line">    k = r - p + <span class="number">1</span>   //k = rank(A[r])</span><br><span class="line">    <span class="keyword">if</span> i == k</span><br><span class="line">        <span class="keyword">return</span> A[r]</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> i &lt; k</span><br><span class="line">        <span class="keyword">return</span> Randomized-Select(A, p, r<span class="number">-1</span>, i)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Randomized-Select(A, r+<span class="number">1</span>, q, i-k)</span><br></pre></td></tr></table></figure><p><img src="/2019/08/median-and-order-statistics/随机选择算法.png" alt></p><h2 id="Intuition-for-analysis"><a href="#Intuition-for-analysis" class="headerlink" title="Intuition for analysis"></a>Intuition for analysis</h2><ul><li>All our analyses assume that all elements are distinct.</li><li>Lucky: $T(n) = T(9n/10) + \Theta(n) = \Theta(n)$</li><li>Unlucky: $T(n) = T(n-1) + \Theta(n) = \Theta(n^2)$</li></ul><h2 id="Analysis-of-expected-time"><a href="#Analysis-of-expected-time" class="headerlink" title="Analysis of expected time"></a>Analysis of expected time</h2><ul><li>The analysis follows that of randomized quick-sort, but it’s a little different.</li><li>Let $T(n) =$  the random variable for the running time of Randomized-Select on an input of size n, assuming random numbers are independent.</li><li>For $k = 0, 1, \cdots, n–1$, define the indicator random variable</li><li>$X_k = \begin{cases}<br>  1 &amp; \text{if partition generates a $k : n-k-1$ split} \\<br>  0 &amp; \text{otherwise}<br>  \end{cases}$</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; \leq \begin{cases} T(\max \{ 0, n-1 \}) + \Theta(n) &amp; \text{if $0 : n-1$ split} \\<br>  T(\max \{ 1, n-2 \}) + \Theta(n) &amp; \text{if $1 : n-2$ split}\\<br>  \cdots \\<br>  T(\max \{ n-1, 0 \}) + \Theta(n) &amp; \text{if $n-1 : 0$ split}\end{cases} \\<br>  &amp; = \sum_{k=0}^{n-1} X_k(T(\max \{ k, n-k-1 \}) + \Theta(n))<br>  \end{split}\end{equation}$</li><li>$\begin{equation}\begin{split} E(T(n)) &amp; \leq E\left[ \sum_{k=0}^{n-1} X_k (T(\max \{ k, n-k-1 \}) + \Theta(n)) \right] \\<br>  &amp; = \sum_{k=0}^{n-1} E[X_k(T(\max \{ k, n-k-1 \}) + \Theta(n))] \\<br>  &amp; = \sum_{k=0}^{n-1} E[X_k] \cdot E[(T(\max \{ k, n-k-1 \}) + \Theta(n))] \\<br>  &amp; = {1 \over n} \sum_{k=0}^{n-1} E[(T(\max \{ k, n-k-1 \})] + {1 \over n} \sum_{k=0}^{n-1} \Theta(n) \\<br>  &amp; \leq {2 \over n} \sum_{k = \lfloor n/2 \rfloor}^{n-1} E[T(k)] + \Theta(n)<br>  \end{split}\end{equation}$</li><li>Use substitution method to get $E(T(n)) = O(n)$</li><li>$\begin{equation}\begin{split}<br>  E(T(n)) &amp; \leq {2 \over n} \sum_{k = \lfloor n/2 \rfloor}^{n-1} E[T(k)] + \Theta(n) \\<br>  &amp; \leq {2 \over n} \sum_{k = \lfloor n/2 \rfloor}^{n-1} ck + \Theta(n) \\<br>  &amp; \leq {2c \over n} \left( {3 \over 8} n^2 \right) + \Theta(n)\\<br>  &amp; = cn - \left( {cn \over 4} - \Theta(n) \right) \\<br>  &amp; \leq cn<br>  \end{split}\end{equation}$</li><li>$\text{if $c$ is chosen large enough so that $cn/4$ dominates the $\Theta(n)$}$</li></ul><h2 id="Summary-of-randomized-order-statistic-selection"><a href="#Summary-of-randomized-order-statistic-selection" class="headerlink" title="Summary of randomized order statistic selection"></a>Summary of randomized order statistic selection</h2><ul><li>Works fast: linear expected time.</li><li>Excellent algorithm in practice.</li><li>But, the worst case is very bad: $\Theta(n^2)$.</li></ul><h1 id="Worst-case-linear-time-order-statistics-selection-最坏情况为线性时间的选择算法"><a href="#Worst-case-linear-time-order-statistics-selection-最坏情况为线性时间的选择算法" class="headerlink" title="Worst-case linear-time order statistics selection (最坏情况为线性时间的选择算法)"></a>Worst-case linear-time order statistics selection (最坏情况为线性时间的选择算法)</h1><ul><li>IDEA: generate good pivot recursively.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT(i, n)</span><br><span class="line">    <span class="number">1.</span> Divide the n elements into groups of <span class="number">5.</span> Find the median of each <span class="number">5</span>-element group by rote.</span><br><span class="line">    // Θ(n)</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span> Recursively SELECT the median x of the n/<span class="number">5</span> group medians to be the pivot.</span><br><span class="line">    // T(n/<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span> Partition around the pivot x. Let k = rank(x).</span><br><span class="line">    // Θ(n)</span><br><span class="line"></span><br><span class="line">    <span class="number">4.</span> <span class="keyword">if</span> i = k</span><br><span class="line">            then <span class="keyword">return</span> x</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> i &lt; k</span><br><span class="line">            then recursively SELECT the i-th smallest element <span class="keyword">in</span> the lower part</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            recursively SELECT the (i–k)th smallest element <span class="keyword">in</span> the upper part</span><br></pre></td></tr></table></figure><p><img src="/2019/08/median-and-order-statistics/最坏情况为线性时间的选择算法.png" alt></p><ul><li>Minor simplification: For $n \geq 50$, we have $\lfloor 3n/10 \rfloor \geq n/4$.</li><li>Therefore, for $n \geq 50$ the recursive call to SELECT in Step 4 is executed recursively on $\leq 3n/4$ elements.</li><li>Thus, the recurrence for running time can assume that Step 4 takes time $T(3n/4)$ in the worst case.</li><li>For $n &lt; 50$, we know that the worst-case time is $T(n) = \Theta(1)$.</li><li>$T(n) \leq \begin{cases}<br>  O(1) &amp; n &lt; 50 \\<br>  T(n/5) + T(3n/4) + O(n) &amp; n \geq 50<br>  \end{cases}$</li><li>Use substitution to confirm $T(n) = O(n)$</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; \leq {1 \over 5} cn + {3 \over 4} cn + O(n) \\<br>  &amp; = cn - ({1 \over 20} cn - O(n)) \\<br>  &amp; \leq cn \quad \text{(if $c$ is chosen large enough to handle both $O(n)$ and initial conditions)}<br>  \end{split}\end{equation}$</li></ul><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul><li>Since the work at each level of recursion is a constant fraction (19/20) smaller, the work per level is a geometric series dominated by the linear work at the root.</li><li>In practice, this algorithm runs slowly, because the constant in front of n is large.</li><li>The randomized algorithm is far more practical.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 中位数 </tag>
            
            <tag> 顺序统计量 </tag>
            
            <tag> 选择问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（5）线性时间排序</title>
      <link href="/2019/08/linear-time-sorting/"/>
      <url>/2019/08/linear-time-sorting/</url>
      
        <content type="html"><![CDATA[<ul><li>How fast can we sort ? <ul><li>All the sorting algorithms we have seen so far are <strong>comparison sorts</strong> (比较排序): only use comparisons to determine the relative order of elements. <ul><li>E.x. insertion sort, merge sort, quick-sort, heap-sort. </li></ul></li><li>The best worst-case running time that we’ve seen for comparison sorting is O(nlgn). </li></ul></li><li>Is <code>O(nlgn)</code> the best we can do ? <ul><li><strong>Decision trees</strong> (决策树) can help us answer this question. </li></ul></li></ul><h1 id="Decision-tree-model-决策树模型"><a href="#Decision-tree-model-决策树模型" class="headerlink" title="Decision-tree model (决策树模型)"></a>Decision-tree model (决策树模型)</h1><h2 id="Sort-langle-a-1-a-2-a-3-rangle"><a href="#Sort-langle-a-1-a-2-a-3-rangle" class="headerlink" title="Sort $\langle a_1, a_2, a_3 \rangle$"></a>Sort $\langle a_1, a_2, a_3 \rangle$</h2><p><img src="/2019/08/linear-time-sorting/decision-tree-model.jpg" alt></p><h2 id="Sort-langle-a-1-a-2-cdots-a-n-rangle"><a href="#Sort-langle-a-1-a-2-cdots-a-n-rangle" class="headerlink" title="Sort $\langle a_1, a_2, \cdots, a_n \rangle$"></a>Sort $\langle a_1, a_2, \cdots, a_n \rangle$</h2><ul><li>Each internal node is labeled <code>i : j</code> for $i, j \in \{1, 2, \cdots, n\}$. <ul><li>The left sub-tree shows subsequent comparisons if $a_i \leq a_j$. </li><li>The right sub-tree shows subsequent comparisons if $a_i &gt; a_j$. </li></ul></li><li>Each leaf contains a permutation (排列) $\langle π(1), π(2), \cdots , π(n)\rangle$. <ul><li>Indicate that the ordering $a_{π(1)} \leq a_{π(2)} \leq \cdots \leq a_{π(n)}$ has been established.</li></ul></li></ul><h2 id="Execution-of-any-comparison-sort"><a href="#Execution-of-any-comparison-sort" class="headerlink" title="Execution of any comparison sort"></a>Execution of any comparison sort</h2><ul><li>Build one tree for each input size n. </li><li>View the algorithm as splitting into two forks (the left sub-tree and the right sub-tree) whenever it make a comparison. </li><li>The tree contains the comparisons along all possible instruction traces. </li><li>The running time of the algorithm = the length of the root to leaf path. <ul><li>Worst-case running time = height of tree. </li></ul></li></ul><h2 id="Lower-bound-on-decision-tree-sorting-comparison-sorting"><a href="#Lower-bound-on-decision-tree-sorting-comparison-sorting" class="headerlink" title="Lower bound on decision-tree sorting (comparison sorting)"></a><strong>Lower bound</strong> on decision-tree sorting (comparison sorting)</h2><ul><li>The tree must contain $\geq n!$ leaves, since there are n! possible permutations. A height-h binary tree has $\leq 2^h$ leaves. Thus, $n! \leq 2^h$. </li><li>$\begin{equation}\begin{split} \therefore h &amp; \geq \log_2 n! \\<br>  &amp; \geq \log_2 \left({n \over e}\right)^n \\<br>  &amp; = n \lg n - n \lg e \\<br>  &amp; = \Omega(n \lg n)<br>  \end{split}\end{equation}$</li><li>Theorem: Any decision tree that can sort n elements must have height Ω(nlgn). </li><li>Corollary: Heap-sort and merge sort are asymptotically optimal comparison sorting algorithms. Randomized quick-sort is also asymptotically optimal in expectation. </li></ul><h1 id="Counting-sort-计数排序"><a href="#Counting-sort-计数排序" class="headerlink" title="Counting sort (计数排序)"></a>Counting sort (计数排序)</h1><ul><li><strong>No comparisons</strong> between elements. </li><li>Input: A[1 . . n], where A[i]∈{0, 1, 2, …, k}. </li><li>Output: B[1 . . n], sorted. </li><li><p>Auxiliary storage (辅助存储器): C[0 . . k]. </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Counting-Sort(A, B, k)</span><br><span class="line">    let C[<span class="number">1.</span>.k] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k</span><br><span class="line">        C[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">        C[A[j]] = C[A[j]] + <span class="number">1</span></span><br><span class="line">    // C[i] = |&#123;key = i&#125;|</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k</span><br><span class="line">        C[i] = C[i] + C[i<span class="number">-1</span>]</span><br><span class="line">    // C[i] = |&#123;key &lt;= i&#125;|</span><br><span class="line">    <span class="keyword">for</span> j = n down to <span class="number">1</span></span><br><span class="line">        B[C[A[j]]] = A[j]</span><br><span class="line">        C[A[j]] = C[A[j] - <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><img src="/2019/08/linear-time-sorting/counting-sort-1.png" alt></li><li><img src="/2019/08/linear-time-sorting/counting-sort-2.png" alt></li></ul><ul><li>$T(n) = \Theta(n + k)$ <ul><li>If $k = O(n)$, then counting sort takes $\Theta(n)$ time. </li></ul></li><li>But, sorting takes $\Omega(n \lg n)$ time! Where’s the fallacy? <ul><li>Comparison sorting takes $\Omega(n \lg n)$ time. </li><li>Counting sort is not a comparison sort. </li><li>In fact, not a single comparison between elements occurs! </li></ul></li></ul><h1 id="Stable-sort-algorithm-稳定性排序算法"><a href="#Stable-sort-algorithm-稳定性排序算法" class="headerlink" title="Stable sort algorithm (稳定性排序算法)"></a>Stable sort algorithm (稳定性排序算法)</h1><ul><li>A stable sorting algorithm preserves the relative order of equal elements (具有相同值的元素的相对次序相同). </li><li>Counting sort is a stable sort. </li><li><img src="/2019/08/linear-time-sorting/stable-sort.png" alt></li><li>Insertion sort and merge sort are stable sorts. </li><li>Quick-sort and heap-sort are not stable sorts. </li></ul><h1 id="Radix-sort-基数排序"><a href="#Radix-sort-基数排序" class="headerlink" title="Radix sort (基数排序)"></a>Radix sort (基数排序)</h1><ul><li>Origin: Herman Hollerith’s card-sorting machine for the 1890 U.S. Census. </li><li><strong>Digit-by-digit sort (按位排序)</strong>. </li><li>Hollerith’s original (bad) idea: sort on most-significant digit first. </li><li>Good idea: Sort on <strong>least-significant digit first (最低有效位)</strong> with auxiliary stable sort. </li></ul><p><img src="/2019/08/linear-time-sorting/radix-sort.png" alt></p><h2 id="Correctness-of-radix-sort"><a href="#Correctness-of-radix-sort" class="headerlink" title="Correctness of radix sort"></a>Correctness of radix sort</h2><ul><li>induction on digit position that we are currently sorting. </li><li>Assume that the numbers are sorted by their low-order $t-1$ digit. </li><li>Sort on digit. <ul><li>If two elements have the same t-th digit <ul><li>Stability ⇒ put in the same order as the input </li><li>By induction hypothesis ⇒ keep in sorted order </li></ul></li><li>If two elements have different t-th digit <ul><li>Sorting ⇒ put them in the right (sorted) order </li></ul></li></ul></li></ul><h2 id="Analysis-of-radix-sort"><a href="#Analysis-of-radix-sort" class="headerlink" title="Analysis of radix sort"></a>Analysis of radix sort</h2><ul><li>Assume counting sort is the auxiliary stable sort. </li><li>Suppose we have $n$ integers of $b$ bits each. </li><li>Split each integer into $b/r$ digits of $r$ bits long (base $2^r$). </li><li>$T(n, b) = \Theta \left( {b \over r} (n + 2^r) \right)$ </li><li>Choose $r$ to minimize $T(n, b)$ <ul><li>Differentiate with respect to $r$ and set to 0. (对 r 求导，求导数等于 0 时的解) </li><li>Increasing r means fewer passes, but as $r &gt;&gt; \lg n$, the time grows exponentially. </li><li>Choosing $r = \lg n$ implies $T(n, b) = \Theta \left({b n \over \lg n}\right)$. </li><li>For numbers in the range from 0 to $n^d – 1$, we have $b = d \lg n$ ⇒ radix sort runs in $\Theta(dn)$ time. </li></ul></li></ul><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><ul><li>In practice, <strong>radix sort is fast for large inputs</strong>, as well as simple to code and maintain.</li><li>Example (32-bit numbers):<ul><li>At most 3 passes when sorting ≥ 2000 numbers.</li><li>Merge sort and quick-sort do at least lg 2000 = 11 passes. </li></ul></li><li>Downside: Unlike quick-sort, radix sort displays little locality of reference, and thus a well-tuned quick-sort fares better on modern processors, which feature steep memory hierarchies. (缺点：不像快速排序，基数排序不呈现时空局限性，所以快速排序在以过高的内存结构为特征的现代处理器中性能更好) </li></ul><h1 id="Bucket-sort-桶排序"><a href="#Bucket-sort-桶排序" class="headerlink" title="Bucket sort (桶排序)"></a>Bucket sort (桶排序)</h1><ul><li>Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. </li><li>It is a distribution sort (分配排序), a generalization of pigeonhole sort (鸽巢排序), and is a cousin of radix sort in the most-to-least significant digit flavor. </li><li>The computational complexity (计算复杂度) depends on the algorithm used to sort each bucket, the number of buckets to use, and whether the input is uniformly distributed (服从均匀分布，输入的元素均匀分布在区间 [0, 1) 上). </li><li><p>Bucket sort works as follows: </p><ol><li>Set up an array of initially empty “buckets”. </li><li>Scatter: Go over the original array, putting each object in its bucket. </li><li>Sort each non-empty bucket. </li><li><p>Gather: Visit the buckets in order and put all elements back into the original array. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Bucket-sort(A)</span><br><span class="line">    n = A.length</span><br><span class="line">    let B[<span class="number">0.</span>.n<span class="number">-1</span>] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n<span class="number">-1</span></span><br><span class="line">       make B[i] an empty list</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">       insert A[i] into list B[nA[i]]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n<span class="number">-1</span></span><br><span class="line">       sort list B[i]</span><br><span class="line">    concatenate the lists B[<span class="number">0</span>], B[<span class="number">1</span>], ... , B[n<span class="number">-1</span>] together <span class="keyword">in</span> order</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="Worst-case-analysis-of-bucket-sort"><a href="#Worst-case-analysis-of-bucket-sort" class="headerlink" title="Worst-case analysis of bucket-sort"></a>Worst-case analysis of bucket-sort</h2><ul><li>The worst-case scenario occurs when all the elements are placed in a single bucket. </li><li>The overall performance would then be dominated by the algorithm used to sort each bucket, which is typically $O(n^2)$ insertion sort, making bucket sort less optimal than $O(n \lg n)$ comparison sort algorithms like quick-sort. </li></ul><h2 id="Average-case-analysis-of-bucket-sort"><a href="#Average-case-analysis-of-bucket-sort" class="headerlink" title="Average-case analysis of bucket-sort"></a>Average-case analysis of bucket-sort</h2><ul><li>Consider the case that the input is uniformly distributed. </li><li>Assume insertion sort is used to sort each bucket, then the third step costs $O(\sum_{i=1}^k n_i^2)$, where $n_i$ is the length of the bucket indexed $i$. </li><li>Let  $X_{ij}$ be the random variable of element $j$ being placed in bucket $i$. We have $n_i = \sum_{j = 1}^n X_{ij}$. </li><li>$\begin{equation}\begin{split} E(n_i^2) &amp; = E(\sum_{j=1}^n X_{ij} \sum_{k=1}^n X_{ik}) \\<br>  &amp; = E(\sum_{j=1}^n \sum_{k=1}^n X_{ij} X_{ik}) \\<br>  &amp; = E(\sum_{j=1}^n X_{ij}^2) + E(\sum_{1 \leq j, k \leq n}^n \sum_{j \not= k}^n X_{ij} X_{ik}) \\<br>  \end{split}\end{equation}$</li><li>$E(X_{ij}^2) = 1^2 \cdot ({1 \over k}) + 0^2 \cdot (1 - {1 \over k}) = {1\over k}$</li><li>$E(X_{ij} X_{ik}) = 1 \cdot ({1 \over k})({1 \over k}) = {1 \over k^2}$</li><li>$\begin{equation}\begin{split} E(n_i^2) &amp; = E(\sum_{j=1}^n X_{ij}^2) + E(\sum_{1 \leq j, k \leq n}^n \sum_{j \not= k}^n X_{ij} X_{ik}) \\<br>  &amp; = n \cdot {1 \over k} + n(n-1) \cdot {1 \over k^2} \\<br>  &amp; = {n^2 + nk - n \over k^2} \\<br>  \end{split}\end{equation}$</li><li>$O(\sum_{i=1}^k E(n_i^2)) = O(\sum_{i=1}^k {n^2 + nk - n \over k^2}) = O({n^2 \over k} + n)$</li><li>If $k$ is chosen to be $k = \Theta(n)$, then bucket-sort runs in $O(n)$ average time.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 线性时间排序 </tag>
            
            <tag> 决策树 </tag>
            
            <tag> 计数排序 </tag>
            
            <tag> 基数排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（4）堆与堆排序</title>
      <link href="/2019/08/heap-and-heapsort/"/>
      <url>/2019/08/heap-and-heapsort/</url>
      
        <content type="html"><![CDATA[<h1 id="Priority-Queue-（优先队列）"><a href="#Priority-Queue-（优先队列）" class="headerlink" title="Priority Queue （优先队列）"></a>Priority Queue （优先队列）</h1><ul><li>A data structure that implements a set S of elements, each associated with a key, supporting the following operations:<ul><li><code>insert(S, x)</code>: insert element x into set S.</li><li><code>max(S)</code>: return element of S with largest key.</li><li><code>extract_max(S)</code>: return the element of S with largest key and remove it from S.</li><li><code>increase_key(S, x, k)</code>: increase the value of element x’s key to new value k.</li></ul></li></ul><h1 id="Heap（堆）"><a href="#Heap（堆）" class="headerlink" title="Heap（堆）"></a>Heap（堆）</h1><ul><li>Implementation of a priority queue</li><li>An array, visualized as a nearly complete binary tree（完全二叉树）</li><li><img src="/2019/08/heap-and-heapsort/array.png" alt></li><li><img src="/2019/08/heap-and-heapsort/heap.png" alt></li></ul><h2 id="Heap-as-a-tree"><a href="#Heap-as-a-tree" class="headerlink" title="Heap as a tree"></a>Heap as a tree</h2><ul><li><strong>root of the tree</strong>: first element in the array, corresponding to i = 1.</li><li><strong>parent(i) = i/2</strong>, return index of node’s parent.</li><li><strong>left(i) = 2i</strong>, return index of node’s left child.</li><li><strong>right(i) = 2i+1</strong>, return the index of node’s right child.</li></ul><h2 id="Max-Heap-Property（最大堆性质）"><a href="#Max-Heap-Property（最大堆性质）" class="headerlink" title="Max Heap Property（最大堆性质）"></a>Max Heap Property（最大堆性质）</h2><ul><li>The key of a node is <strong>no less than</strong> the keys of its children. </li><li>Min Heap defined analogously.</li></ul><h1 id="Heap-operations"><a href="#Heap-operations" class="headerlink" title="Heap operations"></a>Heap operations</h1><ul><li><code>max_heapify</code>:  correct a single violation of the heap property in a subtree’s root</li><li><code>build_max_heap</code>: produce a max-heap from an unordered array</li><li><code>insert</code></li><li><code>extract_max</code></li><li><code>heapsort</code></li></ul><h2 id="Max-Heapify"><a href="#Max-Heapify" class="headerlink" title="Max_Heapify"></a>Max_Heapify</h2><ul><li>Assume that the trees rooted at left(i) and right(i) are max-heaps.</li><li><p>If element A[i] violates the max-heap property, correct violation by “trickling”（滴下） element A[i] down the tree, making the subtree rooted at index i a max-heap.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Max_Heapify(A, i)</span><br><span class="line">    l = left(i)</span><br><span class="line">    r = right(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= heap_size(A) <span class="keyword">and</span> A[l] &gt; A[i]</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt;= heap_size(A) <span class="keyword">and</span> A[r] &gt; A[largest]</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i</span><br><span class="line">        exchange A[i] <span class="keyword">and</span> A[largest]</span><br><span class="line">        Max_Heapify(A, largest)</span><br></pre></td></tr></table></figure></li><li><p><img src="/2019/08/heap-and-heapsort/max-heapify-1.png" alt></p></li><li><img src="/2019/08/heap-and-heapsort/max-heapify-2.png" alt></li><li><img src="/2019/08/heap-and-heapsort/max-heapify-3.png" alt></li><li>For a size n tree, the size of its sub-tree is <strong>at most 2n/3</strong></li><li>$T(n) \leq T(2n/3) + \Theta(1)$</li><li>$T(n) = O(\lg n)$</li><li>In other words, the running time of max_heapify operation for a <code>height h</code> node is O(h).</li></ul><h2 id="Build-Max-Heap"><a href="#Build-Max-Heap" class="headerlink" title="Build_Max_Heap"></a>Build_Max_Heap</h2><ul><li><p>Convert A[1..n] to a max-heap.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Build_Max_Heap(A)</span><br><span class="line"><span class="keyword">for</span> i = n/<span class="number">2</span> down to <span class="number">1</span></span><br><span class="line">Max_Heapify(A, i)</span><br></pre></td></tr></table></figure></li><li><p>Why start at n/2 ?</p><ul><li>Because elements A[n/2+1 … n] are all leaves of the tree.</li></ul></li><li>T(n) = O(nlgn) via simple analysis.</li><li><img src="/2019/08/heap-and-heapsort/build-max-heap-1.png" alt></li><li><img src="/2019/08/heap-and-heapsort/build-max-heap-2.png" alt></li><li><img src="/2019/08/heap-and-heapsort/build-max-heap-3.png" alt></li></ul><h3 id="Build-Max-Heap-analysis"><a href="#Build-Max-Heap-analysis" class="headerlink" title="Build_Max_Heap analysis"></a>Build_Max_Heap analysis</h3><ul><li>Observe that Max_Heapify takes <strong>O(1)</strong> time for nodes that are one level above the leaves, and in general, <strong>O(L)</strong> time for the nodes that are <em>L</em> levels above the leaves.</li><li>We have n/4 nodes with level 1, n/8 with level 2, and so on till we have one root node that is <strong>lgn</strong> levels above the leaves.</li><li>Total amount of work in the for loop can be summed as:</li><li>$T(n) = {n \over 4} (1c) + {n \over 8} (2c) + {n \over 16} (3c) + \cdots + 1 (\lg n c)$</li><li>Setting ${n \over 4} = 2^k$ and simplifying we get:</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; = c 2^k \left( {1 \over 2^0} + {2 \over 2^1} + {3 \over 2^2} + \cdots + {k+1 \over 2^k} \right) \\<br>  &amp; = c 2^k \left( 4 - {k+3 \over 2^k} \right) \\<br>  &amp; = c (n - \log_2 n -1) \\<br>  &amp; = O(n)<br>  \end{split}\end{equation}$</li></ul><h1 id="Heap-sort（堆排序）"><a href="#Heap-sort（堆排序）" class="headerlink" title="Heap-sort（堆排序）"></a>Heap-sort（堆排序）</h1><ul><li><p>Sorting strategy</p><ol><li>Build Max Heap from unordered array</li><li>Find maximum element A[1]</li><li>Swap elements A[n] and A[1]: now max element is at the end of the array!</li><li>Discard node n from heap (by decrementing heap-size variable)</li><li>New root may violate max heap property, but its children are max heaps. Run max_heapify to fix this.</li><li>Go to Step 2 unless heap is empty.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Heapsort(A)</span><br><span class="line">    Build_Max_Heap(A, n)</span><br><span class="line">    <span class="keyword">for</span> i = n down to <span class="number">2</span></span><br><span class="line">        exchange A[<span class="number">1</span>] <span class="keyword">with</span> A[i]</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        Max_Heapify(A, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><p><img src="/2019/08/heap-and-heapsort/heapsort-1.png" alt></p></li><li><img src="/2019/08/heap-and-heapsort/heapsort-2.png" alt></li><li><img src="/2019/08/heap-and-heapsort/heapsort-3.png" alt></li><li><img src="/2019/08/heap-and-heapsort/heapsort-4.png" alt></li><li>Running time<ul><li>After n iterations（循环，重复）, the Heap is empty.</li><li>Every iteration involves a swap and a max_heapify operation, hence it takes O(lgn) time.</li><li>$T(n) = O(n \lg n)$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（3）快速排序与随机算法</title>
      <link href="/2019/08/quick-sort-and-randomized-algorithm/"/>
      <url>/2019/08/quick-sort-and-randomized-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h1><ul><li>Proposed by C.A.R. Hoare in 1962.</li><li>Divide-and-conquer algorithm.</li><li>Sorts “in place” (like insertion sort, but not like merge sort).</li><li>Very practical (with tuning).</li></ul><h2 id="Quick-sort-an-n-element-array"><a href="#Quick-sort-an-n-element-array" class="headerlink" title="Quick sort an n-element array"></a>Quick sort an n-element array</h2><ol><li>Divide: Partition (划分) the array into two sub-arrays around a <strong>pivot x</strong> such that <strong>elements in lower sub-array ≤ x ≤ elements in upper sub-array</strong>.</li><li>Conquer: Recursively sort the two sub-arrays.</li><li>Combine: Trivial.</li></ol><ul><li><p>Key: Linear-time partitioning subroutine.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Partition(A, p, q)</span><br><span class="line">    x = A[p]</span><br><span class="line">    i = p</span><br><span class="line">    <span class="keyword">for</span> j = p+<span class="number">1</span> to q</span><br><span class="line">        <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">    exchange A[p] <span class="keyword">with</span> A[i]</span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></li><li><p><img src="/2019/08/quick-sort-and-randomized-algorithm/快排划分示例.png" alt></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quicksort(A, p, q)</span><br><span class="line">    <span class="keyword">if</span> p &lt; q</span><br><span class="line">        r = Partition(A, p, q)</span><br><span class="line">        Quicksort(A, p, r<span class="number">-1</span>)</span><br><span class="line">        Quicksort(A, r+<span class="number">1</span>, q)</span><br></pre></td></tr></table></figure></li><li><p>Initial call: Quick-sort(A, 0, n-1).</p></li><li>One of the tricks to making quick-sort go fast is to look for a special purpose sorting routine for small numbers of elements. Beyond what kind of optimization is used, the core of it is this partitioning routine.</li></ul><h2 id="Analysis-of-quick-sort"><a href="#Analysis-of-quick-sort" class="headerlink" title="Analysis of quick-sort"></a><strong>Analysis of quick-sort</strong></h2><ul><li>Assume all input elements are distinct.</li><li><p>In practice, there are better partitioning algorithms when duplicate input elements may exist.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Hoare-Partition(A, p, q)</span><br><span class="line">    x = A[p]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    j = q + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> TRUE</span><br><span class="line">        repeat</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        until A[j] &lt;= x</span><br><span class="line">        repeat</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        until A[i] &gt;= x</span><br><span class="line">        <span class="keyword">if</span> i &lt; j</span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure></li></ul><h3 id="Worst-case-analysis"><a href="#Worst-case-analysis" class="headerlink" title="Worst-case analysis"></a>Worst-case analysis</h3><ul><li>Input sorted or reverse sorted.</li><li>Partition around min or max element.</li><li>One side of partition always has no elements.</li><li>$\begin{equation}\begin{split} T(n) &amp; = T(0) + T(n-1) + \Theta(n) \\<br>  &amp; = \Theta(1) + T(n-1) + \Theta(n) \\<br>  &amp; = T(n-1) + \Theta(n) \\<br>  &amp; = \Theta(n^2) \\<br>  \end{split}\end{equation}$</li><li><img src="/2019/08/quick-sort-and-randomized-algorithm/worst-case recursion tree.png" alt></li></ul><h3 id="Best-case-analysis-for-intuition-only"><a href="#Best-case-analysis-for-intuition-only" class="headerlink" title="Best-case analysis (for intuition only !)"></a>Best-case analysis (for intuition only !)</h3><ul><li>If we’re lucky, partition splits the array evenly.（均匀地划分数组）</li><li>$T(n) = 2T(n/2) + \Theta(n) = \Theta(n \lg n)$</li></ul><h3 id="“Almost-best”-case-analysis"><a href="#“Almost-best”-case-analysis" class="headerlink" title="“Almost-best” case analysis"></a>“Almost-best” case analysis</h3><ul><li>What if the split is always 1/10 : 9/10 ?</li><li>$T(n) = T(n/10) + T(9n/10) + \Theta(n) = \Theta(n \lg n)$</li><li><img src="/2019/08/quick-sort-and-randomized-algorithm/almost best case recursion tree.png" alt></li></ul><h3 id="More-intuition"><a href="#More-intuition" class="headerlink" title="More intuition"></a>More intuition</h3><ul><li>Suppose we alternative lucky, unlucky, lucky, unlucky, lucky, …</li><li>lucky step: $L(n) = 2U(n/2) + \Theta(n)$</li><li>unlucky step: $U(n) = L(n-1) + \Theta(n)$</li><li>Solving: $L(n) = 2L(n/2-1) + \Theta(n) = \Theta(n \lg n)$, lucky!</li><li>How can we make sure we are usually lucky?</li></ul><h1 id="Randomized-quick-sort-analysis"><a href="#Randomized-quick-sort-analysis" class="headerlink" title="Randomized quick-sort analysis"></a>Randomized quick-sort analysis</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Randomized-Partition(A, p, r)</span><br><span class="line">i = random(p, r)</span><br><span class="line">exchange A[p] <span class="keyword">with</span> A[i]</span><br><span class="line">    <span class="keyword">return</span> Partition(A, p, r)</span><br><span class="line"></span><br><span class="line">Randomized-Quicksort(A, p, r)</span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">    q = Randomized-Partition(A, p, r)</span><br><span class="line">        Randomized-Quicksort(A, p, q<span class="number">-1</span>)</span><br><span class="line">        Randomized-Quicksort(A, q+<span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><ul><li><strong>Let <code>T(n)</code> be the random variable</strong> for the running time of randomized quick-sort on an input of size n, assuming random numbers are independent.</li><li>For k = 0, 1, … , n–1, define the <strong>indicator random variable</strong>（指示器随机变量）</li><li>$X_k = \begin{cases}<br>  1 &amp; \text{if partition generates a $k : n-k-1$ split} \\<br>  0 &amp; \text{otherwise} \\<br>  \end{cases}$</li><li>$E(X_k) = 0 \times P\{X_k = 0\} + 1 \times P\{X_k = 1\} = P\{X_k = 1\} = 1/n$</li><li>$\begin{equation}\begin{split}<br>  T(n) &amp; = \begin{cases}<br>  T(0) + T(n-1) + \Theta(n) &amp; \text{if $0 : n-1$ split} \\<br>  T(1) + T(n-2) + \Theta(n) &amp; \text{if $1 : n-2$ split} \\<br>  \cdots \\<br>  T(n-1) + T(0) + \Theta(n) &amp; \text{if $n-1 : 0$ split} \\<br>  \end{cases} \\<br>  &amp; = \sum_{k = 0} ^{n-1} X_k [T(k) + T(n-k-1) + \Theta(n)] \\<br>  \end{split}\end{equation}$</li><li>$\begin{equation}\begin{split}<br>  E[T(n)] &amp; = E\{\sum_{k = 0}^{n-1} X_k [T(k) + T(n-k-1) + \Theta(n)]\} \\<br>  &amp; = \sum_{k = 0}^{n-1} E\{X_k [T(k) + T(n-k-1) + \Theta(n)]\} \\<br>  &amp; = \sum_{k = 0}^{n-1} E[X_k]E[T(k) + T(n-k-1) + \Theta(n)] \\<br>  &amp; = {1 \over n}  \sum_{k = 0}^{n-1} E[T(k)] + {1 \over n}  \sum_{k = 0}^{n-1} E[T(n-k-1)] + {1 \over n} \sum_{k = 0}^{n-1} \Theta(n) \\<br>  &amp; = {2 \over n} \sum_{k = 0}^{n-1} E[T(n)] + \Theta(n) \\<br>  &amp; = {2 \over n} \sum_{k = 2}^{n-1} E[T(n)] + \Theta(n) \quad \quad \text{k = 0, 1 terms are absorbed in $\Theta(n)$} \\<br>  \end{split}\end{equation}$</li><li>$\text{For the fact}\sum_{k = 2}^{n-1} k \lg k \leq {1 \over 2} n^2 \lg n - {1 \over 8} n^2$</li><li>$\begin{equation}\begin{split}<br>  E[T(n)] &amp; \leq {2 \over n} \sum_{k = 2}^{n-1} ak \lg k + \Theta(n) \\<br>  &amp; = {2a \over n} \left( {1 \over 2} n^2 \lg n - {1 \over 8} n^2 \right) + \Theta(n) \\<br>  &amp; = an \lg n - \left( {an \over 4} - \Theta(n)\right) \\<br>  &amp; \leq an \lg n \quad \quad \text{if a is chosen large enough so that an/4 dominates the $\Theta(n)$}<br>  \end{split}\end{equation}$</li></ul><h1 id="Quick-sort-in-practice"><a href="#Quick-sort-in-practice" class="headerlink" title="Quick-sort in practice"></a>Quick-sort in practice</h1><ul><li>Quick-sort is a great general-purpose sorting algorithm.</li><li>Quick-sort is typically three or more times faster than merge sort.</li><li>Quick-sort can benefit substantially from code tuning.</li><li>Quick-sort behaves well even with caching and virtual memory.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 随机算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（2）分治法</title>
      <link href="/2019/08/divide-and-conquer/"/>
      <url>/2019/08/divide-and-conquer/</url>
      
        <content type="html"><![CDATA[<h1 id="Divide-and-conquer（分治法）"><a href="#Divide-and-conquer（分治法）" class="headerlink" title="Divide and conquer（分治法）"></a>Divide and conquer（分治法）</h1><ul><li>Divide and conquer is the most well-known <strong><em>algorithm design</em></strong>（算法设计）strategy<ol><li><strong>Divide</strong> the problem (instance) into one or more smaller sub-problems.</li><li><strong>Conquer</strong> each sub-problems recursively.</li><li><strong>Combine</strong> the solutions to the sub-problems into the solution for the original problem.</li></ol></li></ul><h1 id="Merge-sort（归并排序）"><a href="#Merge-sort（归并排序）" class="headerlink" title="Merge sort（归并排序）"></a>Merge sort（归并排序）</h1><ol><li>Divide: Trivial.</li><li>Conquer: Recursively sort 2 sub-arrays.</li><li>Combine: Linear-time merge.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Merge-Sort(A, p, r)</span><br><span class="line">    <span class="keyword">if</span> p &lt; r</span><br><span class="line">        q = (p + r) / <span class="number">2</span></span><br><span class="line">        Merge-Sort(A, p, q)</span><br><span class="line">        Merge-Sort(A, q, r)</span><br><span class="line">        Merge(A, p, q, r)</span><br><span class="line"></span><br><span class="line">Merge(A, p, q, r)</span><br><span class="line">    n1 = q - p + <span class="number">1</span></span><br><span class="line">    n2 = r - q</span><br><span class="line">    let L[<span class="number">1.</span>.n1+<span class="number">1</span>] <span class="keyword">and</span> R[<span class="number">1.</span>.n2+<span class="number">1</span>] be new arrays</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n1</span><br><span class="line">        L[i] = A[p + i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n2</span><br><span class="line">        R[j] = A[q + j]</span><br><span class="line">    L[n1 + <span class="number">1</span>] = ∞</span><br><span class="line">    R[n2 + <span class="number">1</span>] = ∞</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k = p to r</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>$T(n) = 2T(n/2) + \Theta(n) = \Theta(n \lg n)$</li></ul><h1 id="Binary-search（二分查找）"><a href="#Binary-search（二分查找）" class="headerlink" title="Binary search（二分查找）"></a>Binary search（二分查找）</h1><ul><li>find x in a sorted array.<ol><li>Divide: compare x with the middle element in the array.</li><li>Conquer: recurs in one sub-array.</li><li>Combine:  Trivial, nothing to do.</li></ol></li><li>$T(n) = T(n/2) + \Theta(1) = \Theta(\lg n)$</li></ul><h1 id="Powering-a-number（乘方）"><a href="#Powering-a-number（乘方）" class="headerlink" title="Powering a number（乘方）"></a>Powering a number（乘方）</h1><ul><li>given a number x and an integer n ≥ 0, compute xⁿ.<ul><li>Naive algorithm: Θ(n)</li><li>Divide-and-conquer Algorithm<ul><li>$a^n = \begin{cases}<br>  a^{n/2} \times a^{n/2} &amp; \text{if $n$ is even} \\<br>  a^{(n-1)/2} \times a^{(n-1)/2} \times a &amp; \text{if $n$ is odd} \\<br>  \end{cases}$</li><li>$T(n) = T(n/2) + \Theta(1) = \Theta(\lg n)$</li></ul></li></ul></li></ul><h1 id="Fibonacci-numbers（斐波那契数）"><a href="#Fibonacci-numbers（斐波那契数）" class="headerlink" title="Fibonacci numbers（斐波那契数）"></a>Fibonacci numbers（斐波那契数）</h1><ul><li>$F_n = \begin{cases}<br>  0 &amp; \text{if $n = 0$} \\<br>  1 &amp; \text{if $n = 1$} \\<br>  F_{n-1} + F_{n-2} &amp; \text{if $n \geq 2$} \\<br>  \end{cases}$</li><li>Naive recursive algorithm（朴素递归算法）<ul><li>$T(n) = \Omega(\varphi^n)$, where $\varphi = (1 + \sqrt 5) / 2$</li><li><strong>Exponential time</strong>（指数级时间）algorithm is bad.</li><li><strong>Polynomial time</strong>（多项式时间）algorithm is good.</li></ul></li><li>Bottom-top algorithm（自底向上算法）<ul><li>Compute the Fibonacci numbers in order, forming each number by summing the two previous.</li><li>Running time is linear, $T(n) = \Theta(n)$.</li></ul></li><li>Naive recursive squaring algorithm（朴素递归平方算法）<ul><li>$F_n = \varphi^n / \sqrt 5$ rounded to the nearest integer.（$\varphi^n / \sqrt 5$ 距离最近的那个整数，就是第n个斐波那契数）</li><li>$T(n) = \Theta(\lg n)$</li><li>This method is unreliable（不可靠）, since floating-point arithmetic（浮点运算）is prone to round-off errors.</li></ul></li><li>Recursive squaring algorithm（递归平方算法）<ul><li>$\begin{bmatrix} F_2 &amp; F_1 \\ F_1 &amp; F_0 \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}^1$</li><li>$\begin{bmatrix} F_{n+1} &amp; F_n \\ F_n &amp; F_{n-1} \end{bmatrix} = \begin{bmatrix} F_n &amp; F_{n-1} \\ F_{n-1} &amp; F_{n-2} \end{bmatrix}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} = \cdots = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}^n$</li><li>$T(n) = \Theta(\lg n)$</li></ul></li></ul><h1 id="Matrix-multiplication（矩阵乘法）"><a href="#Matrix-multiplication（矩阵乘法）" class="headerlink" title="Matrix multiplication（矩阵乘法）"></a>Matrix multiplication（矩阵乘法）</h1><ul><li>Standard algorithm</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Matrix-Multiply(A, B)</span><br><span class="line">    n = A.rows</span><br><span class="line">    let C be a new n×n matrix</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">            C[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k = <span class="number">1</span> to n</span><br><span class="line">                C[i][j] = C[i][j] + A[i][k] × B[k][j]</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure><ul><li>$T(n) = \Theta(n^3)$</li><li><strong>Divide-and-conquer algorithm</strong><ul><li>n x n matrix = 2 x 2 matrix of (n/2) x (n/2) sub-matrices</li><li><img src="/2019/08/divide-and-conquer/矩阵乘法的分治法.png" alt></li><li>$\left.\begin{array}{l}r = ae + bg\\s = af + bh\\t = ce + dg\\u = cf + dh\\\end{array}\right\} \quad \left.\begin{array}{l}\text{8 mults of $(n/2)\times(n/2)$ sub-matrices}\\\text{4 adds of $(n/2)\times(n/2)$ sub-matrices}\\\end{array}\right.$</li><li>$T(n) = 8T(n/2) + \Theta(n^2) = \Theta(n^3)$, no better than the ordinary algorithm.</li></ul></li><li><strong>Strassen algorithm</strong><ul><li>Multiply 2 x 2 matrices with only 7 recursive mults<ol><li>Divide: Partition A and B into (n/2)×(n/2) submatrices. Form terms to be multiplied using + and –</li><li>Conquer: Perform 7 multiplications of (n/2)×(n/2) submatrices recursively.</li><li>Combine: Form C using + and – on (n/2)×(n/2) submatrices.</li></ol><ul><li>$\left.\begin{array}{l}P_1 = a \cdot (f-h)\\ P_2 = (a+b) \cdot h\\ P_3 = (c+d) \cdot e\\ P_4 = d \cdot (g-e)\\ P_5 = (a+d) \cdot (e+h)\\ P_6 = (b-d) \cdot (g+h)\\ P_7 = (a-c) \cdot (e+f)\\ \end{array}\right\} \quad \left.\begin{array}{l}r = P_5 + P_4 - P_2 + P_6\\ s = P_1 + P_2\\ t = P_3 + P_4\\ u = P_5 + P_1 - P_3 - P_7\\ \end{array}\right.$</li><li>7 mult, 18 adds/subs (no reliance on commutativity of mult)</li><li>$T(n) = 7T(n/2) + \Theta(n^2) = \Theta(n^{\log_2 7}) = O(n^{2.81})$</li></ul></li></ul></li></ul><h1 id="VLSI-layout（Very-large-scale-integration-layout-超大规模集成电路布局）"><a href="#VLSI-layout（Very-large-scale-integration-layout-超大规模集成电路布局）" class="headerlink" title="VLSI layout（Very large-scale integration layout, 超大规模集成电路布局）"></a>VLSI layout（Very large-scale integration layout, 超大规模集成电路布局）</h1><ul><li>Problem: Embed a complete binary tree with n leaves in a grid using minimal area</li><li><img src="/2019/08/divide-and-conquer/VLSI1.png" alt></li><li><img src="/2019/08/divide-and-conquer/VLSI2.png" alt></li></ul><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul><li>Divide and conquer is just one of several powerful techniques for algorithm design.</li><li>Divide-and-conquer algorithms can be analyzed using recurrences and the master method (so practice this math).</li><li>Can lead to more efficient algorithms.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 分治法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 乘方 </tag>
            
            <tag> 斐波那契数 </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论（1）算法分析</title>
      <link href="/2019/08/analysis-of-algorithm/"/>
      <url>/2019/08/analysis-of-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="Analysis-of-algorithm"><a href="#Analysis-of-algorithm" class="headerlink" title="Analysis of algorithm"></a>Analysis of algorithm</h1><ul><li>The analysis of algorithm is the <strong>theoretical study</strong>（理论研究）of computer program <strong>performance</strong>（性能）and <strong>resource usage</strong>（资源利用）.</li><li>Why do we study algorithms and performance if it’s at the bottom of heap?<ol><li>Performance measures the line between the feasible（可行）and the infeasible, algorithms are on the cutting edge of entrepreneurship（解决问题的最前沿）.</li><li>Algorithm give you a language for talking about program behavior, and that turns out to be a language that has been pervasive through computer science. Performance is like currency（货币）, it the universal thing that you quantity.</li><li>Algorithm is tons of fun, speed if always fun.</li></ol></li></ul><h1 id="Running-time"><a href="#Running-time" class="headerlink" title="Running time"></a>Running time</h1><ul><li>Depends on <strong>input</strong> itself（输入本身）. ( Ex. already sorted )</li><li>Depends on <strong>input size</strong>（输入规模）. ( Ex. 6 vs 6×10ⁿ ）<ul><li>Parameterize  things in the input size.（依输入规模将其参数化）</li><li>Talk about time as a function of the size of the things that we are sorting.</li></ul></li><li>We want <strong>upper bounds</strong>.（运行时间的上界）<ul><li>It represents a guarantee to the user.</li></ul></li></ul><h1 id="Kinds-of-analysis"><a href="#Kinds-of-analysis" class="headerlink" title="Kinds of analysis"></a>Kinds of analysis</h1><ul><li><strong>Worst-case analysis</strong>（最坏情况分析）（usually）<ul><li>T(n) = the maximum time on any input of size n. </li><li>Worst-case time depends on computer.</li><li>Compare algorithms typically for <strong>relative speed</strong>（相对速度）(on same machine).</li><li><strong>absolute speed</strong> （绝对速度）(on different machine).</li></ul></li><li><strong>Average-case analysis</strong>（平均情况分析）（sometimes）<ul><li>T(n) = the expect time over all inputs of size n.</li><li>Need an assumption of the statistical distribution of inputs.</li></ul></li><li>Best-case analysis（最好情况分析）（bogus假象）</li></ul><h1 id="Problem-Sorting"><a href="#Problem-Sorting" class="headerlink" title="Problem: Sorting"></a>Problem: Sorting</h1><ul><li>Input: sequence &lt; a1, a2, … , an &gt; of numbers.</li><li>Output:permutation &lt; a1′, a2′, … , an′ &gt; such that a1′ ≤ a2′ ≤ … ≤ an′.</li></ul><h2 id="Insertion-Sort（插入排序）"><a href="#Insertion-Sort（插入排序）" class="headerlink" title="Insertion Sort（插入排序）"></a>Insertion Sort（插入排序）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Insertion-Sort(A, n) <span class="comment">//Sorts A[1...n]</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">2</span> to n</span><br><span class="line">        key = A[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><h2 id="Insertion-sort-analysis"><a href="#Insertion-sort-analysis" class="headerlink" title="Insertion sort analysis"></a>Insertion sort analysis</h2><ul><li>Worst-case: input reverse sorted.</li><li>$T(n)  = \sum_{j=2}^n \Theta(j) = \Theta(n^2)$</li><li>Is insertion sort fast?<ul><li>moderately fast for small n</li><li>not at all for lager n</li></ul></li></ul><h2 id="Merge-Sort（归并排序）"><a href="#Merge-Sort（归并排序）" class="headerlink" title="Merge Sort（归并排序）"></a>Merge Sort（归并排序）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Merge sort A[<span class="number">1.</span>..n]</span><br><span class="line"><span class="comment">//T(n)</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> If n=<span class="number">1</span>, done.</span><br><span class="line"><span class="comment">//Θ(1), constant time</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Recursively sort A[<span class="number">1.</span>..n/<span class="number">2</span>] <span class="keyword">and</span> A[n/<span class="number">2</span>+<span class="number">1.</span>..n].</span><br><span class="line"><span class="comment">//2T(n/2)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="string">"Merge"</span> <span class="number">2</span> sorted lists.</span><br><span class="line"><span class="comment">//key subroutine, Θ(n)</span></span><br></pre></td></tr></table></figure><ul><li><strong>Recurrence</strong>（递归表达式）for the performance of merge sort</li><li>$T(n) = \begin{cases}<br>  \Theta(1) &amp; n=1 \\<br>  2T(n/2)+\Theta(n) &amp; n &gt; 1<br>  \end{cases}$</li></ul><h2 id="Recursion-tree-method（递归树法）"><a href="#Recursion-tree-method（递归树法）" class="headerlink" title="Recursion-tree method（递归树法）"></a>Recursion-tree method（递归树法）</h2><ul><li><img src="/2019/08/analysis-of-algorithm/递归树法示例1.jpg" alt></li><li>Θ(nlgn) is asymptotically faster than Θ(n²).</li><li>Merge sort, on a large enough input size (more than 30), is going to beat insertion sort.</li></ul><h1 id="Asymptotic-analysis"><a href="#Asymptotic-analysis" class="headerlink" title="Asymptotic analysis"></a>Asymptotic analysis</h1><ol><li>Ignore machine-dependent constants（忽略依赖于机器的常量）, look at the <strong>growth of the running time</strong> instead of the actual running time（关注运行时间的增长）.</li><li>Asymptotic analysis satisfies our issue of being able to compare both relative and absolute speed.</li><li>Some of the slower algorithms, even though may asymptotically be slower（从渐进的观点来看低速）, they may still be faster on reasonable sizes of things（在合理的输入规模下运行得更快）.</li><li>We have to balance our mathematical understanding（数学理解）with our engineering common sense（工程直觉）in order to do good programming.</li></ol><h1 id="Asymptotic-notation"><a href="#Asymptotic-notation" class="headerlink" title="Asymptotic notation"></a>Asymptotic notation</h1><ul><li><strong>Ο notation</strong> — asymptotically upper bounds（渐进上界，≤）<ul><li>f(n) = Ο(g(n)) means there are consts c &gt; 0, n0 &gt; 0, such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0.<ul><li>Ex. 2n² = Ο(n³).</li></ul></li><li>Set definition: Ο(g(n)) = { f(n): there are consts c &gt; 0, n0 &gt; 0, such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0 }</li><li>Macro convention（宏用法）: A set in a formula represents an anonymous function in that set.<ul><li>f(n) = n³ + Ο(n²) means there is a function h(n)∈Ο(n²), such that f(n) = n³ + h(n).</li><li>n² + Ο(n) = Ο(n²) means for any f(n)∈Ο(n), there is an h(n)∈Ο(n²), such that n² + f(n) = h(n).</li></ul></li></ul></li><li><strong>Ω notation</strong> — asymptotically lower bounds（渐进下界，≥）<ul><li>Ω(g(n)) = { f(n): there exist consts c &gt; 0, n0 &gt; 0, such that 0 ≤ cg(n) ≤ f(n) for all n ≥ n0 }<ul><li>sqrt(n) = Ω(lgn) means up to constant factors root n is at least lgn for sufficiently large n.</li></ul></li></ul></li><li><strong>Θ notation</strong> — asymptotically tight bounds（渐进紧确界，=）<ul><li>Θ(g(n)) = Ο(g(n)) ∩ Ω(g(n)) = { f(n): there exist consts c1 &gt; 0, c2 &gt; 0, n0 &gt; 0, such that 0 ≤ c1g(n) ≤ f(n) ≤ c2g(n) for all n ≥ n0 } </li><li>From a formula, drop low order terms（弃掉低阶项）and ignore leading constants（忽略前面的常数因子）<ul><li>Ex. 3n³ + 90n² - 5n + 1024 = Θ(n³)</li></ul></li><li>As n→∞, Θ(n²) algorithm always beats a Θ(n³) algorithm.</li></ul></li><li><strong>ο notation</strong> — non-asymptotically tight upper bounds（非渐进紧确上界， &lt; ）<ul><li>ο(g(n)) = { f(n): for any constant c &gt; 0, there is const n0 &gt; 0, such that 0 ≤ f(n) &lt; cg(n) for all n ≥ n0 }</li><li>$\lim_{n \to \infty} {f(n) \over g(n)} = 0$<ul><li>Ex. 2n = ο(n²), but 2n² ≠ ο(n²).</li></ul></li></ul></li><li><strong>ω</strong> <strong>notation</strong> — non-asymptotically tight lower bounds（非渐进紧确下界， &gt; ）<ul><li>ο(g(n)) = { f(n): for any constant c &gt; 0, there is const n0 &gt; 0, such that 0 ≤ cg(n) &lt; f(n) for all n ≥ n0 }</li><li>$\lim_{n \to \infty} {f(n) \over g(n)} = \infty$</li><li>Ex. n²/2 = ω(n), but n²/2 ≠ ω(n²).</li></ul></li></ul><h1 id="Solving-recurrences"><a href="#Solving-recurrences" class="headerlink" title="Solving recurrences"></a>Solving recurrences</h1><h2 id="Substitution-method（代换法）"><a href="#Substitution-method（代换法）" class="headerlink" title="Substitution method（代换法）"></a>Substitution method（代换法）</h2><ol><li>Guess the form of the solution</li><li>Verify whether the recurrence satisfy this bound by induction（数学归纳法验证）</li><li>Solve for constants</li></ol><ul><li>Ex. T(n) = 4T(n/2)+n</li><li>Guess T(n)=Ο(n³), assume T(k)≤ck³ for k＜n, T(n) = 4T(n/2)+n ≤ 4(n/2)³+n = ½cn³+n = cn³-(½cn³-n) ≤ cn³, if (½cn³-n) ≥ 0, e.g. c≥2, n≥1.（<strong>desired - residual</strong>  期望 - 余项）</li><li>We must also handle the initial conditions/the boundary conditions, that is, ground the induction with base cases.</li><li>Base：T(n)=Θ(1) for all n&lt;n0, where n0 is a suitable constant. For 1 ≤ n＜n0, we have “Θ(1)”≤cn³, if we pick c big enough.</li><li>Guess T(n)=Ο(n²), assume T(k)≤ck² is useless, IDEA：Strengthen the induction hypothesis, <strong>subtract a low-order term</strong>.</li><li>Assume T(k)≤c₁k²-c₂k for k&lt;n, T(n) ≤ c₁n²-c₂n-(c₂-1)n ≤ c₁n²-c₂n, if c₂≥1. Pick c₁ big enough to handle the initial conditions.</li></ul><h2 id="Recursion-tree-method（递归树法）-1"><a href="#Recursion-tree-method（递归树法）-1" class="headerlink" title="Recursion-tree method（递归树法）"></a>Recursion-tree method（递归树法）</h2><ul><li>A recursion-tree models the costs (time) of a recursive execution of an algorithm.</li><li>The recursion-tree method is good for generating guesses for the substitution method.</li><li>The recursion-tree method can be unreliable（不可靠）, just like any method that uses ellipses (…).</li><li>The recursion-tree method promotes intuition（直观）, however.</li><li><img src="/2019/08/analysis-of-algorithm/递归树法示例2.jpg" alt></li></ul><h2 id="Master-method（主方法）"><a href="#Master-method（主方法）" class="headerlink" title="Master method（主方法）"></a>Master method（主方法）</h2><ul><li>Applies to recurrence of the form：<strong>T(n) = aT(n/b) + f(n).</strong></li><li>Where <strong>a ≥ 1</strong>（至少递归一次）and <strong>b &gt; 1</strong>（子问题规模减小）are constants and <strong>f(n) is an asymptotically positive function</strong>（渐进正函数，存在某特定n0，当n≥n0时，f(n)＞0）.</li><li><img src="/2019/08/analysis-of-algorithm/主方法比较示意图.png" alt></li><li>Compare $f(n)$ with $n^{\log_b a}$</li><li>Case 1:<ul><li>$f(n) = O(n^{ {\log_b}^a - \varepsilon})$ for some constant $\varepsilon &gt; 0$</li><li>Solution: $T(n) = \Theta(n^{\log_b a})$</li><li>The weight increases geometrically from the root to the leaves. The leaves hold a constant fraction of the total weight.</li></ul></li><li>Case 2:<ul><li>$f(n) = \Theta(n^{\log_b a} \lg^k n)$ for some constant $k \geq 0$</li><li>Solution: $T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$</li><li>(k = 0) The weight is approximately the same on each of the $\log_b n$ levels.</li></ul></li><li>Case 3:<ul><li>$f(n) = \Omega(n^{ {\log_b}^a + \varepsilon})$ for some constant $\varepsilon &gt; 0$</li><li>Solution: $T(n) = \Theta(f(n))$</li><li>The weight decreases geometrically from the root to the leaves. The root holds a constant fraction of the total weight.</li></ul></li><li>Ex. $T(n) = 4T(n/2) + f(n), a=4, b=2, n^{\log_b a} = n^2$.<ol><li>$f(n) = n = O(n^{2-\varepsilon})$, Case 1, T(n)=Θ(n²).</li><li>$f(n) = n^2 = \Theta(n^2 lg^0 n)$, Case 2, T(n)=Θ(n²lgn).</li><li>$f(n) = n^3 = Ω(n^{2+\varepsilon})$, Case 3, T(n)=Θ(n³).</li><li>$f(n)=n^2 / \lg n$, master method doesn’t apply, in particular, for every constant $\varepsilon&gt;0$, we have $n^\varepsilon = \omega(\lg n)$.</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《算法导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> 算法分析 </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 渐进分析 </tag>
            
            <tag> 解递归式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu问题汇总</title>
      <link href="/2019/07/ubuntu-question/"/>
      <url>/2019/07/ubuntu-question/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-终端基本语法"><a href="#Ubuntu-终端基本语法" class="headerlink" title="Ubuntu 终端基本语法"></a>Ubuntu 终端基本语法</h1><h2 id="设置-grub2-启动引导"><a href="#设置-grub2-启动引导" class="headerlink" title="设置 grub2 启动引导"></a>设置 grub2 启动引导</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br><span class="line"># 删除或注释 GRUB_TIMEOUT_STYLE=hidden</span><br><span class="line"># 将 GRUB_TIMEOUT 由 0 修改为 10</span><br><span class="line"># 将 GRUB_DEFAULT 由 0 改为 saved, 并在文件末尾加上 GRUB_SAVEDEFAULT=true, 自由切换默认程序</span><br><span class="line"></span><br><span class="line"># 更新 grub</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><h2 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install xxxx</span><br></pre></td></tr></table></figure><h2 id="卸载移除应用"><a href="#卸载移除应用" class="headerlink" title="卸载移除应用"></a>卸载移除应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove xxxx</span><br></pre></td></tr></table></figure><h2 id="root-模式"><a href="#root-模式" class="headerlink" title="root 模式"></a>root 模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入root</span><br><span class="line">sudo su</span><br><span class="line"># 退出root</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="强制删除文件或目录"><a href="#强制删除文件或目录" class="headerlink" title="强制删除文件或目录"></a>强制删除文件或目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf xxx</span><br></pre></td></tr></table></figure><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"># 全部子目录及文件权限修改为每个人都有读和写以及执行的权限</span><br><span class="line">sudo chmod 777 * -R</span><br></pre></td></tr></table></figure><h2 id="添加和删除-PPA-源"><a href="#添加和删除-PPA-源" class="headerlink" title="添加和删除 PPA 源"></a>添加和删除 PPA 源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加 PPA 源</span><br><span class="line">sudo add-apt-repository ppa:user/ppa-name</span><br><span class="line">sudo apt-get update</span><br><span class="line"># 删除 PPA 源</span><br><span class="line">sudo add-apt-repository -r ppa:/user/ppa-name</span><br><span class="line"># 删除后进入 /etc/apt/source.list.d 目录将相应 PPA 源的保存文件删除</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h1 id="应用安装"><a href="#应用安装" class="headerlink" title="应用安装"></a>应用安装</h1><h2 id="安装-typora"><a href="#安装-typora" class="headerlink" title="安装 typora"></a>安装 typora</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &apos;deb https://typora.io/linux ./&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure><h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 配置 git 库</span><br><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line"># 安装 git</span><br><span class="line">sudo apt-get install git</span><br><span class="line"># 配置git config</span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;email&quot;</span><br><span class="line"># 避免频繁输入 github 账号密码</span><br><span class="line">sudo apt-get install vim</span><br><span class="line">touch .git-credentials</span><br><span class="line">sudo gedit .git-credentials # 在主目录输入</span><br><span class="line">https://Username:Password@github.com # 输入相应文字后保存</span><br></pre></td></tr></table></figure><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install curl</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><h2 id="安装-sublime-text"><a href="#安装-sublime-text" class="headerlink" title="安装 sublime text"></a>安装 sublime text</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line">echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text</span><br></pre></td></tr></table></figure><h2 id="安装-gThumb"><a href="#安装-gThumb" class="headerlink" title="安装 gThumb"></a>安装 gThumb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gthumb</span><br></pre></td></tr></table></figure><h2 id="安装-XMind"><a href="#安装-XMind" class="headerlink" title="安装 XMind"></a>安装 XMind</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 在官网 https://www.xmind.cn/xmind8-pro/ 下载文件 (如 xmind-8-update8-linux.zip)</span></span><br><span class="line"><span class="comment"># 2. 解压文件到 /opt/ 目录</span></span><br><span class="line">sudo unzip xmind<span class="number">-8</span>-update8-linux.zip -d /opt/xmind8</span><br><span class="line">sudo chmod -R <span class="number">777</span> /opt/xmind8/*</span><br><span class="line"><span class="comment"># 3. 在解压文件夹中打开终端安装相关依赖</span></span><br><span class="line">sudo ./setup.sh</span><br><span class="line"><span class="comment"># 4. 安装完成后进入 /opt/xmind8/XMind_amd64 双击 XMind 确认是否可以运行</span></span><br><span class="line"><span class="comment"># 5. 下载破解补丁 (链接: https://pan.baidu.com/s/1iLZ8OBuckGrRLlBJrgDCFA 提取码: 8s6y) 放到 /opt/xmind8/XMind_amd64 目录下, 并添加到 XMind.ini 中</span></span><br><span class="line">sudo echo -javaagent:/opt/xmind8/XMind_amd64/XMindCrack.jar &gt;&gt; /opt/xmind8/XMind_amd64/XMind.ini</span><br><span class="line"><span class="comment"># 6. 修改 hosts 文件, 在最后加上一列 "127.0.0.1 www.xmind.net"</span></span><br><span class="line">sudo gedit /etc/hosts</span><br><span class="line"><span class="comment"># 7. 运行 xmind 输入序列号即可完成破解 </span></span><br><span class="line">XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345</span><br><span class="line"><span class="comment"># 8. 在 /opt/xmind8/XMind_amd64/ 添加运行脚本</span></span><br><span class="line">sudo gedit run.sh</span><br><span class="line">在文件中添加两行</span><br><span class="line">cd /opt/xmind8/XMind_amd64/</span><br><span class="line">/opt/xmind8/XMind_amd64/XMind</span><br><span class="line"><span class="comment"># 9. 修改 run.sh 文件的权限</span></span><br><span class="line">sudo chmod a+x ./run.sh</span><br><span class="line"><span class="comment"># 10. 在 /usr/share/applications 中建立 xmind.desktop 文件</span></span><br><span class="line">cd /usr/share/applications</span><br><span class="line">sudo gedit xmind.desktop</span><br><span class="line">在文件中输入</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Name=Xmind8</span><br><span class="line">Exec=/opt/xmind8/XMind_amd64/run.sh</span><br><span class="line">Icon=/opt/xmind8/xmind_logo.png</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application</span><br></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="Ubuntu-18-04-和-Windows-10-时间不同步"><a href="#Ubuntu-18-04-和-Windows-10-时间不同步" class="headerlink" title="Ubuntu 18.04 和 Windows 10 时间不同步"></a>Ubuntu 18.04 和 Windows 10 时间不同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line">sudo hwclock --localtime --systohc</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《图像处理》空域图像增强</title>
      <link href="/2019/07/spatial-domain-enhancement-by-book-image-processing/"/>
      <url>/2019/07/spatial-domain-enhancement-by-book-image-processing/</url>
      
        <content type="html"><![CDATA[<h1 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h1><ul><li>图像增强技术是最基本和最常用的一种图像处理技术，也常作为其他图像处理技术之前的预处理手段</li><li>图像增强的目的是通过对图像的特定加工，以将被处理的图像转化为对具体应用来说视觉质量和效果更好或更有用的图像</li><li>目前常用的图像增强技术根据根据其处理所进行的空间不同，可分为基于空域（图像域）的方法和基于变换域的方法两类</li></ul><h1 id="空域增强：点操作"><a href="#空域增强：点操作" class="headerlink" title="空域增强：点操作"></a>空域增强：点操作</h1><ul><li>空域：像素位置所在的空间，也称图像空间</li><li>空域图像增强：直接作用于像素，在图像空间进行的增强</li><li>点操作<ul><li>增强操作仅定义在每个像素点的位置上（增强操作仅利用了单个像素的信息）</li><li>种类<ul><li>几何点操作：改变像素的坐标位置 (x,y)</li><li>灰度点操作：改变像素的灰度 f</li></ul></li></ul></li></ul><h2 id="图像坐标变换"><a href="#图像坐标变换" class="headerlink" title="图像坐标变换"></a>图像坐标变换</h2><ul><li>图像（空间/几何）坐标变换是一种位置映射操作，涉及的是图像空间里各个坐标位置间的转换及方式</li></ul><h3 id="基本坐标变换"><a href="#基本坐标变换" class="headerlink" title="基本坐标变换"></a>基本坐标变换</h3><ul><li>变换的表示<ul><li>$\begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}\begin{bmatrix}{a}&amp;{b}&amp;{c}\end{bmatrix}^T\ =\ 0\ \Leftrightarrow\ {点} (x,y) {在直线} ax\ +\ by\ +\ c\ =\ 0 {上}$，这样点矢量 $\begin{bmatrix}{x}&amp;{y}\end{bmatrix}^T$ 就用一个 3-D 矢量 $\begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}^T$ 来表示了</li><li><strong>齐次坐标</strong>：<ul><li>如果空间中的点用矢量形式表示为 $\boldsymbol \omega = \begin{bmatrix}{x}&amp;{y}&amp;{z}\end{bmatrix}^T$，则对应的齐次坐标可表示为 ${\boldsymbol \omega}_h = \begin{bmatrix}{kx}&amp;{ky}&amp;{kz}&amp;{k}\end{bmatrix}^T,k$ 为非零常数</li></ul></li><li><strong>坐标变换</strong>：<ul><li>设原坐标的矢量为 $\boldsymbol v = \begin{bmatrix}{x}&amp;{y}&amp;{1}\end{bmatrix}^T$，变换后坐标的矢量为 $\boldsymbol v’ = \begin{bmatrix}{x’}&amp;{y’}&amp;{1}\end{bmatrix}^T$，则坐标变换可借助矩阵写为 $\boldsymbol v’ = A_{3{\times}3}\boldsymbol v$</li><li>令 $\boldsymbol v_{1}, \boldsymbol v_{2}, \cdots, \boldsymbol v_{m}$ 代表 m 个点的坐标矢量，则对一个其列由这些列矢量组成的 3 × m 矩阵 $\boldsymbol V$，可用一个  3 × 3 矩阵 $A$ 同时变换所有的点，即 $\boldsymbol V’ = A\boldsymbol V$</li></ul></li></ul></li><li><strong>平移变换</strong><ul><li>平移变换矩阵 $T = \begin{bmatrix}<br>  {1}&amp;{0}&amp;{T_{x}}\\<br>  {0}&amp;{1}&amp;{T_{y}}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li><strong>放缩变换</strong>（尺寸变换）<ul><li>放缩变换矩阵 $S = \begin{bmatrix}<br>  {S_{x}}&amp;{0}&amp;{0}\\<br>  {0}&amp;{S_{y}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li><strong>旋转变换</strong><ul><li>旋转轴垂直于图像平面，旋转角 $\gamma$ 按从旋转轴正向看原点而<strong>顺时针</strong>（从 Y 轴向 X 轴旋转）定义</li><li>旋转轴位于坐标原点时，旋转变换矩阵 $R_{\gamma} = \begin{bmatrix}<br>  {\cos{\gamma}}&amp;{\sin{\gamma}}&amp;{0}\\<br>  {-\sin{\gamma}}&amp;{\cos{\gamma}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>旋转轴不在坐标原点时，<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/旋转变换轴不在原点的情况.png" alt></li></ul></li></ul><h3 id="坐标变换扩展"><a href="#坐标变换扩展" class="headerlink" title="坐标变换扩展"></a>坐标变换扩展</h3><ul><li><strong>反变换</strong><ul><li>基本坐标变换反向进行</li><li>平移变换逆矩阵 $T^{-1} = \begin{bmatrix}<br>  {1}&amp;{0}&amp;{-T_{x}}\\<br>  {0}&amp;{1}&amp;{-T_{y}}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>放缩变换逆矩阵 $S^{-1} = \begin{bmatrix}<br>  {\frac{1}{S_{x}}}&amp;{0}&amp;{0}\\<br>  {0}&amp;{\frac{1}{S_{y}}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>绕在原点的旋转轴顺时针旋转 $\gamma$ 角度的逆矩阵 ${R_{\gamma}}^{-1} = \begin{bmatrix}<br>  {\cos{\gamma}}&amp;{-\sin{\gamma}}&amp;{0}\\<br>  {\sin{\gamma}}&amp;{\cos{\gamma}}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix} = {R_{\gamma}}^T$</li></ul></li><li><p><strong>变换级联</strong></p><ul><li>多个不同变换接续进行，如旋转变换的旋转轴不在原点时的旋转</li></ul></li><li><strong>3-点映射变换</strong><ul><li>将矩形映射为平行四边形，而将三角形映射为另一个三角形的变换</li><li>除平移、放缩、旋转变换外还有拉伸变换和剪切变换</li><li><strong>拉伸变换</strong><ul><li>在一个方向上放大，而在其正交方向上缩小的变换</li><li>放缩变换的一种特例，放缩系数互为倒数</li><li>设拉伸系数为 L，则拉伸变换矩阵 $\boldsymbol L = \begin{bmatrix}<br>  {L}&amp;{0}&amp;{0}\\<br>  {0}&amp;{1/L}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li><strong>剪切变换</strong><ul><li>仅像素的水平坐标或垂直坐标之一发生（与像素的垂直或水平坐标数值相关的）平移变化</li><li>水平剪切变换矩阵 $\boldsymbol J_{h} = \begin{bmatrix}<br>  {1}&amp;{J_{x}}&amp;{0}\\<br>  {0}&amp;{1}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li><li>垂直剪切变换矩阵 $\boldsymbol J_{v} = \begin{bmatrix}<br>  {1}&amp;{0}&amp;{0}\\<br>  {J_{y}}&amp;{1}&amp;{0}\\<br>  {0}&amp;{0}&amp;{1}\\<br>  \end{bmatrix}$</li></ul></li><li>五种典型的坐标变换示意<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/五种典型的坐标变换示意.png" alt></li></ul></li><li><strong>旋转变换的分解</strong><ul><li>通过结合剪以及水平和垂直方向的放缩来实现快速旋转，但是放缩操作需额外的计算，还可能导致分辨率减小<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/旋转变换的分解1.png" alt></li><li>为避免放缩操作，可将图像旋转分解为 3 个 1-D 剪切变换的级联以加速<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/旋转变换的分解2.png" alt></li></ul></li></ul><h2 id="图像间运算"><a href="#图像间运算" class="headerlink" title="图像间运算"></a>图像间运算</h2><ul><li>图像间的运算指以图像为单位进行的操作（按数组方式进行），运算的结果是一幅新图像</li></ul><h3 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h3><ul><li>算术运算<ul><li>一般用于<strong>灰度图像</strong></li><li>设有分别属于两幅图像对应位置的两个像素 p 和 q</li><li>加法：p + q</li><li>减法：p - q</li><li>乘法：p × q（也可写为 pq）</li><li>除法：p ÷ q</li><li>将两个像素的灰度值通过相应运算得到一个新的灰度值作为对应输出图像中同一位置处像素的灰度值</li></ul></li><li>逻辑运算<ul><li>只用于<strong>二值图像</strong>（0 和 1）</li><li>补（COMPLEMENT）：NOT q（也可写为 $\bar{q}$）</li><li>与（AND）：p AND q（也可写为 p ▪ q）</li><li>或（OR）：p OR q（也可写为 p + q）</li><li>异或（XOR）：p XOR q（也可写为 p ⊕ q）</li></ul></li></ul><h3 id="图像间算术运算的应用"><a href="#图像间算术运算的应用" class="headerlink" title="图像间算术运算的应用"></a>图像间算术运算的应用</h3><ul><li>图像间加法的应用<ul><li>用于图像平均以减少和去除图像采集中混入的噪声</li><li>实际采集到的图像 g(x,y) 可看作是由原始场景图像 f(x,y) 和噪声图像 e(x,y) 叠加而成的，即 g(x,y) = f(x,y) + e(x,y)，假设图像在各点的噪声是互不相关的，且噪声具有零均值的统计特性</li><li>将 M 个图像相加再求平均得到一幅新的图像，即 $\bar{g}(x,y)={\frac{1}{M}}\sum_{i=1}^{M}g_{i}(x,y)$</li><li>可以证明新图像的期望值为原始场景图像 $E\{\bar{g}(x,y)\}=f(x,y)$</li><li>如果考虑新图像和噪声图像各自的均方差之间的关系，则有 $\sigma_{\bar{g}(x,y)} = \sqrt{\frac{1}{M}} \times \sigma_{e(x,y)}$</li><li>可见随着平均图数量增加，噪声在每个像素位置的影响将越来越小</li></ul></li><li>图像间减法的应用<ul><li>两图相减可把差异凸显出来</li><li>医学图像处理：消除背景，医学成像的基本工具之一</li><li>运动检测：对时间上相邻的两幅图像求差可以将图像中目标的位置和形状变化凸显出来</li></ul></li><li>图像间乘法和除法的应用<ul><li>校正由于照明或传感器的非均匀性所造成的图像明暗变化</li><li>模板运算</li><li>彩色空间中的转换</li></ul></li></ul><h2 id="图像灰度映射"><a href="#图像灰度映射" class="headerlink" title="图像灰度映射"></a>图像灰度映射</h2><h3 id="灰度映射原理"><a href="#灰度映射原理" class="headerlink" title="灰度映射原理"></a>灰度映射原理</h3><ul><li>图像灰度映射要根据原始图像中的每个像素的灰度值，按照某种映射规则，直接将其变换或转化为另一灰度值，从而达到增强图像视觉效果的目的</li><li>灰度映射函数 $t=E_{H}(s)$，t 为增强灰度值，s 为原始灰度值</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/灰度映射原理.png" alt></li></ul><h3 id="典型灰度映射"><a href="#典型灰度映射" class="headerlink" title="典型灰度映射"></a>典型灰度映射</h3><ul><li><strong>图像求反</strong><ul><li>将原图灰度值翻转，使白变黑，使黑变白</li><li>照片和底片关系就是这样</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/图像求反灰度映射.png" alt></li></ul></li><li><strong>增强对比度</strong><ul><li>增加图像各相邻部分的灰度差别，具体通过增加图像中某两个灰度值之间的动态范围来进行</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/增强对比度灰度映射.png" alt></li></ul></li><li><strong>动态范围压缩</strong><ul><li>如果原图动态范围太大，超出显示设备允许的动态范围，会导致细节丢失，此时需要对原图进行一定的灰度范围压缩，常用压缩方式是借助对数形式的灰度映射函数 $t=Clog(1+|s|)$</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/动态范围压缩灰度映射.png" alt></li></ul></li><li><strong>伽马校正</strong><ul><li>借助<strong>指数变换</strong>映射的增强技术 $t=Cs^{\gamma}$</li><li>当 $\gamma &lt; 1$ 时，变换的结果是输入中较窄的低灰度范围被映射到输出中较宽的灰度范围，而同时输入中较宽的高灰度范围被映射到输出中较窄的灰度范围</li><li>许多图像获取、显示、打印设备的输出响应与输入激励满足对数变换的规律，为校正其响应为线性的，需进行指数变换，如常见的 CRT 显示器的亮度-电压响应满足指数变换规律，直接显示的效果会暗许多，校正后显示结果基本与原图一致</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/伽马校正示例.png" alt></li></ul></li></ul><h2 id="直方图变换"><a href="#直方图变换" class="headerlink" title="直方图变换"></a>直方图变换</h2><ul><li>直方图变换（也叫直方图修正）是以概率论为基础，通过改变图像的直方图来改变图像中各像素的灰度，以达到图像增强的目的</li></ul><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><ul><li>直方图均衡化借助图像的直方图表达来进行，目标是<strong>平衡不同灰度级像素的数量</strong></li><li>灰度统计<strong>直方图</strong><ul><li>提供了图像像素的灰度值分布情况</li><li>是一个以灰度值为自变量的 <strong>1-D的离散函数</strong> $h(k) = n_{k} \quad k=0,1,\cdots,L-1$</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/灰度统计直方图.png" alt></li><li>直方图的均值和方差也是图像灰度的均值和方差</li><li>图像的视觉效果和其直方图有对应关系</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/不同类型图像及其直方图示例.png" alt></li></ul></li><li>灰度统计<strong>累积直方图</strong><ul><li>也是一个 1-D 离散函数</li><li>可以表示成 $H(k) = \sum_{i=0}^{k}n_{i} \quad k=0,1,\cdots,L-1$</li><li>累积直方图中列 k 的高度给出图像中灰度值小于和等于 k 的像素的总个数</li></ul></li><li>直方图均衡化原理<ul><li>直方图均衡化主要用于<strong>增强动态范围偏小的图像的对比度</strong></li><li>基本思想：把原始图像的<strong>直方图变换为均匀分布的形式</strong>，增加像素之间灰度值差别的动态范围，从而达到增强图像整体对比度的结果</li><li>归一化直方图<ul><li>将直方图以<strong>归一化的概率形式表达</strong>给出了对各灰度值在图像中所占的数量比例</li><li>$p_{s}(s_{k}) = \frac{n_{k}}{N} \quad 0 \leq s_{k} \leq 1 \quad k = 0,1,\cdots,L-1$</li><li>$s_{k}$ 为图像 f(x,y) 的第 k 级灰度值，N是图像中像素的总个数，L 是灰度级的数量</li></ul></li><li>增强函数 $E_{H}(s)$<ul><li>两个条件<ul><li>$E_{H}(s)$ 在 $0 \leq s \leq 1$ 范围内是单值单增函数 $\Longrightarrow$ 各灰度级在变换后仍<strong>保持排列次序</strong></li><li>对 $0 \leq s \leq 1$ 有 $0 \leq E_{H}(s) \leq 1$ $\Longrightarrow$ 变换前后图像的<strong>灰度值动态范围保持一致性</strong></li></ul></li><li><strong>累积分布函数</strong><ul><li>$t_{k} = E_{H}(s_{k}) = \sum_{i=0}^k\frac{n_{i}}{N} = \sum_{i=0}^k{p_{s}(s_{i})} \quad 0 \leq s_{k} \leq 1 \quad k = 0,1,\cdots,L-1$</li><li>提供了图像像素灰度值得累积分布情况</li><li>$t_{k}$ 是 k 的单值单增函数</li><li>灰度值取值范围一致，$0 \leq t_{k} \leq 1$</li><li>将 s 的分布转换为 t 的均匀分布</li></ul></li></ul></li><li>取整扩展<ul><li>$t_{k} = int[t_{k} \times (L-1) + 0.5]$</li></ul></li><li>确定映射对应关系<ul><li>$s_{k} \rightarrow t_{k}$</li></ul></li><li>根据映射关系计算均衡化直方图</li></ul></li><li>直方图均衡化的列表计算<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/直方图均衡化计算列表.jpg" alt></li><li>直方图均衡化效果<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/直方图均衡化效果.png" alt></li></ul><h3 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h3><ul><li>直方图均衡化：能自动增强图像整体对比度，但实际增强效果不易控制，结果总是得到全局均衡化的直方图</li><li>直方图规定化：有选择地增强某个特定灰度值范围内的对比度，使图像灰度值的分布满足特定的要求</li><li>直方图规定化原理<ul><li>要调整原始图像的直方图去逼近所规定的目标直方图</li><li>三个步骤<ul><li>对原始直方图进行灰度均衡化</li><li>$t_{k} = E_{H_{s}}(s_{i}) = \sum_{i=0}^k{p_{s}(s_{i})} \quad k = 0,1,\cdots,L-1$</li><li>规定需要的直方图，并计算能使规定的直方图均衡化的变换</li><li>$v_{l} = E_{H_{u}}(u_{j}) = \sum_{j=0}^l{p_{u}(u_{j})} \quad l = 0,1,\cdots,L-1$</li><li>将步骤 1 得到的变换反转过来，即将原始直方图（灰度级数 M）对应映射到规定直方图（灰度级数 N）<ul><li>单映射规则（SML）</li><li>从大到小依次找到使 $| \sum_{i=0}^k{p_{s}(s_{i})} - \sum_{j=0}^l{p_{u}(u_{j})} |$ 最小的 k 和 l，然后将 $p_{s}(s_{i})$ 分别对应到 $p_{u}(u_{j})$ 去</li><li><strong>组映射规则（GML）</strong></li><li>设有一个整数函数 $I(l), 0 \leq l \leq N-1$，满足 $0 \leq I(0) \leq \cdots \leq I(l) \leq \cdots \leq I(N-1) \leq M-1$。现在要确定能使 $| \sum_{i=0}^{I(l)}{p_{s}(s_{i})} - \sum_{j=0}^l{p_{u}(u_{j})} |$达到最小的 $I(l)$，然后分组对应</li></ul></li></ul></li></ul></li><li>直方图规定化的列表计算<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/直方图规定化计算列表.jpg" alt></li><li>直方图规定化的绘图计算<ul><li>将直方图画成一长条，每一段对应直方图的一项</li><li>单映射规则是从原始累积直方图的各项依次向规定累计直方图进行映射，每次选择最接近的数值，即遵循最短（最垂直）的连线<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/单映射规则绘图示例.png" alt></li><li>组映射规则是<strong>从规定累积直方图</strong>的各项依次向原始累积直方图进行，遵循最短（最垂直）的连线<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/组映射规则绘图示例.png" alt></li></ul></li><li>两种映射规则的比较<ul><li>单映射规则：有偏的映射规则，最大误差为 $p_{u}(u_{j})/2$</li><li>组映射规则：统计无偏的映射规则，最大误差为 $p_{s}(s_{i})/2$</li><li>$\because N \leq M \quad \therefore p_{s}(s_{i})/2 \leq p_{u}(u_{j})/2$</li></ul></li><li>直方图均衡化和直方图规定化<ul><li>直方图规定化是直方图变换或直方图修正的一般形式</li><li>直方图均衡化可看作使用完全水平的直方图作为规定直方图的直方图规定化</li></ul></li></ul><h1 id="空域增强：模板操作"><a href="#空域增强：模板操作" class="headerlink" title="空域增强：模板操作"></a>空域增强：模板操作</h1><ul><li>像素在图像空间是按某种规律排列的，相互之间有一定的联系，而相邻或接近的像素之间有更密切的联系，常可结合在一起考虑</li><li>在图像处理中，常用模板来组合相邻或接近的像素，根据这些像素的统计特性或局部运算来进行操作，称为模板操作或模板运算</li><li>利用模板操作来进行图像增强常称为滤波，可以是线性的也可以是非线性的</li><li>由于模板操作涉图像中的局部区域，所以也可方便地进行局部增强</li></ul><h2 id="像素间联系"><a href="#像素间联系" class="headerlink" title="像素间联系"></a>像素间联系</h2><h3 id="像素的邻域和邻接"><a href="#像素的邻域和邻接" class="headerlink" title="像素的邻域和邻接"></a>像素的邻域和邻接</h3><ul><li>邻域：由一个像素周围与其关系最密切的近邻像素组成的集合<ul><li>4-邻域 $N_{4}(p)$：由像素 p 的垂直（上、下）和水平（左、右）共 4 个近邻像素组成</li><li>对角邻域 $N_{D}(p)$：由像素 P 的 对角（左上、右上、左下、右下）共 4 个近邻像素组成</li><li>8-邻域 $N_{8}(P)$：由像素 p 的 4 个 4-邻域像素和 4 个对角邻域像素合起来构成</li></ul></li><li>邻接：一种像素间的空间接近关系<ul><li>4-邻接</li><li>对角邻接</li><li>8-邻接</li></ul></li></ul><h3 id="像素间的连接和连通"><a href="#像素间的连接和连通" class="headerlink" title="像素间的连接和连通"></a>像素间的连接和连通</h3><ul><li>连接：两个像素间的一种空间和属性关系<ul><li>连接与否<ol><li>空间上邻接</li><li>灰度值满足某个特定的相似准则（灰度值相等或同在一个灰度值集合中取值）</li></ol></li><li>两种常用的连接（设 V 是定义连接的灰度值集合）<ul><li>4-连接：2 个像素 p 和 r 在 V 中取值，且 r 在 $N_{4}(p)$ 中</li><li>8-连接：2 个像素 p 和 r 在 V 中取值，且 r 在 $N_{8}(p)$ 中</li></ul></li><li>两个连接的像素一定是邻接的，反之则不一定</li></ul></li><li>连通：连通是连接的推广<ul><li>通路<ul><li>从具有坐标 $(x, y)$ 的像素 p 到具有坐标 $(s, t)$ 的像素 q 的一条通路由一系列具有坐标 $(x_{0}, y_{0}), (x_{1}, y_{1}), \cdots, (x_{n}, y_{n})$ 的独立像素组成，这里 $(x_{0}, y_{0}) = (x, y), (x_{n}, y_{n}) = (s, t)$，且 $(x_{i}, y_{i})$ 与 $(x_{i-1}, y_{i-1})$ 邻接，其中 1 ≤ i ≤ n，n为通路长度</li><li>根据所采用的邻接定义不同，可得到不同的通路<ul><li>4-通路</li><li>8-通路</li></ul></li><li>这里对通路的定义仅考虑了像素坐标空间上的联系，没有考虑像素属性空间上的联系</li></ul></li><li>连通<ul><li>通路建立了两个像素 p 和 q 之间的空间联系，如果这条通路上的所有像素的灰度值均满足某个特定的相似准则，即两两邻接的像素也是连接的，则可以说像素 p 和 q 是连通的</li><li>根据所采用的连接定义的不同，可得到不同的连通<ul><li>4-连通</li><li>8-连通</li></ul></li><li>当 n = 1 时，连通转化为其特例 —— 连接</li></ul></li></ul></li><li>邻接、连接、通路、连通之间的关系<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/邻接、连接、通路、连通之间的关系.png" alt></li></ul><h3 id="像素集合的邻接、连接和连通"><a href="#像素集合的邻接、连接和连通" class="headerlink" title="像素集合的邻接、连接和连通"></a>像素集合的邻接、连接和连通</h3><ul><li>子集：图像中（部分）像素的集合，是图像的一部分</li><li>图像子集邻接：S 的一个或一些像素与 T 的一个或一些像素邻接</li><li>图像子集连接：图像子集邻接且邻接像素的灰度值满足特定的相似准则，即 S 的一个或一些像素与 T 的一个或一些像素连接</li><li>连通组元：由在同一个图像子集中的与同一个像素相连通的所有像素构成</li><li>连通集：只有一个连通组元（即所有像素都互相连通）的图像子集</li><li>区域：一幅图像里的每个连通集构成该图像的一个区域<ul><li>简单连通：区域没有孔</li><li>多重连通：区域有孔</li></ul></li><li>轮廓：即区域的边界，是该区域的一个子集，将该区域与其他区域分离开<ul><li>组成一个区域的边界像素本身属于该区域而在其邻域中有不属于该区域的像素</li></ul></li></ul><h3 id="像素间的距离"><a href="#像素间的距离" class="headerlink" title="像素间的距离"></a>像素间的距离</h3><ul><li>距离量度函数 <code>D(p,q)</code><ul><li>D(p,q) ≥ 0 (D(p,q) = 0 当且仅当 p = q) → 距离恒正</li><li>D(p,q) = D(q,p) → 距离是相对的，与起终点无关</li><li>D(p,q) ≤ D(p,r) + D(r,q) → 沿直线距离最短</li></ul></li><li>测度空间 <code>(A,d)</code><ul><li>A 为抽象集合</li><li>d 为从集合 A 向实数集 R 映射的距离度量函数（d: A × A → R）</li></ul></li><li>2-D 图像中的 3 种距离<ul><li>欧氏距离（范数为 2） $D_{E}(p,q) = \sqrt{(x-s)^2 + (y-t)^2}$</li><li>城区距离（曼哈顿距离，范数为 1） $D_{4}(p,q) = |x-s|+|y-t|$</li><li>棋盘距离（切比雪夫距离，范数为 ∞） $D_{8}(p,q) = \max(|x-s|,|y-t|)$</li></ul></li><li>用距离定义邻域<ul><li>$N_{4}(p) = \{r|D_{4}(p,r) = 1\}$</li><li>$N_{8}(p) = \{r|D_{8}(p,r) = 1\}$</li></ul></li><li><a href="https://blog.csdn.net/alinawly/article/details/80804727" target="_blank" rel="noopener">范数和距离</a><ul><li>函数的范数可表示为 ${\Vert f \Vert}_{m} = [\int|f(x)|^m dx]^{1/m}$</li><li><strong>闵可夫斯基（Minkowski）距离</strong>度量为 $D_{m}(p,q) = [|x-s|^m + |y-t|^m ]^{1/m}$，对应范数为参数 m</li><li>考虑与原点为单位距离的点的集合<ul><li>m = 1 → 菱形</li><li>m = 2 → 圆</li><li>m = ∞ → 正方形</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/3种范数和3种距离.png" alt></li></ul></li></ul></li></ul><h2 id="模板运算"><a href="#模板运算" class="headerlink" title="模板运算"></a>模板运算</h2><ul><li>模板：一般可看作尺寸为 n × n (n 为较小的奇数) 的小图像，在其各位置上的值常称为系数值，系数值由功能确定</li><li>模板运算：将赋予某个像素的值作为它本身灰度值和其相邻像素灰度值的函数</li><li>滤波：利用像素本身以及其邻域像素的灰度关系进行图像增强的方法</li><li>滤波器：实现滤波功能的模板</li></ul><h3 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h3><ul><li>模板卷积：用模板与需处理图像在图像空间进行卷积的运算过程</li><li>模板卷积过程不能原地完成，所以输出结果要是用另一幅图像</li><li>模板卷积步骤<ol><li>将模板在输入图像中漫游，并将模板中心与图像中某个像素位置重合</li><li>将模板上的各个系数与模板下各对应像素的灰度值相乘</li><li>将所有乘积相加（为保持灰度范围，常将结果再除以模板系数之和）</li><li>将上述结果（模板的输出响应）赋给输出图像中对应模板中心位置的像素</li></ol></li><li>用 3 × 3 的模板进行模板操作的示意图<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/用3×3的模板进行模板操作的示意图.jpg" alt></li></ul><h3 id="模板排序"><a href="#模板排序" class="headerlink" title="模板排序"></a>模板排序</h3><ul><li>模板排序：用模板来提取需处理图像中与模板同尺寸的图像子集并将其中像素根据其幅度值排序的运算过程</li><li>模板排序过程也不能原地完成</li><li>模板排序步骤<ol><li>将模板在输入图象中漫游，并将模板中心与图象中某个象素位置重合</li><li>读取模板下输入图象中各对应象素的灰度值</li><li>将这些灰度值进行排序，一般将它们从小到大排成一列（单增）</li><li>根据运算目的从排序结果中选一个序，取出该序象素的灰度值</li><li>将取出的灰度值赋给输出图象中对应模板中心位置的象素</li></ol></li><li>模板排序中<ul><li>模板只划定像素范围，系数均看作 1 且不影响赋值</li><li>赋给输出图像的值必定是输入图像中与模板对应的像素值中的一个</li><li>模板只是为了选取像素，因而不一定是方形的，或者说，虽然用方形模板，但其中有些系数取 0</li></ul></li></ul><h3 id="图像边界处的模板运算"><a href="#图像边界处的模板运算" class="headerlink" title="图像边界处的模板运算"></a>图像边界处的模板运算</h3><ul><li>当模板中心对应输入图像的边界像素时，其邻域范围有可能扩展到输入图像的边界之外</li><li>解决方法<ul><li>忽略边界处的像素<ul><li>仅处理图像内部与边界距离大于等于模板半径 r 的像素</li></ul></li><li>将输入图像进行扩展<ul><li>在图像的 4 条边界外各增加/扩展一个 r 行或 r 列的带</li><li>新增行列中的像素的幅度值<ul><li>取为 0</li><li>取为原图像中 4-邻接像素的值（4 个角上的取为 8-邻接像素的值）</li><li>将图像在水平和垂直方向上均看作周期循环的（最后一行后是第一行，最后一列后是第一列）</li><li>利用外插技术，根据接近边界处行列像素的幅度值以一定的规则进行外推</li></ul></li><li>上述确定幅度值的方法都对边界像素给予了特殊的权重，并会使图像的平均灰度发生小的改变</li></ul></li></ul></li></ul><h3 id="空域滤波分类"><a href="#空域滤波分类" class="headerlink" title="空域滤波分类"></a>空域滤波分类</h3><ul><li>将模板运算用于图像空域增强一般称为<strong>空域滤波</strong></li><li>根据滤波功能分类<ul><li>平滑滤波<ul><li>减弱或消除图像中的高频率分量（高频分量对应图像中区域边缘等灰度值具有较大较快变化的部分，滤去后可减少局部灰度起伏，使图像变得比较平滑）</li><li>消除噪声（噪声的空间相关性较弱，对应较高的空间频率）</li></ul></li><li>锐化滤波<ul><li>减弱或消除图像中的低频率分量（低频分量对应图像中灰度值缓慢变化的区域，与图像的整体特性有关，滤去可使图像反差增加，边缘明显）</li><li>增强被模糊的细节或目标的边缘</li></ul></li></ul></li><li>根据滤波运算特点分类<ul><li>从统计的角度看，滤波是一种估计，它基于一组观察结果来估计未观察的量</li><li>线性滤波：对观察结果进行线性组合，理论基础比较成熟</li><li>非线性滤波：对观察结果的逻辑组合，理论基础较弱</li></ul></li><li>空域滤波增强技术分类<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/空域滤波增强技术分类.png" alt></li></ul><h2 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h2><ul><li>线性滤波既可以得到平滑的效果（图像反差减少），也可以得到锐化的效果（图像反差增加），主要取决于所用模板的系数值</li><li>线性滤波基于<strong>模板卷积</strong>进行</li></ul><h3 id="线性平滑滤波"><a href="#线性平滑滤波" class="headerlink" title="线性平滑滤波"></a>线性平滑滤波</h3><ul><li><strong>邻域平均</strong><ul><li>用一个像素邻域的平均值作为滤波结果</li><li>滤波模板的所有系数都取为 1</li><li>为保持灰度值范围，卷积结果要除以系数总个数再行赋值</li><li>$g(x,y) = {1 \over n^2} \sum_{(s,t) \in N(x,y)}f(s,t)$</li><li>N(x,y) 对应 f(x,y) 中 (x,y) 的 n × n 邻域</li></ul></li><li><strong>加权平均</strong><ul><li>离中心近的像素应对滤波结果有较大的贡献</li><li>将接近模板中心的系数取得比模板周边的系数大</li><li>$g(x,y) = \frac{\sum_{(s,t) \in N(x,y)}\; w(s,t)f(s,t)}{\sum_{(s,t) \in N(x,y)}\; w(s,t)}$</li></ul></li><li><strong>高斯平均</strong><ul><li>加权平均的一种特例</li><li>根据高斯分布（标准正态分布）来确定模板系数</li><li>${1 \over 273}\begin{bmatrix}<br>  1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\<br>  4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\<br>  7 &amp; 26 &amp; 41 &amp; 26 &amp; 7 \\<br>  4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\<br>  1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\<br>  \end{bmatrix}$</li><li>模板分解<ul><li>一个 2-D 高斯卷积可分解为顺序执行的两个 1-D 高斯卷积，即一个 2-D 高斯平均模板可拆分成两个 1-D 高斯平均模板</li><li>${1 \over 16}\begin{bmatrix}<br>  1 &amp; 2 &amp; 1 \\<br>  2 &amp; 4 &amp; 2 \\<br>  1 &amp; 2 &amp; 1 \\<br>  \end{bmatrix} = {1 \over 4}\begin{bmatrix}<br>  1 \\<br>  2 \\<br>  1 \\<br>  \end{bmatrix}{1 \over 4}\begin{bmatrix}<br>  1 &amp; 2 &amp; 1 \\<br>  \end{bmatrix}$</li><li>计算量为 <code>O(n²)</code> 的单个 n × n 模板被计算量为 <code>O(n)</code> 的两个 1 × n 模板所替换</li><li>对 n &gt; 3，总可以借助模板分解减少计算量</li></ul></li><li>1-D 离散模板<ul><li>可对高斯函数在整数位置 <code>-n,…,0,…,+n</code> 采样，具体可取 n = 2σ + 1（σ 为高斯方差），而模板尺寸为 s = 2n + 1</li><li>对高斯函数的简单近似可借助杨辉三角进行<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/1-D高斯模板系数.png" alt></li></ul></li><li>高斯滤波器<ul><li>特点<ul><li>线性的</li><li>与位置无关的</li><li>旋转对称的（各向同性的）</li><li>可以控制效果的（有一个控制参数）</li><li>可以连续多次使用的</li><li>可分离的（2-D 可用 1-D 的来计算）</li><li>不能递归执行</li></ul></li><li>线性滤波器都会改变图像中的噪声方差<ul><li>一个线性滤波器 $h(x,y)$ 会使噪声方差乘以因子 $\sum\sum h(x,y)$</li><li>对于高斯滤波器，这个因子是 $1 \over 4\pi\sigma^2$</li><li>取 $\sigma = {n \over 2\sqrt{\pi}}$，可使高斯滤波器与一个 n × n 的邻域平均滤波器具有相同的效果</li></ul></li></ul></li></ul></li><li><strong>边缘保持平滑</strong><ul><li>为了避免局部平均会模糊不同区域之间的边缘，考虑选择只在不包含边缘的邻域中进行平均</li><li>取中心像素的8个不同邻域，对每个邻域都统计其像素的灰度方差，并将灰度方差最小（方差小的邻域中像素灰度级的变化小，包含边缘的概率也小）的那个邻域中的像素均值赋给中心像素<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/8个边缘保持平滑模板.png" alt></li></ul></li></ul><h3 id="线性锐化滤波"><a href="#线性锐化滤波" class="headerlink" title="线性锐化滤波"></a>线性锐化滤波</h3><ul><li><strong>拉普拉斯算子</strong><ul><li>线性锐化滤波可借助模板卷积实现<ul><li>对应积分运算的模板卷积可以平滑图像，对应微分运算的模板卷积可以锐化图像</li><li>锐化模板系数的取值在中心为正而周围原理中心处为负</li></ul></li><li>拉普拉斯算子是一个<strong>各向同性</strong>的二阶微分算子<ul><li>$\nabla^2 f = {\partial^2 f \over \partial x^2} + {\partial^2 f \over \partial y^2}$</li><li>两个二阶偏导数可借助差分来计算</li><li>$\begin{cases}<br>  {\partial^2 f \over \partial x^2} = 2f(x,y) - f(x+1,y) - f(x-1,y)\\<br>  {\partial^2 f \over \partial y^2} = 2f(x,y) - f(x,y+1) - f(x,y-1)\\<br>  \end{cases}$</li><li>可得到</li><li>$\nabla^2 f(x,y) = 4(x,y) - f(x+1,y) - f(x-1,y) - f(x,y+1) - f(x,y-1)$</li><li>据此得到的模板仅考虑了中心像素的 4-邻域，类似地也可以考虑 8-邻域</li></ul></li><li>两种拉普拉斯算子模板<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/两种拉普拉斯算子模板.png" alt><ul><li>两种模板系数之和均为 0<ul><li>灰度值为常数或变化很小的区域的卷积输出为 0 或很小</li><li>输出图的平均灰度值为 0，图中一部分像素灰度值小于 0</li></ul></li><li>通过变换将输出灰度值范围变回 [0, L-1]<ul><li>图像处理中只考虑大于或等于 0 的灰度值</li><li>变换后才能正常显示</li></ul></li></ul></li><li>拉普拉斯算子可增强图像中的灰度不连续边缘，减弱灰度值缓慢变化区域的对比度，将结果叠加到原始图像上，就可以得到锐化后的图像</li></ul></li><li><strong>高频提升滤波</strong><ul><li>图像锐化的效果可以通过叠加图像微分结果取得，也可通过减除图像积分结果取得</li><li>用原始图像 f(x,y) 减去平滑或模糊图像 g(x,y) 就得到<strong>非锐化掩模</strong> h(x,y)，如将非锐化掩模加到原始图像上就能锐化图像</li><li>进一步，把原始图像乘以一个放大倍数 A 再减去平滑图像就可实现<strong>高频提升滤波</strong></li><li>$h_{b}(x,y) = Af(x,y) - g(x,y) = (A-1)f(x,y) + h(x,y)$<ul><li>A = 1 → 非锐化掩模（平滑时丢失的锐化分量）</li><li>A &gt; 1 → 加权的原始图像与非锐化掩模相加（使原始图像锐化）</li><li>A = 2 → 非锐化掩模化<ol><li>平滑原始图像</li><li>从原始图像中减去平滑后的效果</li><li>将上述结果加到原始图像上</li></ol></li></ul></li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/拉普拉斯算子与高频提升滤波的比较.png" alt></li></ul></li></ul><h2 id="非线性滤波"><a href="#非线性滤波" class="headerlink" title="非线性滤波"></a>非线性滤波</h2><ul><li>线性滤波常不能区分图像中有用的内容和无用的噪声<ul><li>在 1-D 傅里叶空间对原始图像加上白噪声，两者的频谱直接叠加。线性滤波将两者的傅里叶变换相乘，结果在每个频率处信号和噪声的强度都由相同的因子所消弱。图像信噪比保持原值，并不增加<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/线性滤波不能区分图像中有用的特征和噪声.png" alt></li></ul></li><li>非线性滤波可区分图像中有用的内容和无用的噪声<ul><li>三个方向发展：逻辑、几何、代数</li><li>分为三种：基于集合的、基于形状的、基于排序的<ul><li>基于形状的非线性滤波围绕数学形态学进行，而基于形状的形态操作建立在集合论的基础上，并可在一定条件下简化成传统的逻辑表达</li></ul></li></ul></li></ul><h3 id="非线性平滑滤波"><a href="#非线性平滑滤波" class="headerlink" title="非线性平滑滤波"></a>非线性平滑滤波</h3><ul><li><strong>中值滤波原理</strong><ul><li>中值滤波依靠<strong>模板排序</strong>来实现</li><li>考虑 1-D 信号，设模板尺寸为 M = 2r+1，r 为模板半径，给定 1-D 信号序列 {fi}, i = 1, 2, … , N.</li><li>则中值滤波输出为 $g_{j} = median [f_{j-r}, f_{j-r+1}, \cdots, f_{j}, \cdots, f_{j+r}]$</li><li>上述定义的操作常称为游程中值，可以通过滑动奇数长度的模板来实现</li><li>中值滤波适合用于对脉冲噪声的消除<ul><li>脉冲噪声会导致受影响的像素值发生明显变化成为野点</li><li>平均滤波不加区别地平均对应模板的所有像素值，而中值滤波则忽略野点，所以不会模糊图像</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/1-D中值滤波示例.png" alt></li></ul></li><li>考虑一个长度为 L 的信号 $f(i) =<br>  \begin{cases}<br>  = 0  &amp; {i &lt; 0} \\<br>  \neq 0 &amp; {i = 0}\\<br>  \neq 0 &amp; {i = L - 1}\\<br>  = 0 &amp; {i \geq L - 1}\\<br>  \end{cases}$<ul><li>L ≤ r → 输出完全是 0，脉冲全被消除 </li><li>如果信号仅包含长度至少为 r+1 的常数段 → 长度小于等于 2r+1 的中值滤波模板对信号滤波并不会使信号发生任何变化</li></ul></li><li>根信号<ul><li>不受中值滤波影响的信号</li><li>一个信号使用一个长度为 2r+1 的中值滤波的根信号的充分条件是该信号局部单调变化且阶数为 r+1（该信号的长度为 r+1 的段均为单调的）</li></ul></li><li>中值滤波的一些特性<ul><li>可以很好地消除孤立尖峰</li><li>有可能导致尖峰附近的边缘偏移，且元素多的更易偏移</li><li>中值滤波趋向于产生为常数的片段</li></ul></li></ul></li><li>2-D 中值滤波<ul><li>$g_{median}(x,y) = median_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>输出值大于等于模板中一半像素的值，又小于等于模板中另一半像素的值</li><li>一般情况下，图像中尺寸小于模板尺寸一半的过亮或过暗区域将会在滤波后被消除掉</li><li>中值滤波既能消除噪声又能较好地保持图像的细节<ul><li>中值滤波的主要功能就是让与周围像素灰度值的差比较大的像素改取与周围像素值接近的值，这样它对孤立的噪声像素的消除能力是很强的</li><li>又由于它不是简单的取均值，所以产生的模糊比较少</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/邻域平均和中值滤波的比较.png" alt> </li></ul></li></ul></li><li>中值滤波的模板<ul><li>中值滤波的效果与所用模板的尺寸有关，也与模板中参与运算的像素个数有关<ul><li>有实验表明，当使用超过包含 9 — 13 个像素的模板来消除图像中的噪声时，计算量的增加比消噪效果的改善更为明显，所以常可使用稀疏的模板来减少运算量<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/一些用于中值滤波的模板.png" alt></li></ul></li><li>中值滤波的效果还与所用模板的形状或模板中参与计算的像素所构成的图案的形状有关<ul><li>方形：对图像细节不敏感，会滤除细线并消除边缘上的角点，也常在常数灰度区域产生条纹</li><li>十字交叉：能保留较细的水平线和垂直线，但有可能将对角线滤除</li><li>X 形：仅保留对角线</li></ul></li></ul></li><li>2-D 中值计算<ul><li>为提高计算速度，常试图顺序使用两个 1-D 中值滤波模板以实现类似于 2-D 中值滤波模板的效果，但他们并不严格相等</li><li>3 种方法<ol><li>直接使用 2-D 模板</li><li>先使用第 1 个 1-D 模板，再使用第 2 个 1-D 模板</li><li>先使用第 2 个 1-D 模板，再使用第 1 个 1-D 模板</li></ol></li><li>中值计算是非线性的，因而计算结果有可能相同，也有可能不同</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/实现2-D中值滤波的3种方法的结果.png" alt></li><li>不严格分解<ul><li>这并不只是非线性滤波模板的特性，有些线性滤波模板也不能准确分解</li><li>究其原因是在一个 n × n 模板中的独立系数个数是 n²，这比在 n × 1 或 1 × n 分量模板中的独立系数个数要多得多</li></ul></li><li>中值滤波器<ul><li>不可分离，但使用优化算法可使它的运行时间与可分离滤波器基本相同</li><li>不能预测图像边缘是否会变化，也不能确定变化程度，还很难估计噪声消除的效果</li></ul></li></ul></li><li><strong>序统计滤波</strong><ul><li>百分比滤波均基于模板排序来工作，所以是一种序统计滤波</li><li>中值滤波：选取灰度序列中位于 50% 位置的像素作为滤波结果<ul><li>$g_{median}(x,y) = median_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可以消除椒盐噪声</li><li>趋向于在图像中产生具有常数灰度的区域</li></ul></li><li>最大值滤波：选取灰度序列中位于 100% 位置的像素作为滤波结果<ul><li>$g_{max}(x,y) = \max_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可用来检测图像中最亮的点，并可减弱暗（低取值）的椒噪声</li><li>趋向于在图像中产生具有（高）常数灰度的区域</li></ul></li><li>最小值滤波：选取灰度序列中位于 0% 位置的像素作为滤波结果<ul><li>$g_{min}(x,y) = \min_{(s,t) \in N(x,y)} [f(s,t)]$</li><li>可用来检测图像中最暗的点，并可减弱亮（高取值）的盐噪声</li><li>趋向于在图像中产生具有（低）常数灰度的区域</li></ul></li><li>中点滤波：取最大值和最小值中点的那个值作为滤波的输出<ul><li>$g_{mid}(x,y) = {1 \over 2}\{ g_{max}(x,y) + g_{min}(x,y) \}$</li><li>结合了排序滤波和平均滤波两种方式的优点</li><li>对多种随机分布的噪声（如高斯噪声、均匀噪声）都比较有效</li></ul></li></ul></li><li><strong>最频值滤波</strong><ul><li>最频值：代表一个分布中最有可能出现的值</li><li>最频值滤波：用最频值作为滤波的输出<ul><li>可以消除噪声（尤其是脉冲噪声）</li><li>可以锐化目标边缘<ul><li>在接近边缘的邻域中，最频值滤波会将最频值移动到更靠近边缘中心的位置，从而使边缘更加尖锐</li><li>这与会模糊边缘的平均滤波不同</li></ul></li></ul></li><li>一个区域灰度分布的均值、中值、最频值都与直方图密切相关<ul><li>均值：直方图均值</li><li>中值：直方图中值</li><li>最频值：统计值最大的灰度值</li><li>直方图对称且仅有一个峰 → 均值、中值、最频值都为该峰</li><li>直方图仅有一个峰但左右不对称 → 最频值对应该峰，中值比均值更接近最频值</li></ul></li></ul></li></ul><h3 id="非线性锐化滤波"><a href="#非线性锐化滤波" class="headerlink" title="非线性锐化滤波"></a>非线性锐化滤波</h3><ul><li><strong>基于梯度的锐化滤波</strong><ul><li>利用微分可以锐化图像（积分平滑图像），最常用的微分方法是利用梯度</li><li>一个连续函数 f(x,y) 的梯度是一个矢量 $\nabla f = \begin{bmatrix} {\partial f \over \partial x} &amp; {\partial f \over \partial y}\\ \end{bmatrix}^T = \begin{bmatrix} G_{x} &amp; G_{y} \end{bmatrix}^T$</li><li>在离散空间，微分用差分实现，下面是两个常用的差分卷积模板，分别计算沿 X 和 Y 方向的差分<img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/两个差分模板.png" alt></li><li>实际锐化滤波中常只使用梯度矢量的幅度（模）</li><li>非线性组合模板的输出值（矢量转化为标量）<ul><li>以 2 为范数计算（对应欧氏距离）：$\vert \nabla f_{(2)} \vert = mag(\nabla f) = [ G_{x}^2 + G_{y}^2 ] ^ {1/2}$</li><li>以 1 为范数计算（对应城区距离）：$\vert \nabla f_{(1)} \vert = \vert G_{x} \vert + \vert G_{y} \vert$</li><li>以 ∞ 为范数计算（对应棋盘距离）：$\vert \nabla f_{(∞)} \vert = max\{ {\vert G_{x} \vert}, {\vert G_{y} \vert} \}$</li></ul></li></ul></li><li><strong>最大-最小锐化变换</strong><ul><li>一种将最大值滤波和最小值滤波结合使用的图像增强技术，可以锐化模糊的边缘并让模糊的目标清晰起来</li><li>这种方法可迭代进行，在每次迭代中将一个模板覆盖区域里的中心像素值与该区域里的最大值和最小值进行比较，然后将中心像素值用与其较接近的极值（最大值或最小值）替换</li><li>最大-最小锐化变换 $S[f(x,y)] = \begin{cases}<br>  g_{max}(x,y)  &amp; {如果 g_{max}(x,y) - f(x,y) \leq f(x,y) - g_{min}(x,y)} \\<br>  g_{min}(x,y) &amp; {其它} \\<br>  \end{cases}$</li><li>迭代进行 $S^{n+1}[f(x,y)] = S \{ S^n[f(x,y)] \}$</li></ul></li><li>锐化滤波模板的通用性质<ol><li>零位移：通过检测和加强图像中对应边缘的部分来增强图像的视觉效果，但不应该改变图像中边缘的位置，一阶微分滤波模板应是反对称的</li><li>消除均值：任意阶的微分滤波模板都不应该对常数值有响应，也即所有系数和为 0</li><li>对称性质：零位移暗示一阶微分算子一般有奇数个反对称的系数，则沿一个方向的卷积计算可简化，对 2r+1 个系数只需要 r 次乘法，2r-1 次加法</li></ol></li></ul><h3 id="线性和非线性混合滤波"><a href="#线性和非线性混合滤波" class="headerlink" title="线性和非线性混合滤波"></a>线性和非线性混合滤波</h3><ul><li>将线性滤波运算和中值滤波运算混合串联起来，先对较大的区域进行计算量较小的线性滤波操作，然后再计算线性滤波输出的中值，作为混合滤波的最终输出<ul><li>1-D 信号 f(i)</li><li>$g(i) = MED[H_{1}(f(i)), H_{2}(f(i)), \cdots, H_{M}(f(i))]$</li><li>2-D 图像 f(x,y)</li><li>$g(x,y) = MED \{ {1 \over 2}[f(x,y-2) + f(x,y-1)], {1 \over 2}[f(x,y+1) + f(x,y+2)], \\<br>  f(x,y), {1 \over 2}[f(x+2,y) + f(x+1,y)], {1 \over 2}[f(x-1,y) + f(x-2,y)]\}$</li></ul></li></ul><h2 id="局部增强"><a href="#局部增强" class="headerlink" title="局部增强"></a>局部增强</h2><ul><li>全局增强：把一幅图像作为一个整体</li><li>局部增强：对图像某些局部区域的细节进行增强</li><li>用全局增强不能保证在所关心区域的局部区域得到所需要的增强效果</li><li>局部增强多了一个选择确定局部区域的步骤，直接利用局部信息以达到局部增强的目的</li><li><strong>直方图变换局部增强</strong><ul><li>直方图变换是空域增强中最常采用的方法，也很容易用于图像的局部增强</li><li>先将图像分成一系列小区域（子图像），对各小区域进行直方图变换，从而使各个小区域得到不同的增强效果</li><li>由于增强是对局部区域分别进行的，增强效果在小区域的边界上有可能不协调，所以实际中常将图像划分为有些互相重叠的小区域以减小这种影响</li><li><img src="/2019/07/spatial-domain-enhancement-by-book-image-processing/局部增强效果示例.png" alt></li><li>点操作中的直方图变换虽然可以使动态范围增加，但增强图像中的灰度级数并不会较原始图像变得更多，只是灰度级数间的距离增加</li><li>直方图变换局部增强在增加动态范围的同时也可以增加全图中的灰度级数，避免了像素间的生硬过渡，视觉效果较柔和</li></ul></li><li><strong>基于均值和方差的局部增强</strong><ul><li>局部增强也可在对图像增强时直接利用局部信息以实现对不同的局部或不同的像素进行不同的增强</li><li>常用的局部信息主要是每个像素的邻域内所有像素的灰度均值和灰度方差<ul><li>灰度均值：平均亮度的测度</li><li>灰度方差：亮度反差（对比度）的测度</li></ul></li><li>利用灰度均值和灰度方差来选择需要增强的像素<ul><li>例如需要增强图像中灰度比较大但方差比较小的区域</li><li>$g(x,y) = \begin{cases}<br>  Ef(x,y)  &amp; {M \leq km(x,y) 且 \sigma(x,y) \leq lS} \\<br>  f(x,y) &amp; {其它} \\<br>  \end{cases}$</li><li>$m(x,y), \sigma(x,y)$ 分别是以像素 $(x,y)$ 为中心的邻域像素的灰度均值和均方差值</li><li>$M, S$ 是 $f(x,y)$ 的灰度均值和均方差值</li><li>$k, l$ 是比例常数（可都取 &lt; 0.5）</li><li>$E$ 是增强系数（&gt; 2）</li></ul></li><li>利用每个像素的邻域内所有像素的均值和方差这两个特性进行<ul><li>如要把输入图 f(x,y) 根据各个像素的邻域特性增强成输出图 g(x,y)，需要在每个像素位置 (x,y) 进行如下变换</li><li>$g(x,y) = A(x,y)[f(x,y) - m(x,y)] + m(x,y)$</li><li>其中 $A(x,y) = k {M \over \sigma(x,y)} \; 0 &lt; k &lt; 1$ 称为局部增益函数</li><li>A 与 f - m 相乘能放大图像的局部变化。由于 A(x,y) 反比于均方差，所以在图像对比度较小的区域得到较大的增益，局部对比度增强。最后加上 m 是为了恢复平均灰度值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图像处理》章毓晋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《图像处理》绪论</title>
      <link href="/2019/07/introduction-by-book-image-processing/"/>
      <url>/2019/07/introduction-by-book-image-processing/</url>
      
        <content type="html"><![CDATA[<h1 id="图像及其表示"><a href="#图像及其表示" class="headerlink" title="图像及其表示"></a>图像及其表示</h1><h2 id="图像和信息"><a href="#图像和信息" class="headerlink" title="图像和信息"></a>图像和信息</h2><ul><li>图像：用各种观测系统以不同形式和手段观测客观世界而获得的，可以直接或间接作用于人眼并进而产生视知觉的实体</li><li>信息：人类从外界获得的信息约有 75% 来自视觉系统</li></ul><h2 id="图像类型"><a href="#图像类型" class="headerlink" title="图像类型"></a>图像类型</h2><ul><li>广义：照片、动画、绘图、视像、文档等</li><li>狭义<ul><li>单幅图像 → 序列图像</li><li>静止图像 → 运动图像（视频）</li><li>2-D 图像 → 3-D、立体对、时空体、多光谱、多视场图像</li><li>灰度图像 → 彩色、深度、纹理图像</li></ul></li><li>基本<ul><li>单幅、静止、2-D、灰度图像均可由 <strong>2-D 数组 $f(x,y)$</strong> 表示</li><li><strong><em>f</em></strong> 表示图像在点 (x,y) 处的某种性质</li></ul></li><li>一般的图像表达函数<ul><li><strong>5-D 有限函数 $T(x,y,z,t,λ)$</strong></li><li>x、y、z 是空间变量，t 代表时间变量，λ 代表波长（对应频谱变量）</li></ul></li></ul><h2 id="图像元素"><a href="#图像元素" class="headerlink" title="图像元素"></a>图像元素</h2><ul><li>图像中的每个基本单元称为图像元素<ul><li>2-D 图像：像素（pixel）</li><li>3-D 图像：体素（voxel）</li></ul></li></ul><h2 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h2><ul><li><strong>2-D 数组 f(x,y)</strong><ul><li>x, y : 2-D 空间 XY 中坐标点的位置</li><li>f : 代表图像在 (x,y) 的性质 F 的数值</li><li>性质 F 可对应不同物理量<ul><li>灰度图像：灰度</li><li>二值图像：文字和空白</li></ul></li></ul></li><li><strong>2-D 矩阵</strong><ul><li>$F = \begin{bmatrix}<br>  {f_{11}}&amp;{f_{12}}&amp;{\cdots}&amp;{f_{1N}}\\<br>  {f_{21}}&amp;{f_{22}}&amp;{\cdots}&amp;{f_{2N}}\\<br>  {\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\<br>  {f_{M1}}&amp;{f_{M2}}&amp;{\cdots}&amp;{f_{MN}}\\<br>  \end{bmatrix}$</li></ul></li><li><strong>矢量</strong><ul><li>$\boldsymbol F = \begin{bmatrix}<br>  {\boldsymbol f_{1}}&amp;{\boldsymbol f_{2}}&amp;{\cdots}&amp;{\boldsymbol f_{N}}\\<br>  \end{bmatrix}$</li><li>其中 ${\boldsymbol f_{i}} = \begin{bmatrix}<br>  {\boldsymbol f_{1i}}&amp;{\boldsymbol f_{2i}}&amp;{\cdots}&amp;{\boldsymbol f_{Mi}}\\<br>  \end{bmatrix}^T{\quad}i = 1, 2, ···, N$</li></ul></li></ul><h2 id="图像显示"><a href="#图像显示" class="headerlink" title="图像显示"></a>图像显示</h2><ul><li>2-D 图像：看作在 2-D 空间位置上的一种幅度分布</li><li><img src="/2019/07/introduction-by-book-image-processing/灰度图像显示方式.png" alt></li><li>上图中是两种灰度图像的显示<ul><li>左图采用的坐标系统在图像计算中采用</li><li>右图采用的坐标系统在屏幕显示中采用</li></ul></li><li><img src="/2019/07/introduction-by-book-image-processing/二值图像显示方式.png" alt></li><li>上图是同一个二值图像的 3 种可视表达方式<ul><li>图(a)：像素区域用其中心表示</li><li>图(b)：像素区域仍用区域表示</li><li>图(c)：幅度值标在图像对应位置</li></ul></li></ul><h1 id="图像分辨率"><a href="#图像分辨率" class="headerlink" title="图像分辨率"></a>图像分辨率</h1><h2 id="空间分辨率和幅度分辨率"><a href="#空间分辨率和幅度分辨率" class="headerlink" title="空间分辨率和幅度分辨率"></a>空间分辨率和幅度分辨率</h2><ul><li>图像所对应的空间视场由几何成像模型所确定<ul><li>空间视场中的精度对应其空间分辨率</li><li>空间分辨率对应<strong>数字化的空间采样点数</strong></li></ul></li><li>图像的幅度范围由亮度成像模型所确定<ul><li>幅度范围中的精度对应其幅度分辨率</li><li>幅度分辨率对应<strong>采样点值的量化级数</strong></li></ul></li></ul><h2 id="采样与量化"><a href="#采样与量化" class="headerlink" title="采样与量化"></a>采样与量化</h2><ul><li>空间<strong>采样</strong>：空间坐标的离散化</li><li>灰度<strong>量化</strong>：灰度值的离散化</li><li><img src="/2019/07/introduction-by-book-image-processing/空间分辨率和幅度分辨率.png" alt></li><li>采样过程可看作将图像平面划分成规则网格，每个网格中心点位置由笛卡尔坐标 (x,y) 决定</li><li>量化过程可看作给点对 (x,y) 通过函数 f(▪) 赋予灰度值</li></ul><h2 id="分辨率与数据量"><a href="#分辨率与数据量" class="headerlink" title="分辨率与数据量"></a>分辨率与数据量</h2><ul><li>图像水平尺寸为$M = 2^m$，图像垂直尺寸为$N = 2^n$，像素灰度级数为$G = 2^k$</li><li>则图像存储所需位数为$b = M \times N \times k$</li></ul><h1 id="图像质量"><a href="#图像质量" class="headerlink" title="图像质量"></a>图像质量</h1><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><ul><li>保持灰度级数不变，降低空间分辨率，会出现像素粒子变粗的现象</li><li>保持空间分辨率不变，降低灰度级数，在灰度缓慢变化区域会出现山脊结构（虚假轮廓）</li></ul><h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><ul><li>图像的亮度本身是一个客观量，人们对它的感知是一个主观量</li><li>图像的亮度常对应图像的灰度，较大的灰度对应较高的亮度</li></ul><h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><ul><li>对比度描述图像局部范围内相邻两部分之间的亮度差别，也可以用相邻两部分亮度平均值的比值来描述</li><li>相对亮度对比度 RBC = $\frac{I_{max}\;\; -\; I_{min}}{I_{max}\;\; +\; I_{min}}$</li></ul><h1 id="图像处理系统"><a href="#图像处理系统" class="headerlink" title="图像处理系统"></a>图像处理系统</h1><h2 id="系统构成框图"><a href="#系统构成框图" class="headerlink" title="系统构成框图"></a>系统构成框图</h2><p><img src="/2019/07/introduction-by-book-image-processing/图像处理系统的构成.png" alt></p><h2 id="图像采集"><a href="#图像采集" class="headerlink" title="图像采集"></a>图像采集</h2><ul><li>图像采集装置<ul><li><strong>物理器件（传感器）</strong>：对某个电磁能量谱波段（如X射线、紫外线、可见光、红外线等）敏感，能产生与所接收到的电磁能量成正比的（模拟）电信号</li><li><strong>数字化器</strong>：能将上述（模拟）电信号转化为数字（离散）的形式</li></ul></li><li>固态采集器件<ul><li>构成<ul><li>固态阵：感光基元产生正比于光强的输出电压，空间分辨率取决于基元排列</li><li>数字化器：幅度分辨率取决于量化级数</li></ul></li><li>器件种类<ul><li>电荷耦合器件 CCD</li><li>互补金属氧化物半导体 CMOS</li><li>电荷注射器件 CID</li></ul></li></ul></li></ul><h2 id="图像显示和打印"><a href="#图像显示和打印" class="headerlink" title="图像显示和打印"></a>图像显示和打印</h2><ul><li>图像显示<ul><li>图像处理结果多是供观察的</li><li>图像数据转换成亮度模式显示</li></ul></li><li>显示设备<ul><li>阴极射线管</li><li>电视显示器</li><li>液晶显示器</li><li>打印设备</li></ul></li><li><strong>半调输出技术</strong><ul><li>多数打印设备仅能直接输出二值图像</li><li>半调输出技术是一种<strong>将灰度图像转化为二值图像</strong>的技术</li><li>半调输出技术利用人眼的集成特性，通过控制输出二值点模式的形式（包括数量，尺寸，形状等）来让人获得视觉上多个灰度的感觉</li><li>半调输出技术仅在<strong>输出设备的灰度值有限</strong>的情况下使用，是<strong>以空间分辨率的减少换取幅度分辨率的增加</strong>（牺牲图像的空间点数来增加图像的灰度级数）</li><li>幅度调制（AM）半调输出<ul><li>通过调整输出黑点的尺寸来显示不同的灰度</li><li>二值点规则排列，墨点的尺寸反比于灰度值，点的形状不是决定性因素</li></ul></li><li>频率调制（FM）半调输出<ul><li>输出黑点的尺寸固定，但其在空间的分布（点间隔或一定区域内点出现频率）取决于灰度值</li><li>缺点：点增益（打印单元尺寸相对于原始单元尺寸的增加量）导致打印图灰度范围的减少或压缩</li></ul></li><li>半调输出模板<ul><li>每个模板对应一个输出单元</li><li>将模板划分为规则网格，每个网格对应一个基本二值点，通过调整各个网格为黑或白，让模板输出不同的灰度，从而达到输出灰度图像的目的</li><li>如果将一个模板分成 n×n 网格， 则可以输出 n² + 1 种不同的灰度</li></ul></li></ul></li><li>抖动技术<ul><li>通过半调输出技术可以看出若要保留细节则灰度级数不能太多，但是一幅图像的灰度级数比较少时图像的视觉质量会比较差</li><li>抖动技术通过调节或变动图像的幅度值来改善量化过粗图像的显示质量</li><li>抖动可通过对原始图像 f(x,y) 加一个随机的小噪声 d(x,y) 来实现，设 b 为图像显示的比特数，则 d(x,y) 的值可以从$-2^{6-b}, -2^{5-b}, 0, 2^{5-b}, 2^{6-b}$五个数中以均匀概率取得，将 f(x,y) 加这样一个随机的小噪声 d(x,y) 的 b 个最高有效比特作为最终输出像素的值</li></ul></li></ul><h2 id="图像存储"><a href="#图像存储" class="headerlink" title="图像存储"></a>图像存储</h2><ul><li>图像存储器<ul><li>处理过程中使用的快速存储器（计算机内存，帧缓存）</li><li>较快重新调用的在线或联机存储器（磁盘，磁光盘）</li><li>不经常使用的数据库（档案库）存储器（磁带，光盘，光盘塔）</li></ul></li><li>图像文件格式<ul><li>BMP 格式：Windows环境下的一种标准，全称 Microsoft 独立位图</li><li>GIF 格式：公用图像文件格式标准，一般为 8 位文件格式</li><li>TIFF 格式：独立于操作系统和文件系统的格式，便于软件之间进行图像数据交换</li><li>JPEG 格式：静止灰度或彩色图像的一种压缩标准</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图像处理》章毓晋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt基础知识</title>
      <link href="/2019/07/qt-knowledge/"/>
      <url>/2019/07/qt-knowledge/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt简介"><a href="#Qt简介" class="headerlink" title="Qt简介"></a>Qt简介</h1><ul><li>Qt 是一个著名的 C++ 应用程序框架。你并不能说它只是一个 GUI 库，因为 Qt 十分庞大，并不仅仅是 GUI 组件。使用 Qt，在一定程度上你获得的是一个“一站式”的解决方案：不再需要研究 STL，不再需要 C++ 的<code>&lt;string&gt;</code>，不再需要到处去找解析 XML、连接数据库、访问网络的各种第三方库，因为Qt自己内置了这些技术。</li><li>后续Qt相关文章均参考 <a href="https://www.devbean.net/2012/08/qt-study-road-2-catelog/" target="_blank" rel="noopener">Qt学习之路2</a> 。</li></ul><h1 id="Qt5-VS2017开发环境搭建"><a href="#Qt5-VS2017开发环境搭建" class="headerlink" title="Qt5+VS2017开发环境搭建"></a>Qt5+VS2017开发环境搭建</h1><ul><li><p><a href="https://blog.csdn.net/gaojixu/article/details/82185694#QtVS2017_60" target="_blank" rel="noopener">Qt5+VS2017环境搭建</a></p><blockquote><p>1.Qt 组件的选取根据需要来选择即可<br>2.为配合 VS2017 的使用需要勾选 MSVC 2017 64-bit 和 MinGW 7.3.0 64-bit</p></blockquote></li></ul><h1 id="信号槽"><a href="#信号槽" class="headerlink" title="信号槽"></a>信号槽</h1><h2 id="什么是信号与槽"><a href="#什么是信号与槽" class="headerlink" title="什么是信号与槽"></a>什么是信号与槽</h2><ul><li><p>所谓信号槽，实际类似<strong>观察者模式</strong>。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个<strong>信号（signal）</strong>。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用<strong>连接（connect）函数</strong>，也就是用自己的一个函数（称为<strong>槽（slot）</strong>）来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** main.cpp ***/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtWidgets/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"Quit"</span>)</span></span>;</span><br><span class="line">QObject::connect(&amp;button, SIGNAL(clicked()), &amp;a, SLOT(quit()));</span><br><span class="line">button.show();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序运行时，会出现一个带有“Quit”字样按钮的窗口，点击按钮程序退出</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect()函数"></a>connect()函数</h2><ul><li>使用<code>connect()</code>可以连接系统提供或者自定义的信号和槽。</li><li><p>Qt5 中 <code>QObject::connect()</code> 有 6 个重载：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> <span class="keyword">char</span> *member,</span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> QMetaMethod &amp;signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> QMetaMethod &amp;method, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *member, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    Functor functor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QMetaObject::<span class="function">Connection <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QObject *context, Functor functor, </span></span></span><br><span class="line"><span class="function"><span class="params">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>connect()</code>函数一般使用 4 个参数：sender、signal、receiver、slot。绑定信号与槽以后，sender 发出 signal 会自动调用 receiver 的 slot 函数</p><ul><li>sender 与 receiver 都是 <code>QObject *</code> 类型的<strong>指针</strong></li><li><code>SIGNAL</code> 和 <code>SLOT</code> 这两个宏可以将两个<strong>除去返回值的函数声明</strong>转换成 <code>const char *</code> 类型</li><li><p>任何成员函数、static 函数、全局函数以及 Lambda 表达式都可作为槽函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line"></span><br><span class="line">    QPushButton button(&quot;Quit&quot;);</span><br><span class="line">    QObject::connect(&amp;button, &amp;QPushButton::clicked, [](bool) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;You clicked me!&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    button.show();</span><br><span class="line"></span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//程序运行时点击Quit按钮会在终端输出&quot;You clicked me!&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="自定义信号槽"><a href="#自定义信号槽" class="headerlink" title="自定义信号槽"></a>自定义信号槽</h2><ul><li><p>信号槽不是 GUI 模块提供的，而是 Qt 核心特性之一。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** newspaper.h ***/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Newspaper(<span class="keyword">const</span> QString &amp; name) :</span><br><span class="line">        m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的信号</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** reader.h ***/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Reader() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的槽函数</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveNewspaper</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Receives Newspaper: "</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** main.cpp ***/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"newspaper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Newspaper <span class="title">newspaper</span><span class="params">(<span class="string">"Newspaper A"</span>)</span></span>;</span><br><span class="line">    Reader reader;</span><br><span class="line">    QObject::connect(&amp;newspaper, &amp;Newspaper::newPaper, </span><br><span class="line">                     &amp;reader, &amp;Reader::receiveNewspaper);</span><br><span class="line">    newspaper.send();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的程序运行时会看到终端输出"Receives Newspaper: Newspaper A"</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Q_OBJECT</code> 宏</strong></p><ul><li><strong>只有继承了 <code>QObject</code> 类的类才具有信号槽能力。</strong></li><li>凡是<code>QObject</code>类（不管是直接子类还是间接子类），都应该在<strong>头文件</strong>的第一行代码写上<code>Q_OBJECT</code>。<strong>不管是不是使用信号槽，都应该添加这个宏。</strong>这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。这个宏由 moc 做特殊处理，生成以 <code>moc_</code> 为前缀的文件。</li></ul></li><li><strong>signals 块</strong><ul><li>signals 块中列出该类需要的信号。</li><li>信号是一个个函数声明，返回值类型为 void（无法获得信号的返回值，也就不需要任何返回值），参数是该类需要让外界知道的数据。</li><li>信号无需在 cpp 文件中进行实现（moc 处理会实现信号函数所需要的函数体）</li><li><code>emit</code> 关键字是 Qt 对 C++ 的扩展，含义是“发出“，也即发出信号。</li></ul></li><li><strong>槽函数（slot 块）</strong><ul><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数。</li><li>与信号函数不同，槽函数必须自己完成实现代码。</li><li>槽函数就是普通的成员函数，因此作为成员函数，也会受到 public、private 等访问控制符的影响。</li><li>sender 和 receiver 都需要是 <code>QObject</code> 的子类。（槽函数是全局函数和 Lambda 表达式等无需接收者的情况除外。）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Qt基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
